from __future__ import annotations
from typing import List, Dict

class VulnerabilityItem:
    def __init__(self, name: str, density: float = 0.0, abs_count: int = 0, kind: str = 'Random'):
        self.name = name
        self.density = density
        self.abs_count = abs_count
        self.kind = kind

def compute_vulnerability_plan(base_host_pool: int, vuln_density: float, vuln_items: List[VulnerabilityItem]) -> tuple[Dict[str,int], dict]:
    """Derive vulnerability allocation.

    Enhancements:
    - Resolves 'Random' kind placeholders by proportionally distributing the derived density pool
      across concrete items (those with non-Random kind or explicit abs counts). If all are Random,
      distributes evenly among their names.
    - Maintains a '__density_pool__' key for backward compatibility while also providing a
      resolved_density_allocation mapping in breakdown for UI use.
    - Explicit abs_count allocations remain additive and are not part of the density-derived split.
    """
    import math as _math
    d = max(0.0, min(1.0, float(vuln_density or 0.0)))
    derived_pool = int(_math.floor(d * (base_host_pool or 0) + 1e-9)) if d > 0 else 0
    plan: Dict[str,int] = {}
    abs_total = 0
    details = []
    concrete_targets: List[str] = []
    random_placeholders: List[str] = []
    # First pass: record abs counts & classify items
    for it in (vuln_items or []):
        ac = int(getattr(it, 'abs_count', 0) or 0)
        if ac > 0:
            abs_total += ac
            plan[it.name] = plan.get(it.name, 0) + ac
        kind_lower = (it.kind or 'Random').strip().lower()
        if kind_lower == 'random':
            random_placeholders.append(it.name)
        else:
            concrete_targets.append(it.name)
        details.append({'name': it.name, 'abs_count': ac, 'kind': it.kind})

    # If there is a density pool, allocate it now into concrete kinds (or among placeholder names)
    # Web UI enumeration (excluding 'Random'): ["SSHCreds", "Bashbug", "FileArtifact", "Incompetence", "Random"]
    DEFAULT_RANDOM_VULNS = ["SSHCreds", "Bashbug", "FileArtifact", "Incompetence"]
    resolved_density_allocation: Dict[str, int] = {}
    if derived_pool > 0:
        # Determine distribution base set
        targets = concrete_targets or (DEFAULT_RANDOM_VULNS if random_placeholders else [])
        if targets:
            # Equal split with residual distribution (largest remainder)
            share = derived_pool / len(targets)
            provisional = []
            residual = derived_pool
            for t in targets:
                alloc = int(_math.floor(share + 1e-9))
                provisional.append((t, share, alloc))
                residual -= alloc
            if residual > 0 and provisional:
                frac_sorted = sorted(provisional, key=lambda x: (x[1]-x[2]), reverse=True)
                for i in range(residual):
                    name, sshare, a = frac_sorted[i % len(frac_sorted)]
                    frac_sorted[i % len(frac_sorted)] = (name, sshare, a+1)  # type: ignore
                provisional = frac_sorted
            for name, _, a in provisional:
                if a > 0:
                    resolved_density_allocation[name] = resolved_density_allocation.get(name, 0) + a
                    plan[name] = plan.get(name, 0) + a
        # Maintain legacy key for any consumers expecting unresolved pool
    # Legacy '__density_pool__' key suppressed (was previously emitted). Allocation now resolved fully.

    breakdown = {
        'base_host_pool': base_host_pool,
        'density': d,
        'derived_pool': derived_pool,
        'explicit_abs_total': abs_total,
        'final_total': derived_pool + abs_total,
        'items': details,
        'resolved_density_allocation': resolved_density_allocation,
        'random_placeholders': random_placeholders,
        'concrete_targets': concrete_targets,
        'random_defaults': DEFAULT_RANDOM_VULNS,
    }
    return plan, breakdown
