from __future__ import annotations
from typing import List, Dict

class VulnerabilityItem:
    def __init__(
        self,
        name: str,
        density: float = 0.0,
        abs_count: int = 0,
        kind: str = 'Random',
        factor: float = 0.0,
        metric: str | None = None,
    ):
        self.name = name
        self.density = density
        self.abs_count = abs_count
        self.kind = kind
        self.factor = factor
        self.metric = metric or 'Weight'

def compute_vulnerability_plan(base_host_pool: int, vuln_density: float, vuln_items: List[VulnerabilityItem]) -> tuple[Dict[str,int], dict]:
    """Derive vulnerability allocation.

    Enhancements:
    - Resolves 'Random' kind placeholders by proportionally distributing the derived density pool
      across concrete items (those with non-Random kind or explicit abs counts). If all are Random,
      distributes evenly among their names.
    - Maintains a '__density_pool__' key for backward compatibility while also providing a
      resolved_density_allocation mapping in breakdown for UI use.
    - Explicit abs_count allocations remain additive and are not part of the density-derived split.
    """
    import math as _math
    DEFAULT_RANDOM_VULNS = ["SSHCreds", "Bashbug", "FileArtifact", "Incompetence"]

    base = max(0, int(base_host_pool or 0))
    density_clamped = max(0.0, min(1.0, float(vuln_density or 0.0)))

    plan: Dict[str, int] = {}
    details: List[Dict[str, object]] = []
    explicit_abs_total = 0

    weight_targets: List[Dict[str, float]] = []
    random_weight_factor = 0.0

    for it in (vuln_items or []):
        name = (it.name or 'Vulnerability').strip() or 'Vulnerability'
        metric = (getattr(it, 'metric', 'Weight') or 'Weight').strip().lower()
        kind = (getattr(it, 'kind', name) or name).strip()
        factor = float(getattr(it, 'factor', 0.0) or 0.0)
        abs_count = int(getattr(it, 'abs_count', 0) or 0)
        is_random = (kind.lower() == 'random') or (name.lower() == 'random')

        details.append({
            'name': name,
            'metric': metric,
            'factor': factor,
            'abs_count': abs_count,
            'kind': kind,
        })

        if metric == 'count' or abs_count > 0:
            if abs_count > 0:
                plan[name] = plan.get(name, 0) + abs_count
                explicit_abs_total += abs_count
            continue

        if factor <= 0.0:
            continue
        if is_random:
            random_weight_factor += factor
        else:
            weight_targets.append({'name': name, 'factor': factor})

    has_weight_based = bool(weight_targets) or random_weight_factor > 0.0
    derived_pool = 0
    if has_weight_based and density_clamped > 0.0 and base > 0:
        derived_pool = int(_math.floor(density_clamped * base + 1e-9))
        derived_pool = max(0, min(base, derived_pool))

    if random_weight_factor > 0.0:
        share = random_weight_factor / len(DEFAULT_RANDOM_VULNS)
        for default_name in DEFAULT_RANDOM_VULNS:
            weight_targets.append({'name': default_name, 'factor': share})

    if derived_pool > 0 and not weight_targets:
        # Fallback to defaults if only density provided without explicit targets
        weight_targets = [{'name': n, 'factor': 1.0} for n in DEFAULT_RANDOM_VULNS]

    total_factor = sum(max(t['factor'], 0.0) for t in weight_targets)
    resolved_density_allocation: Dict[str, int] = {}
    if derived_pool > 0 and total_factor > 0:
        provisional: List[Dict[str, float]] = []
        residual = derived_pool
        for t in weight_targets:
            weight = max(t['factor'], 0.0)
            if weight <= 0.0:
                continue
            exact = (weight / total_factor) * derived_pool
            alloc = int(_math.floor(exact + 1e-9))
            provisional.append({'name': t['name'], 'exact': exact, 'alloc': alloc})
            residual -= alloc
        if residual > 0 and provisional:
            provisional.sort(key=lambda x: (x['exact'] - x['alloc']), reverse=True)
            for idx in range(residual):
                provisional[idx % len(provisional)]['alloc'] += 1
        for entry in provisional:
            alloc = int(entry['alloc'])
            if alloc <= 0:
                continue
            name = entry['name']
            plan[name] = plan.get(name, 0) + alloc
            resolved_density_allocation[name] = resolved_density_allocation.get(name, 0) + alloc

    breakdown = {
        'base_host_pool': base,
        'density': density_clamped,
        'derived_pool': derived_pool,
        'explicit_abs_total': explicit_abs_total,
        'final_total': derived_pool + explicit_abs_total,
        'items': details,
        'resolved_density_allocation': resolved_density_allocation,
        'random_defaults': DEFAULT_RANDOM_VULNS,
        'has_weight_based': has_weight_based,
        'random_weight_factor': random_weight_factor,
        'total_weight_factor': total_factor,
    }
    return plan, breakdown
