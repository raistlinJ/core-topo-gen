<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>CORE TopoGen Web GUI</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet">
    <style>
        /* initial padding; JS will adjust based on dock height */
        body { padding-bottom: 42vh; }
        .dock-panel { position: fixed; bottom: 0; left: 0; right: 0; height: 40vh; background: #fff; border-top: 1px solid #dee2e6; box-shadow: 0 -2px 8px rgba(0,0,0,.08); z-index: 1030; display:flex; flex-direction:column; }
        .dock-grip { height: 6px; cursor: ns-resize; background: repeating-linear-gradient(90deg, #e9ecef 0, #e9ecef 6px, #f8f9fa 6px, #f8f9fa 12px); border-bottom: 1px solid #dee2e6; }
        .dock-panel .nav-tabs { flex-shrink:0; }
        .dock-panel .tab-content { flex:1 1 auto; min-height:0; overflow:auto; }
        .dock-panel .tab-pane { height:100%; overflow:auto; }
        .dock-panel pre { height:auto; min-height:100%; overflow:auto; }
        #xmlPre, #logsPre { max-height:none; }
        .dock-toggle-btn { position: fixed; right: 12px; bottom: 12px; z-index: 1040; }
    </style>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.3/font/bootstrap-icons.css" rel="stylesheet">
</head>
<body>
<div class="container-fluid mt-4">
    <!-- Full-width top header -->
    <div class="row">
        <div class="col-12">
            <div class="d-flex align-items-center justify-content-between bg-primary text-white rounded-top shadow-sm px-3 py-2">
                <div class="d-flex align-items-center gap-2">
                    <i class="bi bi-shield-lock-fill fs-4"></i>
                    <h3 class="mb-0">CORE TopoGen Web GUI</h3>
                </div>
            </div>
            <nav class="navbar navbar-expand bg-light border rounded-bottom shadow-sm mb-3 px-2 py-0">
                <ul class="navbar-nav me-auto mb-0 small">
                    <li class="nav-item"><a class="nav-link active" aria-current="page" href="{{ url_for('index') }}">Scenarios</a></li>
                    <li class="nav-item"><a class="nav-link" href="{{ url_for('data_sources_page') }}">Vulnerability Sources</a></li>
                    <li class="nav-item"><a class="nav-link" href="{{ url_for('reports_page') }}">Reports</a></li>
                </ul>
            </nav>
        </div>
    </div>
    <div class="row">
            <div class="col-md-3 mb-3">
                <div class="card shadow-sm h-100 d-flex flex-column">
                            <div class="card-header d-flex justify-content-between align-items-center">
                                <span class="fw-bold">Scenarios</span>
                                <div class="btn-toolbar gap-2">
                                    <button type="button" class="btn btn-sm btn-outline-secondary" id="importBtn">Import</button>
                                    <button type="button" class="btn btn-sm btn-outline-info" id="exportBtn">Export</button>
                                </div>
                            </div>
                    <div class="list-group list-group-flush flex-grow-1 overflow-auto" id="scenarioList" style="min-height:0;"></div>
                    <form id="hiddenLoadForm" class="d-none" action="{{ url_for('load_xml') }}" method="post" enctype="multipart/form-data">
                        <input type="file" name="scenarios_xml" id="hiddenLoadInput" accept=".xml">
                    </form>
                    <div class="card-footer" style="position: sticky; bottom: 0; background: #fff; z-index: 1;">
                        <button type="button" class="btn btn-sm btn-primary w-100" id="appendScenarioBtn">New Scenario</button>
                    </div>
                </div>
            </div>
    <div class="col-md-9">

            <div class="card shadow mt-3">
                <div class="card-body">
                    {% with messages = get_flashed_messages() %}
                        {% if messages %}
                            <div class="alert alert-info">{{ messages[0] }}</div>
                        {% endif %}
                    {% endwith %}

                    <div class="card mb-3" id="baseCoreScenarioCard">
                        <div class="card-header d-flex justify-content-between align-items-center">
                            <strong>Base CORE Scenario</strong>
                            <div class="d-flex align-items-center gap-2">
                                {% if payload.base_upload %}
                                    {% if payload.base_upload.valid %}
                                        <span class="badge text-bg-success">VALID</span>
                                    {% else %}
                                        <span class="badge text-bg-danger">INVALID</span>
                                    {% endif %}
                                    <a class="btn btn-sm btn-outline-secondary" href="{{ url_for('base_details') }}?path={{ payload.base_upload.path | urlencode }}" target="_blank">Details</a>
                                    <form action="{{ url_for('remove_base') }}" method="post" class="d-inline" onsubmit="document.getElementById('scenarios_json').value = JSON.stringify({ scenarios: state.scenarios });">
                                        <button type="submit" class="btn btn-sm btn-outline-danger">Remove</button>
                                    </form>
                                {% endif %}
                            </div>
                        </div>
                        <div class="card-body">
                            <div class="mb-3">
                                <label class="form-label d-flex align-items-center justify-content-between">
                                    <span>Base Scenario File</span>
                                </label>
                                <input class="form-control" id="baseFileInput" readonly>
                                <div class="form-text">Shows the uploaded file name; full path is stored internally.</div>
                            </div>
                            <form class="d-flex gap-2" action="{{ url_for('upload_base') }}" method="post" enctype="multipart/form-data">
                                <input type="file" class="form-control" name="base_xml" accept=".xml" required>
                                <button type="submit" class="btn btn-primary">{% if payload.base_upload %}Update{% else %}Upload{% endif %}</button>
                            </form>
                            {% if payload.base_upload and not payload.base_upload.valid and logs %}
                                <div class="alert alert-danger mt-3 mb-0" style="white-space: pre-wrap;">{{ logs }}</div>
                            {% endif %}
                        </div>
                    </div>

                    <form id="editorForm" action="{{ url_for('save_xml') }}" method="post">
                        <input type="hidden" name="scenarios_json" id="scenarios_json">
                        <div id="editorRoot"></div>
                        <div class="d-flex gap-2 mt-3">
                            <button type="submit" class="btn btn-success">Save XML</button>
                        </div>
                    </form>

                    <div class="card mt-3">
                        <div class="card-header"><strong>CORE Connection</strong></div>
                        <div class="card-body">
                            <div class="row g-2 align-items-end">
                                <div class="col-auto">
                                    <label for="coreHost" class="form-label mb-0">IP</label>
                                    <input type="text" class="form-control" id="coreHost" placeholder="localhost" value="{{ (payload.core.host if payload.core else 'localhost') | e }}">
                                </div>
                                <div class="col-auto">
                                    <label for="corePort" class="form-label mb-0">Port</label>
                                    <input type="number" class="form-control" id="corePort" placeholder="50051" value="{{ (payload.core.port if payload.core else 50051) }}">
                                </div>
                            </div>
                        </div>
                    </div>

                    

                    <form class="d-flex gap-2 mt-3 align-items-center" action="{{ url_for('run_cli') }}" method="post" onsubmit="return prepareRunCli()">
                        <button class="btn btn-secondary" type="button" id="testCoreBtn">Test CORE Connection</button>
                        <span id="coreStatus" class="small text-muted">Not tested</span>
                        <input type="hidden" name="xml_path" id="xml_path">
                        <span class="d-inline-block" tabindex="0" id="runSyncWrap" data-bs-toggle="tooltip" data-bs-title="Test CORE connection first">
                            <button class="btn btn-warning pe-none" type="submit" id="runSyncBtn" disabled>Run CLI</button>
                        </span>
                        <span class="d-inline-block" tabindex="0" id="runAsyncWrap" data-bs-toggle="tooltip" data-bs-title="Test CORE connection first">
                            <button class="btn btn-outline-warning pe-none" type="button" id="runAsyncBtn" onclick="runAsync()" disabled>Run Async</button>
                        </span>
                        <a class="btn btn-outline-info pe-none" id="reportsBtn" href="{{ url_for('reports_page') }}" disabled>Reports</a>
                        <button class="btn btn-outline-danger d-none" type="button" id="cancelRunBtn" onclick="cancelRun()">Cancel</button>
                    </form>
                </div>
            </div>
            
        </div>
    </div>
</div>
<div class="dock-panel" id="dockPanel">
    <div class="dock-grip" id="dockGrip" title="Drag to resize"></div>
    <ul class="nav nav-tabs px-3 pt-2 align-items-center" role="tablist">
        <li class="nav-item d-flex align-items-center" role="presentation">
            <button class="nav-link active" id="tab-logs" data-bs-toggle="tab" data-bs-target="#dock-logs" type="button" role="tab">Logs</button>
        </li>
        <li class="nav-item d-flex align-items-center ms-3 small" role="presentation">
            <div class="d-flex align-items-center gap-1">
                <label class="form-label mb-0 me-1">Level</label>
                <select id="logLevelFilter" class="form-select form-select-sm" style="width:auto;">
                    <option value="DEBUG">DEBUG</option>
                    <option value="INFO" selected>INFO</option>
                    <option value="WARN">WARN</option>
                    <option value="ERROR">ERROR</option>
                </select>
            </div>
        </li>
        <li class="nav-item" role="presentation">
            <button class="nav-link" id="tab-xml" data-bs-toggle="tab" data-bs-target="#dock-xml" type="button" role="tab">XML Preview</button>
        </li>
        <li class="ms-auto nav-item" role="presentation">
            <button class="btn btn-sm btn-outline-secondary" id="dockHideBtn" type="button">Hide</button>
        </li>
    </ul>
    <div class="tab-content px-3 pb-2">
        <div class="tab-pane fade show active" id="dock-logs" role="tabpanel" aria-labelledby="tab-logs">
            <pre class="w-100 m-0" style="white-space: pre; overflow:auto; width:100%; font-size:0.8rem;" id="logsPre">{{ (logs or '') | e }}</pre>
        </div>
        <div class="tab-pane fade" id="dock-xml" role="tabpanel" aria-labelledby="tab-xml">
            <pre class="w-100 m-0" style="white-space: pre; overflow:auto; width:100%; font-size:0.75rem;" id="xmlPre">{{ (xml_preview or '') | e }}</pre>
        </div>
    </div>
</div>
<button class="btn btn-primary btn-sm dock-toggle-btn d-none" id="dockShowBtn" type="button">Advanced Information</button>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"></script>
<script id="payload-data" type="application/json">{{ payload | tojson }}</script>
<script>
const payloadDataEl = document.getElementById('payload-data');
let initialPayload = null;
// Prevent TDZ: define catalog early on window
window.VULN_CATALOG = window.VULN_CATALOG || { types: [], vectors: [], items: [] };
// ---------------- Logging (buffer + level filter) -----------------
const LOG_LEVELS = { DEBUG: 10, INFO: 20, WARN: 30, ERROR: 40 };
let currentLogLevel = LOG_LEVELS.INFO; // default threshold
let logBuffer = [];
function renderLogs() {
    const logsPre = document.getElementById('logsPre');
    if (!logsPre) return;
    const filtered = logBuffer.filter(r => r.levelValue >= currentLogLevel).map(r => r.line);
    logsPre.textContent = filtered.join('\n') + (filtered.length ? '\n' : '');
    logsPre.scrollTop = logsPre.scrollHeight;
}
function setLogLevel(levelName) {
    if (LOG_LEVELS[levelName] !== undefined) { currentLogLevel = LOG_LEVELS[levelName]; renderLogs(); }
}
function logLine(level, msg) {
    const ts = new Date().toISOString();
    const lvlVal = LOG_LEVELS[level] ?? LOG_LEVELS.INFO;
    const line = `[${ts}] ${level.padEnd(5)} ${msg}`;
    logBuffer.push({ level, levelValue: lvlVal, line });
    if (lvlVal >= currentLogLevel) {
        const logsPre = document.getElementById('logsPre');
        if (logsPre) {
            logsPre.textContent += line + '\n';
            logsPre.scrollTop = logsPre.scrollHeight;
        }
    }
}
function logDebug(m){ logLine('DEBUG', m); }
function logInfo(m){ logLine('INFO', m); }
function logWarn(m){ logLine('WARN', m); }
function logError(m){ logLine('ERROR', m); }

logInfo('UI initialized');
try {
    initialPayload = JSON.parse(payloadDataEl?.textContent || 'null');
} catch (e) {
    initialPayload = null;
}

function defaultScenario(name) {
    return {
        name: name || `Scenario ${document.querySelectorAll('.scenario-card').length + 1}`,
        base: { filepath: '' },
        sections: {
            // Default: one Count-based row; weight-based nodes/density start at 0
            'Node Information': { total_nodes: 0, density: 0, items: [ { selected: 'Random', factor: 1.0, v_metric: 'Count', v_count: 1 } ] },
            'Routing': { density: 0.5, items: [] },
            'Services': { density: 0.5, items: [] },
            'Traffic': { density: 0.5, items: [] },
            'Events': { density: 0.5, items: [] },
            'Vulnerabilities': { density: 0.5, items: [] },
            'Segmentation': { density: 0.5, items: [] }
        },
        notes: ''
    };
}

let state = initialPayload ?? { scenarios: [ defaultScenario('Scenario 1') ], result_path: null };
let activeIdx = 0;

const dropdownsBySection = {
    'Node Information': ['Server','Workstation','PC','Random'],
    'Routing': ['RIP','RIPv2','BGP','OSPFv2','OSPFv3'],
    'Services': ['SSH','HTTP','DHCPClient','Random'],
    'Traffic': ['Random','TCP','UDP','CUSTOM'],
    'Events': ['Script Path'],
    'Vulnerabilities': ['Category','Specific','Random'],
    'Segmentation': ['Random','Firewall','NAT','CUSTOM']
};

function render() {
    renderSidebar();
    renderMain();
    // Download link visibility if provided
        // no download button; export is available in the left panel
    // Sync Base Scenario File input with active scenario
    const baseIn = document.getElementById('baseFileInput');
    if (baseIn && state.scenarios.length) {
        const full = state.scenarios[activeIdx]?.base?.filepath || '';
        const baseName = full.split(/[/\\]/).pop();
        if (baseIn.value !== baseName) baseIn.value = baseName;
        // Read-only display: no input handler needed to modify state
    }
}

function renderSidebar() {
    const list = document.getElementById('scenarioList');
    list.innerHTML = '';
    state.scenarios.forEach((scen, idx) => {
        const a = document.createElement('a');
    a.href = '#';
    a.className = 'list-group-item list-group-item-action' + (idx === activeIdx ? ' active bg-primary text-white' : '');
        a.textContent = scen.name || `Scenario ${idx+1}`;
    a.onclick = (e) => { e.preventDefault(); activeIdx = idx; render(); };
        list.appendChild(a);
    });
            const appendScenarioBtn = document.getElementById('appendScenarioBtn');
            const importBtn = document.getElementById('importBtn');
            const exportBtn = document.getElementById('exportBtn');
        const hiddenLoadInput = document.getElementById('hiddenLoadInput');
        const hiddenLoadForm = document.getElementById('hiddenLoadForm');
            if (appendScenarioBtn) appendScenarioBtn.onclick = (e) => { e.preventDefault(); logInfo('New scenario created'); state.scenarios.push(defaultScenario()); activeIdx = state.scenarios.length - 1; render(); };
            if (importBtn) importBtn.onclick = (e) => { e.preventDefault(); logInfo('Import scenarios clicked'); hiddenLoadInput.click(); };
        if (hiddenLoadInput) hiddenLoadInput.onchange = () => { if (hiddenLoadInput.files && hiddenLoadInput.files.length > 0) hiddenLoadForm.submit(); };
            if (exportBtn) exportBtn.onclick = (e) => {
                e.preventDefault();
                logInfo('Export clicked');
                const rp = state.result_path || '';
                if (!rp.endsWith('.xml')) {
                    logWarn('Export blocked: no saved XML');
                    alert('Please Save XML first (middle panel) to export the current scenarios.');
                    return;
                }
                window.location.href = window.location.origin + '/download_report?path=' + encodeURIComponent(rp);
            };
}

function renderMain() {
    const root = document.getElementById('editorRoot');
    root.innerHTML = '';
    if (!state.scenarios.length) { return; }
    const scen = state.scenarios[activeIdx] || state.scenarios[0];
    // No auto-insertion of Count rows for Node Information; totals should only include user-added Count rows
    // Simple scenario header (no group box)
    const headerRow = document.createElement('div');
    headerRow.className = 'mb-3 d-flex justify-content-between align-items-center';
    headerRow.innerHTML = `
        <div class="d-flex align-items-center gap-2">
            <strong>Scenario:</strong>
            <input class="form-control form-control-sm" style="width:260px" value="${scen.name}" data-scen-idx="${activeIdx}" data-field="name" />
        </div>
        <button class="btn btn-sm btn-outline-danger" data-action="remove-scenario" data-scen-idx="${activeIdx}">Remove</button>`;
    root.appendChild(headerRow);

    // Section cards (Node Information first)
    const secNames = ['Node Information','Routing','Services','Traffic','Events','Vulnerabilities','Segmentation'];
    secNames.forEach(name => {
        const sec = scen.sections[name] || { items: [] };
    const hasNodes = (name === 'Node Information');
        const itemCount = (sec.items || []).length;
        // Determine if any weight rows exist in this section (used for Node Information behavior)
        const hasWeightRowsPre = hasNodes ? ((sec.items || []).some(it => ((it.v_metric || (it.selected==='Specific'? 'Count' : 'Weight')) === 'Weight'))) : false;
        // Always ensure density has a sensible default value
        if (hasNodes) {
            if (hasWeightRowsPre) {
                if (sec.density === undefined || sec.density === null || isNaN(sec.density) || sec.density === 0) {
                    sec.density = 0.5;
                }
            } else {
                sec.density = 0;
            }
        } else {
            if (sec.density === undefined || sec.density === null || isNaN(sec.density)) {
                sec.density = 0.5;
            }
        }
        const densVal = sec.density;
        const nodesVal = (hasNodes ? (sec.total_nodes ?? 0) : '');
        const extraNodeCount = hasNodes ? ((sec.items || []).reduce((acc, it) => {
            const metric = it.v_metric || (it.selected==='Specific'?'Count':'Weight');
            return acc + (metric === 'Count' ? (parseInt(it.v_count) || 0) : 0);
        }, 0)) : 0;
    const hasWeightRows = hasNodes ? hasWeightRowsPre : false;
        const totalNodeCount = hasNodes ? (((hasWeightRows ? (parseInt(nodesVal) || 0) : 0)) + extraNodeCount) : 0;
        const collapsed = (!hasNodes && itemCount === 0);
        const card = document.createElement('div');
        card.className = 'card mb-3';
        const collapseId = `collapse-${name.replace(/\s+/g,'-')}`;
        const iconHtml = itemCount > 0
            ? `<i class='bi bi-collection-fill text-success' data-bs-toggle="tooltip" data-bs-title="${itemCount} item(s)"></i>`
            : `<i class='bi bi-collection text-muted' data-bs-toggle="tooltip" data-bs-title="No items"></i>`;
        card.innerHTML = `
            <div class="card-header d-flex align-items-center gap-2">
                ${iconHtml}
                <strong>${name}</strong>
                <div class="ms-auto d-flex gap-2">
                    ${hasNodes ? `<div class=\"d-flex align-items-center small text-muted\" title=\"Weight-based nodes plus count-based nodes\">Total Nodes: <span class=\"ms-1 fw-semibold\">${totalNodeCount}</span></div>` : ''}
                    <button class="btn btn-sm btn-outline-primary" data-action="add-item" data-scen-idx="${activeIdx}" data-sec="${name}">Add</button>
                    <button class="btn btn-sm btn-outline-secondary" type="button" data-action="toggle-collapse" data-target="#${collapseId}">${collapsed ? 'Expand' : 'Collapse'}</button>
                </div>
            </div>
            <div id="${collapseId}" class="card-body" style="display:${collapsed ? 'none':'block'};">
                                <div class="table-responsive">
                                                                                <table class="table table-sm align-middle">
                                                                                        <thead>
                                                                                            <tr>
                                                                                                <th style="width:280px"></th>
                                                                                                <th></th>
                                                                                                <th style="width:160px"></th>
                                                                                                <th style="width:80px"></th>
                                                                                            </tr>
                                                                                        </thead>
                                                                    <tbody>
                                                                                ${(() => {
                                                                                const items = sec.items || [];
                                                                                const rowsByMetric = items.map((it, iidx) => ({ it, iidx, metric: (it.v_metric || (name==='Vulnerabilities' && (it.selected||'Category')==='Specific' ? 'Count' : 'Weight')) }));
                                                                                const weights = rowsByMetric.filter(x => x.metric === 'Weight');
                                                                                const counts = rowsByMetric.filter(x => x.metric === 'Count');
                                                                                const parts = [];
                                                                                const showWeightHeader = (weights.length > 0);
                                                                                if (showWeightHeader) {
                                                                                    const densCtrl = (
                                                                                        name === 'Node Information'
                                                                                            ? `<div class=\"d-flex align-items-center justify-content-end gap-2\">`
                                                                                                + `<span>Nodes</span>`
                                                                                                + `<input type=\"number\" min=\"1\" step=\"1\" class=\"form-control form-control-sm\" style=\"width:100px\" value=\"${nodesVal}\" data-scen-idx=\"${activeIdx}\" data-sec=\"${name}\" data-field=\"total_nodes\">`
                                                                                                + `<span>Density</span>`
                                                                                                + `<input type=\"number\" step=\"0.01\" min=\"0\" max=\"1\" class=\"form-control form-control-sm\" style=\"width:100px\" value=\"${densVal}\" data-scen-idx=\"${activeIdx}\" data-sec=\"${name}\" data-field=\"density\">`
                                                                                              + `</div>`
                                                                                            : `<div class=\"d-flex align-items-center justify-content-end gap-2\"><span>Density</span><input type=\"number\" step=\"0.01\" min=\"0\" max=\"1\" class=\"form-control form-control-sm\" style=\"width:100px\" value=\"${densVal}\" data-scen-idx=\"${activeIdx}\" data-sec=\"${name}\" data-field=\"density\"></div>`
                                                                                    );
                                                                                    parts.push(`<tr class=\"table-light\"><td colspan=\"2\"><strong>Weight-based</strong></td><td class=\"text-end\">${densCtrl}</td><td></td></tr>`);
                                                                                    if (weights.length) { parts.push(weights.map(x => renderItemRow(activeIdx, name, x.iidx, x.it)).join('')); }
                                                                                }
                                                                                if (counts.length) {
                                                                                    const countHdr = (name === 'Node Information') ? 'Count-based' : 'Count-based';
                                                                                    parts.push(`<tr class=\"table-light\"><td colspan=\"4\"><strong>${countHdr}</strong></td></tr>`);
                                                                                    parts.push(counts.map(x => renderItemRow(activeIdx, name, x.iidx, x.it)).join(''));
                                                                                }
                                                                                return parts.join('');
                                                                            })()}
                                                                    </tbody>
                    </table>
                </div>
                    <div class="text-danger small mt-1 section-warning" data-scen-idx="${activeIdx}" data-sec="${name}" style="display:none">Weights must sum to 1.000</div>
            </div>`;
        root.appendChild(card);
    });
        // activate tooltips for icons
        if(window.bootstrap){
            const tts = root.querySelectorAll('[data-bs-toggle="tooltip"]');
            tts.forEach(el => new bootstrap.Tooltip(el));
        }

    // Notes card
    const notesCard = document.createElement('div');
    notesCard.className = 'card mb-3';
    notesCard.innerHTML = `
        <div class="card-header"><strong>Notes</strong></div>
        <div class="card-body">
            <textarea class="form-control" rows="3" data-scen-idx="${activeIdx}" data-field="notes">${scen.notes || ''}</textarea>
        </div>`;
    root.appendChild(notesCard);

    wireHandlers();
    wireCoreControls();
    // Populate dynamic vuln selects after DOM paint
    populateVulnSelects();
    // Hook up Specific picker buttons
    document.querySelectorAll('[data-action="pick-specific"]').forEach(btn => {
        btn.onclick = () => {
            const sidx = parseInt(btn.getAttribute('data-scen-idx'));
            const sec = btn.getAttribute('data-sec');
            const iidx = parseInt(btn.getAttribute('data-item-idx'));
            openVulnPicker(sidx, sec, iidx);
        };
    });
}

// renderSections was deprecated and removed; rendering is handled in renderMain()

function renderItemRow(sidx, secName, iidx, it) {
    const opts = (dropdownsBySection[secName] || []).map(o => `<option ${o===it.selected?'selected':''}>${o}</option>`).join('');
    const weight = (it.factor ?? 1.0);
    const extras = (() => {
        if (secName === 'Events') {
            return `<input class="form-control form-control-sm" placeholder="script path" value="${it.script_path || ''}" data-scen-idx="${sidx}" data-sec="${secName}" data-item-idx="${iidx}" data-field="script_path">`;
        }
        if (secName === 'Traffic') {
            return `
                <div class="d-flex flex-wrap gap-2">
                    <div>
                        <label class="form-label mb-0">Pattern</label>
                        <select class="form-select form-select-sm" data-field="pattern" data-scen-idx="${sidx}" data-sec="${secName}" data-item-idx="${iidx}">
                            ${['continuous','periodic','burst','poisson','ramp'].map(p => `<option ${((it.pattern||'')===p)?'selected':''}>${p}</option>`).join('')}
                        </select>
                    </div>
                    <div>
                        <label class="form-label mb-0">Rate (kbps)</label>
                        <input type="number" step="0.1" class="form-control form-control-sm" value="${it.rate_kbps ?? 64.0}" data-field="rate_kbps" data-scen-idx="${sidx}" data-sec="${secName}" data-item-idx="${iidx}">
                    </div>
                    <div>
                        <label class="form-label mb-0">Period (s)</label>
                        <input type="number" step="0.1" class="form-control form-control-sm" value="${it.period_s ?? 1.0}" data-field="period_s" data-scen-idx="${sidx}" data-sec="${secName}" data-item-idx="${iidx}">
                    </div>
                    <div>
                        <label class="form-label mb-0">Jitter (%)</label>
                        <input type="number" step="0.1" class="form-control form-control-sm" value="${it.jitter_pct ?? 10.0}" data-field="jitter_pct" data-scen-idx="${sidx}" data-sec="${secName}" data-item-idx="${iidx}">
                    </div>
                </div>`;
        }
        if (secName === 'Vulnerabilities') {
            const mode = it.selected || 'Type/Vector';
            if (mode === 'Specific') {
                const nm = it.v_name || '';
                // Try to obtain full description (prefer stored v_desc, else look up in catalog)
                let fullDesc = it.v_desc || '';
                if (!fullDesc && nm && window.VULN_CATALOG && Array.isArray(window.VULN_CATALOG.items)) {
                    const match = window.VULN_CATALOG.items.find(x => x.Name === nm && (!it.v_path || x.Path === it.v_path));
                    if (match && match.Description) { fullDesc = match.Description; }
                }
                const abbr = (s, n=80) => (s && s.length > n ? (s.slice(0, n-1) + '…') : (s||''));
                const esc = (s) => (s||'')
                    .replace(/&/g,'&amp;')
                    .replace(/</g,'&lt;')
                    .replace(/>/g,'&gt;')
                    .replace(/"/g,'&quot;')
                    .replace(/'/g,'&#39;');
                const descShort = abbr(fullDesc);
                const centerText = nm ? `${nm}${descShort ? ' — ' + descShort : ''}` : '<span class="text-muted">No selection</span>';
                return `<span class="small" ${fullDesc ? `data-bs-toggle="tooltip" data-bs-title="${esc(fullDesc)}"` : ''}>${centerText}</span>`;
            }
            return '';
        }
        return '';
    })();
    // Build first cell content, optionally augmenting Selected with Vulnerabilities controls
    const firstCell = (() => {
        const selectedCtl = `<select class="form-select form-select-sm" data-field="selected" data-scen-idx="${sidx}" data-sec="${secName}" data-item-idx="${iidx}">${opts}</select>`;
        if (secName !== 'Vulnerabilities') return selectedCtl;
    const mode = it.selected || 'Category';
    if (mode === 'Category') {
            return `
            <div class="d-flex flex-wrap gap-2 align-items-end">
                <div style="min-width:160px">${selectedCtl}</div>
                <div>
                    <label class="form-label mb-0">Type</label>
                    <select class="form-select form-select-sm vuln-type" data-field="v_type" data-scen-idx="${sidx}" data-sec="${secName}" data-item-idx="${iidx}"></select>
                </div>
                <div>
                    <label class="form-label mb-0">Vector</label>
                    <select class="form-select form-select-sm vuln-vector" data-field="v_vector" data-scen-idx="${sidx}" data-sec="${secName}" data-item-idx="${iidx}"></select>
                </div>
            </div>`;
        } else if (mode === 'Specific') {
            const nm = it.v_name || '';
            // Try to obtain full description (prefer stored v_desc, else look up in catalog)
            let fullDesc = it.v_desc || '';
            if (!fullDesc && nm && window.VULN_CATALOG && Array.isArray(window.VULN_CATALOG.items)) {
                const match = window.VULN_CATALOG.items.find(x => x.Name === nm && (!it.v_path || x.Path === it.v_path));
                if (match && match.Description) { fullDesc = match.Description; }
            }
            const abbr = (s, n=80) => (s && s.length > n ? (s.slice(0, n-1) + '…') : (s||''));
            const esc = (s) => (s||'')
                .replace(/&/g,'&amp;')
                .replace(/</g,'&lt;')
                .replace(/>/g,'&gt;')
                .replace(/"/g,'&quot;')
                .replace(/'/g,'&#39;');
            const descShort = abbr(fullDesc);
            return `
            <div class="d-flex flex-wrap gap-2 align-items-center">
                <div style="min-width:160px">${selectedCtl}</div>
                <button type="button" class="btn btn-sm btn-outline-primary" data-action="pick-specific" data-scen-idx="${sidx}" data-sec="${secName}" data-item-idx="${iidx}">Choose...</button>
            </div>`;
        }
        return selectedCtl;
    })();
    // Right-most: Weight or Count cell
    const weightCell = (() => {
        if (secName === 'Vulnerabilities') {
            const mode = it.selected || 'Type/Vector';
            const metric = it.v_metric || (mode === 'Specific' ? 'Count' : 'Weight');
            const metricSel = `<select class="form-select form-select-sm" style="min-width: 140px" data-field="v_metric" data-scen-idx="${sidx}" data-sec="${secName}" data-item-idx="${iidx}"><option ${metric==='Weight'?'selected':''}>Weight</option><option ${metric==='Count'?'selected':''}>Count</option></select>`;
            if (metric === 'Count') {
                const count = (parseInt(it.v_count, 10) || 1);
                return `<div class="d-flex gap-2">${metricSel}<select class="form-select form-select-sm" style="min-width: 120px" data-field="v_count" data-scen-idx="${sidx}" data-sec="${secName}" data-item-idx="${iidx}">${Array.from({length:10},(_,k)=>k+1).map(n=>`<option ${n===count?'selected':''}>${n}</option>`).join('')}</select></div>`;
            }
            return `<div class="d-flex gap-2">${metricSel}<input type="number" step="0.01" min="0" max="1" class="form-control form-control-sm weight-input" style="min-width: 120px" value="${weight}" data-field="factor" data-scen-idx="${sidx}" data-sec="${secName}" data-item-idx="${iidx}"></div>`;
        }
        // For all other sections, provide a Count/Weight selector as well
        const metric = it.v_metric || 'Weight';
        const metricSel = `<select class="form-select form-select-sm" style="min-width: 140px" data-field="v_metric" data-scen-idx="${sidx}" data-sec="${secName}" data-item-idx="${iidx}"><option ${metric==='Weight'?'selected':''}>Weight</option><option ${metric==='Count'?'selected':''}>Count</option></select>`;
        if (metric === 'Count') {
            const count = (parseInt(it.v_count, 10) || 1);
            return `<div class="d-flex gap-2">${metricSel}<select class="form-select form-select-sm" style="min-width: 120px" data-field="v_count" data-scen-idx="${sidx}" data-sec="${secName}" data-item-idx="${iidx}">${Array.from({length:10},(_,k)=>k+1).map(n=>`<option ${n===count?'selected':''}>${n}</option>`).join('')}</select></div>`;
        }
        return `<div class="d-flex gap-2">${metricSel}<input type="number" step="0.01" min="0" max="1" class="form-control form-control-sm weight-input" style="min-width: 120px" value="${weight}" data-field="factor" data-scen-idx="${sidx}" data-sec="${secName}" data-item-idx="${iidx}"></div>`;
    })();
    return `
        <tr>
            <td>${firstCell}</td>
            <td>${extras}</td>
            <td>${weightCell}</td>
            <td><button type="button" class="btn btn-sm btn-outline-danger" data-action="remove-item" data-scen-idx="${sidx}" data-sec="${secName}" data-item-idx="${iidx}">Remove</button></td>
        </tr>`;
}

// Render Vulnerabilities rows grouped with two row-headers
function renderVulnRows(sidx, secName, items) {
    const withIdx = items.map((it, iidx) => ({ it, iidx }));
    const typeOrRandom = withIdx.filter(x => (x.it.selected || 'Category') !== 'Specific');
    const specifics = withIdx.filter(x => (x.it.selected || 'Category') === 'Specific');
    const parts = [];
    if (typeOrRandom.length) {
        parts.push(`<tr class="table-light"><td colspan="4"><strong>Category or Random</strong></td></tr>`);
        parts.push(typeOrRandom.map(x => renderItemRow(sidx, secName, x.iidx, x.it)).join(''));
    }
    if (specifics.length) {
        parts.push(`<tr class="table-light"><td colspan="4"><strong>Specific</strong></td></tr>`);
        parts.push(specifics.map(x => renderItemRow(sidx, secName, x.iidx, x.it)).join(''));
    }
    return parts.join('');
}

function wireHandlers() {
    document.querySelectorAll('[data-field]').forEach(el => {
        const sidx = parseInt(el.getAttribute('data-scen-idx'));
        const sec = el.getAttribute('data-sec');
        const field = el.getAttribute('data-field');
        const iidx = el.getAttribute('data-item-idx');
        const handler = () => {
            if (sec) {
                if (iidx !== null) {
                    const item = state.scenarios[sidx].sections[sec].items[parseInt(iidx)];
                    if (['factor','rate_kbps','period_s','jitter_pct','total_nodes','density'].includes(field)) {
                        item ? (item[field] = parseFloat(el.value)) : state.scenarios[sidx].sections[sec][field] = parseFloat(el.value);
                                            if (field === 'factor') {
                                                adjustWeightsProportionally(sidx, sec, parseInt(iidx));
                                                updateWeightWarning(sidx, sec);
                                                updateWeightInputsDisplay(sidx, sec);
                                            }
                    } else if (['pattern','selected','script_path','v_type','v_vector','v_name','v_path','v_count','v_metric'].includes(field)) {
                        const prev = item[field];
                        if (field === 'v_count') {
                            const n = parseInt(el.value, 10) || 1;
                            item[field] = n;
                        } else {
                            item[field] = el.value;
                        }
                        if (field === 'selected') {
                            if (item.selected === 'Specific') {
                                if (!item.v_count) item.v_count = 1;
                                if (!item.v_metric) item.v_metric = 'Count';
                            } else {
                                if (!item.v_metric) item.v_metric = 'Weight';
                            }
                            // Re-render to show/hide appropriate controls and recalc weight warnings
                            renderMain();
                        } else if (field === 'v_metric') {
                            // On metric toggle, normalize weights for current section and re-render
                            if (item.v_metric === 'Count' && (item.v_count === undefined || item.v_count === null || isNaN(parseInt(item.v_count, 10)))) {
                                item.v_count = 1;
                            }
                            redistributeEven(sidx, sec);
                            updateWeightWarning(sidx, sec);
                            renderMain();
                        } else if (field === 'v_count') {
                            // Count change affects Total Nodes label
                            renderMain();
                        }
                    } else {
                        state.scenarios[sidx].sections[sec][field] = el.value;
                    }
                } else {
                    if (field === 'density' || field === 'total_nodes') {
                        let v = parseFloat(el.value);
                        if (field === 'density') {
                            if (isNaN(v)) v = 0.5;
                            v = Math.max(0, Math.min(1, v));
                        }
                        state.scenarios[sidx].sections[sec][field] = v;
                        // keep hidden for submit and update any warnings
                        if (field === 'density') { updateWeightWarning(sidx, sec); }
                        // Ensure Total Nodes label refreshes on total_nodes edits
                        if (field === 'total_nodes') { renderMain(); }
                    } else {
                        state.scenarios[sidx].sections[sec][field] = el.value;
                    }
                }
            } else {
                if (field === 'name') state.scenarios[sidx].name = el.value;
                if (field === 'base-file') state.scenarios[sidx].base.filepath = el.value;
                if (field === 'notes') state.scenarios[sidx].notes = el.value;
            }
            // keep hidden for submit
            document.getElementById('scenarios_json').value = JSON.stringify({ scenarios: state.scenarios });
            logDebug(`Field change: scen=${sidx} sec=${sec||''} field=${field}`);
        };
        el.addEventListener('input', handler);
        el.addEventListener('change', handler);
    });
    document.querySelectorAll('[data-action="remove-item"]').forEach(btn => {
        btn.onclick = () => {
            const sidx = parseInt(btn.getAttribute('data-scen-idx'));
            const sec = btn.getAttribute('data-sec');
            const iidx = parseInt(btn.getAttribute('data-item-idx'));
            state.scenarios[sidx].sections[sec].items.splice(iidx,1);
            logInfo(`Removed item ${iidx} from ${sec}`);
              redistributeEven(sidx, sec);
              // Re-render to refresh totals and labels
              renderMain();
        };
    });
    document.querySelectorAll('[data-action="add-item"]').forEach(btn => {
        btn.onclick = () => {
            const sidx = parseInt(btn.getAttribute('data-scen-idx'));
            const sec = btn.getAttribute('data-sec');
            const item = { selected: 'Random', factor: 1.0 };
            if (sec === 'Events') item.script_path = '';
            if (sec === 'Traffic') { item.pattern = 'continuous'; item.rate_kbps = 64.0; item.period_s = 1.0; item.jitter_pct = 10.0; }
            if (sec === 'Vulnerabilities') { item.selected = 'Category'; item.v_type = 'Random'; item.v_vector = 'Random'; }
            // Default new rows: Node Information -> Count; others -> Weight.
            if (sec === 'Node Information') { item.v_metric = 'Count'; item.v_count = 1; }
            else { item.v_metric = 'Weight'; }
            state.scenarios[sidx].sections[sec].items.push(item);
            logInfo(`Added item to ${sec}`);
              redistributeEven(sidx, sec);
              renderMain();
        };
    });
    document.querySelectorAll('[data-action="toggle-collapse"]').forEach(btn => {
        btn.onclick = () => {
            const targetSel = btn.getAttribute('data-target');
            const target = document.querySelector(targetSel);
            if (!target) return;
            const visible = target.style.display !== 'none';
            target.style.display = visible ? 'none' : 'block';
            btn.textContent = visible ? 'Expand' : 'Collapse';
            logDebug(`Section toggle ${targetSel} -> ${visible ? 'collapsed':'expanded'}`);
        };
    });
        document.querySelectorAll('[data-action="remove-scenario"]').forEach(btn => {
        btn.onclick = async () => {
                const sidx = parseInt(btn.getAttribute('data-scen-idx'));
                const scen = state.scenarios[sidx];
                if(!scen){ return; }
                let runCount = 0;
                try {
                    const resp = await fetch('/reports_data');
                    if(resp.ok){
                        const data = await resp.json();
                        runCount = (data.history||[]).filter(r => (r.scenario_names||[]).includes(scen.name)).length;
                    }
                } catch(e) {}
                let lines = [];
                lines.push(`Delete scenario "${scen.name}"?`);
                if(runCount > 0){
                    lines.push("");
                    lines.push(`WARNING: ${runCount} run history entr${runCount===1?'y':'ies'} and their artifact files (XML, report, pre-session XML) will be permanently deleted.`);
                }
                lines.push("");
                lines.push("This action cannot be undone.");
                lines.push("");
                lines.push("Proceed?");
                const msg = lines.join('\n');
                if(!window.confirm(msg)) { return; }
                state.scenarios.splice(sidx,1);
                if (activeIdx >= state.scenarios.length) activeIdx = Math.max(0, state.scenarios.length - 1);
                render();
                if(runCount > 0){
                    try { await fetch('/purge_history_for_scenario', {method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ name: scen.name })}); } catch(e) {}
                }
        };
    });
    // keep hidden JSON synced
    document.getElementById('scenarios_json').value = JSON.stringify({ scenarios: state.scenarios });
        // Initialize warnings per section
        const scen = state.scenarios[activeIdx];
        if (scen) {
            ['Node Information','Routing','Services','Traffic','Events','Vulnerabilities','Segmentation'].forEach(sec => updateWeightWarning(activeIdx, sec));
        }
}

function wireCoreControls() {
    // defaults
    if (!state.core) state.core = { host: (initialPayload?.core?.host || 'localhost'), port: (initialPayload?.core?.port || 50051) };
    const hostEl = document.getElementById('coreHost');
    const portEl = document.getElementById('corePort');
    const btn = document.getElementById('testCoreBtn');
    const statusEl = document.getElementById('coreStatus');
    const runSync = document.getElementById('runSyncBtn');
    const runAsync = document.getElementById('runAsyncBtn');
    const cancelBtn = document.getElementById('cancelRunBtn');
    const runSyncWrap = document.getElementById('runSyncWrap');
    const runAsyncWrap = document.getElementById('runAsyncWrap');

    const setRunEnabled = (ok) => {
        if (ok) {
            runSync.removeAttribute('disabled');
            runAsync.removeAttribute('disabled');
            runSync.classList.remove('pe-none');
            runAsync.classList.remove('pe-none');
            runSyncWrap?.setAttribute('data-bs-title', '');
            runAsyncWrap?.setAttribute('data-bs-title', '');
            statusEl.classList.remove('text-danger');
            statusEl.classList.add('text-success');
            statusEl.textContent = 'CORE reachable';
        } else {
            runSync.setAttribute('disabled', 'disabled');
            runAsync.setAttribute('disabled', 'disabled');
            runSync.classList.add('pe-none');
            runAsync.classList.add('pe-none');
            runSyncWrap?.setAttribute('data-bs-title', 'Test CORE connection first');
            runAsyncWrap?.setAttribute('data-bs-title', 'Test CORE connection first');
            statusEl.classList.remove('text-success');
            statusEl.classList.add('text-danger');
        }
    };

    // initialize values
    if (hostEl) hostEl.value = state.core.host || 'localhost';
    if (portEl) portEl.value = state.core.port || 50051;
    // restore prior success only if host/port unchanged
    if (state.core_ok === true && state.core_tested_host === (hostEl.value || '').trim() && String(state.core_tested_port) === String(portEl.value)) {
        setRunEnabled(true);
    } else {
        setRunEnabled(false);
        statusEl.textContent = 'Not tested';
    }

    const onEdit = () => {
    state.core.host = hostEl.value.trim();
    state.core.port = parseInt(portEl.value || '50051', 10) || 50051;
    state.core_ok = false; // changing values invalidates previous test
        // any edit resets test state
        setRunEnabled(false);
        statusEl.textContent = 'Not tested';
    };
    hostEl?.addEventListener('input', onEdit);
    portEl?.addEventListener('input', onEdit);

    btn?.addEventListener('click', async () => {
    btn.disabled = true;
    logInfo('Testing CORE connection');
        statusEl.classList.remove('text-danger', 'text-success');
        statusEl.textContent = 'Testing...';
        try {
            const res = await fetch("{{ url_for('test_core') }}", {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ host: hostEl.value.trim() || 'localhost', port: parseInt(portEl.value || '50051', 10) || 50051 })
            });
            const data = await res.json();
            if (data && data.ok) {
                // persist success and the tested values
                state.core_ok = true;
                state.core_tested_host = hostEl.value.trim() || 'localhost';
                state.core_tested_port = parseInt(portEl.value || '50051', 10) || 50051;
                setRunEnabled(true);
                logInfo(`CORE reachable at ${data.host||hostEl.value}:${data.port||portEl.value}`);
            } else {
                setRunEnabled(false);
                statusEl.textContent = 'Connection failed' + (data?.error ? `: ${data.error}` : '');
                logWarn(`CORE connection failed: ${data?.error||'unknown'}`);
            }
        } catch (e) {
            setRunEnabled(false);
            statusEl.textContent = 'Connection failed';
            logError('CORE test threw exception');
        } finally {
            btn.disabled = false;
        }
    });
}

function prepareRunCli() {
    // prefer the last saved XML path or result_path if it's XML
    const rp = state.result_path || '';
    if (!rp.endsWith('.xml')) {
        alert('Please save XML first.');
        logWarn('Run CLI blocked: no saved XML');
        return false;
    }
    // confirmation dialog warning user a CORE scenario will be created and started
    const confirmMsg = 'This action will generate a new CORE scenario and attempt to start it using the provided daemon connection.\n\nProceed?';
    if (!window.confirm(confirmMsg)) {
        logInfo('Run CLI cancelled by user at confirmation');
        return false;
    }
    document.getElementById('xml_path').value = rp;
    logInfo('Running CLI sync');
    return true;
}

render();

// Always serialize state just before submitting the Save XML form
const editorForm = document.getElementById('editorForm');
if (editorForm) {
    editorForm.addEventListener('submit', () => {
        document.getElementById('scenarios_json').value = JSON.stringify({ scenarios: state.scenarios });
    });
}

// Enable Bootstrap tooltips globally
document.addEventListener('DOMContentLoaded', () => {
    const tooltipTriggerList = [].slice.call(document.querySelectorAll('[data-bs-toggle="tooltip"]'));
    tooltipTriggerList.forEach(el => new bootstrap.Tooltip(el));
    setupDock();
    // ingest any server-rendered lines present at load
    try {
        const lp = document.getElementById('logsPre');
        if (lp && lp.textContent.trim()) {
            lp.textContent.split(/\n/).forEach(line => {
                if (!line.trim()) return;
                let lvl = 'INFO';
                if (line.includes(' ERROR')) lvl = 'ERROR';
                else if (line.includes(' WARN')) lvl = 'WARN';
                else if (line.includes(' DEBUG')) lvl = 'DEBUG';
                logBuffer.push({ level: lvl, levelValue: LOG_LEVELS[lvl], line });
            });
            renderLogs();
        }
    } catch(e) {}
    const sel = document.getElementById('logLevelFilter');
    sel?.addEventListener('change', () => setLogLevel(sel.value));
        setupVulnCatalog();
});

// Vulnerability catalog and UI helpers
async function setupVulnCatalog(){
        try {
                const res = await fetch('/vuln_catalog');
        if(res.ok){ window.VULN_CATALOG = await res.json(); }
    } catch(e) { window.VULN_CATALOG = { types: [], vectors: [], items: [] }; }
}

function populateVulnSelects() {
        document.querySelectorAll('.vuln-type').forEach(sel => {
                const sidx = parseInt(sel.getAttribute('data-scen-idx'));
                const sec = sel.getAttribute('data-sec');
                const iidx = parseInt(sel.getAttribute('data-item-idx'));
                const cur = (state.scenarios[sidx].sections[sec].items[iidx].v_type) || 'Random';
                const opts = ['Random', ...(window.VULN_CATALOG?.types || [])];
                sel.innerHTML = opts.map(o => `<option ${o===cur?'selected':''}>${o}</option>`).join('');
        });
        document.querySelectorAll('.vuln-vector').forEach(sel => {
                const sidx = parseInt(sel.getAttribute('data-scen-idx'));
                const sec = sel.getAttribute('data-sec');
                const iidx = parseInt(sel.getAttribute('data-item-idx'));
                const cur = (state.scenarios[sidx].sections[sec].items[iidx].v_vector) || 'Random';
                const opts = ['Random', ...(window.VULN_CATALOG?.vectors || [])];
                sel.innerHTML = opts.map(o => `<option ${o===cur?'selected':''}>${o}</option>`).join('');
        });
}

// Modal for Specific selection
function ensureVulnModal(){
        if(document.getElementById('vulnModal')) return;
        const modal = document.createElement('div');
        modal.className = 'modal fade';
        modal.id = 'vulnModal';
        modal.innerHTML = `
        <div class="modal-dialog modal-lg">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title">Select Vulnerability</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
                </div>
                <div class="modal-body">
                    <div class="d-flex align-items-start gap-2 mb-2">
                        <div class="flex-grow-1">
                            <input class="form-control" placeholder="Filter (string or /regex/)" id="vulnFilter">
                            <div class="invalid-feedback" id="vulnFilterError">Invalid regex</div>
                        </div>
                        <button class="btn btn-outline-secondary" type="button" id="vulnFilterClear" title="Clear filter">Clear</button>
                    </div>
                    <div class="text-muted small mb-2" id="vulnFilterMeta"></div>
                    <div class="table-responsive" style="max-height:50vh; overflow:auto;">
                        <table class="table table-sm">
                            <thead><tr><th>Name</th><th>Type</th><th>Vector</th><th>Path</th></tr></thead>
                            <tbody id="vulnList"></tbody>
                        </table>
                    </div>
                </div>
                <div class="modal-footer">
                    <button class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
                </div>
            </div>
        </div>`;
        document.body.appendChild(modal);
}

function openVulnPicker(sidx, secName, iidx){
        ensureVulnModal();
        const modalEl = document.getElementById('vulnModal');
        const filterInput = modalEl.querySelector('#vulnFilter');
    const filterClearBtn = modalEl.querySelector('#vulnFilterClear');
    const filterMeta = modalEl.querySelector('#vulnFilterMeta');
    const filterError = modalEl.querySelector('#vulnFilterError');
        const tbody = modalEl.querySelector('#vulnList');
    let current = (window.VULN_CATALOG?.items || []);
        const renderRows = () => {
                tbody.innerHTML = '';
                current.forEach((it, idx) => {
                        const tr = document.createElement('tr');
                        tr.innerHTML = `<td>${it.Name}</td><td>${it.Type}</td><td>${it.Vector}</td><td>${it.Path}</td>`;
                        tr.style.cursor = 'pointer';
            tr.onclick = () => {
                                const item = state.scenarios[sidx].sections[secName].items[iidx];
                                item.v_name = it.Name;
                                item.v_path = it.Path;
                                item.v_type = it.Type;
                                item.v_vector = it.Vector;
                if (it.Description) item.v_desc = it.Description;
                                // also set selected to Specific defensively
                                item.selected = 'Specific';
                                // update state	enable
                                document.getElementById('scenarios_json').value = JSON.stringify({ scenarios: state.scenarios });
                                if(window.bootstrap){ bootstrap.Modal.getInstance(modalEl)?.hide(); }
                                renderMain();
                        };
                        tbody.appendChild(tr);
                });
        };
    const applyFilter = () => {
        const raw = (filterInput.value||'').trim();
        try { localStorage.setItem('vulnPickerFilter', raw); } catch(e){}
        // Reset error state by default
        filterInput.classList.remove('is-invalid');
        if (filterError) filterError.style.display = '';
        if(!raw){
            current = (window.VULN_CATALOG?.items || []);
            renderRows();
            if (filterMeta) filterMeta.textContent = `${current.length}/${(window.VULN_CATALOG?.items || []).length} shown`;
            return;
        }
        let matcher = null;
        if (raw.startsWith('/') && raw.endsWith('/') && raw.length >= 2) {
            try { matcher = new RegExp(raw.slice(1, -1), 'i'); } catch(e){ matcher = null; }
            if (!matcher) {
                // Flag invalid regex, keep previous results (do not change current)
                filterInput.classList.add('is-invalid');
                if (filterMeta) filterMeta.textContent = `Invalid regex`;
                return;
            }
        }
        if (matcher) {
            current = (window.VULN_CATALOG?.items || []).filter(it => matcher.test(it.Name) || matcher.test(it.Type) || matcher.test(it.Vector) || matcher.test(it.Path));
        } else {
            const lower = raw.toLowerCase();
            current = (window.VULN_CATALOG?.items || []).filter(it => (it.Name||'').toLowerCase().includes(lower) || (it.Type||'').toLowerCase().includes(lower) || (it.Vector||'').toLowerCase().includes(lower) || (it.Path||'').toLowerCase().includes(lower));
        }
        renderRows();
    if (filterMeta) filterMeta.textContent = `${current.length}/${(window.VULN_CATALOG?.items || []).length} shown`;
    };
    filterInput.oninput = applyFilter;
    filterClearBtn.onclick = () => { filterInput.value = ''; applyFilter(); };
    // Load last-used filter, if any
    try {
        const saved = localStorage.getItem('vulnPickerFilter');
        if (saved) filterInput.value = saved;
    } catch(e){}
    // Initial render and apply saved filter
    renderRows();
    applyFilter();
        if(window.bootstrap){ new bootstrap.Modal(modalEl).show(); }
}


async function runAsync() {
    const rp = state.result_path || '';
    if (!rp.endsWith('.xml')) { alert('Please save XML first.'); logWarn('Async run blocked: no saved XML'); return; }
    const confirmMsg = 'This action will generate a new CORE scenario and attempt to start it asynchronously using the daemon connection.\n\nProceed?';
    if (!window.confirm(confirmMsg)) { logInfo('Async run cancelled by user at confirmation'); return; }
    const form = new FormData(); form.append('xml_path', rp);
        const res = await fetch("{{ url_for('run_cli_async') }}", { method: 'POST', body: form });
    if (!res.ok) { alert('Failed to start run'); return; }
    const { run_id } = await res.json();
    logInfo(`Async run started id=${run_id}`);
    startLogStream(run_id);
    pollRunStatus(run_id);
}

let evtSrc = null;
function startLogStream(runId) {
    if (evtSrc) { try { evtSrc.close(); } catch(e){} }
    evtSrc = new EventSource('/stream/' + runId);
    const logsPre = document.getElementById('logsPre');
    logsPre.textContent = '';
    logBuffer = [];
    // Toggle buttons
    document.getElementById('runAsyncBtn').classList.add('d-none');
    document.getElementById('runSyncBtn').classList.add('disabled');
    document.getElementById('cancelRunBtn').classList.remove('d-none');
    evtSrc.onmessage = (ev) => {
        const raw = ev.data || '';
        let lvl = 'INFO';
        if (/\bERROR\b/.test(raw)) lvl = 'ERROR';
        else if (/\bWARN(ING)?\b/.test(raw)) lvl = 'WARN';
        else if (/\bDEBUG\b/.test(raw)) lvl = 'DEBUG';
        logLine(lvl, raw);
    };
    evtSrc.addEventListener('end', () => {
        evtSrc.close();
        document.getElementById('runAsyncBtn').classList.remove('d-none');
        document.getElementById('runSyncBtn').classList.remove('disabled');
        document.getElementById('cancelRunBtn').classList.add('d-none');
        logInfo('Async run ended');
    });
}

async function pollRunStatus(runId) {
    const xmlPre = document.getElementById('xmlPre');
    try {
    const res = await fetch('/run_status/' + runId);
        if (!res.ok) return;
        const data = await res.json();
        // Update download link
        const rp = data.report_path || data.xml_path;
        if (rp) { state.result_path = rp; }
        // Refresh XML preview if we have the xml path and it's changed
        if (data.xml_path && xmlPre && !xmlPre.textContent.trim()) {
                    try {
                        const txt = await (await fetch('/download_report?path=' + encodeURIComponent(data.xml_path))).text();
                        xmlPre.textContent = txt;
                    } catch(e){}
        }
        if (!data.done) {
            setTimeout(() => pollRunStatus(runId), 1000);
        }
    } catch(e) {
        // ignore transient errors
        setTimeout(() => pollRunStatus(runId), 1500);
    }
}

    async function cancelRun() {
        if (!evtSrc) return;
        // Extract runId from the EventSource URL
        const url = evtSrc.url;
        const runId = url.split('/').pop();
        try {
            await fetch('/cancel_run/' + runId, { method: 'POST' });
        } catch(e) {}
    try { evtSrc.close(); } catch(e){}
        document.getElementById('runAsyncBtn').classList.remove('d-none');
        document.getElementById('runSyncBtn').classList.remove('disabled');
        document.getElementById('cancelRunBtn').classList.add('d-none');
    logInfo('Run cancelled by user');
    }

    function redistributeEven(sidx, secName) {
        const items = state.scenarios[sidx].sections[secName].items;
        const n = items.length;
        if (n === 0) return;
    const weightIdxs = items.map((it,i) => ({i,it})).filter(x => ((x.it.v_metric|| (x.it.selected==='Specific'?'Count':'Weight')) === 'Weight')).map(x => x.i);
    const m = weightIdxs.length;
    if (m === 0) { return; }
    const even = Math.round((1.0 / m) * 1000) / 1000;
    weightIdxs.slice(0, -1).forEach(i => { items[i].factor = even; });
        // last item gets the residual to hit 1.0
    const sumOther = weightIdxs.slice(0, -1).reduce((a, i) => a + (parseFloat(items[i].factor)||0), 0);
    const lastIdx = weightIdxs[weightIdxs.length - 1];
    items[lastIdx].factor = Math.max(0, Math.round((1.0 - sumOther) * 1000) / 1000);
        updateWeightWarning(sidx, secName);
    }

    function adjustWeightsProportionally(sidx, secName, changedIdx) {
        const items = state.scenarios[sidx].sections[secName].items;
        const n = items.length;
    const weightIdxs = items.map((it,i) => ({i,it})).filter(x => ((x.it.v_metric|| (x.it.selected==='Specific'?'Count':'Weight')) === 'Weight')).map(x => x.i);
        const m = weightIdxs.length;
        if (m <= 1) { if (m === 1) items[weightIdxs[0]].factor = 1.0; return; }
        // clamp changed value
        items[changedIdx].factor = Math.max(0, Math.min(1, parseFloat(items[changedIdx].factor)||0));
        const targetSum = 1.0;
        const changed = parseFloat(items[changedIdx].factor)||0;
        const others = weightIdxs.map(i => i !== changedIdx ? (parseFloat(items[i].factor)||0) : 0);
        const sumOthers = others.reduce((a,b) => a + b, 0);
        const residual = Math.max(0, targetSum - changed);
        if (sumOthers <= 0) {
            // Distribute evenly across others
            const even = residual / (m - 1);
            weightIdxs.forEach(i => { if (i !== changedIdx) items[i].factor = Math.round(even * 1000) / 1000; });
        } else {
            // Scale others proportionally to keep overall sum 1.0
            weightIdxs.forEach((i, idx) => {
                if (i === changedIdx) return;
                const ratio = others[idx] / sumOthers;
                items[i].factor = Math.round((residual * ratio) * 1000) / 1000;
            });
        }
        // Final normalization to exact 1.000 with 3 decimals
        normalizeToThousandths(sidx, secName);
    }

    function updateWeightWarning(sidx, secName) {
        const items = state.scenarios[sidx].sections[secName].items;
    // Exempt Node Information from weight validation (single Random item default)
    if (secName === 'Node Information') return;
    if (!items || items.length === 0) return;
        const sum = Math.round(items.reduce((a,b) => {
            const metric = b.v_metric || (b.selected==='Specific'?'Count':'Weight');
            return a + (metric==='Weight' ? (parseFloat(b.factor)||0) : 0);
        }, 0) * 1000) / 1000;
    const warn = document.querySelector(".section-warning[data-scen-idx='" + sidx + "'][data-sec='" + secName + "']");
        if (warn) {
            const density = parseFloat((state.scenarios[sidx].sections[secName]||{}).density);
            const weightCount = items.filter(b => (b.v_metric || (b.selected==='Specific'?'Count':'Weight')) === 'Weight').length;
            const badWeights = weightCount > 0 ? (Math.abs(sum - 1.0) > 0.005) : false;
            const badDensity = isNaN(density) ? false : (density < 0 || density > 1);
            warn.style.display = (badWeights || badDensity) ? 'block' : 'none';
            let msgs = [];
            if (badWeights) msgs.push('Weights must sum to 1.000 (current: ' + sum.toFixed(3) + ')');
            if (badDensity) msgs.push('Density must be between 0 and 1 (current: ' + density.toFixed(2) + ')');
            warn.textContent = msgs.join(' • ');
        }
    }

    function normalizeToThousandths(sidx, secName) {
        const items = state.scenarios[sidx].sections[secName].items;
        if (!items || items.length === 0) return;
        const vals = items.map(it => {
            const metric = it.v_metric || (it.selected==='Specific'?'Count':'Weight');
            const v = Math.max(0, Math.min(1, parseFloat(it.factor)||0));
            return metric==='Weight' ? v : 0;
        });
        // Convert to thousandths without rounding first
        const thousandthsRaw = vals.map(v => v * 1000);
        const floors = thousandthsRaw.map(v => Math.floor(v));
        let sumFloors = floors.reduce((a,b) => a + b, 0);
        let remainder = 1000 - sumFloors;
        if (remainder > 0) {
            // Distribute +1 to largest fractional parts
            const remainders = thousandthsRaw.map((v, i) => ({ idx: i, frac: v - floors[i] }));
            remainders.sort((a,b) => b.frac - a.frac);
            for (let k = 0; k < remainders.length && remainder > 0; k++) {
                floors[remainders[k].idx] += 1; remainder -= 1;
            }
        } else if (remainder < 0) {
            // Remove -1 from largest values to reduce sum to 1000
            const order = floors.map((v,i) => ({ idx: i, v }));
            order.sort((a,b) => b.v - a.v);
            while (remainder < 0) {
                for (let k = 0; k < order.length && remainder < 0; k++) {
                    const i = order[k].idx;
                    if (floors[i] > 0) { floors[i] -= 1; remainder += 1; }
                }
                if (order.length === 0) break;
            }
        }
        for (let i = 0; i < items.length; i++) {
            const metric = items[i].v_metric || (items[i].selected==='Specific'?'Count':'Weight');
            items[i].factor = (metric==='Weight') ? (floors[i] / 1000.0) : (items[i].factor||0);
        }
    }

    function updateWeightInputsDisplay(sidx, secName) {
        const items = state.scenarios[sidx].sections[secName].items;
    document.querySelectorAll("input.weight-input[data-scen-idx='" + sidx + "'][data-sec='" + secName + "']").forEach(input => {
            const iidx = parseInt(input.getAttribute('data-item-idx'));
            if (!isNaN(iidx) && items[iidx]) {
                input.value = (parseFloat(items[iidx].factor) || 0).toFixed(3);
            }
        });
    }

    function setupDock() {
        const dock = document.getElementById('dockPanel');
        const grip = document.getElementById('dockGrip');
        const hideBtn = document.getElementById('dockHideBtn');
        const showBtn = document.getElementById('dockShowBtn');
        if (!dock || !grip || !hideBtn || !showBtn) return;

        const setBodyPad = (px) => { document.body.style.paddingBottom = Math.max(px, 0) + 'px'; };
        const applyHeight = (px) => {
            dock.style.height = px + 'px';
            setBodyPad(px + 12);
            localStorage.setItem('coretg_dock_height_px', String(px));
        };
        // Init from storage or default to current offsetHeight
        const savedH = parseInt(localStorage.getItem('coretg_dock_height_px') || '0', 10);
        const initialH = (savedH > 100 ? savedH : dock.offsetHeight);
        applyHeight(initialH);

        // Resizing
        let resizing = false;
        let startY = 0;
        let startH = initialH;
        const onMove = (e) => {
            if (!resizing) return;
            const dy = startY - (e.touches ? e.touches[0].clientY : e.clientY);
            const newH = Math.min(Math.max(startH + dy, 120), window.innerHeight - 80);
            applyHeight(newH);
        };
        const onUp = () => { resizing = false; document.removeEventListener('mousemove', onMove); document.removeEventListener('mouseup', onUp); document.removeEventListener('touchmove', onMove); document.removeEventListener('touchend', onUp); };
        grip.addEventListener('mousedown', (e) => { resizing = true; startY = e.clientY; startH = dock.offsetHeight; document.addEventListener('mousemove', onMove); document.addEventListener('mouseup', onUp); });
        grip.addEventListener('touchstart', (e) => { resizing = true; startY = e.touches[0].clientY; startH = dock.offsetHeight; document.addEventListener('touchmove', onMove); document.addEventListener('touchend', onUp); }, { passive: true });

        // Hide/show
        const applyHidden = (hidden) => {
            if (hidden) {
                dock.classList.add('d-none');
                showBtn.classList.remove('d-none');
                setBodyPad(12);
            } else {
                dock.classList.remove('d-none');
                showBtn.classList.add('d-none');
                applyHeight(parseInt(localStorage.getItem('coretg_dock_height_px') || String(initialH), 10));
            }
            localStorage.setItem('coretg_dock_hidden', hidden ? '1' : '0');
        };
    // Init hidden state (default hidden if no saved preference)
    const savedHidden = localStorage.getItem('coretg_dock_hidden');
    applyHidden(savedHidden ? savedHidden === '1' : true);
        hideBtn.addEventListener('click', () => applyHidden(true));
        showBtn.addEventListener('click', () => applyHidden(false));

        // Persist active tab across reloads
        const tabButtons = dock.querySelectorAll(".nav-link[data-bs-toggle='tab']");
        tabButtons.forEach(btn => {
            btn.addEventListener('shown.bs.tab', (e) => {
                const target = e.target.getAttribute('data-bs-target');
                if (target) localStorage.setItem('coretg_dock_active_tab', target);
            });
        });
        // Restore previously active tab, if any
        const savedTab = localStorage.getItem('coretg_dock_active_tab');
        if (savedTab) {
            const btn = dock.querySelector(".nav-link[data-bs-target='" + savedTab + "']");
            if (btn) {
                try { new bootstrap.Tab(btn).show(); } catch(e) {}
            }
        }
    }
</script>
</body>
<!-- Success Modal -->
<div class="modal fade" id="runSuccessModal" tabindex="-1" aria-hidden="true">
    <div class="modal-dialog modal-dialog-centered">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title">Run Completed</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <p class="mb-1" id="runSuccessBody">Generation complete.</p>
                <p class="small text-muted mb-0">View and download artifacts on the Reports page.</p>
            </div>
            <div class="modal-footer">
                <a href="{{ url_for('reports_page') }}" class="btn btn-primary">Open Reports</a>
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
            </div>
        </div>
    </div>
</div>
<script>
function enableReportsButton(){
    const btn = document.getElementById('reportsBtn');
    if(!btn) return; btn.removeAttribute('disabled'); btn.classList.remove('pe-none');
}
function showRunSuccessModal(msg){
    try { if(msg) document.getElementById('runSuccessBody').textContent = msg; new bootstrap.Modal(document.getElementById('runSuccessModal')).show(); } catch(e){}
}
document.addEventListener('DOMContentLoaded', () => {
    if (window.runSuccessFlag) { enableReportsButton(); showRunSuccessModal('Synchronous run completed successfully.'); }
});
// Capture server-provided flag (injected if present)
// Inject run success flag
window.runSuccessFlag = ("{{ '1' if (run_success is defined and run_success) else '0' }}" === '1');
// Wrap pollRunStatus to detect async completion success
const __origPollRunStatus = pollRunStatus;
pollRunStatus = async function(runId){
    await __origPollRunStatus(runId);
    try {
        const res = await fetch('/run_status/' + runId);
        if(!res.ok) return;
        const data = await res.json();
        if(data.done && data.returncode === 0){
            enableReportsButton();
            showRunSuccessModal('Asynchronous run completed successfully.');
        } else if(!data.done) {
            setTimeout(() => pollRunStatus(runId), 800);
        }
    } catch(e){}
};
</script>
</html>
