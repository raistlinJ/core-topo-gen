{% extends 'layout.html' %}
{% block title %}Scenarios - CORE TopoGen{% endblock %}
{% block active_page %}{% set active_page = 'scenarios' %}{% endblock %}
{% block extra_head %}
<style>
    body { padding-bottom: 42vh; }
    .pulse-change { animation: pulseHighlight .9s ease-in-out; }
    @keyframes pulseHighlight { 0% { box-shadow:0 0 0 0 rgba(13,110,253,.7); transform:scale(1);} 40% { box-shadow:0 0 0 6px rgba(13,110,253,.0); transform:scale(1.03);} 100% { box-shadow:0 0 0 0 rgba(13,110,253,0); transform:scale(1); } }
    .popover { max-width: 420px; }
    .host-total-badge + .badge, .host-total-badge + button { margin-left: .25rem; }
    /* Hide H/S bounds by default; JS adds .hs-show to display them */
    .hs-bounds-wrapper { display: none; }
    .hs-bounds-wrapper.hs-show { display: flex; }
    .form-switch.form-switch-sm .form-check-input {
        height: 1rem;
        width: 2rem;
        transform: scale(0.85);
        margin-top: 0.15rem;
    }
    .form-switch.form-switch-sm .form-check-label {
        padding-left: .35rem;
    }
    fieldset.hitl-step-fieldset {
        border: 0;
        padding: 0;
        margin: 0;
        min-width: 0;
    }
    fieldset.hitl-step-fieldset[disabled] {
        opacity: 0.6;
        pointer-events: none;
    }
</style>
{% endblock %}
<!-- hs-bounds-wrapper styles moved into style block above -->
{% block content %}
    <div class="row">
        <div class="col-md-3 mb-3">
                <div class="card shadow-sm h-100 d-flex flex-column">
                            <div class="card-header d-flex justify-content-between align-items-center">
                                <span class="fw-bold">Scenarios</span>
                                <div class="btn-toolbar gap-2 align-items-center">
                                    <button type="button" class="btn btn-sm btn-outline-secondary" id="importBtn" title="Import scenarios XML">Import</button>
                                    <button type="button" class="btn btn-sm btn-outline-info" id="exportBtn" title="Export last saved XML">Export</button>
                                    <div class="btn-group" role="group" aria-label="Bulk scenario actions">
                                        <button type="button" class="btn btn-sm btn-outline-secondary" id="selectAllScenariosBtn" title="Select all (or clear if all selected)">All</button>
                                        <button type="button" class="btn btn-sm btn-outline-danger" id="deleteSelectedScenariosBtn" title="Delete selected scenarios" disabled>Delete</button>
                                    </div>
                                </div>
                            </div>
                    <div class="list-group list-group-flush flex-grow-1 overflow-auto" id="scenarioList" style="min-height:0;"></div>
                    <form id="hiddenLoadForm" class="d-none" action="{{ url_for('load_xml') }}" method="post" enctype="multipart/form-data">
                        <input type="file" name="scenarios_xml" id="hiddenLoadInput" accept=".xml">
                    </form>
                    <div class="card-footer" style="position: sticky; bottom: 0; background: #fff; z-index: 1;">
                        <button type="button" class="btn btn-sm btn-primary w-100" id="appendScenarioBtn">New Scenario</button>
                    </div>
                </div>
            </div>
    <div class="col-md-9">

            <div class="card shadow mt-3">
                <div class="card-body">
                    {% with messages = get_flashed_messages() %}
                        {% if messages %}
                            <div class="alert alert-info">{{ messages[0] }}</div>
                        {% endif %}
                    {% endwith %}

                    <div class="card mb-3" id="baseCoreScenarioCard">
                        <div class="card-header d-flex justify-content-between align-items-center">
                            <strong>Base CORE Scenario</strong>
                            <div class="d-flex align-items-center gap-2" id="baseScenarioControls">
                                {% set has_base = payload.base_upload is defined and payload.base_upload %}
                                <span id="baseValidityBadge" class="badge {% if not has_base %}d-none{% else %}{% if payload.base_upload.valid %}text-bg-success{% else %}text-bg-danger{% endif %}{% endif %}">
                                    {% if has_base %}{% if payload.base_upload.valid %}VALID{% else %}INVALID{% endif %}{% else %}VALID{% endif %}
                                </span>
                                <a id="baseDetailsLink" class="btn btn-sm btn-outline-secondary {% if not has_base %}d-none{% endif %}" href="{% if has_base %}{{ url_for('core_details') }}?path={{ payload.base_upload.path | urlencode }}{% else %}#{% endif %}" target="_blank" data-base-url="{{ url_for('core_details') }}?path=">Details</a>
                                <form action="{{ url_for('remove_base') }}" method="post" class="d-inline {% if not has_base %}d-none{% endif %}" id="baseRemoveForm" onsubmit="saveScrollBeforeNav(); document.getElementById('scenarios_json').value = JSON.stringify({ scenarios: state.scenarios });">
                                    <button type="submit" class="btn btn-sm btn-outline-danger">Remove</button>
                                </form>
                                <button class="btn btn-sm btn-outline-secondary" type="button" id="baseCoreCollapseBtn" data-preview-collapse="baseCoreScenarioBody" data-label-collapse="Collapse" data-label-expand="Expand">Collapse</button>
                            </div>
                        </div>
                        <div class="card-body collapse show" id="baseCoreScenarioBody">
                            <div class="mb-3">
                                <label class="form-label d-flex align-items-center justify-content-between">
                                    <span>Base Scenario File</span>
                                </label>
                                <input class="form-control" id="baseFileInput" readonly>
                                <div class="form-text">Shows the uploaded file name; full path is stored internally.</div>
                            </div>
                            <form class="d-flex gap-2" action="{{ url_for('upload_base') }}" method="post" enctype="multipart/form-data" onsubmit="saveScrollBeforeNav()">
                                <input type="file" class="form-control" name="base_xml" accept=".xml" required>
                                <button type="submit" class="btn btn-primary">{% if payload.base_upload %}Update{% else %}Upload{% endif %}</button>
                            </form>
                            {% if payload.base_upload and not payload.base_upload.valid and logs %}
                                <div class="alert alert-danger mt-3 mb-0" style="white-space: pre-wrap;">{{ logs }}</div>
                            {% endif %}
                        </div>
                    </div>

                    <div class="card mt-3" id="scenarioEditorCard">
                        <div class="card-header d-flex justify-content-between align-items-center">
                            <strong>Scenario Editor</strong>
                            <button class="btn btn-sm btn-outline-primary" type="button" data-bs-toggle="modal" data-bs-target="#externalIfxModal">External IFX Configuration</button>
                        </div>
                        <div class="card-body">
                            <form id="editorForm" action="{{ url_for('save_xml') }}" method="post">
                                <input type="hidden" name="scenarios_json" id="scenarios_json">
                                <input type="hidden" name="active_index" id="active_index" value="0">
                                        <input type="hidden" name="core_json" id="core_json">
                                <div id="editorRoot"></div>
                                <div class="d-flex gap-2 mt-3">
                                    <button type="submit" class="btn btn-success">Save XML</button>
                                    <button type="button" class="btn btn-outline-info" id="downloadXmlBtn" disabled title="Save XML first">Download XML</button>
                                </div>
                            </form>
                        </div>
                    </div>


                    <!-- Planning Workflow card visually removed but retained (d-none) for underlying JS functionality -->
                    <div class="card mt-3 d-none" id="planWorkflowCard">
                        <div class="card-header d-flex justify-content-between align-items-center">
                            <strong>Planning Workflow</strong>
                            <div id="planStatusBadge" class="badge text-bg-secondary">No Preview</div>
                        </div>
                        <div class="card-body">
                            <div class="d-flex flex-wrap gap-2 align-items-center mb-2">
                                                                <button class="btn btn-sm btn-outline-primary" type="button" id="planPreviewBtn" title="Generate full preview (routers, IPs, services)" disabled>Full Preview</button>
                                                                <!-- Run (Seed) workflow removed: deterministic seed input and run button eliminated -->
                                <!-- Single Full Preview button (above) is authoritative; secondary button and strict checkbox removed -->
                            </div>
                            <div class="small text-muted" id="planHint">Save XML and test CORE connection to enable planning.</div>
                            <pre id="planPreviewJson" class="small bg-light p-2 border rounded d-none" style="max-height:260px;overflow:auto;font-size:0.65rem;"></pre>
                            <div id="fullPreviewStructured" class="mt-2 d-none">
                                <div class="d-flex flex-wrap gap-2 align-items-center mb-2">
                                    <div class="btn-group btn-group-sm" role="group" aria-label="Full preview sections" id="fullPreviewSectionTabs"></div>
                                    <button type="button" class="btn btn-sm btn-outline-secondary" id="toggleRawFullPreviewBtn" title="Toggle raw JSON / structured view">Raw JSON</button>
                                    <!-- Copy seed button removed -->
                                </div>
                                <div id="fullPreviewSectionContent" class="border rounded p-2 bg-white small" style="max-height:300px; overflow:auto; font-size:.7rem;"></div>
                            </div>
                            <div id="planViolationsWrap" class="d-none mt-2">
                                <div class="alert alert-warning py-2 mb-0"><strong>Violations</strong><ul id="planViolationsList" class="mb-0 small"></ul></div>
                            </div>
                        </div>
                    </div>
                    <!-- Run form repurposed: Run CLI now triggers Full Preview (no direct execution here) -->
                    <form class="d-flex gap-2 mt-3 align-items-center" action="javascript:void(0)" id="runLegacyForm">
                        <input type="hidden" name="xml_path" id="xml_path">
                        <span class="d-inline-block" tabindex="0" id="runSyncWrap" data-bs-toggle="tooltip" data-bs-title="Runs CLI using current XML">
                            <button class="btn btn-warning" type="button" id="runSyncBtn" disabled title="Generates a Full Preview (no execution)">Generate</button>
                        </span>
                        <button class="btn btn-outline-danger d-none" type="button" id="cancelRunBtn" onclick="cancelRun()">Cancel</button>
                    </form>
                </div>
            </div>
            
        </div>
    </div>
<!-- Run Progress Modal -->
<div class="modal fade" id="runProgressModal" tabindex="-1" aria-hidden="true">
    <div class="modal-dialog modal-dialog-centered modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title">Running CLI…</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <div class="d-flex justify-content-between align-items-center mb-2 small text-muted">
                    <div id="runProgressStatus">Starting…</div>
                    <div id="runProgressMeta"></div>
                </div>
                <div id="runProgressModeHint" class="mb-2 fw-bold text-warning d-none"></div>
                <div class="progress mb-2">
                    <div class="progress-bar progress-bar-striped progress-bar-animated" id="runProgressBar" style="width: 100%">Working…</div>
                </div>
                <div class="border rounded" style="max-height: 260px; overflow: auto;">
                    <pre class="m-0 p-2 small" id="runProgressLog" style="white-space: pre-wrap;"></pre>
                </div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" id="runProgressHideBtn" data-bs-dismiss="modal">Hide</button>
            </div>
        </div>
    </div>
</div>
{% set xml_preview_enabled = True %}
{% set xml_preview_text = xml_preview %}

<!-- External IFX Configuration Modal -->
<div class="modal fade" id="externalIfxModal" tabindex="-1" aria-hidden="true">
    <div class="modal-dialog modal-lg modal-dialog-scrollable">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title">External IFX Configuration</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <p class="small text-muted">Configure hardware-in-the-loop attachments and external interface mappings for each scenario.</p>
                <div id="externalIfxBusyNotice" class="alert alert-info small d-none" role="status" aria-live="polite"></div>
                <div id="externalIfxHitlContainer" class="d-flex flex-column gap-3"></div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
                <button type="button" class="btn btn-primary d-none" id="externalIfxApplyBtn">Apply</button>
            </div>
        </div>
    </div>
</div>
<!-- Proxmox Assignment Modal -->
<div class="modal fade" id="proxmoxAssignModal" tabindex="-1" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title">Assign Proxmox Resource</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <div class="alert alert-info small" id="proxmoxAssignHint" style="display:none;"></div>
                <form id="proxmoxAssignForm">
                    <div class="mb-3">
                        <label for="proxmoxUrl" class="form-label">URL</label>
                        <input type="url" class="form-control" id="proxmoxUrl" placeholder="https://proxmox.example.local" autocomplete="url" required>
                        <div class="form-text">Provide the base URL to the Proxmox API (https://host.domain).</div>
                    </div>
                    <div class="mb-3">
                        <label for="proxmoxPort" class="form-label">Port</label>
                        <input type="number" class="form-control" id="proxmoxPort" placeholder="8006" min="1" max="65535" autocomplete="on" required>
                    </div>
                    <div class="form-check form-switch mb-3">
                        <input class="form-check-input" type="checkbox" role="switch" id="proxmoxVerifySsl" checked>
                        <label class="form-check-label" for="proxmoxVerifySsl">Enforce SSL certificate verification</label>
                        <div class="form-text">Uncheck when connecting to Proxmox with self-signed or invalid certificates.</div>
                    </div>
                    <div class="mb-3">
                        <label for="proxmoxUsername" class="form-label">Username</label>
                        <input type="text" class="form-control" id="proxmoxUsername" placeholder="root@pam" autocomplete="username" required>
                    </div>
                    <div class="mb-3">
                        <label for="proxmoxPassword" class="form-label">Password</label>
                        <input type="password" class="form-control" id="proxmoxPassword" placeholder="••••••" autocomplete="current-password" required>
                    </div>
                </form>
                <div class="alert alert-danger d-none" id="proxmoxAssignError"></div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-outline-secondary" data-bs-dismiss="modal">Cancel</button>
                <button type="button" class="btn btn-primary" id="proxmoxAssignSave">Validate &amp; Save</button>
            </div>
        </div>
    </div>
</div>
<!-- CORE Connection Modal -->
<div class="modal fade" id="coreConnectionModal" tabindex="-1" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title">CORE Connection</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <div class="alert alert-info small d-none" id="coreConnectionHint"></div>
                <form id="coreConnectionForm" class="needs-validation" novalidate>
                    <div class="row g-2">
                        <div class="col-md-8">
                            <div class="mb-3">
                                <label for="coreSshHost" class="form-label">SSH Host</label>
                                <input type="text" class="form-control" id="coreSshHost" placeholder="Defaults to gRPC host" data-hitl-core-field="ssh_host" autocomplete="off">
                            </div>
                        </div>
                        <div class="col-md-4">
                            <div class="mb-3">
                                <label for="coreSshPort" class="form-label">SSH Port</label>
                                <input type="number" class="form-control" id="coreSshPort" min="1" max="65535" data-hitl-core-field="ssh_port" autocomplete="off">
                            </div>
                        </div>
                    </div>
                    <div class="row g-2">
                        <div class="col-md-6">
                            <div class="mb-3">
                                <label for="coreSshUsername" class="form-label">SSH Username</label>
                                <input type="text" class="form-control" id="coreSshUsername" data-hitl-core-field="ssh_username" autocomplete="username" required>
                            </div>
                        </div>
                        <div class="col-md-6">
                            <div class="mb-3">
                                <label for="coreSshPassword" class="form-label">SSH Password</label>
                                <input type="password" class="form-control" id="coreSshPassword" data-hitl-core-field="ssh_password" autocomplete="current-password">
                                <div class="form-text">Passwords are stored in the secure credential vault after a successful test.</div>
                            </div>
                        </div>
                    </div>
                    <div class="mt-4">
                        <button class="btn btn-link p-0" type="button" data-bs-toggle="collapse" data-bs-target="#coreConnAdvanced" aria-expanded="false" aria-controls="coreConnAdvanced">Advanced</button>
                        <div class="collapse" id="coreConnAdvanced">
                            <div class="border rounded p-2 mt-2">
                                <div class="small text-muted mb-2">Usually you don’t need to change these.</div>
                                <div class="mb-3">
                                    <label for="coreGrpcHost" class="form-label">gRPC Host</label>
                                    <input type="text" class="form-control" id="coreGrpcHost" placeholder="core-host.example" data-hitl-core-field="grpc_host" autocomplete="off" required>
                                </div>
                                <div class="mb-1">
                                    <label for="coreGrpcPort" class="form-label">gRPC Port</label>
                                    <input type="number" class="form-control" id="coreGrpcPort" min="1" max="65535" data-hitl-core-field="grpc_port" autocomplete="off" required>
                                </div>
                            </div>
                        </div>
                    </div>
                </form>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-outline-secondary" data-bs-dismiss="modal">Cancel</button>
                <button type="button" class="btn btn-primary" id="coreConnectionSaveBtn">Save &amp; Validate</button>
            </div>
        </div>
    </div>
</div>
{% include 'partials/dock.html' %}

<!-- Graph libraries for Full Preview Modal -->
<script src="https://cdn.jsdelivr.net/npm/d3@7/dist/d3.min.js"></script>
<script src="{{ url_for('static', filename='core_graph.js') }}"></script>

<!-- Toast container -->
<div aria-live="polite" aria-atomic="true" class="position-fixed" style="z-index: 1080; right: 12px; bottom: 12px;">
    <div id="toastContainer" class="toast-container"></div>
    <template id="toastTemplate">
        <div class="toast align-items-center text-bg-dark border-0" role="alert" aria-live="assertive" aria-atomic="true">
            <div class="d-flex">
                <div class="toast-body">Action completed.</div>
                <button type="button" class="btn-close btn-close-white me-2 m-auto" data-bs-dismiss="toast" aria-label="Close"></button>
            </div>
        </div>
    </template>
</div>
<!-- Success Modal -->
<div class="modal fade" id="runSuccessModal" tabindex="-1" aria-hidden="true">
    <div class="modal-dialog modal-dialog-centered">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title">Run Completed</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <p class="mb-1" id="runSuccessBody">Generation complete.</p>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
            </div>
        </div>
    </div>
</div>
<!-- Full Preview Modal -->
<div class="modal fade" id="fullPreviewModal" tabindex="-1" aria-hidden="true">
    <div class="modal-dialog modal-fullscreen-lg-down modal-xl modal-dialog-scrollable">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title">Full Preview <span class="text-muted small" id="fpModalSeed"></span></h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <div class="row g-3">
                    <div class="col-lg-8">
                        <div class="card" id="fpGraphCard">
                            <div class="card-header d-flex justify-content-between align-items-center">
                                <strong>Graph</strong>
                                <div class="d-flex align-items-center gap-2">
                                    <div class="form-check form-switch form-switch-sm mb-0">
                                        <input class="form-check-input" type="checkbox" role="switch" id="fpGraphLabelsToggle">
                                        <label class="form-check-label small" for="fpGraphLabelsToggle">Show labels</label>
                                    </div>
                                    <div class="btn-group btn-group-sm">
                                        <button class="btn btn-outline-secondary" type="button" id="fpGraphResetBtn">Reset</button>
                                        <button class="btn btn-outline-secondary" type="button" id="fpGraphPngBtn">PNG</button>
                                        <button class="btn btn-outline-secondary" type="button" id="fpOpenStandaloneBtn">Open Page</button>
                                    </div>
                                </div>
                            </div>
                            <div class="card-body p-2">
                                <div id="fpGraph" style="height:480px; position:relative; background:#fafafa; border:1px solid #e0e0e0; border-radius:4px; overflow:hidden;">
                                    <div class="position-absolute top-50 start-50 translate-middle text-muted" id="fpGraphLoading">Rendering...</div>
                                </div>
                                <div class="form-text mt-1">Drag to reposition nodes. Hover for details. PNG exports current view.</div>
                            </div>
                        </div>
                        <div class="card mt-3">
                            <div class="card-header d-flex justify-content-between align-items-center">
                                <strong>Routers</strong>
                                <button class="btn btn-sm btn-outline-secondary" type="button" data-preview-collapse="fpRoutersWrap" data-label-collapse="Collapse" data-label-expand="Expand">Collapse</button>
                            </div>
                            <div class="card-body collapse p-2" id="fpRoutersWrap"><div class="text-muted small">No data</div></div>
                        </div>
                        <div class="card mt-3">
                            <div class="card-header d-flex justify-content-between align-items-center">
                                <strong>Hosts</strong>
                                <button class="btn btn-sm btn-outline-secondary" type="button" data-preview-collapse="fpHostsWrap" data-label-collapse="Collapse" data-label-expand="Expand">Collapse</button>
                            </div>
                            <div class="card-body collapse p-2" id="fpHostsWrap"><div class="text-muted small">No data</div></div>
                        </div>
                        <div class="card mt-3">
                            <div class="card-header d-flex justify-content-between align-items-center">
                                <strong>Switches</strong>
                                <button class="btn btn-sm btn-outline-secondary" type="button" data-preview-collapse="fpSwitchesWrap" data-label-collapse="Collapse" data-label-expand="Expand">Collapse</button>
                            </div>
                            <div class="card-body collapse p-2" id="fpSwitchesWrap"><div class="text-muted small">No data</div></div>
                        </div>
                        <div class="card mt-3">
                            <div class="card-header d-flex justify-content-between align-items-center">
                                <strong>Node Sections</strong>
                                <button class="btn btn-sm btn-outline-secondary" type="button" data-preview-collapse="fpNodeSectionsWrap" data-label-collapse="Collapse" data-label-expand="Expand">Collapse</button>
                            </div>
                            <div class="card-body collapse p-2" style="max-height:240px;overflow:auto;" id="fpNodeSectionsWrap"><div class="text-muted small">No data</div></div>
                        </div>
                    </div>
                    <div class="col-lg-4">
                        <div class="card mb-3">
                            <div class="card-header d-flex justify-content-between align-items-center">
                                <strong>Counts</strong>
                                <button class="btn btn-sm btn-outline-secondary" type="button" data-preview-collapse="fpCounts" data-label-collapse="Collapse" data-label-expand="Expand">Collapse</button>
                            </div>
                            <div class="card-body collapse p-2" id="fpCounts"></div>
                        </div>
                        <div class="card mb-3">
                            <div class="card-header d-flex justify-content-between align-items-center">
                                <strong>R2R Policy</strong>
                                <button class="btn btn-sm btn-outline-secondary" type="button" data-preview-collapse="fpR2RPolicyBody" data-label-collapse="Collapse" data-label-expand="Expand">Collapse</button>
                            </div>
                            <div class="card-body collapse p-2" id="fpR2RPolicyBody"><pre class="small mb-0" id="fpR2RPolicy" style="max-height:160px; overflow:auto;"></pre></div>
                        </div>
                        <div class="card mb-3">
                            <div class="card-header d-flex justify-content-between align-items-center">
                                <strong>R2S Policy</strong>
                                <button class="btn btn-sm btn-outline-secondary" type="button" data-preview-collapse="fpR2SPolicyBody" data-label-collapse="Collapse" data-label-expand="Expand">Collapse</button>
                            </div>
                            <div class="card-body collapse p-2" id="fpR2SPolicyBody"><pre class="small mb-0" id="fpR2SPolicy" style="max-height:160px; overflow:auto;"></pre></div>
                        </div>
                        <div class="card mb-3">
                            <div class="card-header d-flex justify-content-between align-items-center">
                                <strong>Segmentation Plan</strong>
                                <button class="btn btn-sm btn-outline-secondary" type="button" data-preview-collapse="fpSegmentationCardBody" data-label-collapse="Collapse" data-label-expand="Expand">Collapse</button>
                            </div>
                            <div class="card-body collapse p-2" id="fpSegmentationCardBody">
                                <div class="small mb-2" id="fpSegmentationTypes" hidden></div>
                                <pre class="small mb-0" id="fpSegmentation" style="max-height:220px; overflow:auto;"></pre>
                                <div class="mt-2" id="fpSegmentationRuntimeWrap" hidden>
                                    <h6 class="small text-uppercase text-muted mb-1">Runtime Segmentation Summary (segmentation_summary.json)</h6>
                                    <pre class="small bg-light p-2 mb-0" id="fpSegmentationRuntime" style="max-height:220px; overflow:auto;"></pre>
                                </div>
                                <div class="small text-muted mt-2" id="fpSegmentationHash" hidden></div>
                            </div>
                        </div>
                        <div class="card mb-3">
                            <div class="card-header d-flex justify-content-between align-items-center">
                                <strong>Router Plan</strong>
                                <button class="btn btn-sm btn-outline-secondary" type="button" data-preview-collapse="fpRouterPlanBody" data-label-collapse="Collapse" data-label-expand="Expand">Collapse</button>
                            </div>
                            <div class="card-body collapse p-2" id="fpRouterPlanBody"><pre class="small mb-0" id="fpRouterPlan" style="max-height:160px; overflow:auto;"></pre></div>
                        </div>
                        <div class="card mb-3">
                            <div class="card-header d-flex justify-content-between align-items-center">
                                <strong>Services Plan</strong>
                                <button class="btn btn-sm btn-outline-secondary" type="button" data-preview-collapse="fpServicesPlanBody" data-label-collapse="Collapse" data-label-expand="Expand">Collapse</button>
                            </div>
                            <div class="card-body collapse p-2" id="fpServicesPlanBody"><pre class="small mb-0" id="fpServicesPlan" style="max-height:160px; overflow:auto;"></pre></div>
                        </div>
                        <div class="card mb-3">
                            <div class="card-header d-flex justify-content-between align-items-center">
                                <strong>Vulnerabilities Plan</strong>
                                <button class="btn btn-sm btn-outline-secondary" type="button" data-preview-collapse="fpVulnPlanBody" data-label-collapse="Collapse" data-label-expand="Expand">Collapse</button>
                            </div>
                            <div class="card-body collapse p-2" id="fpVulnPlanBody"><pre class="small mb-0" id="fpVulnPlan" style="max-height:160px; overflow:auto;"></pre></div>
                        </div>
                        <div class="card mb-3">
                            <div class="card-header d-flex justify-content-between align-items-center">
                                <strong>Traffic Plan</strong>
                                <button class="btn btn-sm btn-outline-secondary" type="button" data-preview-collapse="fpTrafficPlanBody" data-label-collapse="Collapse" data-label-expand="Expand">Collapse</button>
                            </div>
                            <div class="card-body collapse p-2" id="fpTrafficPlanBody"><pre class="small mb-0" id="fpTrafficPlan" style="max-height:160px; overflow:auto;"></pre></div>
                        </div>
                        <!-- Removed History, Role Distribution, Service Distribution cards -->
                        <!-- Drift card removed (no approved plan concept) -->
                    </div>
                </div>
            </div>
            <div class="modal-footer d-flex justify-content-between align-items-center">
                <div class="d-flex gap-2">
                    <button class="btn btn-warning" type="button" id="fpExecuteBtn" title="Execute scenario now">Execute</button>
                </div>
                <button class="btn btn-secondary" data-bs-dismiss="modal" type="button">Close</button>
            </div>
        </div>
    </div>
</div>
<!-- Planning Semantics Modal -->
<div class="modal fade" id="planningSemanticsModal" tabindex="-1" aria-hidden="true">
    <div class="modal-dialog modal-lg modal-dialog-scrollable">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" data-i18n="modal.planningSemantics.title">Planning Semantics</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <div class="spinner-border text-primary d-none" id="planningSemanticsSpinner" role="status"><span class="visually-hidden">Loading...</span></div>
                <div id="planningSemanticsContent" class="small"></div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal" data-i18n="common.close">Close</button>
            </div>
        </div>
    </div>
</div>
{% endblock %}
{% block extra_scripts %}
<script id="payload-data" type="application/json">{{ payload | tojson }}</script>
<script id="current-user-meta" type="application/json">{{ {'username': current_user.username, 'role': current_user.role}|tojson }}</script>
<script>
// --- BEGIN PAGE JS ---
const payloadDataEl = document.getElementById('payload-data');
const currentUserDataEl = document.getElementById('current-user-meta');
let currentUserMeta = null;
try {
    currentUserMeta = JSON.parse(currentUserDataEl?.textContent || 'null');
} catch (e) {
    currentUserMeta = null;
}
const CORETG_USERNAME = (currentUserMeta && typeof currentUserMeta.username === 'string') ? currentUserMeta.username : '';
const CORETG_USER_ROLE = (currentUserMeta && typeof currentUserMeta.role === 'string') ? currentUserMeta.role : '';
window.CORETG_USERNAME = CORETG_USERNAME;
window.CORETG_USER_ROLE = CORETG_USER_ROLE;
const DEFAULT_INTERNAL_BRIDGE_NAME = 'corebridge';

function computeInternalBridgeName(usernameValue) {
    const base = (usernameValue || window.CORETG_USERNAME || '').toString().trim();
    if (!base) return DEFAULT_INTERNAL_BRIDGE_NAME;
    let normalized = base.replace(/[^A-Za-z0-9]+/g, '-').replace(/-+/g, '-').replace(/^-|-$/g, '');
    if (!normalized) {
        normalized = base.replace(/\s+/g, '').replace(/[^A-Za-z0-9]/g, '');
    }
    if (!normalized) return DEFAULT_INTERNAL_BRIDGE_NAME;
    normalized = normalized.toLowerCase();
    let truncated = normalized.slice(0, 10);
    if (!truncated) return DEFAULT_INTERNAL_BRIDGE_NAME;
    let trimmed = truncated.replace(/[-_]+$/g, '');
    if (!trimmed) {
        trimmed = truncated.replace(/[-_]+/g, '');
    }
    if (!trimmed) return DEFAULT_INTERNAL_BRIDGE_NAME;
    return trimmed;
}
// Prevent TDZ: define catalog early on window
window.VULN_CATALOG = window.VULN_CATALOG || { types: [], vectors: [], items: [] };
// Prevent TDZ: define catalog early on window
window.VULN_CATALOG = window.VULN_CATALOG || { types: [], vectors: [], items: [] };
function setupPreviewCollapsers(){
    const toggles = document.querySelectorAll('[data-preview-collapse]');
    toggles.forEach(btn => {
        if(btn.dataset.collapserBound) return;
        const targetId = btn.getAttribute('data-preview-collapse');
        const target = document.getElementById(targetId);
        if(!target) return;
        btn.dataset.collapserBound = '1';
        const collapseLabel = btn.dataset.labelCollapse || 'Collapse';
        const expandLabel = btn.dataset.labelExpand || 'Expand';
        const hasBootstrap = !!(window.bootstrap && bootstrap.Collapse);
        if(hasBootstrap){
            const instance = bootstrap.Collapse.getOrCreateInstance(target, { toggle: false });
            const updateLabel = () => {
                btn.textContent = target.classList.contains('show') ? collapseLabel : expandLabel;
            };
            target.addEventListener('shown.bs.collapse', updateLabel);
            target.addEventListener('hidden.bs.collapse', updateLabel);
            if(!target.classList.contains('show')){
                instance.show();
            }
            updateLabel();
            btn.addEventListener('click', ev => {
                ev.preventDefault();
                if(target.classList.contains('show')){
                    instance.hide();
                } else {
                    instance.show();
                }
            });
        } else {
            const updateLabel = () => {
                btn.textContent = target.classList.contains('d-none') ? expandLabel : collapseLabel;
            };
            target.classList.remove('d-none');
            updateLabel();
            btn.addEventListener('click', ev => {
                ev.preventDefault();
                target.classList.toggle('d-none');
                updateLabel();
            });
        }
    });
}
window.setupPreviewCollapsers = setupPreviewCollapsers;
if(document.readyState === 'loading'){ document.addEventListener('DOMContentLoaded', () => setupPreviewCollapsers()); }
else { setupPreviewCollapsers(); }
// ---------------- Unified Logging Bridge -----------------
// Forward all app/UI logs into dock log system (defined in partial 'dock.html').
// We DO NOT override existing dock log functions if already present.
function appendLog(line, level){
    if(!line) return;
    let lvl = (level||'INFO').toString().toUpperCase();
    if(!['DEBUG','INFO','WARN','ERROR'].includes(lvl)) lvl='INFO';
    if(window.logLine){ window.logLine(lvl, line); return; }
    // Fallback: create a very small inline buffer if dock not initialized yet.
    try {
        const pre = document.getElementById('logsPre') || document.getElementById('runProgressLog');
        if(pre){
            const text = `[${new Date().toISOString()}] ${lvl} ${line}\n`;
            if(typeof pre.append === 'function'){ pre.append(text); }
            else { pre.appendChild(document.createTextNode(text)); }
        }
    } catch(e){}
}
if(!window.logInfo) window.logInfo = (m)=>appendLog(m,'INFO');
if(!window.logWarn) window.logWarn = (m)=>appendLog(m,'WARN');
if(!window.logError) window.logError = (m)=>appendLog(m,'ERROR');
if(!window.logDebug) window.logDebug = (m)=>appendLog(m,'DEBUG');
appendLog('UI initialized','INFO');
try {
    initialPayload = JSON.parse(payloadDataEl?.textContent || 'null');
} catch (e) {
    initialPayload = null;
}
// If server provides a fresh result_path (e.g., after Save XML), reflect it in localStorage early
try {
    if (initialPayload && initialPayload.result_path) {
        const persisted = JSON.parse(localStorage.getItem('coretg_editor_state') || 'null') || {};
        persisted.result_path = initialPayload.result_path;
        if (initialPayload.core) persisted.core = initialPayload.core;
        localStorage.setItem('coretg_editor_state', JSON.stringify(persisted));
    }
} catch(e){}

function defaultScenario(name) {
    return {
        name: name || `Scenario ${document.querySelectorAll('.scenario-card').length + 1}`,
        base: { filepath: '' },
        hitl: { enabled: false, interfaces: [] },
        density_count: 10,
        sections: {
            // Default: one Count-based row; weight-based nodes/density start at 0
            'Node Information': { total_nodes: 0, density: 0, items: [ { selected: 'Random', factor: 1.0, v_metric: 'Count', v_count: 5 } ] },
            'Routing': { density: 0.5, items: [] },
            'Services': { density: 0.5, items: [] },
            'Traffic': { density: 0.5, items: [] },
            'Events': { density: 0.5, items: [] },
            'Vulnerabilities': { density: 0.5, items: [] },
            'Segmentation': { density: 0.5, items: [] }
        },
        notes: ''
    };
}

const HITL_ATTACHMENT_CHOICES = [
    { value: 'existing_router', label: 'Existing Router' },
    { value: 'existing_switch', label: 'Existing Switch' },
    { value: 'new_router', label: 'New Router' },
];

const HITL_ATTACHMENT_ALLOWED = new Set(HITL_ATTACHMENT_CHOICES.map(opt => opt.value));
const DEFAULT_HITL_ATTACHMENT = 'existing_router';

function normalizeHitlAttachment(value) {
    if (value === null || value === undefined) return DEFAULT_HITL_ATTACHMENT;
    let normalized = String(value).trim().toLowerCase();
    if (!normalized) return DEFAULT_HITL_ATTACHMENT;
    normalized = normalized.replace(/[\s-]+/g, '_');
    return HITL_ATTACHMENT_ALLOWED.has(normalized) ? normalized : DEFAULT_HITL_ATTACHMENT;
}

function prettyHitlAttachment(value) {
    const normalized = normalizeHitlAttachment(value);
    const match = HITL_ATTACHMENT_CHOICES.find(opt => opt.value === normalized);
    return match ? match.label : 'Existing Router';
}

function hitlAttachmentAttemptOrder(preference) {
    const normalized = normalizeHitlAttachment(preference);
    switch (normalized) {
        case 'existing_router':
            return ['existing_router', 'existing_switch', 'new_router'];
        case 'existing_switch':
            return ['existing_switch', 'existing_router', 'new_router'];
        case 'new_router':
        default:
            return ['new_router', 'existing_router', 'existing_switch'];
    }
}

function ensureHitlStateForScenario(scen) {
    if (!scen || typeof scen !== 'object') return { enabled: false, interfaces: [] };
    if (!scen.hitl || typeof scen.hitl !== 'object') {
        scen.hitl = { enabled: false, interfaces: [] };
    }
    const normalizeAddrList = (value) => {
        if (Array.isArray(value)) {
            return value.map(v => (v ?? '').toString().trim()).filter(Boolean);
        }
        if (typeof value === 'string') {
            return value.split(',').map(v => v.trim()).filter(Boolean);
        }
        return [];
    };
    if (!Array.isArray(scen.hitl.interfaces)) {
        const raw = scen.hitl.interfaces;
        if (typeof raw === 'string' && raw.trim()) {
            scen.hitl.interfaces = [{ name: raw.trim() }];
        } else if (raw && typeof raw === 'object' && raw.name) {
            scen.hitl.interfaces = [{ ...raw }];
        } else {
            scen.hitl.interfaces = [];
        }
    }
    scen.hitl.interfaces = scen.hitl.interfaces.map(entry => {
        if (!entry) return null;
        if (typeof entry === 'string') {
            const name = entry.trim();
            return name ? { name } : null;
        }
        if (typeof entry !== 'object') return null;
        const clone = { ...entry };
        if (!clone.name && clone.interface) clone.name = clone.interface;
        if (!clone.name && clone.iface) clone.name = clone.iface;
        if (!clone.name || typeof clone.name !== 'string' || !clone.name.trim()) {
            return null;
        }
        clone.name = clone.name.trim();
        if (clone.alias && !clone.description) clone.description = clone.alias;
        if (clone.display && !clone.description) clone.description = clone.display;
        if (clone.summary && !clone.description) clone.description = clone.summary;
        if (clone.ipv4 !== undefined) clone.ipv4 = normalizeAddrList(clone.ipv4);
        if (clone.ipv6 !== undefined) clone.ipv6 = normalizeAddrList(clone.ipv6);
        if (clone.proxmox_target && typeof clone.proxmox_target === 'object') {
            const target = clone.proxmox_target;
            const node = (target.node ?? '').toString().trim();
            const vmid = target.vmid;
            const ifaceId = (target.interface_id ?? target.interface ?? target.id ?? '').toString().trim();
            const macaddr = (target.macaddr ?? target.mac ?? '').toString();
            const bridge = (target.bridge ?? '').toString();
            const model = (target.model ?? '').toString();
            const vmName = (target.vm_name ?? target.name ?? '').toString();
            const label = (target.label ?? '').toString();
            clone.proxmox_target = {
                node,
                vmid,
                interface_id: ifaceId,
                macaddr,
                bridge,
                model,
                vm_name: vmName,
                label,
            };
        } else {
            delete clone.proxmox_target;
        }
        if (clone.external_vm && typeof clone.external_vm === 'object') {
            const ext = clone.external_vm;
            const vmKey = (ext.vm_key ?? ext.key ?? '').toString();
            const vmNode = (ext.vm_node ?? ext.node ?? '').toString();
            const vmName = (ext.vm_name ?? ext.name ?? '').toString();
            const status = (ext.status ?? '').toString();
            let vmid = ext.vmid ?? ext.id ?? '';
            if (typeof vmid === 'string') vmid = vmid.trim();
            const ifaceIdRaw = (ext.interface_id ?? ext.iface ?? '').toString().trim();
            const ifaceBridgeRaw = (ext.interface_bridge ?? ext.bridge ?? '').toString().trim();
            const ifaceMacRaw = (ext.interface_mac ?? ext.macaddr ?? ext.mac ?? '').toString().trim();
            const ifaceModelRaw = (ext.interface_model ?? ext.model ?? '').toString().trim();
            if (vmKey) {
                const normalized = {
                    vm_key: vmKey,
                    vm_node: vmNode,
                    vm_name: vmName,
                    vmid,
                    status,
                };
                if (ifaceIdRaw) normalized.interface_id = ifaceIdRaw;
                if (ifaceBridgeRaw) normalized.interface_bridge = ifaceBridgeRaw;
                if (ifaceMacRaw) normalized.interface_mac = ifaceMacRaw;
                if (ifaceModelRaw) normalized.interface_model = ifaceModelRaw;
                clone.external_vm = normalized;
            } else {
                delete clone.external_vm;
            }
        } else {
            delete clone.external_vm;
        }
        clone.attachment = normalizeHitlAttachment(clone.attachment);
        return clone;
    }).filter(Boolean);
    scen.hitl.enabled = !!scen.hitl.enabled;
    if (!scen.hitl.core || typeof scen.hitl.core !== 'object') {
        scen.hitl.core = {
            vm_key: '',
            vm_name: '',
            vm_node: '',
            grpc_host: '',
            grpc_port: 50051,
            ssh_host: '',
            ssh_port: 22,
            ssh_username: '',
            ssh_password: '',
            core_secret_id: null,
            validated: false,
            last_validated_at: null,
            stored_summary: null,
            last_tested_at: null,
            last_tested_status: null,
            last_tested_message: null,
            last_tested_host: null,
            last_tested_port: null,
            internal_bridge: '',
            internal_bridge_owner: '',
            last_interfaces_refresh: null,
            last_interfaces_attempt: null,
            interfaces_refresh_inflight: false,
            last_interfaces_error: null,
        };
    } else {
        const core = scen.hitl.core;
        core.vm_key = (core.vm_key ?? '').toString();
        core.vm_name = (core.vm_name ?? '').toString();
        core.vm_node = (core.vm_node ?? '').toString();
        core.grpc_host = (core.grpc_host ?? '').toString();
        core.ssh_host = (core.ssh_host ?? '').toString();
        const sshPort = parseInt(core.ssh_port, 10);
        core.ssh_port = Number.isFinite(sshPort) && sshPort > 0 ? sshPort : 22;
        const grpcPort = parseInt(core.grpc_port, 10);
        core.grpc_port = Number.isFinite(grpcPort) && grpcPort > 0 ? grpcPort : 50051;
        core.ssh_username = (core.ssh_username ?? '').toString();
        core.ssh_password = (core.ssh_password ?? '').toString();
        core.internal_bridge = (core.internal_bridge ?? '').toString().trim();
        core.internal_bridge_owner = (core.internal_bridge_owner ?? '').toString().trim();
        if (typeof core.last_tested_at !== 'string') core.last_tested_at = null;
        if (typeof core.last_tested_status !== 'string') core.last_tested_status = null;
        if (typeof core.last_tested_message !== 'string') core.last_tested_message = null;
        if (typeof core.last_tested_host !== 'string') core.last_tested_host = null;
        const testedPort = parseInt(core.last_tested_port, 10);
        core.last_tested_port = Number.isFinite(testedPort) && testedPort > 0 ? testedPort : null;
        if (typeof core.core_secret_id === 'string') {
            core.core_secret_id = core.core_secret_id.trim() || null;
        } else if (core.core_secret_id == null) {
            core.core_secret_id = null;
        } else {
            core.core_secret_id = null;
        }
        core.validated = !!(core.validated || core.core_secret_id);
        if (typeof core.last_validated_at !== 'string') core.last_validated_at = null;
        if (!core.stored_summary || typeof core.stored_summary !== 'object') {
            core.stored_summary = null;
        }
        if (typeof core.last_interfaces_refresh !== 'string') core.last_interfaces_refresh = null;
        if (typeof core.last_interfaces_attempt !== 'string') core.last_interfaces_attempt = null;
        core.interfaces_refresh_inflight = core.interfaces_refresh_inflight === true;
        if (typeof core.last_interfaces_error === 'string') {
            core.last_interfaces_error = core.last_interfaces_error.trim();
            if (!core.last_interfaces_error) core.last_interfaces_error = null;
        } else {
            core.last_interfaces_error = null;
        }
    }
    const coreVmKeyCurrent = (scen.hitl.core?.vm_key ?? '').toString();
    const coreVmNodeCurrent = (scen.hitl.core?.vm_node ?? '').toString().trim();
    if (coreVmKeyCurrent) {
        scen.hitl.interfaces.forEach(iface => {
            if (iface && iface.external_vm && iface.external_vm.vm_key === coreVmKeyCurrent) {
                delete iface.external_vm;
            }
        });
    }
    if (coreVmNodeCurrent) {
        scen.hitl.interfaces.forEach(iface => {
            const vmNode = iface?.external_vm?.vm_node ? String(iface.external_vm.vm_node).trim() : '';
            if (vmNode && vmNode !== coreVmNodeCurrent) {
                delete iface.external_vm;
            }
        });
    }
    if (!scen.hitl.proxmox || typeof scen.hitl.proxmox !== 'object') {
        scen.hitl.proxmox = {
            url: '',
            port: 8006,
            username: '',
            verify_ssl: true,
            secret_id: null,
            validated: false,
            last_validated_at: null,
            last_message: '',
            inventory: { fetched_at: null, vms: [] },
            inventory_error: null,
        };
    } else {
        const prox = scen.hitl.proxmox;
        prox.url = (prox.url ?? '').toString().trim();
        const parsedPort = parseInt(prox.port, 10);
        prox.port = Number.isFinite(parsedPort) && parsedPort > 0 ? parsedPort : 8006;
        prox.username = (prox.username ?? '').toString().trim();
        if ('password' in prox) {
            delete prox.password;
        }
        prox.verify_ssl = prox.verify_ssl === false ? false : true;
        if (typeof prox.secret_id !== 'string' || !prox.secret_id.trim()) {
            prox.secret_id = null;
        }
        prox.validated = !!prox.validated;
        prox.last_validated_at = prox.last_validated_at || null;
        prox.last_message = (prox.last_message ?? '').toString();
        prox.inventory_error = prox.inventory_error ? prox.inventory_error.toString() : null;
        if (!prox.inventory || typeof prox.inventory !== 'object') {
            prox.inventory = { fetched_at: null, vms: [] };
        } else {
            const inv = prox.inventory;
            inv.fetched_at = inv.fetched_at || null;
            const vms = Array.isArray(inv.vms) ? inv.vms : [];
            inv.vms = vms.map(vm => {
                if (!vm || typeof vm !== 'object') return null;
                const node = (vm.node ?? vm.host ?? '').toString();
                const vmid = vm.vmid;
                const name = (vm.name ?? '').toString();
                const status = (vm.status ?? '').toString();
                const interfaces = Array.isArray(vm.interfaces) ? vm.interfaces : [];
                const safeIfaces = interfaces.map(iface => {
                    if (!iface || typeof iface !== 'object') return null;
                    const id = (iface.id ?? '').toString();
                    const macaddr = (iface.macaddr ?? iface.mac ?? '').toString();
                    const bridge = (iface.bridge ?? '').toString();
                    const model = (iface.model ?? '').toString();
                    const tag = (iface.tag ?? '').toString();
                    const raw = (iface.raw ?? '').toString();
                    if (!id) return null;
                    return { id, macaddr, bridge, model, tag, raw };
                }).filter(Boolean);
                if (!node || vmid === undefined || safeIfaces.length === 0) {
                    return {
                        node,
                        vmid,
                        name,
                        status,
                        interfaces: safeIfaces,
                    };
                }
                return {
                    node,
                    vmid,
                    name,
                    status,
                    interfaces: safeIfaces,
                };
            }).filter(Boolean);
        }
    }
    return scen.hitl;
}

function updateProxmoxSummary(sidx) {
    try {
        const scenario = state.scenarios?.[sidx];
        if (!scenario) return;
        const hitl = ensureHitlStateForScenario(scenario);
        const prox = hitl.proxmox || { url: '', port: 8006, username: '' };
        const proxPort = prox.port ?? 8006;
        const proxHasCreds = !!(prox.url && prox.username);
        const proxValidated = !!(prox.validated && prox.secret_id);
        const normalizeHost = (raw) => {
            if (!raw && raw !== 0) return '';
            let text = String(raw).trim().toLowerCase();
            if (text.startsWith('[') && text.endsWith(']')) text = text.slice(1, -1);
            if (text.startsWith('::ffff:') && /^::ffff:\d+\.\d+\.\d+\.\d+$/.test(text)) {
                text = text.replace('::ffff:', '');
            }
            return text;
        };
        const core = hitl.core || {};
        const coreVmKey = (core.vm_key || '').toString();
        const coreHost = (core.grpc_host || '').toString().trim();
        const corePort = Number.isFinite(Number(core.grpc_port)) && Number(core.grpc_port) > 0 ? Number(core.grpc_port) : 50051;
        const coreSshHostRaw = (core.ssh_host || '').toString().trim();
        const coreSshHost = coreSshHostRaw || coreHost;
        const coreSshPort = Number.isFinite(Number(core.ssh_port)) && Number(core.ssh_port) > 0 ? Number(core.ssh_port) : 22;
        const coreUser = (core.ssh_username || '').toString().trim();
        const coreSecretId = typeof core.core_secret_id === 'string' ? core.core_secret_id.trim() : '';
        const coreHasSecret = !!coreSecretId;
        const corePasswordRaw = (core.ssh_password || '').toString();
        const corePasswordAvailable = !!corePasswordRaw || coreHasSecret;
        const selectedVm = (() => {
            const inventory = hitl.proxmox?.inventory;
            const vms = inventory && Array.isArray(inventory.vms) ? inventory.vms : [];
            return vms.find(vm => `${vm.node ?? ''}::${vm.vmid ?? ''}` === coreVmKey) || null;
        })();
        const vmInterfaceCount = selectedVm && Array.isArray(selectedVm.interfaces) ? selectedVm.interfaces.length : 0;
        const coreVmHasInterfaces = !coreVmKey || vmInterfaceCount >= 1;
        const coreVmSupportsHitl = !coreVmKey || vmInterfaceCount >= 2;
        const coreInputsComplete = !!(coreVmKey && coreHost && corePort && coreSshHost && coreSshPort && coreUser && corePasswordAvailable);
        const coreTestSuccess = core.last_tested_status === 'success';
        const coreTestMatches = coreTestSuccess
            && !!core.last_tested_host
            && normalizeHost(core.last_tested_host) === normalizeHost(coreHost)
            && Number(core.last_tested_port) === Number(corePort);
        const coreConnectionReady = proxValidated && coreInputsComplete && coreVmHasInterfaces && coreTestMatches;
        const coreReady = coreConnectionReady && coreVmSupportsHitl;
        const coreHitlBlocked = coreConnectionReady && !coreVmSupportsHitl;
        const coreTestable = proxValidated && coreInputsComplete && coreVmHasInterfaces;
    const hitlAuthReady = proxValidated && coreHasSecret && !!coreVmKey;

        const summaryEl = document.querySelector(`[data-proxmox-summary="${sidx}"]`);
        if (summaryEl) {
            const detailParts = [];
            if (proxHasCreds) {
                if (prox.last_message) {
                    detailParts.push(prox.last_message);
                } else if (proxValidated && prox.last_validated_at) {
                    try {
                        const dt = new Date(prox.last_validated_at);
                        if (!Number.isNaN(dt.getTime())) {
                            detailParts.push(`Last checked ${dt.toLocaleString()}`);
                        }
                    } catch (e) { /* ignore */ }
                }
                detailParts.push(prox.verify_ssl === false ? 'SSL verify off' : 'SSL verify on');
            }
            const proxSummary = proxHasCreds
                ? (proxValidated
                    ? `Proxmox validated for ${prox.username} @ ${prox.url}:${proxPort}`
                    : `Proxmox pending validation for ${prox.username} @ ${prox.url}:${proxPort}`)
                : 'Proxmox resource not assigned.';
            const detailsText = detailParts.length ? ` • ${detailParts.join(' • ')}` : '';
            summaryEl.textContent = `${proxSummary}${detailsText}`;
            summaryEl.classList.remove('text-success', 'text-warning', 'text-muted', 'text-danger');
            if (proxValidated) summaryEl.classList.add('text-success');
            else if (proxHasCreds) summaryEl.classList.add('text-warning');
            else summaryEl.classList.add('text-muted');
        }

        const assignBtn = document.querySelector(`[data-proxmox-assign][data-scen-idx="${sidx}"]`);
        if (assignBtn) {
            assignBtn.textContent = prox.secret_id ? 'Update Proxmox Resource' : 'Assign Proxmox Resource';
        }
        const proxClearBtn = document.querySelector(`[data-proxmox-clear][data-scen-idx="${sidx}"]`);
        if (proxClearBtn) {
            const hasAny = !!(prox.secret_id || proxHasCreds);
            proxClearBtn.disabled = !hasAny;
        }
        const inventoryStatusEl = document.querySelector(`[data-proxmox-inventory-status="${sidx}"]`);
        if (inventoryStatusEl) {
            const loading = proxInventoryFetchInFlight.has(sidx);
            let statusText = '';
            if (!proxHasCreds) {
                statusText = 'Assign credentials to load VM inventory.';
            } else if (!proxValidated) {
                statusText = 'Validate credentials to load VM inventory.';
            } else if (loading) {
                statusText = 'Fetching Proxmox VM inventory…';
            } else {
                const inv = prox.inventory && typeof prox.inventory === 'object' ? prox.inventory : { vms: [] };
                const vms = Array.isArray(inv.vms) ? inv.vms : [];
                if (vms.length) {
                    const fetchedAt = inv.fetched_at ? (() => {
                        try { return new Date(inv.fetched_at).toLocaleString(); } catch (err) { return null; }
                    })() : null;
                    statusText = `Loaded ${vms.length} VM${vms.length === 1 ? '' : 's'}${fetchedAt ? ` • Last fetched ${fetchedAt}` : ''}`;
                } else if (prox.inventory_error) {
                    statusText = `Inventory error: ${prox.inventory_error}`;
                } else {
                    statusText = 'No VMs reported. Refresh to retry.';
                }
            }
            inventoryStatusEl.textContent = statusText;
            inventoryStatusEl.classList.toggle('text-danger', !!prox.inventory_error);
        }
        const refreshBtn = document.querySelector(`[data-proxmox-refresh][data-scen-idx="${sidx}"]`);
        if (refreshBtn) {
            const loading = proxInventoryFetchInFlight.has(sidx);
            const canRefresh = proxValidated && !loading;
            refreshBtn.disabled = !canRefresh;
            refreshBtn.textContent = loading ? 'Refreshing VMs' : 'Refresh VM List';
        }
        const refreshBadge = document.querySelector(`[data-proxmox-refresh-badge="${sidx}"]`);
        if (refreshBadge) {
            const loading = proxInventoryFetchInFlight.has(sidx);
            refreshBadge.style.display = loading ? '' : 'none';
            refreshBadge.textContent = 'Refreshing vm list';
        }
        const coreStatusEl = document.querySelector(`[data-hitl-core-status="${sidx}"]`);
        if (coreStatusEl) {
            let statusText = '';
            let className = 'text-muted';
            if (!proxValidated) {
                statusText = 'Validate Proxmox credentials to choose a CORE VM.';
            } else if (!coreVmKey) {
                statusText = 'Select a CORE VM to configure connection details.';
            } else if (!coreVmHasInterfaces) {
                const plural = vmInterfaceCount === 1 ? '' : 's';
                statusText = `Selected CORE VM exposes ${vmInterfaceCount || 0} network interface${plural}. Add at least one interface to enable CORE connectivity.`;
                className = 'text-danger';
            } else if (!coreInputsComplete) {
                statusText = 'Enter gRPC and SSH connection details, including credentials.';
                className = 'text-warning';
            } else if (!coreVmSupportsHitl) {
                if (coreHitlBlocked) {
                    statusText = 'CORE connection verified. Add a second interface before enabling HITL mappings in Step 3.';
                } else {
                    statusText = 'Selected CORE VM exposes only one interface. Add a second interface before enabling HITL mappings in Step 3.';
                }
                className = 'text-warning';
            } else if (coreReady) {
                const testedAt = core.last_tested_at ? (() => {
                    try { return new Date(core.last_tested_at).toLocaleString(); } catch (err) { return null; }
                })() : null;
                const storedAt = core.last_validated_at ? (() => {
                    try { return new Date(core.last_validated_at).toLocaleString(); } catch (err) { return null; }
                })() : null;
                const storedNote = storedAt ? ` • Credentials stored ${storedAt}` : '';
                statusText = `CORE connection verified${testedAt ? ` • Last tested ${testedAt}` : ''}${storedNote}`;
                className = 'text-success';
            } else if (coreHasSecret && coreTestSuccess) {
                statusText = 'Stored CORE credentials available. Re-test if connection details changed.';
                className = 'text-warning';
            } else if (core.last_tested_status === 'failure') {
                statusText = core.last_tested_message ? `Last test failed: ${core.last_tested_message}` : 'CORE connection test failed.';
                className = 'text-danger';
            } else if (core.last_tested_status === 'success') {
                statusText = 'CORE connection test succeeded for a different endpoint. Update details or re-test.';
                className = 'text-warning';
            } else {
                statusText = 'Test the CORE connection to continue.';
                className = 'text-warning';
            }
            coreStatusEl.textContent = statusText;
            coreStatusEl.classList.remove('text-success', 'text-warning', 'text-muted', 'text-danger');
            coreStatusEl.classList.add(className);
        }
        const testBtn = document.querySelector(`[data-hitl-core-test][data-scen-idx="${sidx}"]`);
        if (testBtn) {
            testBtn.disabled = !coreTestable;
        }
        const coreClearBtn = document.querySelector(`[data-hitl-core-clear][data-scen-idx="${sidx}"]`);
        if (coreClearBtn) {
            coreClearBtn.disabled = !(coreVmKey || coreHost || coreUser || corePasswordRaw || coreSshHostRaw || coreHasSecret);
        }
        const summaryDetailEl = document.querySelector(`[data-hitl-core-summary="${sidx}"]`);
        if (summaryDetailEl) {
            const sanitize = (value) => {
                return String(value ?? '').replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&#39;');
            };
            if (!coreVmKey || !selectedVm) {
                summaryDetailEl.innerHTML = '';
            } else {
                const name = sanitize(selectedVm.name ? String(selectedVm.name) : `VM ${selectedVm.vmid}`);
                const node = sanitize(selectedVm.node ? String(selectedVm.node) : '—');
                const status = selectedVm.status ? sanitize(String(selectedVm.status)) : null;
                const vmid = selectedVm.vmid !== undefined && selectedVm.vmid !== null ? sanitize(String(selectedVm.vmid)) : '—';
                const ifaceCount = Array.isArray(selectedVm.interfaces) ? selectedVm.interfaces.length : 0;
                const ifaceInfo = ifaceCount ? `${ifaceCount} interface${ifaceCount === 1 ? '' : 's'}` : 'No interfaces reported';
                const ifaceLabel = sanitize(ifaceInfo);
                summaryDetailEl.innerHTML = `
                    <div class="border rounded p-3 bg-light small">
                        <div class="d-flex justify-content-between align-items-center mb-2">
                            <span class="fw-semibold">${name}</span>
                            ${status ? `<span class="badge text-bg-secondary text-uppercase">${status}</span>` : ''}
                        </div>
                        <dl class="row mb-0">
                            <dt class="col-5 text-muted">Node</dt><dd class="col-7">${node}</dd>
                            <dt class="col-5 text-muted">VM ID</dt><dd class="col-7">${vmid}</dd>
                            <dt class="col-5 text-muted">Interfaces</dt><dd class="col-7">${ifaceLabel}</dd>
                        </dl>
                    </div>`;
            }
        }
        const step3Enabled = hitl.enabled && hitlAuthReady;
        const gateNotice = document.querySelector(`[data-hitl-interface-gate="${sidx}"]`);
        if (gateNotice) {
            const shouldHide = step3Enabled && coreReady;
            gateNotice.classList.toggle('d-none', shouldHide);
            gateNotice.classList.remove('alert-info', 'alert-warning', 'alert-danger');
            let gateText = 'Complete steps 1 and 2 to map this interface.';
            if (!hitlAuthReady) {
                gateNotice.classList.add('alert-warning');
                if (!proxValidated) gateText = 'Validate Proxmox credentials (Step 1) to unlock HITL interface mappings.';
                else if (!coreHasSecret) gateText = 'Store CORE credentials (Step 2) to unlock HITL interface mappings.';
                else if (!coreVmKey) gateText = 'Select a CORE VM in Step 2 to unlock HITL interface mappings.';
                else gateText = 'Authenticate Steps 1 and 2 to manage HITL interface mappings.';
            } else if (!step3Enabled) {
                gateNotice.classList.add('alert-info');
                gateText = 'Enable Hardware in the Loop to manage HITL interface mappings.';
            } else if (!coreVmKey) {
                gateNotice.classList.add('alert-info');
            } else if (!coreVmHasInterfaces) {
                gateNotice.classList.add('alert-danger');
                gateText = 'Selected CORE VM must expose at least one interface before mapping HITL interfaces.';
            } else if (!coreVmSupportsHitl) {
                gateNotice.classList.add('alert-warning');
                gateText = 'Selected CORE VM exposes only one interface. HITL cannot be used until a second interface is added.';
            } else {
                gateNotice.classList.add('alert-info');
            }
            gateNotice.textContent = gateText;
        }
        const availableSelect = document.querySelector(`[data-hitl-available][data-scen-idx="${sidx}"]`);
        if (availableSelect) {
            availableSelect.disabled = !(coreReady && step3Enabled);
        }
        const hostInterfaces = Array.isArray(state.host_interfaces) ? state.host_interfaces : [];
        const selectedNames = new Set((Array.isArray(hitl.interfaces) ? hitl.interfaces : []).map(entry => (entry && entry.name) ? String(entry.name) : '').filter(Boolean));
        const selectableInterfaces = hostInterfaces.filter(entry => {
            if (!entry || !entry.name || selectedNames.has(entry.name)) return false;
            const bridge = (entry.bridge || (entry.proxmox && entry.proxmox.bridge) || (entry.proxmox && entry.proxmox.raw && entry.proxmox.raw.bridge) || '').toString().trim().toLowerCase();
            return bridge !== 'vmbr0';
        });
        const availableCount = selectableInterfaces.length;
        document.querySelectorAll(`[data-hitl-add][data-scen-idx="${sidx}"]`).forEach(btn => {
            btn.disabled = !(coreReady && step3Enabled) || availableCount === 0;
        });
        document.querySelectorAll(`[data-hitl-attach][data-scen-idx="${sidx}"]`).forEach(selectEl => {
            selectEl.disabled = !(coreReady && step3Enabled);
        });
    } catch (e) {
        console.warn('updateProxmoxSummary failed', e);
    }
}

async function fetchProxmoxInventory(sidx, options = {}) {
    const force = !!options.force;
    if (Number.isNaN(sidx) || sidx === null || sidx === undefined) return null;
    const scenario = state.scenarios?.[sidx];
    if (!scenario) return null;
    const hitlState = ensureHitlStateForScenario(scenario);
    const prox = hitlState.proxmox || {};
    const hasSecret = !!prox.secret_id;
    const isValidated = !!(prox.validated && prox.secret_id);
    if (!hasSecret || !isValidated) {
        return null;
    }
    const existingInv = prox.inventory && Array.isArray(prox.inventory.vms) ? prox.inventory.vms : [];
    if (existingInv.length && prox.inventory?.fetched_at && !force) {
        proxInventoryFetchInFlight.delete(sidx);
        if (proxInventoryFetchInFlight.size === 0) {
            toggleEditorBusy(false);
        }
        toggleExternalIfxModalBusy(proxInventoryFetchInFlight.size > 0);
        return prox.inventory;
    }
    if (proxInventoryFetchInFlight.has(sidx)) {
        return null;
    }
    proxInventoryFetchInFlight.add(sidx);
    toggleEditorBusy(true);
    toggleExternalIfxModalBusy(true);
    updateProxmoxSummary(sidx);
    let shouldRerender = false;
    try {
        logInfo(`Fetching Proxmox VM inventory for scenario ${sidx}`);
        const resp = await fetch('/api/proxmox/vms', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            credentials: 'same-origin',
            body: JSON.stringify({ secret_id: prox.secret_id }),
        });
        let data = null;
        try { data = await resp.json(); } catch (err) { data = null; }
        if (!resp.ok || !data || data.success === false) {
            const message = (data && data.error) ? data.error : `Failed to load VM inventory (HTTP ${resp.status})`;
            throw new Error(message);
        }
        const inventory = data.inventory || {};
        const cleanedInventory = {
            fetched_at: inventory.fetched_at || new Date().toISOString(),
            vms: Array.isArray(inventory.vms) ? inventory.vms : [],
        };
        hitlState.proxmox.inventory = cleanedInventory;
        hitlState.proxmox.inventory_error = null;
        persistEditorState();
        const hidden = document.getElementById('scenarios_json');
        if (hidden) hidden.value = JSON.stringify({ scenarios: state.scenarios, active_index: activeIdx });
        const vmCount = cleanedInventory.vms.length;
        try { showToast(`Loaded ${vmCount} Proxmox VM${vmCount === 1 ? '' : 's'}`, { autohide: true, delay: 2500 }); } catch (e) {}
        shouldRerender = true;
        return cleanedInventory;
    } catch (err) {
        const message = err instanceof Error ? err.message : 'Failed to load Proxmox VM inventory';
        hitlState.proxmox.inventory_error = message;
        hitlState.proxmox.inventory = { fetched_at: null, vms: [] };
        persistEditorState();
        const hidden = document.getElementById('scenarios_json');
        if (hidden) hidden.value = JSON.stringify({ scenarios: state.scenarios, active_index: activeIdx });
        logError(message);
        try { showToast(message, { autohide: false }); } catch (e) {}
        shouldRerender = true;
        return null;
    } finally {
        proxInventoryFetchInFlight.delete(sidx);
        if (proxInventoryFetchInFlight.size === 0) {
            toggleEditorBusy(false);
        }
        toggleExternalIfxModalBusy(proxInventoryFetchInFlight.size > 0);
        updateProxmoxSummary(sidx);
        if (shouldRerender) {
            renderMain();
        }
    }
}

const HITL_PREVIEW_CACHE = new WeakMap();

const _sha256K = new Uint32Array([
    0x428a2f98,0x71374491,0xb5c0fbcf,0xe9b5dba5,0x3956c25b,0x59f111f1,0x923f82a4,0xab1c5ed5,
    0xd807aa98,0x12835b01,0x243185be,0x550c7dc3,0x72be5d74,0x80deb1fe,0x9bdc06a7,0xc19bf174,
    0xe49b69c1,0xefbe4786,0x0fc19dc6,0x240ca1cc,0x2de92c6f,0x4a7484aa,0x5cb0a9dc,0x76f988da,
    0x983e5152,0xa831c66d,0xb00327c8,0xbf597fc7,0xc6e00bf3,0xd5a79147,0x06ca6351,0x14292967,
    0x27b70a85,0x2e1b2138,0x4d2c6dfc,0x53380d13,0x650a7354,0x766a0abb,0x81c2c92e,0x92722c85,
    0xa2bfe8a1,0xa81a664b,0xc24b8b70,0xc76c51a3,0xd192e819,0xd6990624,0xf40e3585,0x106aa070,
    0x19a4c116,0x1e376c08,0x2748774c,0x34b0bcb5,0x391c0cb3,0x4ed8aa4a,0x5b9cca4f,0x682e6ff3,
    0x748f82ee,0x78a5636f,0x84c87814,0x8cc70208,0x90befffa,0xa4506ceb,0xbef9a3f7,0xc67178f2,
]);

const _sha256Init = new Uint32Array([
    0x6a09e667,0xbb67ae85,0x3c6ef372,0xa54ff53a,0x510e527f,0x9b05688c,0x1f83d9ab,0x5be0cd19,
]);

function _utf8ToBytes(str){
    if(typeof TextEncoder !== 'undefined'){
        return new TextEncoder().encode(str);
    }
    const bytes = [];
    for(let i=0;i<str.length;i++){
        let code = str.charCodeAt(i);
        if(code < 0x80){
            bytes.push(code);
        } else if(code < 0x800){
            bytes.push(0xc0 | (code >> 6));
            bytes.push(0x80 | (code & 0x3f));
        } else if(code < 0xd800 || code >= 0xe000){
            bytes.push(0xe0 | (code >> 12));
            bytes.push(0x80 | ((code >> 6) & 0x3f));
            bytes.push(0x80 | (code & 0x3f));
        } else {
            i++;
            code = 0x10000 + (((code & 0x3ff) << 10) | (str.charCodeAt(i) & 0x3ff));
            bytes.push(0xf0 | (code >> 18));
            bytes.push(0x80 | ((code >> 12) & 0x3f));
            bytes.push(0x80 | ((code >> 6) & 0x3f));
            bytes.push(0x80 | (code & 0x3f));
        }
    }
    return new Uint8Array(bytes);
}

function _sha256Bytes(message){
    const msg = message instanceof Uint8Array ? message : new Uint8Array(message || []);
    const l = msg.length;
    const bitLenHi = Math.floor((l >>> 29));
    const bitLenLo = (l << 3) >>> 0;
    const paddedLen = ((l + 9 + 63) >> 6) << 6;
    const padded = new Uint8Array(paddedLen);
    padded.set(msg);
    padded[l] = 0x80;
    const view = new DataView(padded.buffer);
    view.setUint32(paddedLen - 8, bitLenHi >>> 0, false);
    view.setUint32(paddedLen - 4, bitLenLo >>> 0, false);
    const w = new Uint32Array(64);
    const H = new Uint32Array(_sha256Init);
    for(let offset=0; offset<paddedLen; offset+=64){
        for(let i=0;i<16;i++){
            w[i] = view.getUint32(offset + (i<<2), false);
        }
        for(let i=16;i<64;i++){
            const s0 = ((w[i-15] >>> 7) | (w[i-15] << 25)) ^ ((w[i-15] >>> 18) | (w[i-15] << 14)) ^ (w[i-15] >>> 3);
            const s1 = ((w[i-2] >>> 17) | (w[i-2] << 15)) ^ ((w[i-2] >>> 19) | (w[i-2] << 13)) ^ (w[i-2] >>> 10);
            w[i] = (((w[i-16] + s0) >>> 0) + ((w[i-7] + s1) >>> 0)) >>> 0;
        }
        let a=H[0],b=H[1],c=H[2],d=H[3],e=H[4],f=H[5],g=H[6],h=H[7];
        for(let i=0;i<64;i++){
            const S1 = ((e>>>6)|(e<<26)) ^ ((e>>>11)|(e<<21)) ^ ((e>>>25)|(e<<7));
            const ch = (e & f) ^ ((~e) & g);
            const temp1 = (h + S1 + ch + _sha256K[i] + w[i]) >>> 0;
            const S0 = ((a>>>2)|(a<<30)) ^ ((a>>>13)|(a<<19)) ^ ((a>>>22)|(a<<10));
            const maj = (a & b) ^ (a & c) ^ (b & c);
            const temp2 = (S0 + maj) >>> 0;
            h = g;
            g = f;
            f = e;
            e = (d + temp1) >>> 0;
            d = c;
            c = b;
            b = a;
            a = (temp1 + temp2) >>> 0;
        }
        H[0] = (H[0] + a) >>> 0;
        H[1] = (H[1] + b) >>> 0;
        H[2] = (H[2] + c) >>> 0;
        H[3] = (H[3] + d) >>> 0;
        H[4] = (H[4] + e) >>> 0;
        H[5] = (H[5] + f) >>> 0;
        H[6] = (H[6] + g) >>> 0;
        H[7] = (H[7] + h) >>> 0;
    }
    const out = new Uint8Array(32);
    const outView = new DataView(out.buffer);
    for(let i=0;i<8;i++){
        outView.setUint32(i<<2, H[i], false);
    }
    return out;
}

function makeDeterministicRng(seed) {
    const base = _sha256Bytes(_utf8ToBytes(String(seed || '')));
    let counter = 0;
    const counterBytes = new Uint8Array(8);
    const counterView = new DataView(counterBytes.buffer);
    return () => {
        counterView.setUint32(0, counter >>> 0, true);
        counterView.setUint32(4, Math.floor(counter / 0x100000000) >>> 0, true);
        counter += 1;
        const combined = new Uint8Array(base.length + counterBytes.length);
        combined.set(base, 0);
        combined.set(counterBytes, base.length);
        const digest = _sha256Bytes(combined);
        let value = 0n;
        for(let i=0;i<8;i++){
            value = (value << 8n) | BigInt(digest[i]);
        }
        return Number(value) / 18446744073709551616;
    };
}

function intToIpv4(value) {
    const num = (Number(value) >>> 0);
    const part1 = (num >>> 24) & 0xff;
    const part2 = (num >>> 16) & 0xff;
    const part3 = (num >>> 8) & 0xff;
    const part4 = num & 0xff;
    return `${part1}.${part2}.${part3}.${part4}`;
}

function slugifyHitlName(rawValue, fallback) {
    let value = '';
    if (typeof rawValue === 'string') {
        value = rawValue.trim().toLowerCase();
    } else if (rawValue !== null && rawValue !== undefined) {
        value = String(rawValue).trim().toLowerCase();
    }
    if (!value) {
        value = (fallback || '').toString().trim().toLowerCase();
    }
    const cleaned = [];
    for (const ch of value) {
        if (/^[a-z0-9]$/.test(ch)) {
            cleaned.push(ch);
        } else if (ch === '-' || ch === '_') {
            cleaned.push(ch);
        } else {
            cleaned.push('-');
        }
    }
    let slug = cleaned.join('').replace(/^[-_]+|[-_]+$/g, '');
    if (!slug) {
        slug = ((fallback || '').toString().trim().toLowerCase()).replace(/^[-_]+|[-_]+$/g, '') || 'iface';
    }
    if (slug.length > 48) slug = slug.slice(0, 48);
    return slug;
}

function computeHitlPreviewLinkIps(scenarioKey, ifaceName, ordinal, prefixLen = 29) {
    try {
        const sanitizedPrefix = Number.isFinite(prefixLen) ? Math.min(Math.max(Math.trunc(prefixLen), 0), 32) : 29;
        const baseNetworkInt = (10 << 24) | (254 << 16); // 10.254.0.0
        const addressSpaceSize = 1 << 16; // /16 block span
        const hostBlock = sanitizedPrefix >= 32 ? 1 : (1 << Math.max(0, 32 - sanitizedPrefix));
        if (hostBlock < 8) {
                const pwdInput = document.querySelector(`[data-hitl-core-field="ssh_password"][data-scen-idx="${sidx}"]`);
                if (pwdInput) pwdInput.removeAttribute('placeholder');
            // Need at least 3 usable hosts (existing router, new router, RJ45)
            return null;
        }
        const subnetSpan = Math.max(0, sanitizedPrefix - 16);
        const totalSubnets = Math.max(1, Math.pow(2, subnetSpan));
        const seed = `${scenarioKey || '__default__'}|${ifaceName || ordinal}|${ordinal}|hitl-link`;
        const rng = makeDeterministicRng(seed);
        const subnetIndex = Math.floor(rng() * totalSubnets) % totalSubnets;
        let networkAddressInt = (baseNetworkInt + (subnetIndex * hostBlock)) >>> 0;
        const maxAddressInt = (baseNetworkInt + addressSpaceSize - 1) >>> 0;
        if (networkAddressInt > maxAddressInt) {
            networkAddressInt = (baseNetworkInt + (networkAddressInt % addressSpaceSize)) >>> 0;
        }
        let broadcastInt = (networkAddressInt + hostBlock - 1) >>> 0;
        if (broadcastInt > maxAddressInt) {
            broadcastInt = (baseNetworkInt + (broadcastInt % addressSpaceSize)) >>> 0;
        }
        const hostInts = [];
        for (let addr = (networkAddressInt + 1) >>> 0; addr < broadcastInt; addr = (addr + 1) >>> 0) {
            hostInts.push(addr >>> 0);
        }
        if (hostInts.length < 3) {
            return null;
        }
        const netmaskInt = sanitizedPrefix === 0 ? 0 : ((0xffffffff << (32 - sanitizedPrefix)) >>> 0);
        const pool = hostInts.slice();
        const selections = [];
        for (let i = 0; i < 3; i++) {
            if (!pool.length) break;
            const choiceIdx = Math.floor(rng() * pool.length) % pool.length;
            selections.push(pool.splice(choiceIdx, 1)[0]);
        }
        if (selections.length < 3) {
            return null;
        }
        return {
            network: intToIpv4(networkAddressInt),
            network_cidr: `${intToIpv4(networkAddressInt)}/${sanitizedPrefix}`,
            prefix_len: sanitizedPrefix,
            netmask: intToIpv4(netmaskInt),
            broadcast_ip4: intToIpv4(broadcastInt),
            existing_router_ip4: intToIpv4(selections[0]),
            new_router_ip4: intToIpv4(selections[1]),
            rj45_ip4: intToIpv4(selections[2]),
        };
    } catch (err) {
        console.warn('HITL: failed to compute preview link IPs', err);
        return null;
    }
}

function deriveHitlLinkMeta(iface, ordinal, totalCount, scenarioKey) {
    if (!iface || typeof iface !== 'object') {
        return {};
    }
    const previewRouter = iface.preview_router || iface.previewRouter || null;
    const previewMetadata = (previewRouter && previewRouter.metadata) || {};
    const result = {
        network: iface.link_network || iface.linkNetwork || null,
        networkCidr: iface.link_network_cidr || iface.linkNetworkCidr || null,
        prefixLen: Number.isFinite(iface.prefix_len) ? Number(iface.prefix_len) : null,
        netmask: iface.netmask || null,
        existingRouterIp4: iface.existing_router_ip4 || null,
        newRouterIp4: iface.new_router_ip4 || null,
        rj45Ip4: iface.rj45_ip4 || null,
        broadcastIp4: iface.broadcast_ip4 || null,
    };
    if (!result.network && previewMetadata.link_network) result.network = previewMetadata.link_network;
    if (!result.networkCidr && previewMetadata.link_network) result.networkCidr = previewMetadata.link_network;
    if (!result.prefixLen && Number.isFinite(previewMetadata.prefix_len)) result.prefixLen = Number(previewMetadata.prefix_len);
    if (!result.netmask && previewMetadata.netmask) result.netmask = previewMetadata.netmask;
    if (!result.existingRouterIp4 && previewMetadata.existing_router_ip4) result.existingRouterIp4 = previewMetadata.existing_router_ip4;
    if (!result.newRouterIp4 && previewMetadata.new_router_ip4) result.newRouterIp4 = previewMetadata.new_router_ip4;
    if (!result.rj45Ip4 && previewMetadata.rj45_ip4) result.rj45Ip4 = previewMetadata.rj45_ip4;
    if (!result.broadcastIp4 && previewMetadata.broadcast_ip4) result.broadcastIp4 = previewMetadata.broadcast_ip4;
    if (previewRouter && typeof previewRouter.ip4 === 'string' && !result.newRouterIp4) {
        result.newRouterIp4 = previewRouter.ip4;
    }
    if (result.newRouterIp4 && typeof result.newRouterIp4 === 'string' && result.newRouterIp4.includes('/')) {
        const parts = result.newRouterIp4.split('/', 2);
        result.newRouterIp4 = parts[0];
        if (!result.prefixLen && parts[1]) {
            const parsed = parseInt(parts[1], 10);
            if (!Number.isNaN(parsed)) {
                result.prefixLen = parsed;
            }
        }
    }
    if (!result.networkCidr && result.network && Number.isFinite(result.prefixLen)) {
        result.networkCidr = `${result.network}/${result.prefixLen}`;
    }
    const needsFallback = !result.networkCidr || !result.newRouterIp4 || !result.rj45Ip4 || !result.existingRouterIp4;
    if (needsFallback) {
        const fallback = computeHitlPreviewLinkIps(scenarioKey, iface.name || `iface-${ordinal + 1}`, ordinal);
        if (fallback) {
            result.network = result.network || fallback.network;
            result.networkCidr = result.networkCidr || fallback.network_cidr || fallback.network;
            result.prefixLen = result.prefixLen || fallback.prefix_len;
            result.netmask = result.netmask || fallback.netmask;
            result.existingRouterIp4 = result.existingRouterIp4 || fallback.existing_router_ip4;
            result.newRouterIp4 = result.newRouterIp4 || fallback.new_router_ip4;
            result.rj45Ip4 = result.rj45Ip4 || fallback.rj45_ip4;
            result.broadcastIp4 = result.broadcastIp4 || fallback.broadcast_ip4;
        }
    }
    if (result.network && Number.isFinite(result.prefixLen) && !result.netmask) {
        const prefix = Math.min(Math.max(Number(result.prefixLen), 0), 32);
        const maskInt = prefix === 0 ? 0 : ((0xffffffff << (32 - prefix)) >>> 0);
        result.netmask = intToIpv4(maskInt);
    }
    if (result.network && Number.isFinite(result.prefixLen) && !result.networkCidr) {
        result.networkCidr = `${result.network}/${result.prefixLen}`;
    }
    return result;
}

function deriveHitlPreviewArtifacts(full) {
    if (!full || typeof full !== 'object') return null;
    if (HITL_PREVIEW_CACHE.has(full)) {
        return HITL_PREVIEW_CACHE.get(full) || null;
    }
    const scenario = Array.isArray(state?.scenarios) ? state.scenarios[activeIdx] : null;
    if (!scenario) {
        HITL_PREVIEW_CACHE.set(full, null);
        return null;
    }
    const hitlState = ensureHitlStateForScenario(scenario);
    if (!hitlState.enabled) {
        HITL_PREVIEW_CACHE.set(full, null);
        return null;
    }
    const scenarioName = (scenario && typeof scenario.name === 'string') ? scenario.name : '';
    const scenarioSeed = scenarioName && scenarioName.trim() ? scenarioName.trim() : '__preview__';
    const rawInterfaces = (hitlState.interfaces || []).filter(entry => entry && typeof entry === 'object' && entry.name);
    if (!rawInterfaces.length) {
        HITL_PREVIEW_CACHE.set(full, null);
        return null;
    }
    const normalizeList = (value) => {
        if (Array.isArray(value)) {
            return value.map(v => (v ?? '').toString().trim()).filter(Boolean);
        }
        if (typeof value === 'string') {
            return value.split(',').map(v => v.trim()).filter(Boolean);
        }
        return [];
    };
    const totalInterfaces = rawInterfaces.length;
    const hitlScenarioKey = (typeof hitlState.scenario_key === 'string' && hitlState.scenario_key.trim())
        ? hitlState.scenario_key.trim()
        : scenarioSeed;
    const interfaces = rawInterfaces.map((entry, idx) => {
        const clone = { ...entry };
        clone.name = (clone.name || '').toString();
        clone.alias = clone.alias ?? clone.description ?? clone.display;
        clone.ipv4 = normalizeList(clone.ipv4);
        clone.ipv6 = normalizeList(clone.ipv6);
        clone.attachment = normalizeHitlAttachment(clone.attachment);
        const fallbackSlug = `iface-${idx + 1}`;
        const slug = slugifyHitlName(clone.name, fallbackSlug);
        clone.slug = slug;
        clone.ordinal = idx;
        const linkMeta = deriveHitlLinkMeta(clone, idx, totalInterfaces, hitlScenarioKey) || {};
        clone.hitl_link_meta = linkMeta;
        if (linkMeta.rj45Ip4 && !clone.rj45_ip4) {
            clone.rj45_ip4 = linkMeta.rj45Ip4;
        }
        if (linkMeta.newRouterIp4 && !clone.new_router_ip4) {
            clone.new_router_ip4 = linkMeta.newRouterIp4;
        }
        if (linkMeta.existingRouterIp4 && !clone.existing_router_ip4) {
            clone.existing_router_ip4 = linkMeta.existingRouterIp4;
        }
        if (linkMeta.networkCidr && !clone.link_network_cidr) {
            clone.link_network_cidr = linkMeta.networkCidr;
        }
        if (linkMeta.netmask && !clone.netmask) {
            clone.netmask = linkMeta.netmask;
        }
        return clone;
    });
    const normalizeName = (raw, idx) => {
        let base = (raw || `iface-${idx}`).toString().trim().toLowerCase();
        base = base.replace(/[^a-z0-9_-]+/g, '-').replace(/-+/g, '-').replace(/^-|-$/g, '');
        if (!base) base = `iface-${idx}`;
        if (base.length > 48) base = base.slice(0, 48);
        return base;
    };
    const existingIds = new Set();
    const noteExisting = val => {
        if (val === undefined || val === null) return;
        existingIds.add(String(val));
    };
    (full.routers || []).forEach(r => noteExisting(r?.node_id ?? r?.id));
    (full.hosts || []).forEach(h => noteExisting(h?.node_id ?? h?.id));
    (full.switches_detail || []).forEach(sw => noteExisting(sw?.switch_id ?? sw?.id));
    const basePreview = full.base_bridge_preview || {};
    noteExisting(basePreview?.bridge_router_id);
    noteExisting(basePreview?.internal_peer_router_id);
    const routerPeers = Array.isArray(full.routers)
        ? full.routers.filter(r => r && r.node_id !== undefined && r.node_id !== null)
        : [];
    routerPeers.sort((a, b) => {
        const aid = Number(a?.node_id ?? a?.id ?? 0);
        const bid = Number(b?.node_id ?? b?.id ?? 0);
        return aid - bid;
    });
    const routerPeerMap = new Map();
    routerPeers.forEach(peer => {
        const peerId = peer?.node_id ?? peer?.id;
        if(peerId !== undefined && peerId !== null){
            routerPeerMap.set(String(peerId), peer);
        }
    });
    const hostPeers = Array.isArray(full.hosts)
        ? full.hosts.filter(h => h && h.node_id !== undefined && h.node_id !== null)
        : [];
    hostPeers.sort((a, b) => {
        const aid = Number(a?.node_id ?? a?.id ?? 0);
        const bid = Number(b?.node_id ?? b?.id ?? 0);
        return aid - bid;
    });
    const existingSubnets = Array.isArray(full.switches_detail)
        ? full.switches_detail.filter(sw => sw && sw.switch_id !== undefined && sw.switch_id !== null).sort((a, b) => {
            const aid = Number(a?.switch_id ?? a?.id ?? 0);
            const bid = Number(b?.switch_id ?? b?.id ?? 0);
            return aid - bid;
        })
        : [];
    const hitlSwitchLookup = new Map();
    existingSubnets.forEach(detail => {
        if (!detail || typeof detail !== 'object') return;
        const meta = (detail.metadata && typeof detail.metadata === 'object') ? detail.metadata : {};
        const slugKey = meta.hitl_slug || meta.hitl_switch_slug || meta.hitl_interface_slug;
        if (slugKey) {
            hitlSwitchLookup.set(`slug:${String(slugKey)}`, detail);
        }
        const ifaceName = meta.hitl_interface_name || meta.interface_name || detail.interface_name;
        if (ifaceName) {
            hitlSwitchLookup.set(`name:${String(ifaceName).toLowerCase().trim()}`, detail);
        }
    });
    const nodes = [];
    const links = [];
    const makeUniqueId = (base) => {
        let candidate = base;
        let suffix = 2;
        while (existingIds.has(String(candidate))) {
            candidate = `${base}-${suffix}`;
            suffix += 1;
        }
        existingIds.add(String(candidate));
        return candidate;
    };
    const includedRouterNodeIds = new Set();
    const includedSwitchNodeIds = new Set();
    const routerOverlayMap = new Map();
    const switchOverlayMap = new Map();
    const routerSwitchInterfaceMap = new Map();

    const registerRouterOverlayNode = (node) => {
        if(!node) return;
        const key = String(node.id ?? node.node_id);
        if(!key) return;
        routerOverlayMap.set(key, node);
    };

    const getOrCreateRouterOverlayNode = (routerId, fallbackLabel = null) => {
        if(routerId === null || routerId === undefined) return null;
        const key = String(routerId);
        if(routerOverlayMap.has(key)){
            return routerOverlayMap.get(key);
        }
        let node = nodes.find(existing => String(existing.id ?? existing.node_id) === key);
        if(!node){
            const basePeer = routerPeerMap.get(key);
            const label = fallbackLabel || basePeer?.name || `Router ${routerId}`;
            node = {
                id: routerId,
                node_id: routerId,
                type: 'router',
                label,
                name: label,
                isHitlRouter: true,
            };
            nodes.push(node);
            includedRouterNodeIds.add(routerId);
        }
        registerRouterOverlayNode(node);
        return node;
    };

    const registerSwitchOverlayNode = (node) => {
        if(!node) return;
        const key = String(node.switch_id ?? node.id);
        if(!key) return;
        switchOverlayMap.set(key, node);
    };

    const registerRouterSwitchInterface = (routerId, entry) => {
        if(routerId === null || routerId === undefined) return;
        const key = String(routerId);
        const list = routerSwitchInterfaceMap.get(key) || [];
        list.push(entry);
        routerSwitchInterfaceMap.set(key, list);
    };
    interfaces.forEach((iface, idx) => {
        const linkMeta = iface.hitl_link_meta || deriveHitlLinkMeta(iface, idx, totalInterfaces, hitlScenarioKey) || {};
        const previewRouterMeta = iface.preview_router || iface.previewRouter || null;
        const baseName = normalizeName(iface.name, idx);
        const attachmentPref = normalizeHitlAttachment(iface.attachment);
        const nodeId = makeUniqueId(`hitl-${baseName}`);
        const alias = iface.alias;
        const labelParts = [];
        if (iface.name) labelParts.push(iface.name);
        if (alias && alias !== iface.name) {
            labelParts.push(alias);
        } else if (iface.mac) {
            labelParts.push(iface.mac);
        }
        const nodeLabel = labelParts.filter(Boolean).join(' · ') || iface.name || `HITL ${idx + 1}`;
        const hitlNode = {
            id: nodeId,
            type: 'rj45',
            label: nodeLabel,
            name: nodeLabel,
            isHitl: true,
            hitlInterface: iface,
            attachment: attachmentPref,
        };
        if (linkMeta && linkMeta.rj45Ip4) {
            hitlNode.ip4 = linkMeta.rj45Ip4;
        } else if (Array.isArray(iface.ipv4) && iface.ipv4.length) {
            hitlNode.ip4 = iface.ipv4[0];
        }
        if (linkMeta && (linkMeta.networkCidr || linkMeta.network)) {
            hitlNode.linkNetwork = linkMeta.networkCidr || linkMeta.network;
        }
        if (linkMeta && Number.isFinite(linkMeta.prefixLen)) {
            hitlNode.prefixLen = Number(linkMeta.prefixLen);
        }
        if (linkMeta && linkMeta.newRouterIp4) {
            hitlNode.peerRouterIp4 = linkMeta.newRouterIp4;
        }
        if (linkMeta && linkMeta.existingRouterIp4) {
            hitlNode.existingRouterIp4 = linkMeta.existingRouterIp4;
        }
        if (linkMeta && linkMeta.netmask) {
            hitlNode.netmask = linkMeta.netmask;
        }
        if (linkMeta && linkMeta.broadcastIp4) {
            hitlNode.broadcastIp4 = linkMeta.broadcastIp4;
        }
        hitlNode.hitlLinkMeta = linkMeta;
        nodes.push(hitlNode);
        const rng = makeDeterministicRng(`${scenarioSeed}|${iface.name}|${idx}|${interfaces.length}`);
        const attempts = hitlAttachmentAttemptOrder(attachmentPref);
        let targetId = null;
        let assignment = null;
        let linkKind = 'hitl-peer';
        let uplinkRouterId = null;
        const pickRouterPeer = () => {
            if (!routerPeers.length) return null;
            const peer = routerPeers[Math.floor(rng() * routerPeers.length)];
            const peerId = peer?.node_id ?? peer?.id;
            return (peerId !== undefined && peerId !== null) ? peerId : null;
        };
        const pickSwitchPeer = () => {
            if (!existingSubnets.length) return null;
            const subnet = existingSubnets[Math.floor(rng() * existingSubnets.length)];
            const candidateId = subnet?.switch_id ?? subnet?.id;
            return (candidateId !== undefined && candidateId !== null) ? candidateId : null;
        };
        const createNewRouter = () => {
            const matchPreviewRouter = () => {
                if (previewRouterMeta && (previewRouterMeta.node_id ?? previewRouterMeta.nodeId ?? previewRouterMeta.id) !== undefined) {
                    return previewRouterMeta;
                }
                return routerPeers.find(peer => {
                    if (!peer) return false;
                    const meta = peer.metadata || peer.meta || peer.details || null;
                    if (!meta || meta.hitl_preview !== true) return false;
                    if (iface.slug && typeof meta.hitl_slug === 'string' && meta.hitl_slug === iface.slug) return true;
                    const ifaceNameLower = (iface.name || '').toString().trim().toLowerCase();
                    if (ifaceNameLower && typeof meta.hitl_interface_name === 'string' && meta.hitl_interface_name.trim().toLowerCase() === ifaceNameLower) {
                        return true;
                    }
                    if (Number.isFinite(meta.ordinal) && meta.ordinal === idx) return true;
                    return false;
                }) || null;
            };

            const previewRouter = matchPreviewRouter();
            if (previewRouter) {
                const routerId = previewRouter.node_id ?? previewRouter.nodeId ?? previewRouter.id;
                if (routerId !== undefined && routerId !== null) {
                    noteExisting(routerId);
                    const routerLabel = previewRouter.name || `HITL Router ${idx + 1}`;
                    const meta = previewRouter.metadata || previewRouter.meta || {};
                    if (meta && meta.uplink_router_node_id !== undefined && meta.uplink_router_node_id !== null) {
                        uplinkRouterId = meta.uplink_router_node_id;
                    } else if (meta && meta.uplinkRouterId !== undefined && meta.uplinkRouterId !== null) {
                        uplinkRouterId = meta.uplinkRouterId;
                    }
                    const prefixCandidate = Number.isFinite(linkMeta?.prefixLen) ? Number(linkMeta.prefixLen) : Number.isFinite(meta?.prefix_len) ? Number(meta.prefix_len) : null;
                    const routerNode = getOrCreateRouterOverlayNode(routerId, routerLabel);
                    if (routerNode) {
                        const assignIfMissing = (key, value) => {
                            if (value === undefined || value === null) return;
                            if (routerNode[key] === undefined || routerNode[key] === null) {
                                routerNode[key] = value;
                            }
                        };
                        assignIfMissing('label', routerLabel);
                        assignIfMissing('name', routerLabel);
                        routerNode.isHitlRouter = true;
                        routerNode.attachment = routerNode.attachment || attachmentPref;
                        routerNode.previewRouter = routerNode.previewRouter || previewRouter;
                        routerNode.hitlInterface = routerNode.hitlInterface || iface;
                        if (linkMeta && !routerNode.hitlLinkMeta) {
                            routerNode.hitlLinkMeta = linkMeta;
                        }
                        if (meta && meta.new_router_ip4) {
                            const value = prefixCandidate && !String(meta.new_router_ip4).includes('/')
                                ? `${meta.new_router_ip4}/${prefixCandidate}`
                                : meta.new_router_ip4;
                            assignIfMissing('ip4', value);
                        } else if (linkMeta && linkMeta.newRouterIp4) {
                            const value = prefixCandidate && !String(linkMeta.newRouterIp4).includes('/')
                                ? `${linkMeta.newRouterIp4}/${prefixCandidate}`
                                : linkMeta.newRouterIp4;
                            assignIfMissing('ip4', value);
                        } else if (typeof previewRouter.ip4 === 'string') {
                            assignIfMissing('ip4', previewRouter.ip4);
                        }
                        if (meta && meta.existing_router_ip4) {
                            assignIfMissing('peerRouterIp4', meta.existing_router_ip4);
                        } else if (linkMeta && linkMeta.existingRouterIp4) {
                            assignIfMissing('peerRouterIp4', linkMeta.existingRouterIp4);
                        }
                        if (linkMeta && (linkMeta.networkCidr || linkMeta.network)) {
                            assignIfMissing('linkNetwork', linkMeta.networkCidr || linkMeta.network);
                        } else if (meta && meta.link_network) {
                            assignIfMissing('linkNetwork', meta.link_network);
                        }
                        if (Number.isFinite(prefixCandidate)) {
                            assignIfMissing('prefixLen', prefixCandidate);
                        }
                        if (uplinkRouterId !== null && (routerNode.uplinkRouterId === undefined || routerNode.uplinkRouterId === null)) {
                            routerNode.uplinkRouterId = uplinkRouterId;
                        }
                        registerRouterOverlayNode(routerNode);
                    }
                    if (!routerPeers.some(peer => String(peer?.node_id ?? peer?.id) === String(routerId))) {
                        routerPeers.push(previewRouter);
                    }
                    routerPeerMap.set(String(routerId), previewRouter);
                    return routerId;
                }
            }

            const routerId = makeUniqueId(`hitl-router-${baseName}`);
            const routerLabel = `HITL Router ${idx + 1}`;
            const routerNode = getOrCreateRouterOverlayNode(routerId, routerLabel);
            if (routerNode) {
                const assignIfMissing = (key, value) => {
                    if (value === undefined || value === null) return;
                    if (routerNode[key] === undefined || routerNode[key] === null) {
                        routerNode[key] = value;
                    }
                };
                assignIfMissing('label', routerLabel);
                assignIfMissing('name', routerLabel);
                routerNode.isHitlRouter = true;
                routerNode.hitlInterface = routerNode.hitlInterface || iface;
                routerNode.attachment = routerNode.attachment || attachmentPref;
                if (linkMeta && !routerNode.hitlLinkMeta) {
                    routerNode.hitlLinkMeta = linkMeta;
                }
                if (linkMeta && linkMeta.newRouterIp4) {
                    const withPrefix = Number.isFinite(linkMeta.prefixLen) && !String(linkMeta.newRouterIp4).includes('/')
                        ? `${linkMeta.newRouterIp4}/${linkMeta.prefixLen}`
                        : linkMeta.newRouterIp4;
                    assignIfMissing('ip4', withPrefix);
                }
                if (linkMeta && (linkMeta.networkCidr || linkMeta.network)) {
                    assignIfMissing('linkNetwork', linkMeta.networkCidr || linkMeta.network);
                }
                if (linkMeta && Number.isFinite(linkMeta.prefixLen)) {
                    assignIfMissing('prefixLen', Number(linkMeta.prefixLen));
                }
                if (linkMeta && linkMeta.existingRouterIp4) {
                    assignIfMissing('peerRouterIp4', linkMeta.existingRouterIp4);
                }
                registerRouterOverlayNode(routerNode);
            }
            const routerCandidates = routerPeers.length ? routerPeers.slice() : [];
            if (routerCandidates.length) {
                const chosen = routerCandidates[Math.floor(rng() * routerCandidates.length) % routerCandidates.length];
                const chosenId = chosen?.node_id ?? chosen?.id;
                if (chosenId !== undefined && chosenId !== null) {
                    uplinkRouterId = chosenId;
                    if (routerNode && (routerNode.uplinkRouterId === undefined || routerNode.uplinkRouterId === null)) {
                        routerNode.uplinkRouterId = chosenId;
                    }
                    noteExisting(chosenId);
                    links.push({ sourceId: routerId, targetId: chosenId, kind: 'hitl-router-uplink', attachment: attachmentPref, assignment: 'uplink_router', linkMeta });
                }
            }
            routerPeers.push({ node_id: routerId, id: routerId, name: routerLabel, type: 'router', isHitlRouter: true });
            routerPeerMap.set(String(routerId), { node_id: routerId, id: routerId, name: routerLabel, type: 'router', isHitlRouter: true });
            noteExisting(routerId);
            return routerId;
        };
        const createNewSwitch = () => {
            const previewSwitchMetaRaw = iface.preview_switch || iface.previewSwitch || null;
            const previewSwitchId = previewSwitchMetaRaw && (previewSwitchMetaRaw.node_id ?? previewSwitchMetaRaw.nodeId ?? previewSwitchMetaRaw.id);
            if (previewSwitchMetaRaw && previewSwitchId !== undefined && previewSwitchId !== null) {
                const switchId = previewSwitchId;
                const switchLabel = previewSwitchMetaRaw.name || `HITL Switch ${idx + 1}`;
                noteExisting(switchId);
                let switchNode = switchOverlayMap.get(String(switchId));
                if (!switchNode) {
                    switchNode = {
                        id: switchId,
                        switch_id: switchId,
                        type: 'switch',
                        label: switchLabel,
                        name: switchLabel,
                        isHitlSwitch: true,
                        hitlInterface: iface,
                        attachment: attachmentPref,
                        previewSwitch: previewSwitchMetaRaw,
                    };
                    nodes.push(switchNode);
                    includedSwitchNodeIds.add(switchId);
                    registerSwitchOverlayNode(switchNode);
                } else {
                    if (!switchNode.label) switchNode.label = switchLabel;
                    if (!switchNode.name) switchNode.name = switchLabel;
                    switchNode.isHitlSwitch = true;
                    switchNode.hitlInterface = switchNode.hitlInterface || iface;
                    switchNode.attachment = switchNode.attachment || attachmentPref;
                    switchNode.previewSwitch = switchNode.previewSwitch || previewSwitchMetaRaw;
                    registerSwitchOverlayNode(switchNode);
                }
                if (linkMeta && !switchNode.hitlLinkMeta) {
                    switchNode.hitlLinkMeta = linkMeta;
                }
                if (!existingSubnets.some(sw => String(sw?.switch_id ?? sw?.id) === String(switchId))) {
                    existingSubnets.push({ switch_id: switchId, id: switchId, name: switchLabel, isHitlSwitch: true });
                }
                const hintedRouterId = iface.targetRouterId ?? previewSwitchMetaRaw.router_id ?? previewSwitchMetaRaw.routerId ?? null;
                if (hintedRouterId !== null && hintedRouterId !== undefined) {
                    uplinkRouterId = hintedRouterId;
                    if (switchNode.router_id === undefined || switchNode.router_id === null) {
                        switchNode.router_id = hintedRouterId;
                    }
                    if (switchNode.uplinkRouterId === undefined || switchNode.uplinkRouterId === null) {
                        switchNode.uplinkRouterId = hintedRouterId;
                    }
                }
                return switchId;
            }
            const slugKey = iface.slug ? `slug:${iface.slug}` : null;
            const nameKey = iface.name ? `name:${String(iface.name).toLowerCase().trim()}` : null;
            const matchedDetail = (slugKey && hitlSwitchLookup.get(slugKey)) || (nameKey && hitlSwitchLookup.get(nameKey)) || null;
            let switchId;
            let switchLabel;
            if (matchedDetail && matchedDetail.switch_id !== undefined && matchedDetail.switch_id !== null) {
                switchId = matchedDetail.switch_id;
                const meta = (matchedDetail.metadata && typeof matchedDetail.metadata === 'object') ? matchedDetail.metadata : {};
                switchLabel = matchedDetail.name || matchedDetail.label || meta.name || `sw-${switchId}`;
            } else {
                switchId = makeUniqueId(`hitl-switch-${baseName}`);
                switchLabel = `HITL Switch ${idx + 1}`;
            }
            let switchNode = switchOverlayMap.get(String(switchId));
            if (!switchNode) {
                switchNode = {
                    id: switchId,
                    switch_id: switchId,
                    type: 'switch',
                    label: switchLabel,
                    name: switchLabel,
                    isHitlSwitch: true,
                    hitlInterface: iface,
                    attachment: attachmentPref,
                };
                nodes.push(switchNode);
                includedSwitchNodeIds.add(switchId);
            } else {
                if (!switchNode.label) switchNode.label = switchLabel;
                if (!switchNode.name) switchNode.name = switchLabel;
                switchNode.isHitlSwitch = true;
                switchNode.hitlInterface = switchNode.hitlInterface || iface;
                switchNode.attachment = switchNode.attachment || attachmentPref;
            }
            registerSwitchOverlayNode(switchNode);
            const assignSwitchIfMissing = (key, value) => {
                if (value === undefined || value === null) return;
                if (switchNode[key] === undefined || switchNode[key] === null) {
                    switchNode[key] = value;
                }
            };
            if (matchedDetail) {
                assignSwitchIfMissing('router_id', matchedDetail.router_id ?? (matchedDetail.metadata && matchedDetail.metadata.target_router_id));
                assignSwitchIfMissing('uplinkRouterId', matchedDetail.router_id ?? (matchedDetail.metadata && matchedDetail.metadata.target_router_id));
                assignSwitchIfMissing('switch_ip', matchedDetail.switch_ip);
                assignSwitchIfMissing('router_ip', matchedDetail.router_ip);
                assignSwitchIfMissing('link_network_cidr', matchedDetail.rsw_subnet);
                assignSwitchIfMissing('link_network', matchedDetail.rsw_subnet || matchedDetail.lan_subnet);
                if (matchedDetail.host_if_ips && matchedDetail.host_if_ips.rj45 && (!switchNode.host_if_ips || !switchNode.host_if_ips.rj45)) {
                    switchNode.host_if_ips = switchNode.host_if_ips || {};
                    switchNode.host_if_ips.rj45 = matchedDetail.host_if_ips.rj45;
                }
            }
            if (linkMeta) {
                switchNode.hitlLinkMeta = switchNode.hitlLinkMeta || linkMeta;
                assignSwitchIfMissing('switch_ip', linkMeta.rj45Ip4 || null);
                assignSwitchIfMissing('router_ip', linkMeta.newRouterIp4 || null);
                assignSwitchIfMissing('link_network_cidr', linkMeta.networkCidr || null);
                assignSwitchIfMissing('link_network', linkMeta.network || null);
            }
            let routerLinkEstablished = false;
            const routerCandidates = routerPeers.length ? routerPeers.slice() : [];
            if (routerCandidates.length) {
                const chosen = routerCandidates[Math.floor(rng() * routerCandidates.length) % routerCandidates.length];
                const chosenId = chosen?.node_id ?? chosen?.id;
                if (chosenId !== undefined && chosenId !== null) {
                    uplinkRouterId = chosenId;
                    assignSwitchIfMissing('router_id', chosenId);
                    switchNode.uplinkRouterId = switchNode.uplinkRouterId ?? chosenId;
                    noteExisting(chosenId);
                    links.push({ sourceId: switchId, targetId: chosenId, kind: 'hitl-switch-uplink', attachment: attachmentPref, assignment: 'uplink_switch' });
                    routerLinkEstablished = true;
                }
            }
            if (!routerLinkEstablished) {
                const fallbackRouterId = createNewRouter();
                if (fallbackRouterId !== null && fallbackRouterId !== undefined) {
                    uplinkRouterId = fallbackRouterId;
                    assignSwitchIfMissing('router_id', fallbackRouterId);
                    switchNode.uplinkRouterId = fallbackRouterId;
                    noteExisting(fallbackRouterId);
                    links.push({ sourceId: switchId, targetId: fallbackRouterId, kind: 'hitl-switch-uplink', attachment: attachmentPref, assignment: 'uplink_switch' });
                    routerLinkEstablished = true;
                }
            }
            if (!matchedDetail) {
                existingSubnets.push({ switch_id: switchId, id: switchId, name: switchLabel, isHitlSwitch: true });
            }
            noteExisting(switchId);
            return switchId;
        };
        for (const attempt of attempts) {
            if (attempt === 'existing_router') {
                const candidate = pickRouterPeer();
                if (candidate !== null) {
                    targetId = candidate;
                    assignment = 'existing_router';
                    linkKind = 'hitl-router';
                    noteExisting(candidate);
                    uplinkRouterId = candidate;
                    break;
                }
            } else if (attempt === 'existing_switch') {
                const candidate = pickSwitchPeer();
                if (candidate !== null) {
                    targetId = candidate;
                    assignment = 'existing_switch';
                    linkKind = 'hitl-switch';
                    noteExisting(candidate);
                    break;
                }
            } else if (attempt === 'new_router') {
                const newRouterId = createNewRouter();
                if (newRouterId !== null) {
                    targetId = newRouterId;
                    assignment = 'new_router';
                    linkKind = 'hitl-router';
                    break;
                }
            }
        }
        if (targetId === null) {
            const fallbackRouter = pickRouterPeer();
            if (fallbackRouter !== null) {
                targetId = fallbackRouter;
                assignment = assignment ?? 'existing_router';
                linkKind = 'hitl-router';
                noteExisting(fallbackRouter);
                uplinkRouterId = fallbackRouter;
            }
        }
        if (targetId === null && hostPeers.length) {
            const peer = hostPeers[Math.floor(rng() * hostPeers.length)];
            const peerId = peer?.node_id ?? peer?.id;
            if (peerId !== undefined && peerId !== null) {
                targetId = peerId;
                assignment = assignment ?? 'existing_host';
                linkKind = 'hitl-host';
                noteExisting(peerId);
            }
        }
        if (targetId === null) {
            const networkId = makeUniqueId(`hitl-net-${baseName}`);
            const networkLabel = `HITL Network ${idx + 1}`;
            nodes.push({
                id: networkId,
                type: 'network',
                label: networkLabel,
                name: networkLabel,
                isHitlNetwork: true,
                hitlInterface: iface,
                attachment: attachmentPref,
            });
            targetId = networkId;
            assignment = assignment ?? 'network';
            linkKind = 'hitl-network';
        }
        if (targetId !== null) {
            hitlNode.peerNodeId = targetId;
            hitlNode.assignment = assignment || attachmentPref;
            if (uplinkRouterId !== null) {
                hitlNode.uplinkRouterId = uplinkRouterId;
            }
            links.push({
                sourceId: nodeId,
                targetId,
                kind: linkKind,
                attachment: attachmentPref,
                assignment: assignment || attachmentPref,
                linkMeta,
            });
        }
    });
    routerSwitchInterfaceMap.forEach((entries, key) => {
        const routerNode = getOrCreateRouterOverlayNode(key);
        if (routerNode) {
            routerNode.hitlSwitchInterfaces = entries;
        }
    });
    const result = nodes.length ? { nodes, links, interfaces, hitlState } : null;
    HITL_PREVIEW_CACHE.set(full, result);
    return result;
}

function normalizeBaseUpload(meta) {
    if (!meta || typeof meta !== 'object') return null;
    const safe = {};
    if (typeof meta.path === 'string') safe.path = meta.path;
    if (typeof meta.display_name === 'string') safe.display_name = meta.display_name;
    if (Object.prototype.hasOwnProperty.call(meta, 'valid')) safe.valid = !!meta.valid;
    return Object.keys(safe).length ? safe : null;
}

const ROUTER_NODE_TYPES = new Set(['router', 'prouter', 'mdr', 'core-router', 'gateway']);
const SWITCH_NODE_TYPES = new Set(['switch', 'lanswitch', 'l3switch', 'bridge', 'core-switch']);
const HOST_NODE_TYPES = new Set(['host', 'pc', 'server', 'workstation', 'client', 'desktop', 'lxc', 'xterm', 'generic', 'terminal', 'laptop']);
const NETWORK_NODE_TYPES = new Set(['network', 'lan', 'wan']);
const WIRELESS_NODE_TYPES = new Set(['wireless', 'wirelesslan', 'wireless-lan', 'wlan', 'wifi']);
const RJ45_NODE_TYPES = new Set(['rj45']);
const HUB_NODE_TYPES = new Set(['hub', 'ethernet', 'tap']);

const NODE_TYPE_STYLE_PRESETS = {
    router: { label: 'Router', color: '#ff7043', radius: 11 },
    switch: { label: 'Switch', color: '#17a2b8', radius: 8 },
    host: { label: 'Host', color: '#ffc107', radius: 5 },
    network: { label: 'Network', color: '#6c757d', radius: 7 },
    hub: { label: 'Hub', color: '#7952b3', radius: 6 },
    rj45: { label: 'RJ45', color: '#20c997', radius: 6, shape: 'square' },
    wireless: { label: 'Wireless', color: '#0dcaf0', radius: 6 },
    wlan: { label: 'WLAN', color: '#0dcaf0', radius: 6 },
    tap: { label: 'TAP', color: '#6f42c1', radius: 6 },
};

function canonicalNodeType(raw) {
    if (raw === null || raw === undefined) return 'host';
    const key = String(raw).trim().toLowerCase();
    if (!key) return 'host';
    if (ROUTER_NODE_TYPES.has(key)) return 'router';
    if (SWITCH_NODE_TYPES.has(key)) return 'switch';
    if (RJ45_NODE_TYPES.has(key)) return 'rj45';
    if (WIRELESS_NODE_TYPES.has(key)) return 'wireless';
    if (NETWORK_NODE_TYPES.has(key)) return 'network';
    if (HUB_NODE_TYPES.has(key)) return 'hub';
    if (HOST_NODE_TYPES.has(key)) return 'host';
    return key;
}

function formatNodeTypeLabel(key) {
    if (!key) return 'Node';
    return key.replace(/[-_]/g, ' ').replace(/\b\w/g, c => c.toUpperCase());
}

function nodeStyleForType(rawType) {
    const key = canonicalNodeType(rawType);
    const preset = NODE_TYPE_STYLE_PRESETS[key];
    if (preset) {
        const radius = Number.isFinite(preset.radius) ? preset.radius : 6;
        const shape = preset.shape || 'circle';
        return { ...preset, radius, shape };
    }
    return {
        label: formatNodeTypeLabel(key),
        color: '#adb5bd',
        radius: 6,
        shape: 'circle',
    };
}

function coerceBool(value) {
    if (typeof value === 'boolean') return value;
    if (typeof value === 'number') return value !== 0;
    if (typeof value === 'string') {
        const val = value.trim().toLowerCase();
        return ['1', 'true', 'yes', 'on', 'y'].includes(val);
    }
    return false;
}

function toPositiveInt(value, fallback) {
    if (typeof value === 'number' && Number.isFinite(value) && value > 0) {
        return Math.round(value);
    }
    if (typeof value === 'string') {
        const trimmed = value.trim();
        if (trimmed) {
            const parsed = parseInt(trimmed, 10);
            if (!Number.isNaN(parsed) && parsed > 0) {
                return parsed;
            }
        }
    }
    return fallback;
}

function normalizeCoreState(raw, includePassword = true) {
    const serverDefaults = (initialPayload && typeof initialPayload.core === 'object') ? initialPayload.core : {};
    const defaults = {
        host: (typeof serverDefaults.host === 'string' && serverDefaults.host.trim()) ? serverDefaults.host.trim() : 'localhost',
        port: toPositiveInt(serverDefaults.port, 50051),
        ssh_enabled: true,
        ssh_host: (typeof serverDefaults.ssh_host === 'string' && serverDefaults.ssh_host.trim()) ? serverDefaults.ssh_host.trim() : '',
        ssh_port: toPositiveInt(serverDefaults.ssh_port, 22),
        ssh_username: (typeof serverDefaults.ssh_username === 'string') ? serverDefaults.ssh_username : '',
    };
    if (!defaults.ssh_host) defaults.ssh_host = defaults.host;
    const source = (raw && typeof raw === 'object') ? raw : {};
    const out = {
        host: defaults.host,
        port: defaults.port,
        ssh_enabled: true,
        ssh_host: defaults.ssh_host,
        ssh_port: defaults.ssh_port,
        ssh_username: defaults.ssh_username,
    };
    if ('host' in source && String(source.host).trim()) {
        out.host = String(source.host).trim();
    }
    out.port = toPositiveInt(source.port, out.port);
    out.ssh_enabled = true;
    if ('ssh_host' in source && String(source.ssh_host).trim()) {
        out.ssh_host = String(source.ssh_host).trim();
    }
    if (!out.ssh_host) {
        out.ssh_host = out.host;
    }
    out.ssh_port = toPositiveInt(source.ssh_port, out.ssh_port);
    if ('ssh_username' in source) {
        out.ssh_username = String(source.ssh_username || '');
    }
    if (includePassword) {
        if ('ssh_password' in source) {
            out.ssh_password = source.ssh_password === null ? '' : String(source.ssh_password);
        } else if (source && typeof source.ssh === 'object' && source.ssh && 'password' in source.ssh) {
            out.ssh_password = String(source.ssh.password || '');
        } else {
            out.ssh_password = '';
        }
    }
    if (!out.ssh_port || !Number.isFinite(out.ssh_port)) {
        out.ssh_port = 22;
    }
    return out;
}

function sanitizeCoreForPersist(coreState) {
    return normalizeCoreState(coreState, false);
}

function restoreCorePasswordFromSession(coreState) {
    const cfg = normalizeCoreState(coreState, true);
    try {
        const stored = sessionStorage.getItem('coretg_core_pw');
        if (stored !== null) {
            cfg.ssh_password = stored;
        }
    } catch (e) {
        /* ignore */
    }
    return cfg;
}

function storeCorePasswordInSession() {
    try {
        const pw = state?.core?.ssh_password ?? '';
                    if (id) {
                        const escapedId = (window.CSS && typeof window.CSS.escape === 'function') ? window.CSS.escape(id) : id;
        } else {
            sessionStorage.removeItem('coretg_core_pw');
        }
    } catch (e) {
        /* ignore */
    }
}

function getCoreConfig(includePassword = true) {
    const normalized = normalizeCoreState(state?.core || {}, includePassword);
    if (!includePassword && 'ssh_password' in normalized) {
        delete normalized.ssh_password;
    }
    return normalized;
}

function getActiveScenarioContext() {
    const scenarios = Array.isArray(state?.scenarios) ? state.scenarios : [];
    const idx = Number.isInteger(activeIdx) && activeIdx >= 0 && activeIdx < scenarios.length ? activeIdx : null;
    const scenario = (idx !== null) ? scenarios[idx] : null;
    const name = (scenario && typeof scenario.name === 'string') ? scenario.name.trim() : '';
    return { idx, scenario, name };
}

function cloneScenarioCoreFromScenario(scenario, includePassword = true) {
    if (!scenario) return null;
    const hitlState = ensureHitlStateForScenario(scenario);
    if (!hitlState || typeof hitlState !== 'object' || !hitlState.core || typeof hitlState.core !== 'object') {
        return null;
    }
    let clone;
    try {
        clone = JSON.parse(JSON.stringify(hitlState.core));
    } catch (err) {
        clone = { ...hitlState.core };
    }
    if (!includePassword) {
        delete clone.ssh_password;
    }
    return clone;
}

function cloneScenarioCoreByIndex(idx, includePassword = true) {
    if (!Number.isInteger(idx)) return null;
    const scenarios = Array.isArray(state?.scenarios) ? state.scenarios : [];
    if (idx < 0 || idx >= scenarios.length) return null;
    return cloneScenarioCoreFromScenario(scenarios[idx], includePassword);
}

function cloneActiveScenarioCore(includePassword = true) {
    const { scenario } = getActiveScenarioContext();
    return cloneScenarioCoreFromScenario(scenario, includePassword);
}

function appendScenarioContextToFormData(form, options = {}) {
    const { includeCore = true, scenarioIndex = null } = options;
    const { idx: activeIdx, name: activeName } = getActiveScenarioContext();
    const idx = Number.isInteger(scenarioIndex) ? scenarioIndex : activeIdx;
    const scenarios = Array.isArray(state?.scenarios) ? state.scenarios : [];
    const scenario = Number.isInteger(idx) && idx >= 0 && idx < scenarios.length ? scenarios[idx] : null;
    const name = scenario && typeof scenario.name === 'string' ? scenario.name : activeName;
    if (Number.isInteger(idx)) {
        form.append('scenario_index', String(idx));
    }
    if (name) {
        form.append('scenario_name', name);
        form.append('scenario', name);
    }
    if (includeCore) {
        const scenarioCore = cloneScenarioCoreFromScenario(scenario, true);
        if (scenarioCore) {
            form.append('hitl_core_json', JSON.stringify(scenarioCore));
        }
    }
}

function enrichPayloadWithScenarioContext(payload, options = {}) {
    const {
        includeCore = true,
        scenarioIndex = null,
        scenarioOverride = null,
    } = options;
    const scenarios = Array.isArray(state?.scenarios) ? state.scenarios : [];
    let idx = Number.isInteger(scenarioIndex) ? scenarioIndex : null;
    let scenario = scenarioOverride;
    if (!scenario) {
        if (idx !== null && idx >= 0 && idx < scenarios.length) {
            scenario = scenarios[idx];
        } else {
            const { idx: activeIdx, scenario: activeScenario } = getActiveScenarioContext();
            idx = activeIdx;
            scenario = activeScenario;
        }
    }
    if (Number.isInteger(idx)) {
        payload.scenario_index = idx;
    }
    const scenarioName = scenario && typeof scenario.name === 'string' ? scenario.name : '';
    if (scenarioName) {
        payload.scenario = scenarioName;
        payload.scenario_name = scenarioName;
    }
    if (includeCore) {
        const scenarioCore = cloneScenarioCoreFromScenario(scenario, true);
        if (scenarioCore) {
            payload.hitl_core = scenarioCore;
        }
    }
    return payload;
}

// Restore persisted editor state (scenarios and last saved xml) and active index from localStorage
let persistedState = null;
try { persistedState = JSON.parse(localStorage.getItem('coretg_editor_state') || 'null'); } catch(e){ persistedState = null; }
let persistedActiveIdx = 0;
try { const v = parseInt(localStorage.getItem('coretg_active_idx')||'0',10); if(!isNaN(v)) persistedActiveIdx = v; } catch(e){}
// Base state is from server payload or default
let state = initialPayload ?? { scenarios: [ defaultScenario('Scenario 1') ], result_path: null };
if (!Array.isArray(state.host_interfaces)) {
    if (Array.isArray(initialPayload?.host_interfaces)) {
        state.host_interfaces = initialPayload.host_interfaces;
    } else if (Array.isArray(persistedState?.host_interfaces)) {
        state.host_interfaces = persistedState.host_interfaces;
    } else {
        state.host_interfaces = [];
    }
}
state.host_interfaces_source = initialPayload?.host_interfaces_source ?? persistedState?.host_interfaces_source ?? state.host_interfaces_source ?? null;
state.host_interfaces_metadata = initialPayload?.host_interfaces_metadata ?? persistedState?.host_interfaces_metadata ?? state.host_interfaces_metadata ?? null;
state.host_interfaces_fetched_at = initialPayload?.host_interfaces_fetched_at ?? persistedState?.host_interfaces_fetched_at ?? state.host_interfaces_fetched_at ?? null;
// If server provided a concrete result_path (save/load/run), prefer server scenarios; else, restore from localStorage if available
const serverHasResult = !!(initialPayload && initialPayload.result_path);
const serverScenarioBases = Array.isArray(initialPayload?.scenarios)
    ? initialPayload.scenarios.map(s => {
        if (!s || typeof s !== 'object' || !s.base || typeof s.base !== 'object') return undefined;
        const meta = {};
        if (typeof s.base.filepath === 'string') meta.filepath = s.base.filepath;
        if (typeof s.base.display_name === 'string') meta.display_name = s.base.display_name;
        return Object.keys(meta).length ? meta : undefined;
    })
    : [];
if (!serverHasResult && persistedState && Array.isArray(persistedState.scenarios) && persistedState.scenarios.length) {
    state.scenarios = persistedState.scenarios;
    if (persistedState.result_path) state.result_path = persistedState.result_path;
    if (serverScenarioBases.length) {
        serverScenarioBases.forEach((serverMeta, idx) => {
            if (!serverMeta) return;
            if (!state.scenarios[idx]) return;
            const scen = state.scenarios[idx];
            if (!scen.base || typeof scen.base !== 'object') scen.base = {};
            scen.base.filepath = (serverMeta.filepath || '');
            if ('display_name' in serverMeta) {
                scen.base.display_name = serverMeta.display_name;
            } else if (scen.base.display_name) {
                delete scen.base.display_name;
            }
        });
    }
}
const serverBaseUpload = normalizeBaseUpload(initialPayload?.base_upload);
const persistedBaseUpload = normalizeBaseUpload(persistedState?.base_upload);
if (!serverHasResult && persistedBaseUpload && (!state.base_upload || !state.base_upload.path)) {
    if (state.scenarios?.[0] && state.scenarios[0].base && (state.scenarios[0].base.filepath || state.scenarios[0].base.display_name)) {
        state.base_upload = { ...persistedBaseUpload };
    }
}
if (serverBaseUpload) {
    state.base_upload = { ...serverBaseUpload };
}
if (state.base_upload && state.scenarios?.[0]) {
    const scenBase = (typeof state.scenarios[0].base === 'object' && state.scenarios[0].base) ? state.scenarios[0].base : (state.scenarios[0].base = {});
    if (!scenBase.filepath && state.base_upload.path) {
        scenBase.filepath = state.base_upload.path;
    }
    if (!scenBase.display_name) {
        if (state.base_upload.display_name) scenBase.display_name = state.base_upload.display_name;
        else if (scenBase.filepath) scenBase.display_name = scenBase.filepath.split(/[/\\]/).pop() || '';
    }
}
if (state.base_upload) {
    if (!state.base_upload.display_name) {
        const fallback = state.scenarios?.[0]?.base?.display_name || (state.base_upload.path ? state.base_upload.path.split(/[/\\]/).pop() : '');
        if (fallback) state.base_upload.display_name = fallback;
    }
    if (!state.base_upload.path && state.scenarios?.[0]?.base?.filepath) {
        state.base_upload.path = state.scenarios[0].base.filepath;
    }
}

(state.scenarios || []).forEach(ensureHitlStateForScenario);
// Clear any stale in-flight flags persisted from a previous session/tab so UI doesn't show a busy state on load
try {
    (state.scenarios || []).forEach((scen) => {
        if (!scen || typeof scen !== 'object') return;
        const hitl = scen.hitl && typeof scen.hitl === 'object' ? scen.hitl : null;
        const core = hitl && typeof hitl.core === 'object' ? hitl.core : null;
        if (core && core.interfaces_refresh_inflight === true) {
            core.interfaces_refresh_inflight = false;
        }
    });
} catch (e) { /* ignore */ }

// Preview workflow state (in-memory only; persisted history handled separately)
let previewState = {
    fullPreview: null,
    fullPreviewHistory: [],
    xmlSaved: !!(state.result_path),
    dirty: false,
    coreTested: false
};
const FULL_PREVIEW_ARTIFACT_VERSION = 2;

function safeClone(value){
    if(value === null || typeof value !== 'object') return value;
    try { return structuredClone(value); }
    catch(e){
        try { return JSON.parse(JSON.stringify(value)); }
        catch(err){ return value; }
    }
}

function summarizeSegRule(rule){
    if(!rule) return '';
    const type = rule.type || rule.action || '';
    if(type === 'nat'){
        const mode = rule.mode ? `${rule.mode} ` : '';
        const internal = rule.internal || rule.internal_subnet || '';
        const external = rule.external || rule.external_subnet || '';
        return `${mode}${internal}${(internal && external)?' -> ':''}${external}`.trim();
    }
    if(type === 'host_block'){
        const src = rule.src || rule.source || '';
        const dst = rule.dst || rule.destination || '';
        return `${src} X ${dst}`.trim();
    }
    if(type === 'custom'){
        return rule.description || 'custom';
    }
    if(type){
        const src = rule.src || rule.source;
        const dst = rule.dst || rule.destination;
        if(src || dst){
            return `${type}: ${src || '*'} -> ${dst || '*'}`;
        }
        return type;
    }
    return '';
}

function buildSegmentationArtifacts(full){
    const seg = (full && full.segmentation_preview) || {};
    const rawRules = Array.isArray(seg.rules) ? seg.rules : [];
    const meta = safeClone(seg);
    if(meta && typeof meta === 'object') delete meta.rules;
    if(!rawRules.length){
        return {
            rows: [],
            tableRows: [],
            table_rows: [],
            json: {
                rules_count: 0,
                types_summary: {},
                rules: [],
                metadata: meta || null
            }
        };
    }
    const summaries = [];
    const tableRows = [];
    const typeCounts = {};
    for(const rawEntry of rawRules){
        const entry = safeClone(rawEntry);
        if(!entry || typeof entry !== 'object') continue;
        const rule = ('rule' in entry && entry.rule) ? safeClone(entry.rule) : safeClone(entry);
        if(!rule || typeof rule !== 'object') continue;
        const nodeId = (entry.node_id !== undefined) ? entry.node_id : (rule.node_id !== undefined ? rule.node_id : null);
        const typeRaw = (rule.type !== undefined && rule.type !== null) ? rule.type : rule.action;
        const type = (typeRaw !== undefined && typeRaw !== null) ? String(typeRaw) : null;
        const summary = summarizeSegRule(rule);
        const src = (rule.src !== undefined && rule.src !== null) ? rule.src : rule.source;
        const dst = (rule.dst !== undefined && rule.dst !== null) ? rule.dst : rule.destination;
        const internal = (rule.internal !== undefined && rule.internal !== null) ? rule.internal : rule.internal_subnet;
        const external = (rule.external !== undefined && rule.external !== null) ? rule.external : rule.external_subnet;
        const proto = (rule.proto !== undefined && rule.proto !== null) ? rule.proto : rule.protocol;
        const port = (rule.port !== undefined) ? rule.port : null;
        const scriptPath = typeof entry.script === 'string' ? entry.script : (typeof rule.script === 'string' ? rule.script : null);
        const scriptName = scriptPath ? scriptPath.split('/').pop() : null;
        const tableRow = {
            node_id: nodeId,
            type,
            summary,
            src: src ?? null,
            dst: dst ?? null,
            subnet: rule.subnet ?? null,
            internal: internal ?? null,
            external: external ?? null,
            proto: proto ?? null,
            port,
            script_path: scriptPath || null,
            script_name: scriptName || null,
            detail: rule
        };
        tableRows.push(tableRow);
        summaries.push({ node_id: nodeId, type, summary });
        const key = type || 'unknown';
        typeCounts[key] = (typeCounts[key] || 0) + 1;
    }
    return {
        rows: summaries,
        tableRows,
        table_rows: tableRows,
        json: {
            rules_count: tableRows.length,
            types_summary: typeCounts,
            rules: tableRows.map(row => ({ node_id: row.node_id, type: row.type, summary: row.summary, detail: safeClone(row.detail) })),
            metadata: meta || null
        }
    };
}

function buildFullPreviewArtifacts(full){
    if(!full) return { segmentation: buildSegmentationArtifacts(full) };
    if(full.__displayArtifactsVersion === FULL_PREVIEW_ARTIFACT_VERSION && full.__displayArtifacts){
        return full.__displayArtifacts;
    }
    let artifacts = null;
    if(full.display_artifacts_version === FULL_PREVIEW_ARTIFACT_VERSION && full.display_artifacts){
        artifacts = safeClone(full.display_artifacts);
    }
    if(!artifacts || !artifacts.segmentation){
        artifacts = { segmentation: buildSegmentationArtifacts(full) };
    } else {
        const seg = artifacts.segmentation;
        if(!seg.tableRows || !seg.table_rows || !Array.isArray(seg.rows)){
            artifacts.segmentation = buildSegmentationArtifacts(full);
        }
    }
    artifacts.__version = FULL_PREVIEW_ARTIFACT_VERSION;
    try {
        Object.defineProperty(full, '__displayArtifacts', { value: artifacts, enumerable: false, configurable: true, writable: true });
        Object.defineProperty(full, '__displayArtifactsVersion', { value: FULL_PREVIEW_ARTIFACT_VERSION, enumerable: false, configurable: true, writable: true });
    } catch(e){
        full.__displayArtifacts = artifacts;
        full.__displayArtifactsVersion = FULL_PREVIEW_ARTIFACT_VERSION;
    }
    return artifacts;
}
// Core settings: prefer server-provided if present; otherwise restore from persisted
// ---------------- Plan Workflow State -----------------
// (Legacy alias cleanup left intentionally blank. Using previewState below.)

// ---------- Full Preview History Persistence ----------
function loadFullPreviewHistory(){
    try { previewState.fullPreviewHistory = JSON.parse(localStorage.getItem('coretg_full_preview_history')||'[]'); } catch(e){ previewState.fullPreviewHistory = []; }
    if(!Array.isArray(previewState.fullPreviewHistory)) previewState.fullPreviewHistory = [];
}
function saveFullPreviewHistory(){
    try { localStorage.setItem('coretg_full_preview_history', JSON.stringify(previewState.fullPreviewHistory.slice(-25))); } catch(e){}
}
loadFullPreviewHistory();

// Run progress modal state (hoisted early to avoid TDZ issues)
let runProgressModalInst = null;
let runProgressEvtSrc = null;
let runProgressRunId = null;

function setupPreviewModalExecute(modalEl, modalInstance){
    if(!modalEl) return;
    const execBtn = modalEl.querySelector('#previewModalExecuteBtn');
    if(!execBtn) return;
    if(execBtn.dataset.enhanced === '1') return;
    execBtn.dataset.enhanced = '1';
    execBtn.addEventListener('click', async () => {
        if(execBtn.disabled) return;
        execBtn.disabled = true;
        execBtn.classList.add('disabled');
        const forceHideModal = () => {
            try { modalInstance?.hide(); } catch(e){}
            if(modalEl){
                modalEl.classList.remove('show');
                modalEl.setAttribute('aria-hidden','true');
                modalEl.style.display = 'none';
            }
            // Remove any lingering backdrop only if no other modals remain visible
            const openModals = document.querySelectorAll('.modal.show');
            if(openModals.length === 0){
                document.querySelectorAll('.modal-backdrop').forEach(b => {
                    try { b.remove(); } catch(e){}
                });
                document.body.classList.remove('modal-open');
                document.body.style.removeProperty('paddingRight');
                document.body.style.removeProperty('overflow');
            }
        };
        const restoreModal = () => {
            try {
                if(modalInstance){
                    modalInstance.show();
                } else if(modalEl){
                    modalEl.style.display = 'block';
                    modalEl.classList.add('show');
                    document.body.classList.add('modal-open');
                }
            } catch(e){}
        };
        const waitForPaint = async () => {
            await new Promise(resolve => requestAnimationFrame(() => resolve()));
        };
        try {
            const execInfo = detectLocalEmulation();
            const confirmMsg = execInfo.shouldFake
                ? 'Execute this scenario now?\n\nCORE not connected; will run with fake local emulation. Proceed?'
                : 'Execute this scenario now? This will start a CORE session.';
            if(!window.confirm(confirmMsg)){
                execBtn.disabled = false;
                execBtn.classList.remove('disabled');
                return;
            }
            forceHideModal();
            await waitForPaint();
            await new Promise(resolve => setTimeout(resolve, 0));
            openRunProgress('Running CLI…');
            maybeShowLocalEmulationHint();
            try {
                const statusEl = document.getElementById('runProgressStatus');
                if(statusEl) statusEl.textContent = 'Starting…';
                const metaEl = document.getElementById('runProgressMeta');
                if(metaEl) metaEl.textContent = '';
                const bar = document.getElementById('runProgressBar');
                if(bar){
                    bar.classList.add('progress-bar-animated');
                    bar.textContent = 'Working…';
                }
            } catch(e){}
            try {
                const showBtn = document.getElementById('dockShowBtn');
                if(showBtn && !showBtn.classList.contains('d-none')) showBtn.click();
            } catch(e){}

            const setRunning = () => {
                try {
                    const statusEl = document.getElementById('runProgressStatus');
                    if(statusEl) statusEl.textContent = 'Running…';
                    const metaEl = document.getElementById('runProgressMeta');
                    if(metaEl) metaEl.textContent = 'Streaming logs…';
                    const bar = document.getElementById('runProgressBar');
                    if(bar){
                        bar.classList.add('progress-bar-animated');
                        bar.textContent = 'Working…';
                    }
                } catch(e){}
            };
            const setFinished = (data) => {
                try {
                    const statusEl = document.getElementById('runProgressStatus');
                    if(statusEl) statusEl.textContent = (data?.returncode === 0) ? 'Scenario started' : 'Finished with errors';
                    const metaEl = document.getElementById('runProgressMeta');
                    if(metaEl) metaEl.textContent = (data?.returncode === 0) ? 'Completed' : 'Finished';
                    const bar = document.getElementById('runProgressBar');
                    if(bar){
                        bar.classList.remove('progress-bar-animated');
                        bar.textContent = (data?.returncode === 0) ? 'Done' : 'Error';
                    }
                } catch(e){}
            };
            const setFailedToStart = (msg) => {
                try {
                    const statusEl = document.getElementById('runProgressStatus');
                    if(statusEl) statusEl.textContent = 'Failed to start';
                    const metaEl = document.getElementById('runProgressMeta');
                    if(metaEl) metaEl.textContent = msg || '';
                    const bar = document.getElementById('runProgressBar');
                    if(bar){
                        bar.classList.remove('progress-bar-animated');
                        bar.textContent = 'Error';
                    }
                } catch(e){}
            };

            let launchFailed = false;
            const result = await runSyncWithModal({
                showProgressModal: false,
                skipConfirm: true,
                onTick: (data) => {
                    if(data && !data.done){
                        setRunning();
                    }
                },
                onComplete: (data) => {
                    setFinished(data);
                    try {
                        if(data?.returncode === 0){
                            setTimeout(()=>{ window.location.href = "{{ url_for('reports_page') }}"; }, 500);
                        }
                    } catch(e){}
                },
                onError: () => {
                    setFailedToStart('Unable to launch CLI');
                    launchFailed = true;
                },
            });
            if(result === false){
                if(!launchFailed){
                    closeRunProgress();
                    restoreModal();
                }
                return;
            }
        } catch(err){
            console.error('Preview execute failed', err);
            closeRunProgress();
            restoreModal();
        } finally {
            execBtn.disabled = false;
            execBtn.classList.remove('disabled');
        }
    });
}

function updatePlanButtons(){
    const previewBtn = document.getElementById('planPreviewBtn');
    const statusBadge = document.getElementById('planStatusBadge');
    const hint = document.getElementById('planHint');
    const genBtn = document.getElementById('runSyncBtn');
    const xmlPathVal = (state.result_path || '').trim();
    previewState.xmlSaved = !!xmlPathVal;
    const canPreview = previewState.xmlSaved || previewState.dirty;
    if(previewBtn) previewBtn.disabled = !canPreview;
    if(genBtn) genBtn.disabled = !canPreview;
    if(hint){
    if(!previewState.xmlSaved) hint.textContent = 'Save XML to enable planning.';
    else hint.textContent = previewState.fullPreview ? 'Full preview ready.' : 'Generate a full preview.';
    }
    if(statusBadge){
    statusBadge.className = 'badge ' + (previewState.fullPreview ? 'text-bg-info' : 'text-bg-secondary');
    statusBadge.textContent = previewState.fullPreview ? 'Preview' : 'No Preview';
    }
}


function showPlanSummary(summary){
    const pre = document.getElementById('planPreviewJson');
    if(!pre) return;
    pre.classList.remove('d-none');
    try{ pre.textContent = JSON.stringify(summary, null, 2); }catch(e){ pre.textContent='(error displaying plan)'; }
}

async function computePlanPreview(){
    // Deprecated lightweight preview replaced by full preview; delegate
    return computeFullPlanPreview();
}

// Approval functions removed

function onCoreTestedSuccess(){ previewState.coreTested = true; updatePlanButtons(); }

// Hook into existing CORE test result update
const originalUpdateCoreStatus = window.updateCoreStatus; // if defined later, we patch after definition
window.updateCoreStatus = function(success, msg){
    if(typeof originalUpdateCoreStatus === 'function') originalUpdateCoreStatus(success, msg);
    if(success) onCoreTestedSuccess();
};

document.addEventListener('DOMContentLoaded', () => {
    document.getElementById('planPreviewBtn')?.addEventListener('click', computePlanPreview);
    // Repurpose Run CLI button to invoke Full Preview logic
    document.getElementById('runSyncBtn')?.addEventListener('click', ()=>{
        // Mirror enablement guard from preview button
        if(document.getElementById('planPreviewBtn')?.disabled){
            logWarn('Full Preview disabled; cannot run');
            return;
        }
        computePlanPreview();
    });
    try { updatePlanButtons(); } catch(e){}
});

async function computeFullPlanPreview(){
    const xmlPathVal = (state.result_path || '').trim();
    if(!xmlPathVal){
        try { await autoSaveXml(); } catch(e){ alert('Auto-save failed: '+e); return; }
    }
    const newXmlPath = (state.result_path || '').trim();
    if(!newXmlPath){ alert('XML path still unavailable after save.'); return; }
    const btn = document.getElementById('planPreviewBtn');
    const pre = document.getElementById('planPreviewJson');
    btn.disabled = true; btn.dataset.prevLabel = btn.textContent; btn.textContent='Full preview...';
    pre.classList.remove('d-none'); pre.textContent='Computing full preview...';
    try {
    // Collect routing row host-per-switch overrides (min/max)
    let r2sHostsMinList = [];
    let r2sHostsMaxList = [];
    try {
        const scen = state.scenarios[0];
        if (scen && scen.sections && scen.sections['Routing']) {
            (scen.sections['Routing'].items || []).forEach(it => {
                    if (id) {
                        const escapedId = (window.CSS && typeof window.CSS.escape === 'function') ? window.CSS.escape(id) : id;
                        const lbl = coreConnectionForm.querySelector(`label[for="${escapedId}"]`);
                }
            });
        }
                    coreState.core_secret_id = null;
                    coreState.validated = false;
                    coreState.last_validated_at = null;
                    coreState.stored_summary = null;
    } catch(e) { /* ignore */ }
    const body = enrichPayloadWithScenarioContext({ xml_path: newXmlPath, r2s_hosts_min_list: r2sHostsMinList, r2s_hosts_max_list: r2sHostsMaxList, core: getCoreConfig(true) });
        const res = await fetch('/api/plan/preview_full', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(body) });
        const data = await res.json();
        try {
            if(window.logLine){ window.logLine('INFO', 'Preview: response received; parsing plan summary'); }
        } catch(e){}
    if(!data.ok){ pre.textContent='Full preview failed: '+(data.error||''); previewState.fullPreview=null; document.getElementById('fullPreviewStructured')?.classList.add('d-none'); }
        else {
            previewState.fullPreview = data.full_preview;
            buildFullPreviewArtifacts(previewState.fullPreview);
            pre.textContent = JSON.stringify(previewState.fullPreview, null, 2);
            renderFullPreviewStructured();
            // Emit detailed calculation logs into dock
            try {
                const fp = previewState.fullPreview || {};
                const counts = fp.counts || {};
                const routersPlanned = fp.routers_planned ?? counts.routers ?? 'n/a';
                const hostsPlanned = counts.hosts_total ?? counts.hosts ?? 'n/a';
                const switchesPlanned = counts.switches ?? 'n/a';
                const r2rEdges = (fp.r2r_edges_preview || []).length;
                let densityInfo = '';
                if(fp.router_plan && typeof fp.router_plan === 'object'){
                    const rp = fp.router_plan;
                    densityInfo = ` density_raw=${rp.density_raw} density_component=${rp.density_component} count_based=${rp.count_based_component} has_weight=${rp.has_weight_based}`;
                }
                window.logLine && window.logLine('INFO', `[preview.plan] Routers planned=${routersPlanned} Hosts=${hostsPlanned} Switches=${switchesPlanned} R2R_edges=${r2rEdges}${densityInfo}`);
                if(fp.routing_items && Array.isArray(fp.routing_items)){
                    fp.routing_items.forEach((ri, idx)=>{
                        try {
                            const proto = ri.protocol || `item${idx}`;
                            const abs_c = ri.abs_count || 0;
                            const factor = ri.factor || 0;
                            window.logLine && window.logLine('INFO', `[preview.plan.item] #${idx} protocol=${proto} abs_count=${abs_c} factor=${factor}`);
                        } catch(e){}
                    });
                }
                // Services breakdown
                try {
                    if(fp.services_plan){
                        const svcKeys = Object.keys(fp.services_plan);
                        window.logLine && window.logLine('INFO', `[preview.plan.services] total=${svcKeys.length} entries=${svcKeys.slice(0,10).join(',')}${svcKeys.length>10?'...':''}`);
                    }
                } catch(e){}
                // Vulnerabilities breakdown
                try {
                    if(fp.vulnerabilities_plan){
                        const vp = fp.vulnerabilities_plan;
                        const totalV = Object.values(vp).reduce((a,b)=> a + (typeof b==='number'? b:0), 0);
                        window.logLine && window.logLine('INFO', `[preview.plan.vuln] total_items=${Object.keys(vp).length} total_alloc=${totalV}`);
                    }
                } catch(e){}
                // Segmentation breakdown
                try {
                    if(fp.segmentation_preview){
                        const rules = (fp.segmentation_preview.rules||[]).length;
                        window.logLine && window.logLine('INFO', `[preview.plan.segmentation] rules=${rules}`);
                    }
                } catch(e){}
                // Traffic breakdown
                try {
                    if(fp.traffic_summary){
                        const ts = fp.traffic_summary;
                        const flows = ts.total_flows || ts.flows || 'n/a';
                        window.logLine && window.logLine('INFO', `[preview.plan.traffic] flows=${flows}`);
                    }
                } catch(e){}
            } catch(e){ /* ignore logging issues */ }
            try { showFullPreviewModal(previewState.fullPreview); } catch(e){ console.warn('Modal render failed', e); }
            // Append to history
            try {
                const fp = previewState.fullPreview;
                previewState.fullPreviewHistory.push({
                    ts: Date.now(),
                    seed: fp.seed,
                    seed_generated: fp.seed_generated,
                    stats: {
                        routers: (fp.routers||[]).length,
                        hosts: (fp.hosts||[]).length,
                        switches: (fp.switches||[]).length,
                        r2r_edges: (fp.r2r_edges_preview||[]).length,
                        seg_rules: (fp.segmentation_preview && fp.segmentation_preview.rules ? fp.segmentation_preview.rules.length : 0)
                    },
                    preview: fp
                });
                saveFullPreviewHistory();
            } catch(e){}
        }
    } catch(e){ pre.textContent='Error: '+e; previewState.fullPreview=null; }
    btn.disabled = false; btn.textContent = btn.dataset.prevLabel || 'Full Preview';
}

function renderFullPreviewStructured(){
    const wrap = document.getElementById('fullPreviewStructured');
    if(!wrap) return;
    const full = previewState.fullPreview;
    if(!full){ wrap.classList.add('d-none'); return; }
    wrap.classList.remove('d-none');
    const tabsEl = document.getElementById('fullPreviewSectionTabs');
    const contentEl = document.getElementById('fullPreviewSectionContent');
    if(!tabsEl || !contentEl) return;
    const sections = [
        { id:'overview', label:'Overview' },
        { id:'routers', label:`Routers (${(full.routers||[]).length})` },
        { id:'hosts', label:`Hosts (${(full.hosts||[]).length})` },
        { id:'switches', label:`Switches (${(full.switches||[]).length})` },
        { id:'subnets', label:'Subnets' },
        { id:'r2r', label:`R2R Edges (${(full.r2r_edges_preview||[]).length})` },
        { id:'seg', label:`Seg Rules (${(full.segmentation_preview && full.segmentation_preview.rules ? full.segmentation_preview.rules.length : 0)})` },
        { id:'services_bd', label:'Services Plan' },
        { id:'vuln_bd', label:'Vuln Plan' },
        { id:'seg_bd', label:'Seg Plan' },
        { id:'router_bd', label:'Router Plan' },
        { id:'traffic_bd', label:'Traffic Plan' },
        { id:'history', label:'History' },
    ];
    // Build tabs
    tabsEl.innerHTML = '';
    sections.forEach((s, idx) => {
        const b = document.createElement('button');
        b.type='button'; b.className='btn btn-outline-primary' + (idx===0?' active':'');
        b.textContent = s.label;
        b.dataset.section = s.id;
        b.onclick = () => { tabsEl.querySelectorAll('button').forEach(x=>x.classList.remove('active')); b.classList.add('active'); renderSectionContent(s.id); };
        tabsEl.appendChild(b);
    });
    function esc(x){ return (''+x).replace(/[&<>]/g,c=>({'&':'&amp;','<':'&lt;','>':'&gt;'}[c])); }
    function renderSectionContent(id){
        if(id==='overview'){
            const stats = [
                ['Routers', (full.routers||[]).length],
                ['Hosts', (full.hosts||[]).length],
                ['Switches', (full.switches||[]).length],
                ['R2R Edges', (full.r2r_edges_preview||[]).length],
                ['Avg R2R Deg', full.r2r_stats_preview && full.r2r_stats_preview.avg],
                ['Seg Rules', full.segmentation_preview && full.segmentation_preview.rules ? full.segmentation_preview.rules.length : 0],
                ['P2P /30', (full.ptp_subnets||[]).length],
                ['Router-Sw /30', (full.router_switch_subnets||[]).length],
                ['LAN /28', (full.lan_subnets||[]).length],
                // Seed removed from UI summary
            ];
            contentEl.innerHTML = '<div class="row g-2">' + stats.map(s=>`<div class="col-auto"><span class="badge text-bg-secondary">${esc(s[0])}: ${esc(s[1]??'-')}</span></div>`).join('') + '</div>';
            return;
        }
        if(id==='routers'){
            contentEl.innerHTML = tableFromObjects(full.routers || [], ['node_id','name','ip4']); return;
        }
        if(id==='hosts'){
            contentEl.innerHTML = tableFromObjects(full.hosts || [], ['node_id','name','role','ip4']); return;
        }
        if(id==='switches'){
            const rows = full.switches_detail || [];
            contentEl.innerHTML = tableFromObjects(rows, ['switch_id','router_id','hosts','rsw_subnet','lan_subnet']); return;
        }
        if(id==='subnets'){
            const p2p = (full.ptp_subnets||[]).map(s=>`<li>${esc(s)}</li>`).join('');
            const rs = (full.router_switch_subnets||[]).map(s=>`<li>${esc(s)}</li>`).join('');
            const lan = (full.lan_subnets||[]).map(s=>`<li>${esc(s)}</li>`).join('');
            contentEl.innerHTML = `<div class="row small g-3"><div class="col"><h6 class="fw-bold">Host P2P (/30)</h6><ul class="mb-0">${p2p||'<li>(none)</li>'}</ul></div><div class="col"><h6 class="fw-bold">Router-Switch (/30)</h6><ul class="mb-0">${rs||'<li>(none)</li>'}</ul></div><div class="col"><h6 class="fw-bold">LAN (/28)</h6><ul class="mb-0">${lan||'<li>(none)</li>'}</ul></div></div>`; return;
        }
        if(id==='r2r'){
            const edges = full.r2r_edges_preview || [];
            const deg = full.r2r_degree_preview || {};
            const degList = Object.entries(deg).map(([k,v])=>`r${k}:${v}`).join(', ');
            const spark = Object.values(deg).join(' ');
            const edgesSample = edges.slice(0,200).map(e=>`(${e[0]}-${e[1]})`).join(' ');
            contentEl.innerHTML = `<div><div class="mb-2"><strong>Degree Stats:</strong> ${esc(JSON.stringify(full.r2r_stats_preview||{}))}</div><div class="mb-2"><strong>Degrees:</strong> ${esc(degList||'(none)')}</div><div class="mb-2"><strong>Edges (${edges.length}):</strong> ${esc(edgesSample||'(none)')} ${edges.length>200?'...':''}</div><div><strong>Spark:</strong> ${esc(spark)}</div></div>`; return;
        }
        if(id==='seg'){
            const artifacts = buildFullPreviewArtifacts(full);
            const segRows = (artifacts && artifacts.segmentation && artifacts.segmentation.rows) || [];
            contentEl.innerHTML = tableFromObjects(segRows, ['node_id','type','summary']);
            return;
        }
        if(id==='router_bd'){
            const rp = (full.router_plan)||{};
            contentEl.innerHTML = `<pre class="small mb-0">${esc(JSON.stringify(rp,null,2))}</pre>`; return;
        }
        if(id==='services_bd'){
            const sp = (full.services_plan)||{};
            contentEl.innerHTML = `<pre class="small mb-0">${esc(JSON.stringify(sp,null,2))}</pre>`; return;
        }
        if(id==='vuln_bd'){
            const vp = (full.vulnerabilities_plan)||{};
            contentEl.innerHTML = `<pre class="small mb-0">${esc(JSON.stringify(vp,null,2))}</pre>`; return;
        }
        if(id==='seg_bd'){
            const sb = (full.segmentation_preview)||{};
            contentEl.innerHTML = `<pre class="small mb-0">${esc(JSON.stringify(sb,null,2))}</pre>`; return;
        }
        if(id==='traffic_bd'){
            const tp = (full.traffic_summary)||{};
            contentEl.innerHTML = `<pre class="small mb-0">${esc(JSON.stringify(tp,null,2))}</pre>`; return;
        }
        if(id==='history'){
            renderPreviewHistory(contentEl, full);
            return;
        }
        contentEl.textContent='Unknown section';
    }
    function tableFromObjects(arr, cols){
        if(!arr.length) return '<div class="text-muted fst-italic">(none)</div>';
        const head = '<thead><tr>' + cols.map(c=>`<th>${esc(c)}</th>`).join('') + '</tr></thead>';
        const body = '<tbody>' + arr.map(o=>'<tr>'+cols.map(c=>`<td>${esc((o[c]!==undefined && o[c]!==null)? (Array.isArray(o[c])? o[c].join(','): o[c]): '')}</td>`).join('')+'</tr>').join('') + '</tbody>';
        return `<div class="table-responsive"><table class="table table-sm table-bordered mb-0">${head}${body}</table></div>`;
    }
    // Initial load
    renderSectionContent('overview');
    // Wire toggle button
    const toggleBtn = document.getElementById('toggleRawFullPreviewBtn');
    if(toggleBtn){
        toggleBtn.onclick = () => {
            const raw = document.getElementById('planPreviewJson');
            const struct = document.getElementById('fullPreviewStructured');
            if(raw.classList.contains('d-none')){ raw.classList.remove('d-none'); toggleBtn.textContent='Structured'; }
            else { raw.classList.add('d-none'); toggleBtn.textContent='Raw JSON'; }
        };
    }
    // Seed copy button removed
}

function renderPreviewHistory(contentEl, currentFull){
    loadFullPreviewHistory();
    if(!previewState.fullPreviewHistory.length){ contentEl.innerHTML = '<div class="text-muted fst-italic">No previous full previews</div>'; return; }
    function esc(x){ return (''+x).replace(/[&<>]/g,c=>({'&':'&amp;','<':'&lt;','>':'&gt;'}[c])); }
    const rows = previewState.fullPreviewHistory.slice().reverse().map((rec,idx) => {
        const dt = new Date(rec.ts).toLocaleTimeString();
        const diffBtn = `<button class="btn btn-sm btn-outline-primary" data-action="diff" data-seed="${esc(rec.seed)}">Diff</button>`;
        return `<tr><td>${idx+1}</td><td>${esc(rec.seed)}</td><td>${esc(rec.stats.routers)}/${esc(rec.stats.hosts)}/${esc(rec.stats.switches)}</td><td>${esc(rec.stats.r2r_edges)}</td><td>${esc(rec.stats.seg_rules)}</td><td>${dt}</td><td class="text-nowrap">${diffBtn}</td></tr>`;
    }).join('');
    contentEl.innerHTML = `<div class="table-responsive"><table class="table table-sm table-bordered mb-2"><thead><tr><th>#</th><th>Seed</th><th>R/H/S</th><th>R2R</th><th>Seg</th><th>Time</th><th></th></tr></thead><tbody>${rows}</tbody></table></div><div id="previewDiffOutput" class="small"></div>`;
    // Seed load buttons removed
    contentEl.querySelectorAll('button[data-action="diff"]').forEach(btn => {
        btn.addEventListener('click', () => { const seed = btn.getAttribute('data-seed'); const rec = previewState.fullPreviewHistory.find(r=> String(r.seed)===seed); if(!rec){ return; } const diffHtml = buildPreviewDiff(rec.preview, currentFull); document.getElementById('previewDiffOutput').innerHTML = diffHtml; });
    });
}

function buildPreviewDiff(a,b){
    const metrics = [
        ['Routers', (a.routers||[]).length, (b.routers||[]).length],
        ['Hosts', (a.hosts||[]).length, (b.hosts||[]).length],
        ['Switches', (a.switches||[]).length, (b.switches||[]).length],
        ['R2R Edges', (a.r2r_edges_preview||[]).length, (b.r2r_edges_preview||[]).length],
        ['Seg Rules', (a.segmentation_preview && a.segmentation_preview.rules ? a.segmentation_preview.rules.length : 0), (b.segmentation_preview && b.segmentation_preview.rules ? b.segmentation_preview.rules.length : 0)]
    ];
    function esc(x){ return (''+x).replace(/[&<>]/g,c=>({'&':'&amp;','<':'&lt;','>':'&gt;'}[c])); }
    const rows = metrics.map(m => { const delta = m[2]-m[1]; const cls = delta===0?'text-secondary':(delta>0?'text-success':'text-danger'); return `<tr><td>${esc(m[0])}</td><td>${esc(m[1])}</td><td>${esc(m[2])}</td><td class="${cls}">${delta>0?'+':''}${esc(delta)}</td></tr>`; }).join('');
    return `<div class="card border-info"><div class="card-header py-1 small">Diff vs current preview</div><div class="card-body p-2"><div class="table-responsive"><table class="table table-sm table-bordered mb-0"><thead><tr><th>Metric</th><th>Old</th><th>Current</th><th>Δ</th></tr></thead><tbody>${rows}</tbody></table></div></div></div>`;
}

// ---------- Full Preview Modal Rendering ----------
function showFullPreviewModal(full){
    if(!full) return;
    const modalEl = document.getElementById('fullPreviewModal');
    if(!modalEl) return;
    document.getElementById('fpModalSeed').textContent = `seed=${full.seed}`;
    // Counts
    const countsEl = document.getElementById('fpCounts');
    const stats = [
        ['Routers',(full.routers||[]).length],
        ['Hosts',(full.hosts||[]).length],
        ['Switches',(full.switches||[]).length],
        ['R2R Edges',(full.r2r_edges_preview||[]).length],
        ['Seg Rules', (full.segmentation_preview && full.segmentation_preview.rules ? full.segmentation_preview.rules.length:0)],
        ['P2P /30',(full.ptp_subnets||[]).length],
        ['R-Sw /30',(full.router_switch_subnets||[]).length],
        ['LAN /28',(full.lan_subnets||[]).length],
    ];
    countsEl.innerHTML = '<div class="row g-1">' + stats.map(s=>`<div class="col-auto"><span class="badge text-bg-secondary">${s[0]}: ${s[1]}</span></div>`).join('') + '</div>';
    // Policies & segmentation
    function setJson(id, obj){ const el=document.getElementById(id); if(el) el.textContent = JSON.stringify(obj||{}, null, 2); }
    setJson('fpR2RPolicy', full.r2r_policy_preview);
    setJson('fpR2SPolicy', full.r2s_policy_preview);
    // Render segmentation plan using shared artifacts so modal and structured views match
    (function(){
        const segEl = document.getElementById('fpSegmentation');
        if(!segEl) return;
        const typesEl = document.getElementById('fpSegmentationTypes');
        const runtimeWrap = document.getElementById('fpSegmentationRuntimeWrap');
        const runtimeEl = document.getElementById('fpSegmentationRuntime');
        const hashEl = document.getElementById('fpSegmentationHash');
        const artifacts = buildFullPreviewArtifacts(full) || {};
        const segArtifacts = artifacts.segmentation || null;
        const segJson = segArtifacts && segArtifacts.json;
        const hasRules = !!(segJson && typeof segJson === 'object' && segJson.rules_count > 0);
        if(hasRules){
            try {
                segEl.textContent = JSON.stringify(segJson, null, 2);
            } catch(e){
                segEl.textContent = '[error rendering segmentation plan JSON]';
            }
        } else {
            segEl.textContent = '(no segmentation plan rules)';
        }
        if(typesEl){
            typesEl.innerHTML = '';
            const typesSummary = hasRules ? (segJson.types_summary || {}) : {};
            const entries = Object.entries(typesSummary).filter(([, count]) => count !== undefined && count !== null);
            if(entries.length){
                typesEl.hidden = false;
                entries.forEach(([type, count]) => {
                    const badge = document.createElement('span');
                    badge.className = 'badge text-bg-light border me-1';
                    badge.textContent = `${type}: ${count}`;
                    typesEl.appendChild(badge);
                });
            } else {
                typesEl.hidden = true;
            }
        }
        const segPreview = (full && full.segmentation_preview) || {};
        const runtimeSummary = segPreview && segPreview.runtime_summary;
        if(runtimeWrap){
            if(runtimeSummary){
                runtimeWrap.hidden = false;
                if(runtimeEl){
                    try {
                        runtimeEl.textContent = JSON.stringify(runtimeSummary, null, 2);
                    } catch(e){
                        runtimeEl.textContent = '[error rendering runtime segmentation summary]';
                    }
                }
            } else {
                runtimeWrap.hidden = true;
                if(runtimeEl){ runtimeEl.textContent = ''; }
            }
        }
        if(hashEl){
            const hashVal = segPreview && segPreview.scripts_hash_sha256;
            if(hashVal){
                hashEl.hidden = false;
                hashEl.textContent = `Scripts Hash (SHA-256): ${hashVal}`;
            } else {
                hashEl.hidden = true;
                hashEl.textContent = '';
            }
        }
    })();
    // Breakdown plans
    try { setJson('fpRouterPlan', full.router_plan); } catch(e){}
    try { setJson('fpServicesPlan', full.services_plan); } catch(e){}
    try { setJson('fpVulnPlan', full.vulnerabilities_plan); } catch(e){}
    try { setJson('fpTrafficPlan', full.traffic_summary || full.traffic_plan || {}); } catch(e){}
    // Tables
    function tableHtml(arr, cols){ if(!arr||!arr.length) return '<div class="text-muted small">(none)</div>'; const head='<thead><tr>'+cols.map(c=>`<th>${c}</th>`).join('')+'</tr></thead>'; const body='<tbody>'+arr.map(o=>'<tr>'+cols.map(c=>`<td>${(o[c]!==undefined&&o[c]!==null)? (Array.isArray(o[c])? o[c].join(','): o[c]): ''}</td>`).join('')+'</tr>').join('')+'</tbody>'; return `<div class="table-responsive"><table class="table table-sm table-bordered mb-0">${head}${body}</table></div>`; }
    function summarizeRouterInterfaces(full){
        const routers = full.routers || [];
        if(!routers.length) return [];
        const r2rLinks = full.r2r_links_preview || [];
        const switches = full.switches_detail || [];
        const r2rMap = {};
        r2rLinks.forEach(link => {
            const routersList = link.routers || [];
            if(routersList.length < 2) return;
            const subnet = link.subnet || '';
            const [ra, rb] = routersList;
            const entryA = `r${rb.id ?? '?'}: ${(ra.ip || '-')}${subnet ? ` [${subnet}]` : ''}`;
            const entryB = `r${ra.id ?? '?'}: ${(rb.ip || '-')}${subnet ? ` [${subnet}]` : ''}`;
            if(ra && ra.id !== undefined){
                const listA = r2rMap[ra.id] || (r2rMap[ra.id] = []);
                listA.push(entryA);
            }
            if(rb && rb.id !== undefined){
                const listB = r2rMap[rb.id] || (r2rMap[rb.id] = []);
                listB.push(entryB);
            }
        });
        const switchMap = {};
        switches.forEach(sw => {
            if(sw.router_id === undefined) return;
            const label = `sw-${sw.switch_id ?? '?'}: ${(sw.router_ip || '-')}${sw.rsw_subnet ? ` [${sw.rsw_subnet}]` : ''}`;
            const list = switchMap[sw.router_id] || (switchMap[sw.router_id] = []);
            list.push(label);
        });
        return routers.map(r => {
            const r2rList = (r2rMap[r.node_id] || []).slice().sort();
            const swList = (switchMap[r.node_id] || []).slice().sort();
            return {
                'ID': r.node_id,
                'Name': r.name || `r${r.node_id}`,
                'Primary IP': r.ip4 || '-',
                'R2R Interfaces': r2rList.length ? r2rList.join('; ') : '-',
                'Switch Links': swList.length ? swList.join('; ') : '-',
            };
        });
    }
    const routersWrap = document.getElementById('fpRoutersWrap'); if(routersWrap) routersWrap.innerHTML = tableHtml(summarizeRouterInterfaces(full),['ID','Name','Primary IP','R2R Interfaces','Switch Links']);
    const hostsWrap = document.getElementById('fpHostsWrap'); if(hostsWrap) hostsWrap.innerHTML = tableHtml(full.hosts,['node_id','name','role','ip4']);
    const switchesWrap = document.getElementById('fpSwitchesWrap'); if(switchesWrap) switchesWrap.innerHTML = tableHtml(full.switches_detail,['switch_id','router_id','hosts','rsw_subnet','lan_subnet']);
    // Graph
    buildFullPreviewModalGraph(full);
    setupPreviewCollapsers();
    try { buildNodeSectionsTable(full); } catch(e){ console.warn('Node sections table failed', e); }
        // Removed history, role distribution, service distribution
    // Approval & drift removed
    document.getElementById('fpExportJsonBtn')?.addEventListener('click', ()=>{ try { const blob=new Blob([JSON.stringify(full,null,2)],{type:'application/json'}); const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download='full_preview_seed_'+(full.seed||'na')+'.json'; document.body.appendChild(a); a.click(); a.remove(); setTimeout(()=>URL.revokeObjectURL(a.href),4000);} catch(e){} });
    // Open standalone full preview page via POST (original GET caused 405 Method Not Allowed)
    document.getElementById('fpOpenStandaloneBtn')?.addEventListener('click', ()=>{
        const xmlPath = state.result_path || '';
        if(!xmlPath.endsWith('.xml')){ alert('Save XML first to open standalone preview.'); return; }
        const scen = state.scenarios && state.scenarios[activeIdx] ? state.scenarios[activeIdx].name : '';
        const form = document.createElement('form');
        form.method='POST';
        form.action='/plan/full_preview_page';
        form.target='_blank';
        const inXml = document.createElement('input'); inXml.type='hidden'; inXml.name='xml_path'; inXml.value=xmlPath; form.appendChild(inXml);
        if(scen){ const inSc = document.createElement('input'); inSc.type='hidden'; inSc.name='scenario'; inSc.value=scen; form.appendChild(inSc); }
        if(full && full.seed){ const inSeed=document.createElement('input'); inSeed.type='hidden'; inSeed.name='seed'; inSeed.value=full.seed; form.appendChild(inSeed); }
        document.body.appendChild(form);
        form.submit();
        setTimeout(()=>{ try { form.remove(); } catch(e){} }, 1000);
    });
    (new bootstrap.Modal(modalEl)).show();
}

// Removed history and distribution functions

// Drift function removed

function normalizeVulnerabilitiesByNode(source){
    const out = {};
    if(!source) return out;
    Object.entries(source).forEach(([key, value])=>{
        if(key === '__density_pool__') return;
        if(Array.isArray(value)){
            out[String(key)] = value;
            const numericKey = Number(key);
            if(Number.isFinite(numericKey)){
                out[numericKey] = value;
            }
        }
    });
    return out;
}

function buildFullPreviewModalGraph(full){
    const labelToggle = document.getElementById('fpGraphLabelsToggle');
    const labelStateKey = 'coretg_graph_labels_state';
    if(labelToggle && !labelToggle.dataset.initialized){
        try {
            const saved = sessionStorage.getItem(labelStateKey);
            if(saved){
                labelToggle.checked = saved === 'on';
                labelToggle.dataset.graphLabelsState = saved;
            }
        } catch(e){}
        labelToggle.dataset.initialized = '1';
    }
    const shouldShowLabels = !!(labelToggle && labelToggle.checked);
    if(labelToggle){
        labelToggle.dataset.graphLabelsState = shouldShowLabels ? 'on' : 'off';
    }
    if(!window.d3){ const g=document.getElementById('fpGraphLoading'); if(g) g.textContent='d3 not loaded'; return; }
    const container = d3.select('#fpGraph');
    container.selectAll('*').remove();
    const w = container.node().clientWidth || 800; const h = container.node().clientHeight || 480;
    const svg = container.append('svg').attr('width', w).attr('height', h).style('cursor','grab');
    const zoomLayer = svg.append('g').attr('class','zoom-layer');
    let currentTransform = d3.zoomIdentity;
    const zoom = d3.zoom().scaleExtent([0.2,4]).on('zoom', (ev)=>{
        currentTransform = ev.transform; zoomLayer.attr('transform', currentTransform);
    });
    svg.call(zoom).on('dblclick.zoom', null);
        const vulnerabilitiesByNode = normalizeVulnerabilitiesByNode(full.vulnerabilities_by_node);
    const nodes=[];
    const nodeById = new Map();
    const hitlPreview = deriveHitlPreviewArtifacts(full);
        const baseCluster = full.base_bridge_preview && full.base_bridge_preview.attached ? (full.base_bridge_preview.target_cluster || null) : null;
        const baseClusterNodeMap = new Map();
        const baseBridgeInfo = full.base_bridge_preview && full.base_bridge_preview.attached ? full.base_bridge_preview : null;
        const legend = svg.append('g').attr('class','legend').attr('transform','translate(8,8)');
        let legendOffset = 0;
        const legendTypesSeen = new Set();
        let legendSpacingAdded = false;

        const ensureLegendEntry = (canonicalType) => {
            if(!canonicalType || legendTypesSeen.has(canonicalType)) return;
            legendTypesSeen.add(canonicalType);
            const style = nodeStyleForType(canonicalType);
            const radius = Math.max(4, Math.min((style.radius ?? 6), 12));
            const entry = legend.append('g').attr('transform', `translate(0,${legendOffset})`);
            if (style.shape === 'square') {
                const side = radius * 2;
                entry.append('rect')
                    .attr('x', 0)
                    .attr('y', 0)
                    .attr('width', side)
                    .attr('height', side)
                    .attr('fill', style.color)
                    .attr('stroke', '#333')
                    .attr('stroke-width', 1);
            } else {
                entry.append('circle')
                    .attr('r', radius)
                    .attr('cx', radius)
                    .attr('cy', radius)
                    .attr('fill', style.color)
                    .attr('stroke', '#333')
                    .attr('stroke-width', 1);
            }
            entry.append('text')
                .text(style.label)
                .attr('x', radius * 2 + 6)
                .attr('y', radius + 4)
                .attr('font-size', '11px');
            legendOffset += Math.max(radius * 2 + 6, 20);
        };

        const registerLegendForNodes = (list) => {
            if(!Array.isArray(list)) return;
            list.forEach(node => {
                if(!node) return;
                const canonical = canonicalNodeType(node.type ?? node.kind ?? node.role);
                if(node.type !== canonical) node.type = canonical;
                ensureLegendEntry(canonical);
            });
        };

        const addLegendSpacing = () => {
            if(!legendSpacingAdded && legendTypesSeen.size > 0){
                legendOffset += 6;
                legendSpacingAdded = true;
            }
        };
        function resolveBaseNodeType(meta){
            if(!meta || typeof meta !== 'object') return 'host';
            const raw = meta.type ?? meta.model ?? meta.kind ?? meta.role ?? '';
            return canonicalNodeType(raw);
        }
        const addNode = (node)=>{
            if(node==null || node.id===undefined || node.id===null) return;
            const key = String(node.id);
            const canonicalType = canonicalNodeType(node.type ?? node.kind ?? node.role);
            const normalized = { ...node, type: canonicalType };
            if(nodeById.has(key)){
                Object.assign(nodeById.get(key), normalized);
                return;
            }
            nodeById.set(key, normalized);
            nodes.push(normalized);
        };
        const bridgeRouterIdNum = baseBridgeInfo ? Number(baseBridgeInfo.bridge_router_id) : null;
        (full.routers||[]).forEach(r=>{
            if(r==null || r.node_id===undefined || r.node_id===null) return;
            const routerIdNum = Number(r.node_id);
            const isBridgeRouter = Number.isFinite(bridgeRouterIdNum) && routerIdNum === bridgeRouterIdNum;
            addNode({id:r.node_id, label:r.name, type:'router', isBaseBridge: isBridgeRouter});
        });
        (full.hosts||[]).forEach(hn=>{
            if(hn==null) return;
            const hostId = hn.node_id;
            if(hostId===undefined || hostId===null) return;
            const keyStr = String(hostId);
            const assignment = Array.isArray(hn.vulnerabilities) ? hn.vulnerabilities : vulnerabilitiesByNode[keyStr] || vulnerabilitiesByNode[hostId] || [];
            const vulnList = Array.isArray(assignment) ? assignment : [];
            const hasVuln = vulnList.length > 0;
            addNode({id:hostId, label:hn.name, type:'host', hasVuln: hasVuln, vulnerabilities: vulnList});
        });
        (full.switches_detail||[]).forEach(sw=>{
            if(sw==null) return;
            const switchId = sw.switch_id;
            if(switchId===undefined || switchId===null) return;
            addNode({id:switchId, label:'sw-'+switchId, type:'switch'});
        });
    const bridgePeerIdNum = baseBridgeInfo ? Number(baseBridgeInfo.internal_peer_router_id) : null;
        const baseBridgeKeys = new Set();
        if(Number.isFinite(bridgeRouterIdNum) && Number.isFinite(bridgePeerIdNum)){
            baseBridgeKeys.add(`${Math.min(bridgeRouterIdNum, bridgePeerIdNum)}-${Math.max(bridgeRouterIdNum, bridgePeerIdNum)}`);
        }

        const linkDescriptors=[];
        (full.r2r_edges_preview||[]).forEach(e=>{
            if(!Array.isArray(e) || e.length<2) return;
            const [a,b] = e;
            if(a===undefined || a===null || b===undefined || b===null) return;
            const key = `${Math.min(Number(a), Number(b))}-${Math.max(Number(a), Number(b))}`;
            const kind = baseBridgeKeys.has(key) ? 'base-bridge' : 'r2r';
            linkDescriptors.push({sourceId:a, targetId:b, kind});
        });
        (full.switches_detail||[]).forEach(sw=>{
            if(sw==null) return;
            const switchId = sw.switch_id;
            const routerId = sw.router_id;
            if(switchId===undefined || switchId===null || routerId===undefined || routerId===null) return;
            (sw.hosts||[]).forEach(hid=>{
                if(hid===undefined || hid===null) return;
                linkDescriptors.push({sourceId:switchId, targetId:hid, kind:'sw-host'});
            });
            linkDescriptors.push({sourceId:routerId, targetId:switchId, kind:'r-sw'});
        });
        const hr = full.host_router_map || {};
        Object.entries(hr).forEach(([hid,rid])=>{
            if(hid===undefined || hid===null) return;
            const hIdNum = Number.isFinite(Number(hid)) ? Number(hid) : parseInt(hid, 10);
            const hostId = Number.isFinite(hIdNum) ? hIdNum : hid;
            if(hostId===undefined || hostId===null) return;
            const hasSwitchLink = linkDescriptors.find(l=>l.kind==='sw-host' && String(l.targetId)===String(hostId));
            if(hasSwitchLink) return;
            const routerCandidate = (typeof rid === 'number' && Number.isFinite(rid)) ? rid : parseInt(rid,10);
            const routerId = Number.isFinite(routerCandidate) ? routerCandidate : rid;
            if(routerId===undefined || routerId===null) return;
            linkDescriptors.push({sourceId:routerId, targetId:hostId, kind:'r-host'});
        });

        const ensureNodeForLink = (id, role)=>{
            if(id===undefined || id===null || (typeof id==='number' && Number.isNaN(id))) return;
            const key = String(id);
            if(nodeById.has(key)) return;
            const type = role==='router'? 'router' : role==='switch'? 'switch' : 'host';
            const labelBase = role==='router'? `router-${key}` : role==='switch'? `sw-${key}` : `host-${key}`;
            const fallback = { id, label: labelBase, type };
            if(type==='host'){
                fallback.hasVuln = false;
                fallback.vulnerabilities = [];
            }
            addNode(fallback);
        };
        linkDescriptors.forEach(link=>{
            if(!link) return;
            if(link.kind==='r2r'){
                ensureNodeForLink(link.sourceId, 'router');
                ensureNodeForLink(link.targetId, 'router');
            } else if(link.kind==='r-sw'){
                ensureNodeForLink(link.sourceId, 'router');
                ensureNodeForLink(link.targetId, 'switch');
            } else if(link.kind==='sw-host'){
                ensureNodeForLink(link.sourceId, 'switch');
                ensureNodeForLink(link.targetId, 'host');
            } else if(link.kind==='r-host'){
                ensureNodeForLink(link.sourceId, 'router');
                ensureNodeForLink(link.targetId, 'host');
            }
        });

        if(hitlPreview && Array.isArray(hitlPreview.nodes)){
            hitlPreview.nodes.forEach(node => {
                if(!node) return;
                const sourceId = node.id ?? node.node_id ?? null;
                if(sourceId !== null){
                    const key = String(sourceId);
                    if(nodeById.has(key)){
                        const existing = nodeById.get(key);
                        const mergeFieldWhenMissing = (field) => {
                            if(Object.prototype.hasOwnProperty.call(node, field)){
                                const value = node[field];
                                if(value !== undefined && value !== null && (existing[field] === undefined || existing[field] === null)){
                                    existing[field] = value;
                                }
                            }
                        };
                        mergeFieldWhenMissing('type');
                        mergeFieldWhenMissing('label');
                        mergeFieldWhenMissing('name');
                        mergeFieldWhenMissing('ip4');
                        mergeFieldWhenMissing('linkNetwork');
                        mergeFieldWhenMissing('prefixLen');
                        mergeFieldWhenMissing('netmask');
                        mergeFieldWhenMissing('peerRouterIp4');
                        mergeFieldWhenMissing('existingRouterIp4');
                        mergeFieldWhenMissing('broadcastIp4');
                        mergeFieldWhenMissing('attachment');
                        mergeFieldWhenMissing('assignment');
                        mergeFieldWhenMissing('hitlAttachment');
                        mergeFieldWhenMissing('hitlAssignment');
                        mergeFieldWhenMissing('hitlUplinkRouterId');
                        mergeFieldWhenMissing('uplinkRouterId');
                        if(node.hitlInterface && !existing.hitlInterface){
                            existing.hitlInterface = node.hitlInterface;
                        }
                        if(node.hitlLinkMeta && !existing.hitlLinkMeta){
                            existing.hitlLinkMeta = node.hitlLinkMeta;
                        }
                        if(Array.isArray(node.hitlSwitchInterfaces) && node.hitlSwitchInterfaces.length){
                            if(!Array.isArray(existing.hitlSwitchInterfaces)){
                                existing.hitlSwitchInterfaces = node.hitlSwitchInterfaces.slice();
                            } else {
                                const seenKeys = new Set(existing.hitlSwitchInterfaces.map(entry => {
                                    if(!entry) return '';
                                    return entry.switch_id !== undefined && entry.switch_id !== null
                                        ? String(entry.switch_id)
                                        : JSON.stringify(entry);
                                }));
                                node.hitlSwitchInterfaces.forEach(entry => {
                                    if(!entry) return;
                                    const keyEntry = entry.switch_id !== undefined && entry.switch_id !== null
                                        ? String(entry.switch_id)
                                        : JSON.stringify(entry);
                                    if(!seenKeys.has(keyEntry)){
                                        existing.hitlSwitchInterfaces.push(entry);
                                        seenKeys.add(keyEntry);
                                    }
                                });
                            }
                        }
                        if(node.isHitlRouter){
                            existing.isHitlRouter = true;
                        }
                        if(node.isHitl){
                            existing.isHitl = true;
                        }
                        if(node.hitlAttachment && !existing.hitlAttachment){
                            existing.hitlAttachment = node.hitlAttachment;
                        }
                        if(node.hitlAssignment && !existing.hitlAssignment){
                            existing.hitlAssignment = node.hitlAssignment;
                        }
                        if(node.hitlUplinkRouterId && !existing.hitlUplinkRouterId){
                            existing.hitlUplinkRouterId = node.hitlUplinkRouterId;
                        }
                        existing._hasHitlOverlay = true;
                        return;
                    }
                }
                const canonical = canonicalNodeType(node.type ?? node.kind ?? node.role);
                const clone = { ...node, type: canonical };
                const key = sourceId !== null ? String(sourceId) : (clone.id !== undefined && clone.id !== null ? String(clone.id) : null);
                if(key !== null){
                    nodeById.set(key, clone);
                }
                nodes.push(clone);
            });
        }

        const filteredLinks = linkDescriptors.filter(link=>{
            if(!link) return false;
            return nodeById.has(String(link.sourceId)) && nodeById.has(String(link.targetId));
        });

        if(hitlPreview && Array.isArray(hitlPreview.links)){
            hitlPreview.links.forEach(link=>{
                if(!link) return;
                if(!nodeById.has(String(link.sourceId)) || !nodeById.has(String(link.targetId))) return;
                filteredLinks.push({
                    sourceId: link.sourceId,
                    targetId: link.targetId,
                    kind: link.kind || 'hitl',
                    attachment: link.attachment || null,
                    assignment: link.assignment || null,
                });
            });
        }

        if(baseCluster && Array.isArray(baseCluster.nodes)){
            baseCluster.nodes.forEach((baseNodeMeta, idx)=>{
                if(!baseNodeMeta) return;
                const originalId = baseNodeMeta.id !== undefined && baseNodeMeta.id !== null ? String(baseNodeMeta.id) : `base-${idx}`;
                if(baseClusterNodeMap.has(originalId)) return;
                const nodeId = `base-cluster-${originalId}`;
                baseClusterNodeMap.set(originalId, nodeId);
                const clusterLabel = baseNodeMeta.name || `Base ${originalId}`;
                const clusterNode = {
                    id: nodeId,
                    name: clusterLabel,
                    label: clusterLabel,
                    type: resolveBaseNodeType(baseNodeMeta),
                    isBaseCluster: true,
                    isBase: true,
                    baseOriginal: baseNodeMeta,
                };
                if(baseNodeMeta.position && Number.isFinite(Number(baseNodeMeta.position.x)) && Number.isFinite(Number(baseNodeMeta.position.y))){
                    clusterNode._layout = { x: Number(baseNodeMeta.position.x), y: Number(baseNodeMeta.position.y) };
                }
                addNode(clusterNode);
            });
        }
        let baseAnchorId = null;
        const baseTargetMeta = full.base_bridge_preview && full.base_bridge_preview.attached ? (full.base_bridge_preview.target || null) : null;
        if(baseClusterNodeMap.size > 0){
            const targetKey = baseTargetMeta && baseTargetMeta.id !== undefined && baseTargetMeta.id !== null ? String(baseTargetMeta.id) : null;
            if(targetKey && baseClusterNodeMap.has(targetKey)){
                baseAnchorId = baseClusterNodeMap.get(targetKey);
            } else {
                baseAnchorId = baseClusterNodeMap.values().next().value;
            }
        } else if(baseTargetMeta){
            baseAnchorId = `base-target-${baseTargetMeta.id || 'base'}`;
            if(!nodeById.has(baseAnchorId)){
                const anchorLabel = baseTargetMeta.name || 'Base Scenario';
                const anchorNode = {
                    id: baseAnchorId,
                    name: anchorLabel,
                    label: anchorLabel,
                    type: resolveBaseNodeType(baseTargetMeta),
                    isBaseExternal: true,
                    isBase: true,
                    baseTarget: baseTargetMeta,
                };
                if(baseTargetMeta.position && Number.isFinite(Number(baseTargetMeta.position.x)) && Number.isFinite(Number(baseTargetMeta.position.y))){
                    anchorNode._layout = { x: Number(baseTargetMeta.position.x), y: Number(baseTargetMeta.position.y) };
                }
                addNode(anchorNode);
            }
        }
        if(baseCluster && Array.isArray(baseCluster.edges)){
            baseCluster.edges.forEach(edge=>{
                if(!Array.isArray(edge) || edge.length < 2) return;
                const aRaw = edge[0];
                const bRaw = edge[1];
                const keyA = aRaw !== undefined && aRaw !== null ? String(aRaw) : null;
                const keyB = bRaw !== undefined && bRaw !== null ? String(bRaw) : null;
                if(!keyA || !keyB) return;
                const mappedA = baseClusterNodeMap.get(keyA);
                const mappedB = baseClusterNodeMap.get(keyB);
                if(!mappedA || !mappedB) return;
                filteredLinks.push({ sourceId: mappedA, targetId: mappedB, kind: 'base-cluster' });
            });
        }
        const bridgeRouterId = baseBridgeInfo ? baseBridgeInfo.bridge_router_id : null;
        if(baseAnchorId && bridgeRouterId !== null){
            filteredLinks.push({ sourceId: bridgeRouterId, targetId: baseAnchorId, kind: 'base-external' });
        }

        if(nodes.length === 0){
            svg.remove();
            container.append('div').attr('class','text-muted small p-2').text('No nodes to display');
            document.getElementById('fpGraphLoading')?.remove();
            return;
        }

        registerLegendForNodes(nodes);
        addLegendSpacing();

        const layoutPositions = full.layout_positions;
        const layoutMaps = (layoutPositions && !layoutPositions.error && typeof layoutPositions === 'object')
            ? {
                    routers: layoutPositions.routers || {},
                    switches: layoutPositions.switches || {},
                    hosts: layoutPositions.hosts || {},
                }
            : null;
        function layoutCoordForNode(node){
            if(!layoutMaps) return null;
            let table = null;
            if(node.type==='router') table = layoutMaps.routers;
            else if(node.type==='switch') table = layoutMaps.switches;
            else if(node.isBase){
                if(node._layout) return node._layout;
                return null;
            }
            else table = layoutMaps.hosts;
            if(!table) return null;
            const key = String(node.id);
            const raw = table[key] || table[node.id];
            if(!raw) return null;
            const x = Number(raw.x);
            const y = Number(raw.y);
            if(Number.isFinite(x) && Number.isFinite(y)) return {x, y};
            return null;
        }
        const layoutCoords = [];
        if(layoutMaps){
            nodes.forEach(n=>{
                let pos = layoutCoordForNode(n);
                if(!pos && n.isBase && n._layout){
                    pos = n._layout;
                }
                if(pos){
                    n._layout = pos;
                    layoutCoords.push(pos);
                }
            });
        }
        const margin = 40;
        const innerWidth = Math.max(w - margin*2, 200);
        const innerHeight = Math.max(h - margin*2, 200);
        let usingLayout = layoutCoords.length > 0;
        const originalPositions = new Map();
    function applyRowJitter(list){
            const buckets = new Map();
            list.forEach(node=>{
                if(!Number.isFinite(node.y)) return;
        if(node.isBase) return;
                const base = node._layout ? node._layout.y : node.y;
                if(!Number.isFinite(base)) return;
                const key = Math.round(base * 1000);
                const bucket = buckets.get(key);
                if(bucket){
                    bucket.push(node);
                } else {
                    buckets.set(key, [node]);
                }
            });
            buckets.forEach(group=>{
                if(group.length <= 1) return;
                group.sort((a,b)=> String(a.id).localeCompare(String(b.id)));
                const mid = (group.length - 1) / 2;
                const spacing = 8;
                group.forEach((node, idx)=>{
                    node.y += (idx - mid) * spacing;
                });
            });
        }
        let scale = 1;
        let offsetX = margin;
        let offsetY = margin;
        if(usingLayout && layoutCoords.length){
            let minX = layoutCoords[0].x, maxX = layoutCoords[0].x;
            let minY = layoutCoords[0].y, maxY = layoutCoords[0].y;
            layoutCoords.forEach(c=>{ if(c.x<minX) minX=c.x; if(c.x>maxX) maxX=c.x; if(c.y<minY) minY=c.y; if(c.y>maxY) maxY=c.y; });
            const spanX = Math.max(1, maxX - minX);
            const spanY = Math.max(1, maxY - minY);
            scale = Math.min(innerWidth/spanX, innerHeight/spanY);
            if(!Number.isFinite(scale) || scale <= 0){
                scale = 1;
                usingLayout = false;
            } else {
                offsetX = margin + (innerWidth - spanX * scale) / 2 - minX * scale;
                offsetY = margin + (innerHeight - spanY * scale) / 2 - minY * scale;
            }
        }

        if(usingLayout){
            nodes.forEach(n=>{
                if(n._layout){
                    n.x = offsetX + n._layout.x * scale;
                    n.y = offsetY + n._layout.y * scale;
                } else {
                    n.x = w/2 + Math.random()*40 - 20;
                    n.y = h/2 + Math.random()*40 - 20;
                }
            });
            applyRowJitter(nodes);
            nodes.forEach(n=>{
                n.layoutX = n.x;
                n.layoutY = n.y;
                if(Number.isFinite(n.x) && Number.isFinite(n.y)){
                    originalPositions.set(n.id, { x: n.x, y: n.y });
                }
            });
        } else {
            nodes.forEach(n=>{
                n.x = w/2 + Math.random()*80 - 40;
                n.y = h/2 + Math.random()*80 - 40;
                n.layoutX = undefined;
                n.layoutY = undefined;
            });
        }

    const simLinks = filteredLinks.map(l=>({...l, source:l.sourceId, target:l.targetId}));

        const isHitlLink = (kind) => typeof kind === 'string' && kind.startsWith('hitl');
        const link = zoomLayer.selectAll('line').data(simLinks).enter().append('line')
            .attr('stroke', l=> {
                if(l.kind === 'base-bridge' || l.kind === 'base-external' || l.kind === 'base-cluster') return '#6f42c1';
                if(l.kind==='r2r') return '#0d6efd';
                if(isHitlLink(l.kind)) return '#20c997';
                return (l.kind==='r-sw'? '#198754':'#999');
            })
            .attr('stroke-width', l=> {
                if(l.kind === 'base-cluster') return 3;
                if(l.kind === 'base-bridge' || l.kind === 'base-external') return 4;
                if(isHitlLink(l.kind)) return 2.4;
                return l.kind==='r2r'? 2:1.2;
            })
            .attr('stroke-linecap', l=> (l.kind === 'base-bridge' || l.kind === 'base-external' || l.kind === 'base-cluster') ? 'round' : null)
            .attr('stroke-dasharray', l=> {
                if(l.kind==='r-host') return '3,3';
                if(isHitlLink(l.kind)) return '5,4';
                return null;
            })
            .attr('opacity', .9);
    const node = zoomLayer.selectAll('g').data(nodes).enter().append('g');
        const vulnerabilityColor = '#28a745';
        const hasVulnerableHosts = nodes.some(n => n.type === 'host' && n.hasVuln);
        const normalNode = node.filter(d => !(d.type === 'host' && d.hasVuln));
        normalNode.each(function(d){
            const nodeGroup = d3.select(this);
            const style = nodeStyleForType(d.type);
            if (style.shape === 'square') {
                const side = (Number.isFinite(style.radius) ? style.radius : 6) * 2;
                nodeGroup.append('rect')
                    .attr('x', -side / 2)
                    .attr('y', -side / 2)
                    .attr('width', side)
                    .attr('height', side)
                    .attr('rx', 2)
                    .attr('ry', 2)
                    .attr('fill', style.color)
                    .attr('stroke', (d.isBase || d.isBaseBridge) ? '#6f42c1' : '#333')
                    .attr('stroke-width', d.isBaseBridge ? 3 : d.isBase ? 2 : 1.1);
            } else {
                const radius = Number.isFinite(style.radius) ? style.radius : 6;
                nodeGroup.append('circle')
                    .attr('r', radius)
                    .attr('fill', style.color)
                    .attr('stroke', (d.isBase || d.isBaseBridge) ? '#6f42c1' : '#333')
                    .attr('stroke-width', d.isBaseBridge ? 3 : d.isBase ? 2 : 1.1);
            }
        });
        const vulnNode = node.filter(d => d.type === 'host' && d.hasVuln);
        const vulnSymbol = d3.symbol().type(d3.symbolStar).size(170);
        vulnNode.append('path')
            .attr('d', vulnSymbol)
            .attr('fill', vulnerabilityColor)
            .attr('stroke', '#333')
            .attr('stroke-width', 1.1);
        const labelGroups = node.append('g').attr('class', 'node-label-wrapper');

        const computeLabelWidth = (d) => {
            const text = d.label || d.name || String(d.id);
            return Math.max(24, (String(text).length * 6 + 6));
        };

        labelGroups.append('rect')
            .attr('class', 'node-label-bg')
            .attr('x', d => -computeLabelWidth(d) / 2)
            .attr('y', 10)
            .attr('width', d => computeLabelWidth(d))
            .attr('height', 16)
            .attr('rx', 3)
            .attr('ry', 3)
            .attr('fill', '#fff')
            .attr('stroke', '#bbb')
            .attr('stroke-width', 0.8)
            .attr('opacity', 0.88);

        labelGroups.append('text')
            .attr('class', 'node-label-text')
            .attr('text-anchor', 'middle')
            .attr('x', 0)
            .attr('y', 21)
            .attr('font-size', '10px')
            .attr('fill', '#212529')
            .text(d => d.label || d.name || String(d.id));

        const simulation = d3.forceSimulation(nodes)
            .force('link', d3.forceLink(simLinks).id(d=>d.id).distance(l=> {
                if(l.kind === 'base-cluster') return 60;
                if(l.kind === 'base-bridge' || l.kind === 'base-external') return 95;
                return l.kind==='r2r'? 80 : (l.kind==='r-sw'? 60 : 40);
            }).strength(l => l.kind === 'base-cluster' ? 0.9 : (l.kind === 'base-bridge' || l.kind === 'base-external' ? 0.7 : 0.6)))
            .force('charge', d3.forceManyBody().strength(d => d.isBase ? -160 : -220))
            .force('center', d3.forceCenter(w/2,h/2))
            .force('layoutX', d3.forceX(d => Number.isFinite(d.layoutX) ? d.layoutX : w/2).strength(usingLayout ? 0.2 : 0.04))
            .force('layoutY', d3.forceY(d => Number.isFinite(d.layoutY) ? d.layoutY : h/2).strength(usingLayout ? 0.2 : 0.04));

        simulation.alpha(1).alphaTarget(0.03).restart();

        link.data(simLinks, d=>`${d.source}-${d.target}`);

        simulation.on('tick', ()=>{
            link.attr('x1', d=>d.source.x).attr('y1', d=>d.source.y).attr('x2', d=>d.target.x).attr('y2', d=>d.target.y);
            node.attr('transform', d=>`translate(${d.x},${d.y})`);
        });

        node.call(d3.drag().on('start', dragstarted).on('drag', dragged).on('end', dragended));

        let sim = simulation;

        let resetStaticPositions = null;
        if(usingLayout){
            resetStaticPositions = () => {
                nodes.forEach(n => {
                    const orig = originalPositions.get(n.id);
                    if(orig){
                        n.layoutX = orig.x;
                        n.layoutY = orig.y;
                        n.x = orig.x;
                        n.y = orig.y;
                        n.vx = 0;
                        n.vy = 0;
                        n.fx = null;
                        n.fy = null;
                    }
                });
                simulation.alpha(0.55).restart();
            };
        }
    // Legend
    const hasBaseBridge = baseBridgeInfo && baseBridgeInfo.attached;
    if(hasBaseBridge){
        const g=legend.append('g').attr('transform',`translate(0,${legendOffset})`);
        g.append('line').attr('x1',0).attr('y1',8).attr('x2',24).attr('y2',8).attr('stroke','#6f42c1').attr('stroke-width',4).attr('stroke-linecap','round');
        g.append('text').text('Bridge to Base Scenario').attr('x',28).attr('y',12).attr('font-size','11px');
        legendOffset += 20;
    }
    if(hasVulnerableHosts){
        const g=legend.append('g').attr('transform',`translate(0,${legendOffset})`);
        const vulnLegendSymbol = d3.symbol().type(d3.symbolStar).size(80);
        g.append('path')
            .attr('d', vulnLegendSymbol)
            .attr('transform','translate(8,8)')
            .attr('fill', vulnerabilityColor)
            .attr('stroke','#333')
            .attr('stroke-width',1);
        g.append('text').text('Host (vulnerable)').attr('x', 20).attr('y', 12).attr('font-size','11px');
        legendOffset += 20;
    }
    // Node labels rendered conditionally (toggle in UI)
    // Build section lookups
    const servicesByNode = full.services_preview || {}; // node_id -> [services]
    const vulnByNode = vulnerabilitiesByNode; // node_id -> [vulns]
    const segRules = (full.segmentation_preview && full.segmentation_preview.rules) || [];
    const segCnt = {}; segRules.forEach(r=>{ segCnt[r.node_id] = (segCnt[r.node_id]||0)+1; });
    const traffic = full.traffic_summary || {};
    const tSend = {}; const tRecv = {};
    try { (traffic.flows || traffic || []).forEach(f=>{ const s=f.src_id??f.src; const d=f.dst_id??f.dst; if(s!==undefined) tSend[s]=(tSend[s]||0)+1; if(d!==undefined) tRecv[d]=(tRecv[d]||0)+1; }); } catch(e){}
    // Tooltip functionality removed per request
    function dragstarted(event,d){
        try { event.sourceEvent?.stopPropagation?.(); } catch(e){}
        if(sim && !event.active) sim.alphaTarget(.35).restart();
        d.fx=d.x; d.fy=d.y;
    }
    function dragged(event,d){ d.fx=event.x; d.fy=event.y; }
    function dragended(event,d){
        if(sim && !event.active) sim.alphaTarget(0.03);
        d.fx=d.x; d.fy=d.y;
        d.layoutX = d.x;
        d.layoutY = d.y;
    }
    document.getElementById('fpGraphLoading')?.remove();
    const resetBtn = document.getElementById('fpGraphResetBtn');
    if(resetBtn){
        resetBtn.addEventListener('click', ()=>{
            if(sim){
                sim.alpha(1).restart();
                nodes.forEach(n=>{ n.fx=null; n.fy=null; });
            }
            if(resetStaticPositions){
                resetStaticPositions();
            }
            svg.transition().duration(250).call(zoom.transform, d3.zoomIdentity);
        });
    }
    // Removed zoom hint tooltip
    svg.on('mousedown', ()=> svg.style('cursor','grabbing'));
    window.addEventListener('mouseup', ()=> svg.style('cursor','grab'));
    document.getElementById('fpGraphPngBtn')?.addEventListener('click', ()=>{ try { const serializer=new XMLSerializer(); const svgStr=serializer.serializeToString(svg.node()); const canvas=document.createElement('canvas'); canvas.width=w*2; canvas.height=h*2; const ctx=canvas.getContext('2d'); const img=new Image(); img.onload=function(){ ctx.fillStyle='#fff'; ctx.fillRect(0,0,canvas.width,canvas.height); ctx.drawImage(img,0,0,canvas.width,canvas.height); canvas.toBlob(b=>{ const a=document.createElement('a'); a.href=URL.createObjectURL(b); a.download='full_preview_graph_'+(full.seed||'na')+'.png'; document.body.appendChild(a); a.click(); a.remove(); setTimeout(()=>URL.revokeObjectURL(a.href),4000); }); }; img.src='data:image/svg+xml;base64,'+btoa(unescape(encodeURIComponent(svgStr))); } catch(e){ console.error('PNG export failed', e); } });

    container.node().dispatchEvent(new CustomEvent('coretg-graph-ready', {
        bubbles: true,
        detail: {
            target: '#fpGraph',
            showLabels: shouldShowLabels,
            svg: container.select('svg').node()
        }
    }));

    if(labelToggle && !labelToggle.dataset.bound){
        labelToggle.dataset.bound = '1';
        labelToggle.addEventListener('change', ()=>{
            const wrap = document.getElementById('fpGraph');
            const show = !!labelToggle.checked;
            labelToggle.dataset.graphLabelsState = show ? 'on' : 'off';
            try { sessionStorage.setItem(labelStateKey, show ? 'on' : 'off'); } catch(e){}
            if(wrap){
                wrap.dataset.showLabels = show ? 'on' : 'off';
                d3.select(wrap).selectAll('.node-label-wrapper').style('display', show ? null : 'none');
            }
            labelToggle.dispatchEvent(new CustomEvent('coretg-graph-label-toggle', {
                bubbles: true,
                detail: { target: '#fpGraph', show }
            }));
        });
    }

    if(labelToggle && labelToggle.dataset.bound && container.node()){
        container.node().dataset.showLabels = shouldShowLabels ? 'on' : 'off';
        container.selectAll('.node-label-wrapper').style('display', shouldShowLabels ? null : 'none');
        try { sessionStorage.setItem(labelStateKey, shouldShowLabels ? 'on' : 'off'); } catch(e){}
    }
}

function buildNodeSectionsTable(full){
    const wrap = document.getElementById('fpNodeSectionsWrap'); if(!wrap) return;
    const servicesByNode = full.services_preview || {};
    const vulnByNode = normalizeVulnerabilitiesByNode(full.vulnerabilities_by_node);
    const segRules = (full.segmentation_preview && full.segmentation_preview.rules) || [];
    const segCnt = {}; segRules.forEach(r=>{ segCnt[r.node_id]=(segCnt[r.node_id]||0)+1; });
    const traffic = full.traffic_summary || {};
    const tSend = {}; const tRecv = {};
    try { (traffic.flows || traffic || []).forEach(f=>{ const s=f.src_id??f.src; const d=f.dst_id??f.dst; if(s!==undefined) tSend[s]=(tSend[s]||0)+1; if(d!==undefined) tRecv[d]=(tRecv[d]||0)+1; }); } catch(e){}
    const all = [];
    const seenIds = new Set();
    const pushNode = (entry) => {
        if(!entry || entry.id === undefined || entry.id === null) return;
        const key = String(entry.id);
        if(seenIds.has(key)) return;
        seenIds.add(key);
        all.push(entry);
    };
    (full.routers||[]).forEach(r=> pushNode({id:r.node_id, name:r.name, type:'router'}));
    (full.hosts||[]).forEach(h=> pushNode({id:h.node_id, name:h.name, type:h.role||'host'}));
    (full.switches_detail||[]).forEach(sw=> pushNode({id:sw.switch_id, name:'sw-'+sw.switch_id, type:'switch'}));
    const hitlPreview = deriveHitlPreviewArtifacts(full);
    if(hitlPreview && Array.isArray(hitlPreview.nodes)){
        hitlPreview.nodes.forEach(node=>{
            if(!node) return;
            const canonical = canonicalNodeType(node.type || (node.isHitl ? 'rj45' : node.isHitlNetwork ? 'network' : 'host'));
            pushNode({
                id: node.id,
                name: node.label || node.name || String(node.id),
                type: canonical,
                hitlAttachment: node.attachment || (node.hitlInterface && node.hitlInterface.attachment) || null,
                hitlAssignment: node.assignment || null,
                hitlPeer: node.peerNodeId || null,
            });
        });
    }
    if(!all.length){ wrap.innerHTML='<div class="text-muted small">No nodes</div>'; return; }
    const rows = all.map(n=>{
        const svc=(servicesByNode[n.id]||[]).join(',');
        const vul=(vulnByNode[n.id]||[]).join(',');
        const sc=segCnt[n.id]||0; const ts=tSend[n.id]||0; const tr=tRecv[n.id]||0;
        let attachmentDisplay = '-';
        if(n.hitlAttachment){
            const baseLabel = prettyHitlAttachment(n.hitlAttachment);
            let assignmentLabel = '';
            if(n.hitlAssignment){
                if(HITL_ATTACHMENT_ALLOWED.has(n.hitlAssignment)){
                    assignmentLabel = prettyHitlAttachment(n.hitlAssignment);
                } else if(n.hitlAssignment === 'existing_host'){
                    assignmentLabel = 'Existing Host';
                } else if(n.hitlAssignment === 'network'){
                    assignmentLabel = 'Isolated Network';
                } else {
                    assignmentLabel = n.hitlAssignment.replace(/_/g, ' ');
                }
            }
            attachmentDisplay = assignmentLabel && assignmentLabel !== baseLabel
                ? `${baseLabel} → ${assignmentLabel}`
                : baseLabel;
        }
        return `<tr><td>${n.id}</td><td>${n.name ?? '-'}</td><td>${n.type || '-'}</td><td>${attachmentDisplay}</td><td>${svc}</td><td>${vul}</td><td>${sc}</td><td>${ts}</td><td>${tr}</td></tr>`;
    }).join('');
    wrap.innerHTML = `<div class='table-responsive'><table class='table table-sm table-bordered mb-0'><thead><tr><th>ID</th><th>Name</th><th>Type</th><th>HITL Attachment</th><th>Services</th><th>Vulns</th><th>Seg Rules</th><th>Traffic S</th><th>Traffic R</th></tr></thead><tbody>${rows}</tbody></table></div>`;
}

// Execute button in Full Preview modal
document.addEventListener('DOMContentLoaded', ()=>{
    const execBtn = document.getElementById('fpExecuteBtn');
    if(execBtn && !execBtn.dataset.boundExecute){
        execBtn.dataset.boundExecute = '1';
        let executing = false;
        const originalLabel = execBtn.textContent;
        const modalEl = document.getElementById('fullPreviewModal');
        const resolveModalInstance = () => {
            if(!modalEl || !window.bootstrap) return null;
            try {
                return bootstrap.Modal.getInstance(modalEl) || new bootstrap.Modal(modalEl);
            } catch(e){
                console.error('Failed to resolve full preview modal instance', e);
                return null;
            }
        };
        execBtn.addEventListener('click', async ()=>{
            if(executing) return;
            if(!state.result_path || !state.result_path.endsWith('.xml')){
                alert('Save XML before executing.');
                return;
            }
            const execInfo = detectLocalEmulation();
            const confirmMsg = execInfo.shouldFake
                ? 'Execute this scenario now?\n\nCORE not connected; will run with fake local emulation. Proceed?'
                : 'Execute this scenario now? This will start a CORE session.';
            if(!window.confirm(confirmMsg)) return;
            const modalInstance = resolveModalInstance();
            const forceHideModal = () => {
                try { modalInstance?.hide(); } catch(e){}
                if(modalEl){
                    modalEl.classList.remove('show');
                    modalEl.setAttribute('aria-hidden','true');
                    modalEl.style.display = 'none';
                }
                const openModals = document.querySelectorAll('.modal.show');
                if(openModals.length === 0){
                    document.querySelectorAll('.modal-backdrop').forEach(b => { try { b.remove(); } catch(e){} });
                    document.body.classList.remove('modal-open');
                    document.body.style.removeProperty('paddingRight');
                    document.body.style.removeProperty('overflow');
                }
            };
            const restoreModal = () => {
                try {
                    if(modalInstance){
                        modalInstance.show();
                    } else if(modalEl){
                        modalEl.style.display = 'block';
                        modalEl.classList.add('show');
                        document.body.classList.add('modal-open');
                    }
                } catch(e){}
            };
            const waitForPaint = async () => {
                await new Promise(resolve => requestAnimationFrame(() => resolve()));
            };
            executing = true;
            execBtn.disabled = true;
            execBtn.classList.add('disabled');
            if(originalLabel){ execBtn.textContent = 'Executing…'; }
            let runStarted = false;
            try {
                forceHideModal();
                await waitForPaint();
                openRunProgress('Executing scenario…');
                maybeShowLocalEmulationHint();
                try {
                    document.getElementById('runProgressStatus').textContent = 'Starting…';
                    document.getElementById('runProgressMeta').textContent = '';
                    const bar = document.getElementById('runProgressBar');
                    if(bar){ bar.classList.add('progress-bar-animated'); bar.textContent = 'Working…'; }
                } catch(e){}
                // Ensure dock visible
                try { const showBtn=document.getElementById('dockShowBtn'); if(showBtn && !showBtn.classList.contains('d-none')) showBtn.click(); } catch(e){}
                appendLog('--- Execute (Full Preview) start: '+state.result_path+' ---','info');
                const form = new FormData();
                form.append('xml_path', state.result_path);
                appendScenarioContextToFormData(form);
                try {
                    form.append('core_json', JSON.stringify(getCoreConfig(true)));
                } catch (err) {
                    form.append('core_json', '{}');
                }
                const res = await fetch("{{ url_for('run_cli_async') }}", { method: 'POST', body: form });
                if(!res.ok){
                    appendLog('Failed to start execution (HTTP '+res.status+')','error');
                    try {
                        const statusEl = document.getElementById('runProgressStatus');
                        if(statusEl) statusEl.textContent = 'Failed to start';
                        const metaEl = document.getElementById('runProgressMeta');
                        if(metaEl) metaEl.textContent = 'HTTP '+res.status;
                        const bar = document.getElementById('runProgressBar');
                        if(bar) bar.classList.remove('progress-bar-animated');
                    } catch(e){}
                    closeRunProgress();
                    restoreModal();
                    return;
                }
                const dataInit = await res.json();
                const run_id = dataInit.run_id;
                if(!run_id){
                    appendLog('Execution start response missing run_id','error');
                    try {
                        const statusEl = document.getElementById('runProgressStatus');
                        if(statusEl) statusEl.textContent = 'Failed to start';
                        const metaEl = document.getElementById('runProgressMeta');
                        if(metaEl) metaEl.textContent = 'Missing run id';
                        const bar = document.getElementById('runProgressBar');
                        if(bar) bar.classList.remove('progress-bar-animated');
                    } catch(e){}
                    closeRunProgress();
                    restoreModal();
                    return;
                }
                runStarted = true;
                appendLog('Run ID: '+run_id,'info');
                try {
                    const statusEl = document.getElementById('runProgressStatus');
                    if(statusEl) statusEl.textContent = 'Running…';
                    const metaEl = document.getElementById('runProgressMeta');
                    if(metaEl) metaEl.textContent = 'Streaming logs…';
                } catch(e){}
                runProgressRunId = run_id;
                try { if(runProgressEvtSrc) runProgressEvtSrc.close(); } catch(e){}
                runProgressEvtSrc = new EventSource('/stream/' + run_id);
                runProgressEvtSrc.onmessage = ev => {
                    if(ev && typeof ev.data === 'string') {
                        try {
                            runProgressLogLine(ev.data);
                        } catch(e) { /* swallow */ }
                    }
                };
                runProgressEvtSrc.addEventListener('end', ()=>{
                    try { runProgressEvtSrc?.close(); } catch(e){}
                    runProgressEvtSrc = null;
                    runProgressLogLine('Execution stream ended');
                });
                // Poll status until done
                (async function poll(){
                    try {
                        const r = await fetch('/run_status/' + run_id);
                        if(!r.ok){ setTimeout(poll, 1200); return; }
                        const st = await r.json();
                        if(!st.done){ setTimeout(poll, 1000); return; }
                        try {
                            const metaEl = document.getElementById('runProgressMeta');
                            if(metaEl) metaEl.textContent = st.returncode===0 ? 'Completed' : 'Finished';
                            const bar = document.getElementById('runProgressBar');
                            if(bar){ bar.classList.remove('progress-bar-animated'); bar.textContent = st.returncode===0 ? 'Done' : 'Error'; }
                        } catch(e){}
                        if(st.returncode===0){
                            appendLog('Execution complete: success; redirecting to Reports','info');
                            try {
                                const statusEl = document.getElementById('runProgressStatus');
                                if(statusEl) statusEl.textContent = 'Scenario started';
                            } catch(e){}
                            setTimeout(()=>{ window.location.href = "{{ url_for('reports_page') }}"; }, 700);
                        } else {
                            appendLog('Execution finished with errors (code '+st.returncode+')','error');
                            try {
                                const statusEl = document.getElementById('runProgressStatus');
                                if(statusEl) statusEl.textContent = 'Finished with errors';
                            } catch(e){}
                        }
                    } catch(e){ setTimeout(poll, 1500); }
                })();
            } catch(e){
                appendLog('Execution exception: '+e,'error');
                try {
                    const statusEl = document.getElementById('runProgressStatus');
                    if(statusEl) statusEl.textContent = 'Exception starting run';
                    const metaEl = document.getElementById('runProgressMeta');
                    if(metaEl) metaEl.textContent = '';
                    const bar = document.getElementById('runProgressBar');
                    if(bar) bar.classList.remove('progress-bar-animated');
                } catch(_){}
                if(!runStarted){
                    closeRunProgress();
                    restoreModal();
                }
            }
            finally {
                execBtn.disabled = false;
                execBtn.classList.remove('disabled');
                if(originalLabel){ execBtn.textContent = originalLabel; }
                executing = false;
            }
        });
    }
});

// Seed clear button
document.addEventListener('DOMContentLoaded', () => {
  const scb = document.getElementById('seedClearBtn');
    // seed clear button removed
});

// ------------- Auto-Save Support for Planning -------------
async function autoSaveXml(){
    return new Promise((resolve, reject) => {
        try {
            // Mirror logic from manual Save XML submission but use fetch
            const scenariosJsonInput = document.getElementById('scenarios_json');
            if(!scenariosJsonInput){ reject('Editor form missing'); return; }
            try { scenariosJsonInput.value = JSON.stringify({ scenarios: state.scenarios, active_index: activeIdx }); } catch(e){ reject('Serialize failed'); return; }
            const coreJsonInput = document.getElementById('core_json');
            if (coreJsonInput) {
                coreJsonInput.value = JSON.stringify(getCoreConfig(true));
            }
            const formData = new FormData();
            formData.append('scenarios_json', scenariosJsonInput.value);
            if (coreJsonInput) {
                formData.append('core_json', coreJsonInput.value);
            }
            fetch('/save_xml', { method:'POST', body: formData })
                .then(r=>r.text())
                .then(html => {
                    // Parse returned HTML for updated payload JSON script tag
                    try {
                        const parser = new DOMParser();
                        const doc = parser.parseFromString(html, 'text/html');
                        const payloadScript = doc.querySelector('#payload-data');
                        if(payloadScript){
                            const newPayload = JSON.parse(payloadScript.textContent || 'null');
                            if(newPayload){
                                if (newPayload.core) {
                                    state.core = normalizeCoreState(newPayload.core, true);
                                    storeCorePasswordInSession();
                                }
                                if(newPayload.result_path){
                                state.result_path = newPayload.result_path;
                                try { const persisted = JSON.parse(localStorage.getItem('coretg_editor_state')||'{}'); persisted.result_path = state.result_path; localStorage.setItem('coretg_editor_state', JSON.stringify(persisted)); } catch(e){}
                                previewState.xmlSaved = true;
                                updatePlanButtons();
                                resolve();
                                return;
                            }
                        }
                        }
                        reject('Could not detect saved XML path in response');
                    } catch(e){ reject(e); }
                })
                .catch(err => reject(err));
        } catch(e){ reject(e); }
    });
}

state.core = restoreCorePasswordFromSession(state.core);
if (persistedState && persistedState.core) {
    const persistedCore = normalizeCoreState(persistedState.core, false);
    state.core = {
        ...state.core,
        ...persistedCore,
    };
    state.core = restoreCorePasswordFromSession(state.core);
}
if (!state.core) {
    state.core = restoreCorePasswordFromSession({});
}
if (persistedState) {
    if (persistedState.core_ok !== undefined) state.core_ok = persistedState.core_ok;
    if (persistedState.core_tested_host !== undefined) state.core_tested_host = persistedState.core_tested_host;
    if (persistedState.core_tested_port !== undefined) state.core_tested_port = persistedState.core_tested_port;
}
let activeIdx = Math.min(Math.max(0, persistedActiveIdx), (state.scenarios.length||1)-1);

function persistEditorState(){
    try {
        const baseUploadMeta = normalizeBaseUpload(state.base_upload) || (state.scenarios?.[0]?.base?.filepath || state.scenarios?.[0]?.base?.display_name ? {
            path: state.scenarios?.[0]?.base?.filepath || '',
            display_name: state.scenarios?.[0]?.base?.display_name || (state.scenarios?.[0]?.base?.filepath ? state.scenarios[0].base.filepath.split(/[/\\]/).pop() || '' : '')
        } : null);
        const coreForPersist = sanitizeCoreForPersist(state.core);
        localStorage.setItem('coretg_editor_state', JSON.stringify({
            scenarios: state.scenarios,
            result_path: state.result_path || null,
            core: coreForPersist || null,
            core_ok: !!state.core_ok,
            core_tested_host: state.core_tested_host || null,
            core_tested_port: state.core_tested_port || null,
            base_upload: baseUploadMeta,
            host_interfaces: Array.isArray(state.host_interfaces) ? state.host_interfaces : [],
            host_interfaces_source: state.host_interfaces_source || null,
            host_interfaces_metadata: state.host_interfaces_metadata || null,
            host_interfaces_fetched_at: state.host_interfaces_fetched_at || null,
        }));
        localStorage.setItem('coretg_active_idx', String(activeIdx||0));
        storeCorePasswordInSession();
    } catch(e){}
}
// Persist initial merged state so it survives cross-page navigation immediately
persistEditorState();

const dropdownsBySection = {
    'Node Information': ['Server','Workstation','PC','Random'],
    // Added 'Random' entry so user can explicitly request a random routing protocol.
    'Routing': ['RIP','RIPv2','BGP','OSPFv2','OSPFv3','Random'],
    'Services': ['SSH','HTTP','DHCPClient','Random'],
    'Traffic': ['Random','TCP','UDP','CUSTOM'],
    'Events': ['Script Path'],
    'Vulnerabilities': ['Category','Specific','Random'],
    'Segmentation': ['Random','Firewall','NAT','CUSTOM']
};

const proxInventoryFetchInFlight = new Set();
// Feature flag: disable automatic CORE VM interface refresh; require explicit user action
const HOST_INTERFACES_AUTO_REFRESH_ENABLED = false;
const HOST_INTERFACES_REFRESH_COOLDOWN_MS = 10_000;
const HOST_INTERFACES_REQUEST_TIMEOUT_MS = 15_000;
const HOST_INTERFACES_MAX_AUTO_RETRIES = 5;
const hostInterfacesRetryTimers = new Map();
const hostInterfacesRetryCounters = new Map();

function isNetworkFetchError(err) {
    if (!err || typeof err !== 'object') return false;
    if (err.name === 'TypeError' && typeof err.message === 'string' && /fetch/i.test(err.message)) return true;
    if (err.message && typeof err.message === 'string' && err.message.includes('Failed to fetch')) return true;
    return false;
}

function isHitlAuthenticationReady(hitlState) {
    if (!hitlState || typeof hitlState !== 'object') return false;
    const proxState = hitlState.proxmox && typeof hitlState.proxmox === 'object' ? hitlState.proxmox : {};
    const coreState = hitlState.core && typeof hitlState.core === 'object' ? hitlState.core : {};
    const proxValidated = !!(proxState.validated && proxState.secret_id);
    const coreSecretId = typeof coreState.core_secret_id === 'string' ? coreState.core_secret_id.trim() : '';
    const vmKey = (coreState.vm_key || '').toString();
    return proxValidated && !!coreSecretId && !!vmKey;
}

function setHitlStatus(sidx, message, tone = 'info') {
    const statusEl = document.querySelector(`[data-hitl-status="${sidx}"]`);
    if (!statusEl) return;
    statusEl.textContent = message;
    const toneClasses = ['text-danger', 'text-warning', 'text-success', 'text-muted'];
    toneClasses.forEach(cls => statusEl.classList.remove(cls));
    switch (tone) {
        case 'error':
            statusEl.classList.add('text-danger');
            break;
        case 'warning':
            statusEl.classList.add('text-warning');
            break;
        case 'success':
            statusEl.classList.add('text-success');
            break;
        case 'neutral':
            statusEl.classList.add('text-muted');
            break;
        default:
            statusEl.classList.add('text-muted');
            break;
    }
}

async function refreshHostInterfacesForScenario(sidx, options = {}) {
    const {
        reason = 'manual',
        silent = false,
        setStatus = null,
        timeoutMs = null,
    } = options;
    const scenario = Number.isInteger(sidx) ? state.scenarios?.[sidx] : null;
    const retryKey = String(sidx);
    if (hostInterfacesRetryTimers.has(retryKey)) {
        clearTimeout(hostInterfacesRetryTimers.get(retryKey));
        hostInterfacesRetryTimers.delete(retryKey);
    }
    const statusFn = typeof setStatus === 'function'
        ? setStatus
        : (message, tone) => setHitlStatus(sidx, message, tone);
    if (!scenario) {
        statusFn('Scenario unavailable for refresh.', 'error');
        return { ok: false, reason: 'no-scenario' };
    }
    const hitlState = ensureHitlStateForScenario(scenario);
    const proxState = hitlState.proxmox && typeof hitlState.proxmox === 'object' ? hitlState.proxmox : {};
    const proxValidated = !!(proxState.validated && proxState.secret_id);
    if (!proxValidated) {
        statusFn('Validate Proxmox credentials in Step 1 before refreshing interfaces.', 'error');
        if (!silent) {
            try { showToast('Validate Proxmox credentials to unlock HITL steps.', { autohide: true, delay: 2800 }); } catch (e) {}
        }
        return { ok: false, reason: 'no-proxmox' };
    }
    const coreState = hitlState.core || (hitlState.core = {});
    const coreSecretId = typeof coreState.core_secret_id === 'string' ? coreState.core_secret_id.trim() : '';
    if (!coreSecretId) {
        statusFn('Store CORE credentials to enumerate interfaces.', 'error');
        if (!silent) {
            try { showToast('Configure CORE credentials to refresh interfaces.', { autohide: true, delay: 2500 }); } catch (e) {}
        }
        return { ok: false, reason: 'no-secret' };
    }
    const nowIso = new Date().toISOString();
    coreState.last_interfaces_attempt = nowIso;
    if (coreState.interfaces_refresh_inflight) {
        statusFn('Interface refresh already in progress.', 'warning');
        return { ok: false, reason: 'busy' };
    }
    const vmKey = (coreState.vm_key || '').toString();
    const coreVmMeta = {
        vm_key: vmKey,
        vm_name: coreState.vm_name || '',
        vm_node: '',
        vmid: '',
    };
    if (vmKey) {
        const [nodePart, vmidPart] = vmKey.split('::');
        coreVmMeta.vm_node = (nodePart || '').trim();
        coreVmMeta.vmid = vmidPart && vmidPart.trim() ? vmidPart.trim() : '';
    }
    const proxInventory = hitlState.proxmox && hitlState.proxmox.inventory && Array.isArray(hitlState.proxmox.inventory.vms)
        ? hitlState.proxmox.inventory.vms
        : [];
    const targetVm = proxInventory.find(vm => `${vm.node ?? ''}::${vm.vmid ?? ''}` === vmKey);
    if (targetVm) {
        coreVmMeta.vm_name = targetVm.name ? String(targetVm.name) : coreVmMeta.vm_name;
        if (!coreVmMeta.vm_node && targetVm.node) coreVmMeta.vm_node = String(targetVm.node);
        if (!coreVmMeta.vmid && targetVm.vmid !== undefined && targetVm.vmid !== null) coreVmMeta.vmid = String(targetVm.vmid);
        if (Array.isArray(targetVm.interfaces)) {
            coreVmMeta.interfaces = targetVm.interfaces;
        }
    }
    coreState.interfaces_refresh_inflight = true;
    coreState.last_interfaces_error = null;
    persistEditorState();
    try { window.requestAnimationFrame(() => renderMain()); } catch (err) {}
    statusFn(reason === 'auto' ? 'Enumerating host interfaces…' : 'Refreshing interface list…', 'neutral');
    const controller = (typeof AbortController === 'function') ? new AbortController() : null;
    const requestTimeoutMs = Number.isFinite(timeoutMs) && timeoutMs > 0 ? timeoutMs : HOST_INTERFACES_REQUEST_TIMEOUT_MS;
    let timeoutId = null;
    let timedOut = false;
    try {
        const payload = {
            core_secret_id: coreSecretId,
            include_down: true,
            core_vm: coreVmMeta,
            scenario_index: sidx,
            scenario_name: scenario?.name || '',
        };
        const fetchOptions = {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Accept': 'application/json',
            },
            credentials: 'same-origin',
            body: JSON.stringify(payload),
        };
        if (controller) {
            fetchOptions.signal = controller.signal;
        }
        const fetchPromise = fetch('/api/host_interfaces', fetchOptions);
        const shouldTimeout = requestTimeoutMs > 0;
        let resp;
        if (shouldTimeout) {
            const timeoutPromise = new Promise((_, reject) => {
                timeoutId = window.setTimeout(() => {
                    timedOut = true;
                    if (controller) {
                        try { controller.abort(); } catch (err) { /* ignore */ }
                    }
                    reject(new Error('RequestTimedOut'));
                }, requestTimeoutMs);
            });
            resp = await Promise.race([fetchPromise, timeoutPromise]);
        } else {
            resp = await fetchPromise;
        }
        if (timeoutId !== null) {
            try { window.clearTimeout(timeoutId); } catch (err) { /* ignore */ }
            timeoutId = null;
        }
        if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
        const contentType = resp.headers.get('content-type') || '';
        let data;
        if (contentType.toLowerCase().includes('application/json')) {
            data = await resp.json();
        } else {
            const text = await resp.text();
            const snippet = text ? text.trim().slice(0, 240) : 'Empty response body';
            throw new Error(`Non-JSON response from host interface endpoint: ${snippet}`);
        }
        if (!data || data.success === false) {
            const errMsg = data && data.error ? data.error : 'Interface enumeration failed';
            throw new Error(errMsg);
        }
        const interfaces = Array.isArray(data.interfaces) ? data.interfaces : [];
        state.host_interfaces = interfaces;
        state.host_interfaces_source = data.source || 'core_vm';
        state.host_interfaces_metadata = data.metadata || null;
        const fetchedAt = data.fetched_at || new Date().toISOString();
        state.host_interfaces_fetched_at = fetchedAt;
        coreState.last_interfaces_refresh = fetchedAt;
        coreState.last_interfaces_error = null;
        persistEditorState();
        hostInterfacesRetryCounters.delete(retryKey);
        const hidden = document.getElementById('scenarios_json');
        if (hidden) hidden.value = JSON.stringify({ scenarios: state.scenarios, active_index: activeIdx });
        renderMain();
        statusFn('Interfaces refreshed from CORE VM', 'success');
        if (!silent) {
            try { showToast('CORE interfaces refreshed', { autohide: true, delay: 2200 }); } catch (e) {}
        }
        return { ok: true, data };
    } catch (err) {
        const requestTimedOut = timedOut || (err && (err.name === 'AbortError' || err.code === 20 || err.message === 'RequestTimedOut'));
        const networkFailure = requestTimedOut || isNetworkFetchError(err);
        const timeoutSeconds = Math.max(1, Math.round((requestTimeoutMs || HOST_INTERFACES_REQUEST_TIMEOUT_MS) / 1000));
        const message = requestTimedOut
            ? `Interface refresh timed out after ${timeoutSeconds} seconds. Verify CORE connectivity and try again.`
            : (networkFailure
                ? 'Unable to reach the server while refreshing interfaces. Will retry shortly.'
                : (err?.message ? String(err.message) : 'Refresh failed. Check server logs.'));
        if (networkFailure) {
            logWarn(`Host interface refresh temporarily unavailable: ${err}`);
        } else {
            logError(`Failed to refresh host interfaces: ${err}`);
        }
        coreState.last_interfaces_error = message;
        statusFn(message, 'error');
        persistEditorState();
        try { renderMain(); } catch (e) {}
        const autoEligible = (reason === 'auto' || reason === 'retry');
        if (networkFailure && autoEligible) {
            const attempts = (hostInterfacesRetryCounters.get(retryKey) || 0) + 1;
            hostInterfacesRetryCounters.set(retryKey, attempts);
            if (attempts <= HOST_INTERFACES_MAX_AUTO_RETRIES) {
                const backoffMs = Math.min(60_000, 2_000 * Math.pow(2, attempts - 1));
                const timerId = window.setTimeout(() => {
                    hostInterfacesRetryTimers.delete(retryKey);
                    refreshHostInterfacesForScenario(sidx, {
                        reason: 'retry',
                        silent: true,
                        setStatus: (msg, tone) => setHitlStatus(sidx, msg, tone),
                    }).catch(err2 => console.warn('Auto retry refresh host interfaces failed', err2));
                }, backoffMs);
                hostInterfacesRetryTimers.set(retryKey, timerId);
            } else {
                logWarn(`Max auto retries reached for host interface refresh on scenario ${retryKey}`);
            }
        }
        return { ok: false, reason: 'error', error: err };
    } finally {
        if (timeoutId !== null) {
            try { window.clearTimeout(timeoutId); } catch (err) { /* ignore */ }
        }
        coreState.interfaces_refresh_inflight = false;
        persistEditorState();
        try { window.requestAnimationFrame(() => renderMain()); } catch (err) {}
    }
}

function scheduleAutoRefreshHostInterfaces(sidx) {
    if (!HOST_INTERFACES_AUTO_REFRESH_ENABLED) return;
    const scenario = Number.isInteger(sidx) ? state.scenarios?.[sidx] : null;
    if (!scenario) return;
    const hitlState = ensureHitlStateForScenario(scenario);
    if (!hitlState.enabled) return;
    if (!isHitlAuthenticationReady(hitlState)) return;
    const coreState = hitlState.core || (hitlState.core = {});
    const hostInterfaces = Array.isArray(state.host_interfaces) ? state.host_interfaces : [];
    if (hostInterfaces.length) return;
    if (coreState.interfaces_refresh_inflight) return;
    const coreSecretId = typeof coreState.core_secret_id === 'string' ? coreState.core_secret_id.trim() : '';
    if (!coreSecretId) return;
    if (!(coreState.vm_key || '').toString()) return;
    const lastAttemptMs = Date.parse(coreState.last_interfaces_attempt || '');
    if (!Number.isNaN(lastAttemptMs) && (Date.now() - lastAttemptMs) < HOST_INTERFACES_REFRESH_COOLDOWN_MS) {
        return;
    }
    window.setTimeout(() => {
        refreshHostInterfacesForScenario(sidx, {
            reason: 'auto',
            silent: true,
            setStatus: (message, tone) => setHitlStatus(sidx, message, tone),
        }).catch(err => console.warn('Auto refresh host interfaces failed', err));
    }, 150);
}

function describeTimestampRelative(isoString) {
    if (!isoString || typeof isoString !== 'string') return null;
    const epoch = Date.parse(isoString);
    if (Number.isNaN(epoch)) return null;
    try {
        const deltaMs = Date.now() - epoch;
        if (Math.abs(deltaMs) < 90_000) return 'just now';
        return new Date(epoch).toLocaleString();
    } catch (err) {
        return null;
    }
}

function updateHitlStatusForScenario(sidx) {
    const scenario = Number.isInteger(sidx) ? state.scenarios?.[sidx] : null;
    if (!scenario) return;
    const hitlState = ensureHitlStateForScenario(scenario);
    if (!hitlState.enabled) {
        if (isHitlAuthenticationReady(hitlState)) {
            setHitlStatus(sidx, 'Enable Hardware in the Loop to manage interface mappings.', 'neutral');
        } else {
            setHitlStatus(sidx, 'Validate Steps 1 and 2 before enabling Hardware in the Loop.', 'warning');
        }
        return;
    }
    if (!isHitlAuthenticationReady(hitlState)) {
        setHitlStatus(sidx, 'Validate Proxmox credentials and store CORE credentials to manage HITL interfaces.', 'warning');
        return;
    }
    const coreState = hitlState.core || {};
    const hostInterfaces = Array.isArray(state.host_interfaces) ? state.host_interfaces : [];
    const hasInterfaces = hostInterfaces.length > 0;
    const refreshBusy = coreState.interfaces_refresh_inflight === true;
    const lastAttemptStr = coreState.last_interfaces_attempt;
    const lastRefreshStr = coreState.last_interfaces_refresh;
    const lastError = coreState.last_interfaces_error;
    if (refreshBusy) {
        setHitlStatus(sidx, 'Enumerating host interfaces…', 'neutral');
        return;
    }
    if (lastError) {
        const attemptLabel = describeTimestampRelative(lastAttemptStr);
        const message = attemptLabel ? `${lastError} • Last attempt ${attemptLabel}` : lastError;
        setHitlStatus(sidx, message, 'error');
        return;
    }
    if (hasInterfaces) {
        const refreshLabel = describeTimestampRelative(lastRefreshStr) || 'recently';
        setHitlStatus(sidx, `Interfaces loaded from CORE VM ${refreshLabel}.`, 'success');
        return;
    }
    const attemptLabel = describeTimestampRelative(lastAttemptStr);
    if (attemptLabel) {
        setHitlStatus(sidx, `No interfaces detected yet • Last attempt ${attemptLabel}`, 'warning');
    } else {
        setHitlStatus(sidx, 'Select Refresh to enumerate interfaces from the CORE VM.', 'neutral');
    }
}

function render() {
    renderSidebar();
    renderMain();
    // Ensure H/S bounds visibility reflects initial r2s_mode values
    updateHsBoundsVisibility();
    // Download link visibility if provided
    // Enable/disable Download XML button based on saved xml path
    const dlBtn = document.getElementById('downloadXmlBtn');
    if (dlBtn) {
        const rp = state.result_path || '';
        if (rp && rp.endsWith('.xml')) { dlBtn.removeAttribute('disabled'); dlBtn.classList.remove('pe-none'); dlBtn.setAttribute('title',''); }
        else { dlBtn.setAttribute('disabled','disabled'); dlBtn.classList.add('pe-none'); dlBtn.setAttribute('title','Save XML first'); }
    }
    // Sync Base Scenario UI with persisted metadata (independent of active scenario)
    const scen0 = state.scenarios?.[0] || {};
    const scen0Base = (typeof scen0.base === 'object' && scen0.base) ? scen0.base : {};
    const metaBase = (state.base_upload && typeof state.base_upload === 'object') ? state.base_upload : (initialPayload?.base_upload && typeof initialPayload.base_upload === 'object' ? initialPayload.base_upload : {});
    const basePath = metaBase.path || scen0Base.filepath || '';
    const baseDisplayName = metaBase.display_name || scen0Base.display_name || (basePath ? basePath.split(/[/\\]/).pop() : '');
    const baseValid = typeof metaBase.valid === 'boolean' ? metaBase.valid : true;

    const baseIn = document.getElementById('baseFileInput');
    if (baseIn) {
        const current = baseIn.value || '';
        const target = baseDisplayName || '';
        if (current !== target) baseIn.value = target;
    }
    const baseBadge = document.getElementById('baseValidityBadge');
    if (baseBadge) {
        if (basePath) {
            baseBadge.textContent = baseValid ? 'VALID' : 'INVALID';
            baseBadge.classList.remove('d-none', 'text-bg-success', 'text-bg-danger');
            baseBadge.classList.add(baseValid ? 'text-bg-success' : 'text-bg-danger');
        } else {
            baseBadge.classList.add('d-none');
            baseBadge.classList.remove('text-bg-success', 'text-bg-danger');
        }
    }
    const baseDetailsLink = document.getElementById('baseDetailsLink');
    if (baseDetailsLink) {
        if (basePath) {
            const baseUrl = baseDetailsLink.dataset.baseUrl || baseDetailsLink.getAttribute('href') || '';
            if (baseUrl) {
                baseDetailsLink.href = `${baseUrl}${encodeURIComponent(basePath)}`;
            }
            baseDetailsLink.classList.remove('d-none');
        } else {
            baseDetailsLink.classList.add('d-none');
        }
    }
    const baseRemoveForm = document.getElementById('baseRemoveForm');
    if (baseRemoveForm) {
        if (basePath) baseRemoveForm.classList.remove('d-none');
        else baseRemoveForm.classList.add('d-none');
    }
}

function toggleEditorBusy(isBusy) {
    const root = document.getElementById('editorRoot');
    if (root) {
        root.classList.toggle('opacity-50', !!isBusy);
        if (isBusy) {
            root.setAttribute('aria-busy', 'true');
        } else {
            root.removeAttribute('aria-busy');
        }
    }
    document.querySelectorAll('#editorRoot button, #editorRoot input, #editorRoot select, #editorRoot textarea').forEach(el => {
        if (el.closest('#proxmoxAssignModal')) return;
        if (el.closest('#coreConnectionModal')) return;
        if (isBusy) {
            el.setAttribute('data-busy-disabled', el.disabled ? '1' : '0');
            el.disabled = true;
        } else if (el.hasAttribute('data-busy-disabled')) {
            const wasDisabled = el.getAttribute('data-busy-disabled') === '1';
            el.disabled = wasDisabled;
            el.removeAttribute('data-busy-disabled');
        }
    });
}

function toggleExternalIfxModalBusy(isBusy) {
    const modal = document.getElementById('externalIfxModal');
    if (!modal) return;
    const busy = !!isBusy;
    const notice = document.getElementById('externalIfxBusyNotice');
    if (busy) {
        modal.setAttribute('aria-busy', 'true');
        if (notice) {
            notice.textContent = 'Refreshing Proxmox interfaces…';
            notice.classList.remove('d-none');
        }
    } else {
        modal.removeAttribute('aria-busy');
        if (notice) {
            notice.classList.add('d-none');
            notice.textContent = '';
        }
    }
    modal.querySelectorAll('button, input, select, textarea').forEach(el => {
        if (el.matches('[data-bs-dismiss="modal"]')) return;
        if (busy) {
            if (!el.hasAttribute('data-ifx-busy-disabled')) {
                el.setAttribute('data-ifx-busy-disabled', el.disabled ? '1' : '0');
            }
            el.disabled = true;
        } else if (el.hasAttribute('data-ifx-busy-disabled')) {
            const wasDisabled = el.getAttribute('data-ifx-busy-disabled') === '1';
            el.disabled = wasDisabled;
            el.removeAttribute('data-ifx-busy-disabled');
        }
    });
}

let externalIfxStatusTimer = null;

function clearExternalIfxStatus() {
    const notice = document.getElementById('externalIfxBusyNotice');
    if (!notice) return;
    notice.classList.add('d-none');
    notice.classList.remove('alert-info', 'alert-success', 'alert-warning', 'alert-danger');
    notice.textContent = '';
    notice.removeAttribute('aria-busy');
    if (externalIfxStatusTimer) {
        clearTimeout(externalIfxStatusTimer);
        externalIfxStatusTimer = null;
    }
}

function updateExternalIfxStatus(message, variant = 'info', { busy = false, autoHideMs = 0 } = {}) {
    const notice = document.getElementById('externalIfxBusyNotice');
    if (!notice) return;
    const variants = ['info', 'success', 'warning', 'danger'];
    if (externalIfxStatusTimer) {
        clearTimeout(externalIfxStatusTimer);
        externalIfxStatusTimer = null;
    }
    notice.classList.remove('alert-info', 'alert-success', 'alert-warning', 'alert-danger');
    if (!message) {
        clearExternalIfxStatus();
        return;
    }
    if (!variants.includes(variant)) variant = 'info';
    notice.classList.remove('d-none');
    notice.classList.add(`alert-${variant}`);
    notice.textContent = message;
    notice.setAttribute('role', 'status');
    notice.setAttribute('aria-live', variant === 'danger' ? 'assertive' : 'polite');
    notice.setAttribute('aria-busy', busy ? 'true' : 'false');
    if (autoHideMs > 0) {
        externalIfxStatusTimer = window.setTimeout(() => {
            clearExternalIfxStatus();
        }, autoHideMs);
    }
}

function setExternalIfxApplyBusy(isBusy, label = 'Applying…') {
    const btn = document.getElementById('externalIfxApplyBtn');
    if (!btn) return;
    if (!btn.dataset.defaultHtml) {
        btn.dataset.defaultHtml = btn.innerHTML || btn.textContent || 'Apply';
    }
    if (isBusy) {
        btn.disabled = true;
        btn.innerHTML = `<span class="spinner-border spinner-border-sm me-2" role="status" aria-hidden="true"></span>${label}`;
    } else {
        btn.disabled = false;
        const fallback = btn.dataset.defaultHtml || 'Apply';
        btn.innerHTML = fallback;
    }
}

async function handleExternalIfxApply() {
    const bridgeName = computeInternalBridgeName();
    logInfo(`External IFX apply initiated for bridge ${bridgeName}`);
    const message = `This will create a new internal bridge named "${bridgeName}" and use it to connect the CORE VM with the selected VM.\n\nDo you want to continue?`;
    if (!window.confirm(message)) {
        logInfo('External IFX apply cancelled by user');
        return;
    }
    setExternalIfxApplyBusy(true);
    updateExternalIfxStatus(`Applying bridge "${bridgeName}"…`, 'info', { busy: true });
    try {
        const { idx, scenario, name: scenarioName } = getActiveScenarioContext();
        if (idx === null || !scenario) {
            const failureMessage = 'Unable to determine the active scenario. Please select a scenario and try again.';
            logWarn('External IFX apply failed: active scenario not found');
            updateExternalIfxStatus(failureMessage, 'danger');
            try { showToast('Unable to determine active scenario for Apply.', { autohide: true, delay: 2500 }); } catch (e) {}
            return;
        }

        logInfo(`External IFX apply context resolved for scenario ${idx} (${scenarioName || 'unnamed'})`);

        const hitlState = ensureHitlStateForScenario(scenario);
        const coreState = hitlState.core || (hitlState.core = {});
        const proxState = hitlState.proxmox || {};
        const pickFirst = (...candidates) => {
            for (let idxCandidate = 0; idxCandidate < candidates.length; idxCandidate += 1) {
                const candidate = candidates[idxCandidate];
                if (candidate === null || candidate === undefined) continue;
                const text = String(candidate).trim();
                if (text) return text;
            }
            return '';
        };
        const hostInterfaces = Array.isArray(state.host_interfaces) ? state.host_interfaces : [];
        const hostInfoLookup = new Map(
            hostInterfaces
                .filter(item => item && typeof item === 'object' && item.name)
                .map(item => [item.name, item])
        );
        const proxInventoryList = proxState && proxState.inventory && Array.isArray(proxState.inventory.vms)
            ? proxState.inventory.vms
            : [];
        const findVmRecord = (nodeVal, vmidVal) => {
            if (!nodeVal || !vmidVal) return null;
            const nodeKey = String(nodeVal).trim();
            const vmidKey = String(vmidVal).trim();
            if (!nodeKey || !vmidKey) return null;
            for (let vmIdx = 0; vmIdx < proxInventoryList.length; vmIdx += 1) {
                const vmEntry = proxInventoryList[vmIdx];
                if (!vmEntry || typeof vmEntry !== 'object') continue;
                const vmNode = vmEntry.node !== undefined && vmEntry.node !== null ? String(vmEntry.node).trim() : '';
                const vmId = vmEntry.vmid !== undefined && vmEntry.vmid !== null ? String(vmEntry.vmid).trim() : '';
                if (vmNode && vmId && vmNode === nodeKey && vmId === vmidKey) {
                    return vmEntry;
                }
            }
            return null;
        };

        const buildHitlApplyPayload = (rawHitl) => {
            const clean = { enabled: !!rawHitl.enabled, interfaces: [], core: {}, proxmox: {} };
            const missingCore = [];
            const ifaceList = Array.isArray(rawHitl.interfaces) ? rawHitl.interfaces : [];
            for (let i = 0; i < ifaceList.length; i += 1) {
                const entry = ifaceList[i];
                if (!entry || typeof entry !== 'object') {
                    continue;
                }
                const sanitized = {
                    name: entry.name || '',
                    attachment: entry.attachment || '',
                };
                const hostInfo = hostInfoLookup.get(sanitized.name) || null;
                let proxTargetClean = null;
                const proxTarget = entry.proxmox_target;
                if (proxTarget && typeof proxTarget === 'object') {
                    proxTargetClean = {
                        node: pickFirst(proxTarget.node, proxTarget.vm_node, proxTarget.raw && proxTarget.raw.node),
                        vmid: pickFirst(proxTarget.vmid, proxTarget.vm_id, proxTarget.raw && proxTarget.raw.vmid, proxTarget.raw && proxTarget.raw.vm_id),
                        interface_id: pickFirst(
                            proxTarget.interface_id,
                            proxTarget.id,
                            proxTarget.adapter,
                            proxTarget.raw && proxTarget.raw.interface_id,
                            proxTarget.raw && proxTarget.raw.id,
                            proxTarget.raw && proxTarget.raw.adapter
                        ),
                    };
                    if (proxTarget.vm_name || proxTarget.label) {
                        proxTargetClean.vm_name = proxTarget.vm_name ?? proxTarget.label ?? '';
                    }
                    if (proxTarget.macaddr) proxTargetClean.macaddr = proxTarget.macaddr;
                    if (proxTarget.bridge) proxTargetClean.bridge = proxTarget.bridge;
                    if (proxTarget.model) proxTargetClean.model = proxTarget.model;
                }
                if (!proxTargetClean && hostInfo && hostInfo.proxmox && typeof hostInfo.proxmox === 'object') {
                    const hostProx = hostInfo.proxmox;
                    proxTargetClean = {
                        node: pickFirst(hostProx.vm_node, hostProx.node, hostProx.raw && hostProx.raw.node),
                        vmid: pickFirst(hostProx.vmid, hostProx.vm_id, hostProx.raw && hostProx.raw.vmid, hostProx.raw && hostProx.raw.vm_id),
                        interface_id: pickFirst(hostProx.id, hostProx.interface_id, hostProx.adapter, hostProx.raw && hostProx.raw.interface_id, hostProx.raw && hostProx.raw.id, hostProx.raw && hostProx.raw.adapter),
                    };
                    const vmName = pickFirst(hostProx.vm_name, hostProx.raw && hostProx.raw.vm_name, hostProx.raw && hostProx.raw.name);
                    if (vmName) proxTargetClean.vm_name = vmName;
                    if (hostProx.macaddr) proxTargetClean.macaddr = String(hostProx.macaddr).trim();
                    if (hostProx.bridge) proxTargetClean.bridge = String(hostProx.bridge).trim();
                    if (hostProx.model) proxTargetClean.model = String(hostProx.model).trim();
                }
                if (proxTargetClean) {
                    if (!proxTargetClean.interface_id && hostInfo && hostInfo.mac) {
                        const macKey = String(hostInfo.mac).trim().toLowerCase();
                        const nodeVal = proxTargetClean.node || (hostInfo.proxmox && pickFirst(hostInfo.proxmox.vm_node, hostInfo.proxmox.node));
                        const vmidVal = proxTargetClean.vmid || (hostInfo.proxmox && pickFirst(hostInfo.proxmox.vmid, hostInfo.proxmox.vm_id));
                        const vmRecord = findVmRecord(nodeVal, vmidVal);
                        if (vmRecord && Array.isArray(vmRecord.interfaces)) {
                            for (let ifaceIdx = 0; ifaceIdx < vmRecord.interfaces.length; ifaceIdx += 1) {
                                const vmIface = vmRecord.interfaces[ifaceIdx];
                                if (!vmIface || typeof vmIface !== 'object') continue;
                                const ifaceMac = vmIface.macaddr ? String(vmIface.macaddr).trim().toLowerCase() : '';
                                if (ifaceMac && ifaceMac === macKey) {
                                    proxTargetClean.interface_id = pickFirst(vmIface.id, vmIface.interface_id, vmIface.name);
                                    if (!proxTargetClean.bridge && vmIface.bridge) proxTargetClean.bridge = String(vmIface.bridge).trim();
                                    if (!proxTargetClean.model && vmIface.model) proxTargetClean.model = String(vmIface.model).trim();
                                    break;
                                }
                            }
                        }
                    }
                    if (!proxTargetClean.interface_id && proxTargetClean.macaddr) {
                        const macKey = String(proxTargetClean.macaddr).trim().toLowerCase();
                        const vmRecord = findVmRecord(proxTargetClean.node, proxTargetClean.vmid);
                        if (vmRecord && Array.isArray(vmRecord.interfaces)) {
                            for (let ifaceIdx = 0; ifaceIdx < vmRecord.interfaces.length; ifaceIdx += 1) {
                                const vmIface = vmRecord.interfaces[ifaceIdx];
                                if (!vmIface || typeof vmIface !== 'object') continue;
                                const ifaceMac = vmIface.macaddr ? String(vmIface.macaddr).trim().toLowerCase() : '';
                                if (ifaceMac && ifaceMac === macKey) {
                                    proxTargetClean.interface_id = pickFirst(vmIface.id, vmIface.interface_id, vmIface.name);
                                    if (!proxTargetClean.bridge && vmIface.bridge) proxTargetClean.bridge = String(vmIface.bridge).trim();
                                    if (!proxTargetClean.model && vmIface.model) proxTargetClean.model = String(vmIface.model).trim();
                                    break;
                                }
                            }
                        }
                    }
                    sanitized.proxmox_target = proxTargetClean;
                }
                const external = entry.external_vm;
                if (external && typeof external === 'object') {
                    const ext = {
                        vm_key: external.vm_key ?? '',
                        vmid: external.vmid ?? '',
                        interface_id: external.interface_id ?? '',
                    };
                    if (external.vm_node) ext.vm_node = external.vm_node;
                    if (external.vm_name) ext.vm_name = external.vm_name;
                    sanitized.external_vm = ext;
                    const hasCoreSelection = proxTargetClean && proxTargetClean.interface_id;
                    const hasExternalSelection = (ext.vm_key && String(ext.vm_key).trim()) ||
                        (ext.vmid && String(ext.vmid).trim()) ||
                        (ext.vm_name && String(ext.vm_name).trim());
                    if (hasExternalSelection && !hasCoreSelection) {
                        missingCore.push(sanitized.name || `Interface ${i + 1}`);
                    }
                }
                clean.interfaces.push(sanitized);
            }
            const coreRaw = rawHitl.core;
            if (coreRaw && typeof coreRaw === 'object') {
                clean.core = {
                    vm_key: coreRaw.vm_key ?? '',
                    vm_name: coreRaw.vm_name ?? '',
                    vm_node: coreRaw.vm_node ?? '',
                    internal_bridge: coreRaw.internal_bridge ?? '',
                    internal_bridge_owner: coreRaw.internal_bridge_owner ?? '',
                };
            }
            const proxRaw = rawHitl.proxmox;
            if (proxRaw && typeof proxRaw === 'object') {
                clean.proxmox = {
                    secret_id: proxRaw.secret_id ?? proxRaw.secretId ?? null,
                };
            }
            return { clean, missingCore };
        };

        const { clean: sanitizedHitl, missingCore } = buildHitlApplyPayload(hitlState);
        const ifaceCount = Array.isArray(sanitizedHitl.interfaces) ? sanitizedHitl.interfaces.length : 0;
        const extSelections = sanitizedHitl.interfaces.filter(iface => iface?.external_vm && (iface.external_vm.vm_key || iface.external_vm.vmid || iface.external_vm.vm_name)).length;
        const proxSelections = sanitizedHitl.interfaces.filter(iface => iface?.proxmox_target && iface.proxmox_target.interface_id).length;
        logInfo(`External IFX apply payload prepared (interfaces=${ifaceCount}, externalMapped=${extSelections}, coreAdapters=${proxSelections})`);
        if (missingCore.length) {
            const detailMessage = missingCore.length === 1
                ? `${missingCore[0]} needs a Proxmox adapter (for example, net0) selected in Step 3 before applying the bridge.`
                : `Select a Proxmox adapter (for example, net0) in Step 3 for: ${missingCore.join(', ')}.`;
            logWarn(`External IFX apply blocked: no Proxmox adapter chosen for ${missingCore.join(', ')}`);
            updateExternalIfxStatus(detailMessage, 'warning', { busy: false });
            try { showToast(detailMessage, { autohide: false }); } catch (e) {}
            return;
        }
        const requestPayload = {
            bridge_name: bridgeName,
            scenario_index: idx,
            scenario_name: scenarioName,
            bridge_owner: window.CORETG_USERNAME || '',
            hitl: sanitizedHitl,
        };
        enrichPayloadWithScenarioContext(requestPayload, { includeCore: false });

        logInfo(`External IFX apply dispatching to /api/hitl/apply_bridge for scenario ${idx}`);

        const resp = await fetch('/api/hitl/apply_bridge', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            credentials: 'same-origin',
            body: JSON.stringify(requestPayload),
        });

        let data = null;
        try { data = await resp.json(); } catch (err) { data = null; }

        logInfo(`External IFX apply response received HTTP ${resp.status}`);

        if (!resp.ok || !data || data.success === false) {
            const errMessage = (data && (data.error || data.message)) ? (data.error || data.message) : `Bridge apply failed (HTTP ${resp.status})`;
            logError(`External IFX apply failed: ${errMessage}`);
            updateExternalIfxStatus(errMessage, 'danger');
            try { showToast(errMessage, { autohide: false }); } catch (e) {}
            return;
        }

        const appliedBridgeName = data.bridge_name || bridgeName;
        coreState.internal_bridge = appliedBridgeName;
        const responseOwner = (data.bridge_owner || requestPayload.bridge_owner || '').toString();
        coreState.internal_bridge_owner = responseOwner;
        window.requestAnimationFrame(() => {
            try { updateProxmoxSummary(idx); } catch (rafErr) { console.warn('Failed to update Proxmox summary', rafErr); }
        });
        window.setTimeout(() => {
            try { persistEditorState(); } catch (persistErr) { console.warn('Failed to persist editor state', persistErr); }
            try {
                const hidden = document.getElementById('scenarios_json');
                if (hidden) hidden.value = JSON.stringify({ scenarios: state.scenarios, active_index: activeIdx });
            } catch (hiddenErr) { console.warn('Failed refreshing hidden scenarios_json', hiddenErr); }
        }, 0);

        const successMessage = data.message || `Bridge "${appliedBridgeName}" applied successfully.`;
        logInfo(`External IFX apply confirmed for scenario ${idx} with bridge ${appliedBridgeName}`);
        updateExternalIfxStatus(successMessage, 'success', { busy: false, autoHideMs: 3000 });
        try { showToast(`${successMessage} Scenario saved and modal closing…`, { autohide: true, delay: 3500 }); } catch (e) {}
        if (Array.isArray(data.warnings) && data.warnings.length) {
            const warningText = data.warnings.join('\n');
            logWarn(`External IFX apply warnings: ${warningText}`);
            updateExternalIfxStatus(`${successMessage}\n${warningText}`, 'warning');
            try { showToast(warningText, { autohide: false }); } catch (e) {}
        }
        window.setTimeout(() => {
            const modalEl = document.getElementById('externalIfxModal');
            if (modalEl && window.bootstrap && window.bootstrap.Modal) {
                try {
                    const modalInstance = window.bootstrap.Modal.getOrCreateInstance(modalEl);
                    modalInstance.hide();
                } catch (modalErr) { console.warn('Failed to close External IFX modal', modalErr); }
            } else if (modalEl) {
                modalEl.classList.remove('show');
                modalEl.setAttribute('aria-hidden', 'true');
                modalEl.style.display = 'none';
            }
        }, 150);
        window.setTimeout(() => {
            const editorForm = document.getElementById('editorForm');
            try {
                if (editorForm && typeof editorForm.requestSubmit === 'function') {
                    editorForm.requestSubmit();
                } else if (editorForm) {
                    editorForm.submit();
                }
            } catch (submitErr) {
                console.warn('Failed to auto-save scenario after External IFX apply', submitErr);
            }
        }, 250);
    } catch (err) {
        try {
            const detail = err && err.stack ? err.stack : (err && err.toString ? err.toString() : 'unknown error');
            logError(`External IFX apply threw unexpected error: ${detail}`);
        } catch (_) {}
        const errMessage = err instanceof Error ? err.message : 'Failed to apply external IFX configuration.';
        logError(`External IFX apply failed: ${errMessage}`);
        updateExternalIfxStatus(errMessage, 'danger');
        try { showToast(errMessage, { autohide: false }); } catch (e) {}
    } finally {
        setExternalIfxApplyBusy(false);
    }
}

function handleCoreFieldUpdate(inputEl, { rerender } = { rerender: false }) {
    if (!inputEl) return;
    const sidx = parseInt(inputEl.getAttribute('data-scen-idx'));
    if (Number.isNaN(sidx) || !state.scenarios?.[sidx]) return;
    const field = inputEl.getAttribute('data-hitl-core-field');
    if (!field) return;
    const hitlState = ensureHitlStateForScenario(state.scenarios[sidx]);
    const coreState = hitlState.core || (hitlState.core = {});
    let dirty = false;
    if (field === 'grpc_port' || field === 'ssh_port') {
        const fallback = field === 'grpc_port' ? 50051 : 22;
        const parsed = parseInt(inputEl.value, 10);
        const sanitized = Number.isFinite(parsed) && parsed > 0 ? parsed : fallback;
        if (coreState[field] !== sanitized) {
            coreState[field] = sanitized;
            dirty = true;
        }
    } else if (field === 'ssh_host') {
        const value = (inputEl.value || '').trim();
        if ((coreState[field] || '') !== value) {
            coreState[field] = value;
            dirty = true;
        }
    } else {
        const value = inputEl.value || '';
        if ((coreState[field] || '') !== value) {
            coreState[field] = value;
            dirty = true;
        }
    }
    if (dirty) {
        coreState.last_tested_status = null;
        coreState.last_tested_message = null;
        coreState.last_tested_at = null;
        coreState.last_tested_host = null;
        coreState.last_tested_port = null;
        persistEditorState();
        const hidden = document.getElementById('scenarios_json');
        if (hidden) hidden.value = JSON.stringify({ scenarios: state.scenarios, active_index: activeIdx });
    }
    updateProxmoxSummary(sidx);
    if (dirty && rerender) {
        renderMain();
    }
}

async function validateCoreConnection(sidx, options = {}) {
    const {
        triggerButton = null,
        workingLabel = 'Testing…',
        statusEl: providedStatusEl,
        hintOnStart = null,
        hintOnSuccess = null,
        hintOnFailure = null,
        successToastMessage = null,
        closeModalOnSuccess = false,
        suppressToasts = false,
    } = options;
    if (Number.isNaN(sidx) || !state.scenarios?.[sidx]) {
        return { ok: false, message: 'Scenario unavailable' };
    }
    const scenario = state.scenarios[sidx];
    const hitlState = ensureHitlStateForScenario(scenario);
    const coreState = hitlState.core || (hitlState.core = {});
    const vmKey = (coreState.vm_key || '').toString().trim();
    const vmNode = (coreState.vm_node || '').toString().trim();
    const body = {
        core: {
            host: coreState.grpc_host || '',
            port: coreState.grpc_port || 50051,
            ssh_host: coreState.ssh_host || coreState.grpc_host || '',
            ssh_port: coreState.ssh_port || 22,
            ssh_username: coreState.ssh_username || '',
            ssh_password: coreState.ssh_password || '',
            ssh_enabled: true,
            core_secret_id: coreState.core_secret_id || null,
            vm_key: vmKey,
            vm_node: vmNode,
        },
    };
    enrichPayloadWithScenarioContext(body, { scenarioIndex: sidx, scenarioOverride: scenario });
    const statusEl = providedStatusEl ?? document.querySelector(`[data-hitl-core-status="${sidx}"]`);
    const button = triggerButton;
    const originalLabel = button?.textContent;
    if (!vmKey) {
        const message = 'Select a CORE VM before testing the connection.';
        if (statusEl) {
            statusEl.textContent = message;
            statusEl.classList.remove('text-success', 'text-warning', 'text-danger', 'text-muted');
            statusEl.classList.add('text-danger');
        }
        if (!suppressToasts) {
            try { showToast(message, { autohide: true, delay: 2600 }); } catch (e) {}
        }
        return { ok: false, message };
    }
    if (button) {
        button.disabled = true;
        button.textContent = workingLabel;
    }
    if (statusEl) {
        statusEl.textContent = workingLabel === 'Testing…' ? 'Testing CORE connection…' : 'Validating CORE connection…';
        statusEl.classList.remove('text-success', 'text-warning', 'text-danger');
        statusEl.classList.add('text-muted');
    }
    if (hintOnStart && typeof setCoreConnectionHint === 'function') {
        setCoreConnectionHint(hintOnStart, 'info');
    }
    const restoreButton = () => {
        if (button) {
            button.disabled = false;
            if (originalLabel !== undefined) {
                button.textContent = originalLabel;
            }
        }
    };
    try {
        const resp = await fetch('/test_core', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            credentials: 'same-origin',
            body: JSON.stringify(body),
        });
        let data = null;
        try { data = await resp.json(); } catch (err) { data = null; }
        const nowIso = new Date().toISOString();
        if (data && data.ok) {
            const summary = (data.core_summary && typeof data.core_summary === 'object') ? data.core_summary : null;
            coreState.last_tested_status = 'success';
            coreState.last_tested_message = data.message
                || (data.forward_host && data.forward_port
                    ? `Tunnel ${data.forward_host}:${data.forward_port}`
                    : 'Connection successful');
            coreState.last_tested_at = nowIso;
            coreState.last_tested_host = data.host || coreState.grpc_host || '';
            coreState.last_tested_port = data.port || coreState.grpc_port || null;
            coreState.core_secret_id = data.core_secret_id || (summary && summary.identifier) || null;
            coreState.validated = !!coreState.core_secret_id;
            coreState.last_validated_at = (summary && summary.stored_at) || nowIso;
            coreState.stored_summary = summary;
            coreState.ssh_password = '';
            persistEditorState();
            const hidden = document.getElementById('scenarios_json');
            if (hidden) hidden.value = JSON.stringify({ scenarios: state.scenarios, active_index: activeIdx });
            const pwdInput = document.querySelector(`[data-hitl-core-field="ssh_password"][data-scen-idx="${sidx}"]`);
            if (pwdInput) {
                pwdInput.value = '';
                pwdInput.setAttribute('placeholder', 'Stored securely');
            }
            updateProxmoxSummary(sidx);
            renderMain();
            if (typeof setCoreConnectionHint === 'function') {
                if (hintOnSuccess) {
                    setCoreConnectionHint(hintOnSuccess, 'success');
                } else if (hintOnStart) {
                    setCoreConnectionHint('Validation successful.', 'success');
                }
            }
            if (!suppressToasts) {
                try {
                    const toastMessage = successToastMessage || data.message || 'CORE connection verified';
                    showToast(toastMessage, { autohide: true, delay: 2500 });
                } catch (e) {}
            }
            if (closeModalOnSuccess && coreConnectionModal && window.bootstrap) {
                try { bootstrap.Modal.getInstance(coreConnectionModal)?.hide(); } catch (e) {}
            }
            return { ok: true, data };
        }
        const message = (data && data.error) ? data.error : `HTTP ${resp.status}`;
        coreState.last_tested_status = 'failure';
        coreState.last_tested_message = message;
        coreState.last_tested_at = nowIso;
        coreState.last_tested_host = coreState.grpc_host || '';
        coreState.last_tested_port = coreState.grpc_port || null;
        persistEditorState();
        const hidden = document.getElementById('scenarios_json');
        if (hidden) hidden.value = JSON.stringify({ scenarios: state.scenarios, active_index: activeIdx });
        updateProxmoxSummary(sidx);
        renderMain();
        const pwdInput = document.querySelector(`[data-hitl-core-field="ssh_password"][data-scen-idx="${sidx}"]`);
        if (pwdInput) pwdInput.removeAttribute('placeholder');
        if (typeof setCoreConnectionHint === 'function') {
            if (hintOnFailure) {
                setCoreConnectionHint(`${hintOnFailure}: ${message}`, 'danger');
            } else if (hintOnStart) {
                setCoreConnectionHint(message, 'danger');
            }
        }
        if (!suppressToasts) {
            try { showToast(`CORE test failed: ${message}`, { autohide: false }); } catch (e) {}
        }
        return { ok: false, message };
    } catch (err) {
        const message = err instanceof Error ? err.message : 'Connection test failed';
        coreState.last_tested_status = 'failure';
        coreState.last_tested_message = message;
        coreState.last_tested_at = new Date().toISOString();
        coreState.last_tested_host = coreState.grpc_host || '';
        coreState.last_tested_port = coreState.grpc_port || null;
        persistEditorState();
        const hidden = document.getElementById('scenarios_json');
        if (hidden) hidden.value = JSON.stringify({ scenarios: state.scenarios, active_index: activeIdx });
        updateProxmoxSummary(sidx);
        renderMain();
        const pwdInput = document.querySelector(`[data-hitl-core-field="ssh_password"][data-scen-idx="${sidx}"]`);
        if (pwdInput) pwdInput.removeAttribute('placeholder');
        if (typeof setCoreConnectionHint === 'function') {
            if (hintOnFailure) {
                setCoreConnectionHint(`${hintOnFailure}: ${message}`, 'danger');
            } else if (hintOnStart) {
                setCoreConnectionHint(message, 'danger');
            }
        }
        if (!suppressToasts) {
            try { showToast(`CORE test failed: ${message}`, { autohide: false }); } catch (e) {}
        }
        return { ok: false, message };
    } finally {
        restoreButton();
    }
}

const CORE_MODAL_INPUT_IDS = {
    grpc_host: 'coreGrpcHost',
    grpc_port: 'coreGrpcPort',
    ssh_host: 'coreSshHost',
    ssh_port: 'coreSshPort',
    ssh_username: 'coreSshUsername',
    ssh_password: 'coreSshPassword',
};

function resolveCoreModalReferences() {
    if (!coreConnectionModal) {
        coreConnectionModal = document.getElementById('coreConnectionModal');
    }
    if (!coreConnectionForm) {
        coreConnectionForm = document.getElementById('coreConnectionForm');
    }
    if (!coreConnectionHint) {
        coreConnectionHint = document.getElementById('coreConnectionHint');
    }
    Object.entries(CORE_MODAL_INPUT_IDS).forEach(([field, id]) => {
        if (!coreModalInputs[field]) {
            coreModalInputs[field] = document.getElementById(id);
        }
    });
}

async function handleCoreConnectionSave(event) {
    event?.preventDefault?.();
    resolveCoreModalReferences();
    if (!coreConnectionModal || !state?.scenarios?.length) {
        return;
    }
    const triggerButton = (event && event.currentTarget && event.currentTarget instanceof HTMLElement)
        ? event.currentTarget
        : (coreConnectionSaveBtn || document.getElementById('coreConnectionSaveBtn'));
    const targetIdxRaw = coreConnectionModal.getAttribute('data-scen-idx') || String(activeIdx);
    const sidx = parseInt(targetIdxRaw, 10);
    if (Number.isNaN(sidx) || !state.scenarios?.[sidx]) {
        return;
    }
    const scenario = state.scenarios[sidx];
    const hitlState = ensureHitlStateForScenario(scenario);
    const coreState = hitlState.core || (hitlState.core = {});
    const proxState = hitlState.proxmox || {};
    const prerequisitesMet = !!(proxState.validated && proxState.secret_id && coreState.vm_key);
    if (!prerequisitesMet) {
        if (typeof setCoreConnectionHint === 'function') {
            setCoreConnectionHint('Select and validate a CORE VM before saving connection details.', 'warning');
        }
        return;
    }
    if (coreConnectionForm && !coreConnectionForm.checkValidity()) {
        coreConnectionForm.classList.add('was-validated');
        const invalidControls = Array.from(coreConnectionForm.querySelectorAll(':invalid'));
        const invalidLabels = invalidControls.map((input) => {
            if (!(input instanceof HTMLElement)) return null;
            const id = input.id || input.getAttribute('name') || '';
            let labelText = '';
            if (id) {
                const escapedId = (window.CSS && typeof window.CSS.escape === 'function') ? window.CSS.escape(id) : id;
                const lbl = coreConnectionForm.querySelector(`label[for="${escapedId}"]`);
                if (lbl) {
                    labelText = lbl.textContent?.trim() || '';
                }
            }
            if (!labelText) {
                labelText = input.getAttribute('placeholder') || input.dataset.hitlCoreField || 'Field';
            }
            return labelText.trim();
        }).filter(Boolean);
        if (typeof setCoreConnectionHint === 'function') {
            const msg = invalidLabels.length
                ? `Fix the highlighted fields: ${invalidLabels.join(', ')}.`
                : 'Please fill out the required fields.';
            setCoreConnectionHint(msg, 'warning');
        }
        const firstInvalid = invalidControls[0];
        try {
            firstInvalid?.focus({ preventScroll: false });
            if (typeof firstInvalid?.select === 'function' && firstInvalid.type !== 'number') {
                firstInvalid.select();
            }
            firstInvalid?.scrollIntoView({ block: 'center', behavior: 'smooth' });
        } catch (err) {}
        coreConnectionForm?.reportValidity();
        return;
    }
    const snapshotBefore = JSON.stringify(coreState);
    Object.entries(coreModalInputs).forEach(([field, input]) => {
        if (!input || input.disabled) return;
        input.setAttribute('data-scen-idx', String(sidx));
        if (field === 'ssh_password' && input.value) {
            input.removeAttribute('placeholder');
        }
        handleCoreFieldUpdate(input, { rerender: false });
    });
    const snapshotAfter = JSON.stringify(coreState);
    const changed = snapshotBefore !== snapshotAfter;
    const modalRefresher = typeof window.refreshCoreConnectionModal === 'function'
        ? window.refreshCoreConnectionModal
        : null;
    if (changed) {
        updateProxmoxSummary(sidx);
        renderMain();
    } else if (modalRefresher) {
        modalRefresher(sidx);
    }
    const statusEl = document.querySelector(`[data-hitl-core-status="${sidx}"]`);
    await validateCoreConnection(sidx, {
        triggerButton,
        workingLabel: 'Validating…',
        statusEl,
        hintOnStart: 'Validating CORE connection…',
        hintOnSuccess: 'Connection saved and validated.',
        hintOnFailure: 'Validation failed',
        successToastMessage: 'CORE connection saved & validated',
        closeModalOnSuccess: true,
    });
}

function wireCoreConnectionSaveButton() {
    if (!coreConnectionSaveBtn) {
        coreConnectionSaveBtn = document.getElementById('coreConnectionSaveBtn');
    }
    if (!coreConnectionSaveBtn) return;
    if (!coreConnectionSaveBtn.dataset.coreSaveBound) {
        coreConnectionSaveBtn.addEventListener('click', handleCoreConnectionSave);
        coreConnectionSaveBtn.dataset.coreSaveBound = '1';
    }
}

// --- Scenario multi-select support ---
let selectedScenarioIds = new Set();
try {
    const savedSel = JSON.parse(localStorage.getItem('coretg_selected_scenarios')||'[]');
    if (Array.isArray(savedSel)) savedSel.forEach(id => selectedScenarioIds.add(id));
} catch(e){}

function persistScenarioSelection() {
    try { localStorage.setItem('coretg_selected_scenarios', JSON.stringify(Array.from(selectedScenarioIds))); } catch(e){}
}

function ensureScenarioIds() {
    let changed = false;
    state.scenarios.forEach(s => {
        if (!s._sid) { s._sid = 'scen_' + Date.now().toString(36) + '_' + Math.random().toString(36).slice(2,8); changed = true; }
    });
    if (changed) persistEditorState();
}

function toggleScenarioSelection(id, checked) {
    if (checked) selectedScenarioIds.add(id); else selectedScenarioIds.delete(id);
    persistScenarioSelection();
    updateBulkButtonsState();
}

function selectAllScenarios() {
    ensureScenarioIds();
    const allIds = state.scenarios.map(s => s._sid);
    const allSelected = allIds.every(id => selectedScenarioIds.has(id));
    if (allSelected) { selectedScenarioIds.clear(); }
    else { allIds.forEach(id => selectedScenarioIds.add(id)); }
    persistScenarioSelection();
    renderSidebar();
}

function deleteSelectedScenarios() {
    if (!selectedScenarioIds.size) return;
    const count = selectedScenarioIds.size;
    if (!confirm(`Delete ${count} selected scenario${count>1?'s':''}? This cannot be undone.`)) return;
    const beforeLen = state.scenarios.length;
    state.scenarios = state.scenarios.filter(s => !selectedScenarioIds.has(s._sid));
    selectedScenarioIds.clear();
    if (!state.scenarios.length) {
        // Always keep at least one blank scenario to avoid empty editor state hassles
        state.scenarios.push(defaultScenario());
        activeIdx = 0;
    } else {
        if (activeIdx >= state.scenarios.length) activeIdx = state.scenarios.length - 1;
    }
    logInfo(`Deleted ${beforeLen - state.scenarios.length} scenarios`);
    persistEditorState();
    persistScenarioSelection();
    try { previewState.dirty = true; updatePlanButtons(); } catch(e){}
    render();
}

function updateBulkButtonsState() {
    const delBtn = document.getElementById('deleteSelectedScenariosBtn');
    if (!delBtn) return;
    if (selectedScenarioIds.size) { delBtn.removeAttribute('disabled'); delBtn.title = 'Delete selected'; }
    else { delBtn.setAttribute('disabled','disabled'); delBtn.title = 'No scenarios selected'; }
}

function renderSidebar() {
    ensureScenarioIds();
    const list = document.getElementById('scenarioList');
    list.innerHTML = '';
    const escapeHtml = (value) => (value ?? '').toString()
        .replace(/&/g,'&amp;')
        .replace(/</g,'&lt;')
        .replace(/>/g,'&gt;')
        .replace(/"/g,'&quot;')
        .replace(/'/g,'&#39;');
    state.scenarios.forEach((scen, idx) => {
        const sid = scen._sid;
        const a = document.createElement('a');
        a.href = '#';
        a.className = 'list-group-item list-group-item-action py-1' + (idx === activeIdx ? ' active bg-primary text-white' : '');
        // Build inner HTML with checkbox
        const isChecked = selectedScenarioIds.has(sid);
        const name = scen.name || `Scenario ${idx+1}`;
        const safeName = escapeHtml(name);
        a.innerHTML = `<div class="d-flex align-items-center">
            <input type="checkbox" class="form-check-input me-2 scenario-select" data-sid="${sid}" ${isChecked? 'checked':''} onclick="event.stopPropagation(); toggleScenarioSelection('${sid}', this.checked);" />
            <span class="flex-grow-1 text-truncate" title="${safeName}">${safeName}</span>
        </div>`;
        a.onclick = (e) => { e.preventDefault(); activeIdx = idx; persistEditorState(); render(); };
        list.appendChild(a);
    });
    const appendScenarioBtn = document.getElementById('appendScenarioBtn');
    const importBtn = document.getElementById('importBtn');
    const exportBtn = document.getElementById('exportBtn');
    const selectAllBtn = document.getElementById('selectAllScenariosBtn');
    const deleteSelectedBtn = document.getElementById('deleteSelectedScenariosBtn');
    const hiddenLoadInput = document.getElementById('hiddenLoadInput');
    const hiddenLoadForm = document.getElementById('hiddenLoadForm');
    if (appendScenarioBtn) appendScenarioBtn.onclick = (e) => { e.preventDefault(); logInfo('New scenario created'); state.scenarios.push(defaultScenario()); activeIdx = state.scenarios.length - 1; persistEditorState(); try { previewState.dirty = true; updatePlanButtons(); } catch(e){} render(); };
    if (importBtn) importBtn.onclick = (e) => { e.preventDefault(); logInfo('Import scenarios clicked'); hiddenLoadInput.click(); };
    if (hiddenLoadInput) hiddenLoadInput.onchange = () => { if (hiddenLoadInput.files && hiddenLoadInput.files.length > 0) { saveScrollBeforeNav(); hiddenLoadForm.submit(); } };
    if (exportBtn) exportBtn.onclick = (e) => {
        e.preventDefault();
        logInfo('Export clicked');
        const rp = state.result_path || '';
        if (!rp.endsWith('.xml')) {
            logWarn('Export blocked: no saved XML');
            alert('Please Save XML first (middle panel) to export the current scenarios.');
            return;
        }
        window.location.href = window.location.origin + '/download_report?path=' + encodeURIComponent(rp);
    };
    if (selectAllBtn) selectAllBtn.onclick = (e) => { e.preventDefault(); selectAllScenarios(); };
    if (deleteSelectedBtn) deleteSelectedBtn.onclick = (e) => { e.preventDefault(); deleteSelectedScenarios(); };
    updateBulkButtonsState();
}

function renderMain() {
    const root = document.getElementById('editorRoot');
    root.innerHTML = '';
    if (!state.scenarios.length) { return; }
    const scen = state.scenarios[activeIdx] || state.scenarios[0];
    const escapeHtml = (value) => (value ?? '').toString()
        .replace(/&/g,'&amp;')
        .replace(/</g,'&lt;')
        .replace(/>/g,'&gt;')
        .replace(/"/g,'&quot;')
        .replace(/'/g,'&#39;');
    const safeScenarioName = escapeHtml(scen?.name || '');
    const defaultScenarioName = escapeHtml(`Scenario ${activeIdx + 1}`);
    const existingMetaCard = document.getElementById('scenarioMetaCard');
    if (existingMetaCard && existingMetaCard.parentNode) {
        existingMetaCard.parentNode.removeChild(existingMetaCard);
    }

    const metaCard = document.createElement('div');
    metaCard.id = 'scenarioMetaCard';
    metaCard.className = 'card mb-3';
    metaCard.innerHTML = `
        <div class="card-body">
            <label class="form-label mb-1 small text-muted" for="scenarioNameInput_${activeIdx}">Scenario name</label>
            <input type="text" class="form-control" id="scenarioNameInput_${activeIdx}" data-field="name" data-scen-idx="${activeIdx}" value="${safeScenarioName}" placeholder="${defaultScenarioName}">
        </div>`;
    const baseScenarioCard = document.getElementById('baseCoreScenarioCard');
    if (baseScenarioCard && baseScenarioCard.parentNode) {
        baseScenarioCard.parentNode.insertBefore(metaCard, baseScenarioCard);
    } else {
        root.appendChild(metaCard);
    }

    const existingHitlCard = document.getElementById('scenarioHitlCard');
    if (existingHitlCard && existingHitlCard.parentNode) {
        existingHitlCard.parentNode.removeChild(existingHitlCard);
    }

    const hostInterfaces = Array.isArray(state.host_interfaces) ? state.host_interfaces : [];
    const hitl = ensureHitlStateForScenario(scen);
    const proxmox = hitl.proxmox || { url: '', port: 8006, username: '', password: '' };
    const proxValidated = !!(proxmox.validated && proxmox.secret_id);
    const hasProxmox = !!(proxmox.url && proxmox.username);
    const proxPort = proxmox.port ?? 8006;
    const proxSummaryText = hasProxmox
        ? (proxValidated
            ? `Proxmox validated for ${proxmox.username} @ ${proxmox.url}:${proxPort}`
            : `Proxmox pending validation for ${proxmox.username} @ ${proxmox.url}:${proxPort}`)
        : 'Proxmox resource not assigned.';
    const proxSummaryHtml = escapeHtml(proxSummaryText);
    const proxSummaryClass = proxValidated ? 'text-success' : (hasProxmox ? 'text-warning' : 'text-muted');
    const proxHasSecret = !!proxmox.secret_id;
    const proxHasAny = proxHasSecret || hasProxmox;
    const proxAssignLabel = proxHasSecret ? 'Update Proxmox Resource' : 'Assign Proxmox Resource';
    const proxInventoryInfo = (proxmox.inventory && typeof proxmox.inventory === 'object') ? proxmox.inventory : { fetched_at: null, vms: [] };
    const proxInventory = Array.isArray(proxInventoryInfo.vms) ? proxInventoryInfo.vms : [];
    const proxInventoryBusy = proxInventoryFetchInFlight.has(activeIdx);
    const proxInventoryError = proxmox.inventory_error ? proxmox.inventory_error.toString() : '';
    let proxInventoryStatus = '';
    if (!hasProxmox) {
        proxInventoryStatus = 'Assign credentials to load VM inventory.';
    } else if (!proxValidated) {
        proxInventoryStatus = 'Validate credentials to load VM inventory.';
    } else if (proxInventoryBusy) {
        proxInventoryStatus = 'Fetching Proxmox VM inventory…';
    } else if (proxInventory.length) {
        let fetchedReadable = '';
        if (proxInventoryInfo.fetched_at) {
            try {
                fetchedReadable = new Date(proxInventoryInfo.fetched_at).toLocaleString();
            } catch (err) {
                fetchedReadable = '';
            }
        }
        proxInventoryStatus = `Loaded ${proxInventory.length} VM${proxInventory.length === 1 ? '' : 's'}${fetchedReadable ? ` • Last fetched ${fetchedReadable}` : ''}`;
    } else if (proxInventoryError) {
        proxInventoryStatus = `Inventory error: ${proxInventoryError}`;
    } else {
        proxInventoryStatus = 'No VMs reported. Refresh to retry.';
    }
    const proxInventoryStatusHtml = escapeHtml(proxInventoryStatus);
    const proxRefreshDisabledAttr = (proxValidated && !proxInventoryBusy) ? '' : 'disabled';
    if (proxValidated && !proxInventoryBusy && !proxInventory.length && !proxInventoryError) {
        fetchProxmoxInventory(activeIdx)
            .catch(err => console.warn('Proxmox inventory fetch failed', err));
    }
    const normalizeHost = (raw) => {
        if (!raw && raw !== 0) return '';
        let text = String(raw).trim().toLowerCase();
        if (text.startsWith('[') && text.endsWith(']')) text = text.slice(1, -1);
        if (text.startsWith('::ffff:') && /^::ffff:\d+\.\d+\.\d+\.\d+$/.test(text)) {
            text = text.replace('::ffff:', '');
        }
        return text;
    };
    const core = hitl.core || {};
    const coreVmKey = (core.vm_key || '').toString();
    const coreVmName = (core.vm_name || '').toString();
    const coreHost = (core.grpc_host || '').toString().trim();
    const corePort = Number.isFinite(Number(core.grpc_port)) && Number(core.grpc_port) > 0 ? Number(core.grpc_port) : 50051;
    const coreSshHostRaw = (core.ssh_host || '').toString().trim();
    const coreSshHost = coreSshHostRaw || coreHost;
    const coreSshPort = Number.isFinite(Number(core.ssh_port)) && Number(core.ssh_port) > 0 ? Number(core.ssh_port) : 22;
    const coreUser = (core.ssh_username || '').toString().trim();
    const coreSecretId = typeof core.core_secret_id === 'string' ? core.core_secret_id.trim() : '';
    const coreHasSecret = !!coreSecretId;
    const corePasswordRaw = (core.ssh_password || '').toString();
    const corePassword = corePasswordRaw;
    const corePasswordAvailable = !!corePasswordRaw || coreHasSecret;
    const selectedCoreVm = proxInventory.find(vm => `${vm.node ?? ''}::${vm.vmid ?? ''}` === coreVmKey) || null;
    const coreVmNode = selectedCoreVm && selectedCoreVm.node !== undefined && selectedCoreVm.node !== null
        ? String(selectedCoreVm.node).trim()
        : (core.vm_node ? String(core.vm_node).trim() : '');
    const vmInterfaceCount = selectedCoreVm && Array.isArray(selectedCoreVm.interfaces) ? selectedCoreVm.interfaces.length : 0;
    const coreVmHasInterfaces = !coreVmKey || vmInterfaceCount >= 1;
    const coreVmSupportsHitl = !coreVmKey || vmInterfaceCount >= 2;
    const coreInputsComplete = !!(coreVmKey && coreHost && corePort && coreSshHost && coreSshPort && coreUser && corePasswordAvailable);
    const coreTestSuccess = core.last_tested_status === 'success';
    const coreTestMatches = coreTestSuccess
        && !!core.last_tested_host
        && normalizeHost(core.last_tested_host) === normalizeHost(coreHost)
        && Number(core.last_tested_port) === Number(corePort);
    const coreConnectionReady = proxValidated && coreInputsComplete && coreVmHasInterfaces && coreTestMatches;
    const coreReady = coreConnectionReady && coreVmSupportsHitl;
    const coreHitlBlocked = coreConnectionReady && !coreVmSupportsHitl;
    const coreTestable = proxValidated && coreInputsComplete && coreVmHasInterfaces;
    const hitlAuthReady = proxValidated && coreHasSecret && !!coreVmKey;
    const coreVmInterfaceWarning = (() => {
        if (!coreVmKey) return '';
        if (!coreVmHasInterfaces) {
            return `<div class="alert alert-danger small mt-2 mb-0">Selected VM exposes ${vmInterfaceCount || 0} network interface${vmInterfaceCount === 1 ? '' : 's'}. Add at least one interface to enable CORE connectivity.</div>`;
        }
        return '';
    })();
    const hostLookup = new Map(hostInterfaces.filter(it => it && typeof it === 'object').map(it => [it.name, it]));
    const getBridgeName = (iface) => {
        if (!iface || typeof iface !== 'object') return '';
        const direct = iface.bridge || iface.proxmox_bridge;
        if (direct) return String(direct).trim();
        const prox = iface.proxmox && typeof iface.proxmox === 'object' ? iface.proxmox : null;
        if (prox) {
            if (prox.bridge) return String(prox.bridge).trim();
            if (prox.raw && typeof prox.raw === 'object' && prox.raw.bridge) return String(prox.raw.bridge).trim();
        }
        return '';
    };
    const isVmbr0Bridge = (iface) => getBridgeName(iface).toLowerCase() === 'vmbr0';
    const describeIface = (iface) => {
        if (!iface || typeof iface !== 'object') return '';
        const parts = [];
        if (Array.isArray(iface.ipv4) && iface.ipv4.length) {
            parts.push(iface.ipv4.filter(Boolean).join(', '));
        }
        if ((!parts.length) && Array.isArray(iface.ipv6) && iface.ipv6.length) {
            parts.push(iface.ipv6.filter(Boolean)[0]);
        }
        if (iface.mac) parts.push(`MAC ${iface.mac}`);
        if (iface.mtu) parts.push(`MTU ${iface.mtu}`);
        if (iface.speed) parts.push(`${iface.speed} Mbps`);
        const bridgeName = getBridgeName(iface);
        if (bridgeName) parts.push(`Bridge ${bridgeName}`);
        if (iface.proxmox && typeof iface.proxmox === 'object') {
            const prox = iface.proxmox;
            const proxBits = [];
            const vmName = prox.vm_name || prox.raw?.vm_name || prox.raw?.name;
            const vmNode = prox.vm_node || prox.raw?.node;
            const ifaceId = prox.id || prox.raw?.id || prox.raw?.interface_id;
            if (vmName) proxBits.push(`${vmName}`);
            if (vmNode) proxBits.push(`node ${vmNode}`);
            if (ifaceId) proxBits.push(`iface ${ifaceId}`);
            if (prox.macaddr && prox.macaddr !== iface.mac) proxBits.push(prox.macaddr);
            if (prox.bridge) proxBits.push(`bridge ${prox.bridge}`);
            if (prox.model) proxBits.push(prox.model);
            if (proxBits.length) {
                parts.push(`Proxmox ${proxBits.join(' • ')}`);
            } else {
                parts.push('Proxmox mapping detected');
            }
        }
        return parts.join(' • ');
    };
    const normalizeVmInterfaceId = (vmIface) => {
        if (!vmIface || typeof vmIface !== 'object') return '';
        const rawId = vmIface.id ?? vmIface.interface_id ?? vmIface.name ?? '';
        return rawId ? String(rawId).trim() : '';
    };
    const isPhysicalVmInterface = (vmIface) => {
        if (!vmIface || typeof vmIface !== 'object') return false;
        const id = normalizeVmInterfaceId(vmIface);
        if (!id) return false;
        const bridge = (vmIface.bridge ?? '').toString().trim();
        if (!bridge) return false;
        if (bridge.toLowerCase() === 'vmbr0') return false;
        return true;
    };
    const getPhysicalVmInterfaces = (vm) => {
        if (!vm || typeof vm !== 'object') return [];
        const interfaces = Array.isArray(vm.interfaces) ? vm.interfaces : [];
        return interfaces.filter(isPhysicalVmInterface);
    };
    const describeVmInterface = (vmIface) => {
        if (!vmIface || typeof vmIface !== 'object') return '';
        const parts = [];
        const bridge = (vmIface.bridge ?? '').toString().trim();
        const macaddr = (vmIface.macaddr ?? '').toString().trim();
        const model = (vmIface.model ?? '').toString().trim();
        if (bridge) parts.push(`bridge ${bridge}`);
        if (macaddr) parts.push(macaddr);
        if (model) parts.push(model);
        return parts.join(' • ');
    };
    if (typeof window !== 'undefined') {
        window.getPhysicalVmInterfaces = getPhysicalVmInterfaces;
        window.describeVmInterface = describeVmInterface;
        window.normalizeVmInterfaceId = normalizeVmInterfaceId;
    }
    const summarizePhysicalVmInterfaces = (vm) => {
        const physical = getPhysicalVmInterfaces(vm);
        if (!physical.length) return '';
        const entries = physical.map(vmIface => {
            const ifaceId = normalizeVmInterfaceId(vmIface) || '(unknown)';
            const desc = describeVmInterface(vmIface);
            return desc ? `${ifaceId} (${desc})` : ifaceId;
        });
        return entries.join(', ');
    };
    const hitlInterfaces = Array.isArray(hitl.interfaces) ? hitl.interfaces : [];
    const hasHitlInterfaces = hitlInterfaces.length > 0;
    const selectedNames = new Set(hitlInterfaces.map(entry => (entry && entry.name ? entry.name : '')).filter(Boolean));
    const availableInterfaces = hostInterfaces.filter(iface => iface && !selectedNames.has(iface.name));
    const selectableInterfaces = availableInterfaces.filter(iface => iface && !isVmbr0Bridge(iface));
    const availableOptionsHtml = availableInterfaces.length
        ? availableInterfaces.map(iface => {
            const summary = describeIface(iface);
            const label = summary ? `${iface.name} — ${summary}` : iface.name;
            const disabled = isVmbr0Bridge(iface);
            const disabledAttr = disabled ? 'disabled data-hitl-bridge="vmbr0"' : '';
            const suffix = disabled ? ' (vmbr0 bridge)' : '';
            const title = disabled ? 'Interfaces on vmbr0 are reserved for the management bridge and cannot be selected for HITL.' : '';
            return `<option value="${escapeHtml(iface.name)}" ${disabledAttr} title="${escapeHtml(title)}">${escapeHtml(label + suffix)}</option>`;
        }).join('')
        : '<option disabled value="">All discovered interfaces selected</option>';
    const hitlToggleWasEnabled = !!hitl.enabled;
    const step3Enabled = hitlToggleWasEnabled && hitlAuthReady;
    const step3Disabled = !step3Enabled;
    const step3ToggleDisabledAttr = hitlAuthReady ? '' : 'disabled';
    const step3ToggleTooltipAttr = hitlAuthReady ? '' : 'data-bs-toggle="tooltip" data-bs-title="Validate Steps 1 and 2 before enabling Hardware in the Loop."';
    const step3ToggleCheckedAttr = hitlToggleWasEnabled ? 'checked' : '';
    const attachmentControlsDisabledAttr = (coreReady && step3Enabled) ? '' : 'disabled';
    const interfaceNoticeText = (() => {
        if (!hitlAuthReady) {
            if (!proxValidated) return 'Validate Proxmox credentials (Step 1) to unlock HITL interface mappings.';
            if (!coreHasSecret) return 'Store CORE credentials (Step 2) to unlock HITL interface mappings.';
            if (!coreVmKey) return 'Select a CORE VM in Step 2 to unlock HITL interface mappings.';
            return 'Authenticate Steps 1 and 2 to manage HITL interface mappings.';
        }
        if (!hitlToggleWasEnabled) return 'Enable Hardware in the Loop to manage HITL interface mappings.';
        if (!coreVmKey) return 'Complete steps 1 and 2 to manage HITL interface mappings.';
        if (!coreVmHasInterfaces) {
            return 'Selected CORE VM must expose at least one interface before mapping HITL interfaces.';
        }
        if (!coreVmSupportsHitl) {
            return 'Selected CORE VM exposes only one interface. HITL cannot be used until a second interface is added.';
        }
        return 'Complete steps 1 and 2 to manage HITL interface mappings.';
    })();
    const interfaceNoticeClass = (() => {
        if (!hitlAuthReady) return 'alert-warning';
        if (!hitlToggleWasEnabled) return 'alert-info';
        if (!coreVmKey) return 'alert-info';
        if (!coreVmHasInterfaces) return 'alert-danger';
        if (!coreVmSupportsHitl) return 'alert-warning';
        return 'alert-info';
    })();
    const externalVmCandidates = proxInventory.filter(vm => {
        const vmKey = `${vm.node ?? ''}::${vm.vmid ?? ''}`;
        if (vmKey === coreVmKey) return false;
        if (!coreVmNode) return false;
        const vmNode = vm && vm.node !== undefined && vm.node !== null ? String(vm.node).trim() : '';
        return vmNode && vmNode === coreVmNode;
    });
    const step4BaseEnabled = step3Enabled && proxValidated && !!coreVmKey && hitlAuthReady;
    const step4HasCandidates = externalVmCandidates.length > 0;
    const step4Enabled = step4BaseEnabled && step4HasCandidates;
    const step4PrereqItems = [
        {
            ok: hitlAuthReady,
            label: hitlAuthReady ? 'Steps 1 and 2 authenticated' : 'Validate Proxmox (Step 1) and CORE credentials (Step 2)',
        },
        {
            ok: step3Enabled,
            label: step3Enabled ? 'Hardware in the Loop toggle is enabled' : 'Enable the Hardware in the Loop toggle in Step 3',
        },
        {
            ok: hasHitlInterfaces,
            label: hasHitlInterfaces ? 'At least one HITL interface selected in Step 3' : 'Add a HITL interface in Step 3',
        },
        {
            ok: proxValidated,
            label: proxValidated ? 'Proxmox credentials are validated' : 'Validate the Proxmox credentials (Step 1)',
        },
        {
            ok: !!coreVmKey,
            label: coreVmKey ? 'CORE VM selected in Step 2' : 'Select a CORE VM in Step 2',
        },
        {
            ok: !proxInventoryBusy,
            label: proxInventoryBusy ? 'Wait for the Proxmox inventory fetch to finish' : 'Proxmox inventory fetch complete',
        },
        {
            ok: !proxInventoryError,
            label: proxInventoryError ? `Resolve Proxmox inventory error: ${proxInventoryError}` : 'Proxmox inventory is available',
        },
    ];
    const step4BlockingItems = step4PrereqItems.filter(item => !item.ok);
    const step4PrereqList = step4BlockingItems.map(item => {
        const icon = '❌';
        const toneClass = 'text-danger';
        return `<li class="${toneClass}">${icon} ${escapeHtml(item.label)}</li>`;
    }).join('');
    const step4PrereqHtml = step4BlockingItems.length
        ? `<div class="alert alert-info small mt-2 mb-0"><div class="fw-semibold">Step 4 prerequisites</div><ul class="mb-0 ps-3" style="list-style: none;">${step4PrereqList}</ul></div>`
        : '';
    const availableSize = Math.min(8, Math.max(4, hostInterfaces.length || 4));
    const gateShouldHide = step3Enabled && coreReady && hitlAuthReady;
    const interfacesGateNotice = `<div class="alert ${interfaceNoticeClass} small mb-3 ${gateShouldHide ? 'd-none' : ''}" data-hitl-interface-gate="${activeIdx}">${interfaceNoticeText}</div>`;
    const allowStep3RefreshUi = !!hitlAuthReady;
    const interfacesRefreshBusyRaw = core.interfaces_refresh_inflight === true;
    const interfacesRefreshBusy = allowStep3RefreshUi ? interfacesRefreshBusyRaw : false;
    const lastInterfacesError = core.last_interfaces_error || '';
    const lastInterfacesAttempt = core.last_interfaces_attempt || '';
    const lastInterfacesRefresh = core.last_interfaces_refresh || '';
    const availableSelectDisabledAttr = (coreReady && step3Enabled) ? '' : 'disabled';
    const addInterfacesDisabledAttr = (coreReady && step3Enabled && availableInterfaces.length && !interfacesRefreshBusy) ? '' : 'disabled';
    const refreshInterfacesDisabledAttr = (step3Enabled && !interfacesRefreshBusy) ? '' : 'disabled';
    const removeInterfaceDisabledAttr = step3Enabled ? '' : 'disabled';
    const refreshButtonLabel = interfacesRefreshBusy
        ? '<span class="spinner-border spinner-border-sm me-2" role="status" aria-hidden="true"></span>Refreshing…'
        : 'Refresh list';
    const retryButtonLabel = interfacesRefreshBusy
        ? '<span class="spinner-border spinner-border-sm me-2" role="status" aria-hidden="true"></span>Refreshing…'
        : 'Refresh CORE VM Interfaces';
    const refreshStatusText = (() => {
        if (interfacesRefreshBusy) return 'Enumerating interfaces…';
        if (lastInterfacesRefresh) {
            const rel = describeTimestampRelative(lastInterfacesRefresh);
            const relSafe = rel ? escapeHtml(rel) : null;
            const exact = (() => {
                try { return escapeHtml(new Date(lastInterfacesRefresh).toLocaleString()); }
                catch (err) { return null; }
            })();
            const parts = [];
            if (relSafe) parts.push(`Last refreshed ${relSafe}`);
            if (!relSafe && exact) parts.push(`Last refreshed ${exact}`);
            if (relSafe && exact && relSafe !== exact) parts.push(`(${exact})`);
            if (!parts.length && exact) parts.push(`Last refreshed ${exact}`);
            if (!parts.length) parts.push('Interfaces cached from previous run.');
            const source = state.host_interfaces_source ? `Source: ${escapeHtml(String(state.host_interfaces_source))}` : '';
            if (source) parts.push(source);
            return parts.join(' • ');
        }
        if (lastInterfacesAttempt) {
            const rel = describeTimestampRelative(lastInterfacesAttempt);
            if (rel) return `Last attempt ${escapeHtml(rel)}`;
        }
        return '';
    })();
    const refreshStatusHtml = refreshStatusText ? `<div class="small text-muted mt-1" data-hitl-refresh-status="${activeIdx}">${refreshStatusText}</div>` : '';
    const interfacesEmptyMessage = (() => {
        if (!hitlAuthReady) {
            if (!proxValidated) return '<div class="alert alert-info mb-0">Validate Proxmox credentials in Step 1 to unlock HITL interfaces.</div>';
            if (!coreHasSecret) return '<div class="alert alert-info mb-0">Store CORE credentials in Step 2 to unlock HITL interfaces.</div>';
            if (!coreVmKey) return '<div class="alert alert-info mb-0">Select a CORE VM in Step 2 to unlock HITL interfaces.</div>';
        }
        if (interfacesRefreshBusy) {
            return '<div class="alert alert-info mb-0">Enumerating interfaces from CORE…</div>';
        }
        if (lastInterfacesError) {
            const rel = describeTimestampRelative(lastInterfacesAttempt);
            const detail = rel ? ` <span class="text-muted">(Last attempt ${escapeHtml(rel)})</span>` : '';
            return `<div class="alert alert-danger mb-0">${escapeHtml(lastInterfacesError)}${detail}</div>`;
        }
        if (lastInterfacesAttempt) {
            const rel = describeTimestampRelative(lastInterfacesAttempt);
            const label = rel ? ` ${escapeHtml(rel)}` : ' previously';
            return `<div class="alert alert-warning mb-0">No interfaces were reported during the last refresh${label}. Verify the CORE VM has multiple adapters and try again.</div>`;
        }
        return '<div class="alert alert-info mb-0">Refresh to load interfaces from the CORE VM.</div>';
    })();
    const externalVmRowsHtml = (() => {
        if (!hasHitlInterfaces || !step3Enabled || (Array.isArray(hostInterfaces) && hostInterfaces.length === 0)) {
            return '<div class="text-muted small">Complete Step 3 (enable HITL and add at least one interface) to configure external connectivity.</div>';
        }
        if (!externalVmCandidates.length) {
            if (!coreVmNode) {
                return '<div class="alert alert-warning small mb-0">Unable to determine the CORE VM\'s Proxmox node. Refresh the inventory so external VMs on the same node can be suggested.</div>';
            }
            const nodeHint = ` on node ${escapeHtml(coreVmNode)}`;
            return `<div class="alert alert-warning small mb-0">No eligible Proxmox VMs${nodeHint} detected that share the CORE VM's node. Refresh the inventory after provisioning additional VMs on the same node.</div>`;
        }
        return hitlInterfaces.map((iface, ifaceIdx) => {
            if (!iface || typeof iface !== 'object') return '';
            const safeName = escapeHtml(iface.name || `Interface ${ifaceIdx + 1}`);
            const selectedExternal = (iface.external_vm && typeof iface.external_vm === 'object') ? iface.external_vm : null;
            const selectedKey = selectedExternal?.vm_key ? String(selectedExternal.vm_key) : '';
            const vmOptionMarkup = externalVmCandidates
                .filter(vm => `${vm.node ?? ''}::${vm.vmid ?? ''}` !== coreVmKey)
                .map(vm => {
                    const vmKey = `${vm.node ?? ''}::${vm.vmid ?? ''}`;
                    const ifaceCount = getPhysicalVmInterfaces(vm).length;
                    const vmName = vm.name ? String(vm.name) : `VM ${vm.vmid}`;
                    const labelParts = [`${vmName} (${ifaceCount} interface${ifaceCount === 1 ? '' : 's'})`];
                    if (vm.node) labelParts.push(`node ${vm.node}`);
                    if (vm.status) labelParts.push(`status ${vm.status}`);
                    return {
                        key: vmKey,
                        label: labelParts.join(' — '),
                        ifaceCount,
                        selected: vmKey === selectedKey,
                    };
                })
                .sort((a, b) => {
                    if (b.ifaceCount !== a.ifaceCount) return b.ifaceCount - a.ifaceCount;
                    const nameA = a.label.toLowerCase();
                    const nameB = b.label.toLowerCase();
                    if (nameA < nameB) return -1;
                    if (nameA > nameB) return 1;
                    return 0;
                })
                .map(option => `<option value="${escapeHtml(option.key)}" ${option.selected ? 'selected' : ''}>${escapeHtml(option.label)}</option>`);
            const selectDisabledAttr = step4Enabled ? '' : 'disabled';
            const selectedVm = selectedKey ? proxInventory.find(vm => `${vm.node ?? ''}::${vm.vmid ?? ''}` === selectedKey) : null;
            const physicalInterfaces = selectedVm ? getPhysicalVmInterfaces(selectedVm) : [];
            const physicalInterfacesSummary = selectedVm ? summarizePhysicalVmInterfaces(selectedVm) : '';
            const selectedIfaceId = selectedExternal?.interface_id ? String(selectedExternal.interface_id).trim() : '';
            const interfaceOptionList = physicalInterfaces.map(vmIface => {
                const ifaceId = normalizeVmInterfaceId(vmIface);
                const desc = describeVmInterface(vmIface);
                const label = desc ? `${ifaceId} — ${desc}` : ifaceId;
                return `<option value="${escapeHtml(ifaceId)}" ${ifaceId === selectedIfaceId ? 'selected' : ''}>${escapeHtml(label)}</option>`;
            });
            if (selectedIfaceId && !physicalInterfaces.some(vmIface => normalizeVmInterfaceId(vmIface) === selectedIfaceId)) {
                interfaceOptionList.unshift(`<option value="${escapeHtml(selectedIfaceId)}" selected>${escapeHtml(`${selectedIfaceId} (not detected)`)}</option>`);
            }
            const interfaceOptionsMarkup = ['<option value="">Select interface…</option>', ...interfaceOptionList].join('');
            const interfaceSelectDisabledAttr = (step4BaseEnabled && !!selectedKey) ? '' : 'disabled';
            const refreshExternalInterfacesDisabledAttr = (step4BaseEnabled && !!selectedKey && !proxInventoryBusy) ? '' : 'disabled';
            const helperParts = [];
            if (selectedExternal?.vm_name) helperParts.push(String(selectedExternal.vm_name));
            if (selectedExternal?.vm_node) helperParts.push(`node ${selectedExternal.vm_node}`);
            if (selectedExternal?.vmid !== undefined && selectedExternal?.vmid !== null && selectedExternal.vmid !== '') {
                helperParts.push(`ID ${selectedExternal.vmid}`);
            }
            if (selectedExternal?.interface_id) helperParts.push(`iface ${selectedExternal.interface_id}`);
            const helperHtml = helperParts.length ? `<div class="form-text">Selected: ${escapeHtml(helperParts.join(' • '))}</div>` : '';
            const interfaceSummaryParts = [];
            if (selectedExternal?.interface_bridge) interfaceSummaryParts.push(`bridge ${selectedExternal.interface_bridge}`);
            if (selectedExternal?.interface_mac) interfaceSummaryParts.push(selectedExternal.interface_mac);
            if (selectedExternal?.interface_model) interfaceSummaryParts.push(selectedExternal.interface_model);
            const interfaceSummaryHtml = interfaceSummaryParts.length ? `<div class="form-text">${escapeHtml(interfaceSummaryParts.join(' • '))}</div>` : '';
            const availableInterfacesHint = physicalInterfacesSummary ? `<div class="form-text text-muted">Physical interfaces: ${escapeHtml(physicalInterfacesSummary)}</div>` : '';
            let interfaceFooterHtml = '';
            if (!selectedKey) {
                interfaceFooterHtml = '<div class="form-text text-muted">Select a VM to choose its interface.</div>';
            } else if (!physicalInterfaces.length) {
                interfaceFooterHtml = '<div class="alert alert-warning small mt-2 mb-0">No physical interfaces detected on this VM (bridged adapters only).</div>';
            } else if (!selectedIfaceId) {
                interfaceFooterHtml = '<div class="form-text text-muted">Select the interface that should connect through this HITL link.</div>';
            }
            return `
                <div class="border rounded p-2 mb-2">
                    <div class="fw-semibold mb-1">CORE VM IFX Mapping: ${safeName}</div>
                    <label class="form-label small mb-1" for="hitlExternalVm_${activeIdx}_${ifaceIdx}">Participant VM</label>
                    <select class="form-select form-select-sm" id="hitlExternalVm_${activeIdx}_${ifaceIdx}" data-hitl-external-vm-select data-scen-idx="${activeIdx}" data-iface-index="${ifaceIdx}" ${selectDisabledAttr}>
                        <option value="">Select VM…</option>
                        ${vmOptionMarkup.join('')}
                    </select>
                    ${helperHtml}
                    <label class="form-label small mb-1 mt-2" for="hitlExternalVmIface_${activeIdx}_${ifaceIdx}">VM Interface</label>
                    <select class="form-select form-select-sm" id="hitlExternalVmIface_${activeIdx}_${ifaceIdx}" data-hitl-external-vm-iface-select data-scen-idx="${activeIdx}" data-iface-index="${ifaceIdx}" ${interfaceSelectDisabledAttr}>
                        ${interfaceOptionsMarkup}
                    </select>
                    <div class="d-flex flex-wrap gap-2 mt-2">
                        <button type="button" class="btn btn-sm btn-outline-secondary" data-hitl-step4-refresh data-scen-idx="${activeIdx}" data-iface-index="${ifaceIdx}" ${refreshExternalInterfacesDisabledAttr}>Refresh interfaces</button>
                    </div>
                    ${availableInterfacesHint}
                    ${interfaceSummaryHtml}
                    ${interfaceFooterHtml}
                </div>`;
        }).join('');
    })();
    const step4Content = (() => {
        if (!hasHitlInterfaces) {
            return '<div class="alert alert-info small mb-0">Add at least one HITL interface in Step 3 to configure external connectivity.</div>' + step4PrereqHtml;
        }
        if (!hitl.enabled) {
            return '<div class="alert alert-info small mb-0">Enable Hardware in the Loop to configure external connectivity.</div>' + step4PrereqHtml;
        }
        if (!proxValidated) {
            return '<div class="alert alert-warning small mb-0">Validate Proxmox credentials to load eligible VMs.</div>' + step4PrereqHtml;
        }
        if (proxInventoryBusy) {
            return '<div class="small text-muted">Loading Proxmox VM inventory…</div>' + step4PrereqHtml;
        }
        if (proxInventoryError) {
            return `<div class="alert alert-danger small mb-0">${escapeHtml(proxInventoryError)}</div>` + step4PrereqHtml;
        }
        if (!coreVmKey) {
            return '<div class="alert alert-warning small mb-0">Select a CORE VM in Step 2 before configuring external connectivity.</div>' + step4PrereqHtml;
        }
        if (!step4HasCandidates) {
            return externalVmRowsHtml + step4PrereqHtml;
        }
        return externalVmRowsHtml + step4PrereqHtml;
    })();
    const selectedInterfacesHtml = (hitl.interfaces && hitl.interfaces.length)
        ? hitl.interfaces.map((iface, ifaceIdx) => {
            const safeName = escapeHtml(iface.name || 'interface');
            const hostInfo = hostLookup.get(iface.name);
            const proxMapping = hostInfo && typeof hostInfo.proxmox === 'object' ? hostInfo.proxmox : null;
            const summary = describeIface(hostInfo || iface);
            const missingBadge = hostInfo ? '' : '<span class="badge rounded-pill text-bg-warning">Not detected</span>';
            const vmbrBadge = isVmbr0Bridge(hostInfo || iface) ? '<span class="badge rounded-pill text-bg-warning">vmbr0</span>' : '';
            const proxBadge = (() => {
                if (!proxMapping) return '';
                const vmName = proxMapping.vm_name || proxMapping.raw?.vm_name || proxMapping.raw?.name || '';
                const ifaceId = proxMapping.id || proxMapping.raw?.id || proxMapping.raw?.interface_id || '';
                const node = proxMapping.vm_node || proxMapping.raw?.node || '';
                const labelParts = [];
                if (vmName) labelParts.push(vmName);
                if (ifaceId) labelParts.push(ifaceId);
                if (node) labelParts.push(`node ${node}`);
                if (!labelParts.length && proxMapping.macaddr) labelParts.push(proxMapping.macaddr);
                const badgeLabel = labelParts.length ? labelParts.join(' • ') : 'Proxmox match';
                return `<span class="badge rounded-pill text-bg-info">${escapeHtml(badgeLabel)}</span>`;
            })();
            const summaryHtml = summary ? escapeHtml(summary) : 'No address information available';
            const attachmentValue = normalizeHitlAttachment(iface.attachment);
            const attachmentLabel = escapeHtml(prettyHitlAttachment(attachmentValue));
            const optionsMarkup = HITL_ATTACHMENT_CHOICES
                .map(opt => `<option value="${opt.value}" ${opt.value === attachmentValue ? 'selected' : ''}>${escapeHtml(opt.label)}</option>`)
                .join('');
            return `<div class="border rounded p-2 mb-2 d-flex justify-content-between align-items-start gap-2 flex-wrap">
                        <div class="flex-grow-1">
                            <div class="fw-semibold d-flex align-items-center gap-2 flex-wrap">${safeName}${missingBadge}${vmbrBadge}${proxBadge}<span class="badge rounded-pill text-bg-secondary">${attachmentLabel}</span></div>
                            <div class="small text-muted">${summaryHtml}</div>
                            <div class="mt-2">
                                <label class="form-label small mb-1" for="hitlAttach_${activeIdx}_${ifaceIdx}">Attach to</label>
                                <select class="form-select form-select-sm" id="hitlAttach_${activeIdx}_${ifaceIdx}" data-hitl-attach data-scen-idx="${activeIdx}" data-iface-index="${ifaceIdx}" ${attachmentControlsDisabledAttr}>
                                    ${optionsMarkup}
                                </select>
                            </div>
                        </div>
                        <button type="button" class="btn btn-sm btn-outline-danger" data-hitl-remove data-scen-idx="${activeIdx}" data-iface="${safeName}" ${removeInterfaceDisabledAttr}>Remove</button>
                    </div>`;
        }).join('')
        : '<div class="text-muted small">No interfaces selected.</div>';
    const hitlCard = document.createElement('div');
    hitlCard.id = 'scenarioHitlCard';
    hitlCard.className = 'card mb-3';
    const hitlInterfacesMarkup = hostInterfaces.length
        ? `
            ${interfacesGateNotice}
            <div class="row g-3">
                <div class="col-md-6">
                    <label class="form-label">Available interfaces</label>
                    <select class="form-select" multiple size="${availableSize}" data-hitl-available data-scen-idx="${activeIdx}" id="hitlAvailable_${activeIdx}" ${availableSelectDisabledAttr}>
                        ${availableOptionsHtml}
                    </select>
                    <div class="d-flex flex-wrap gap-2 mt-2">
                        <button type="button" class="btn btn-sm btn-outline-primary" data-hitl-add data-scen-idx="${activeIdx}" ${addInterfacesDisabledAttr}>Add selected</button>
                        <button type="button" class="btn btn-sm btn-outline-secondary" data-hitl-refresh data-scen-idx="${activeIdx}" ${refreshInterfacesDisabledAttr} ${interfacesRefreshBusy ? 'data-refresh-busy="1"' : ''}>${refreshButtonLabel}</button>
                    </div>
                    <div class="form-text">Use ⌘/Ctrl to multi-select before adding.</div>
                    ${refreshStatusHtml}
                    ${!hasHitlInterfaces ? '<div class="alert alert-info small mt-3 mb-0">Add at least one interface to enable CORE VM IFX mapping.</div>' : ''}
                </div>
                ${hasHitlInterfaces ? `
                <div class="col-md-6">
                    <label class="form-label">Selected interfaces</label>
                    <div id="hitlSelected_${activeIdx}">
                        ${selectedInterfacesHtml}
                    </div>
                </div>` : ''}
            </div>`
        : `
            <div class="d-flex flex-column gap-3">
                ${interfacesEmptyMessage}
                <div>
                    <button type="button" class="btn btn-sm btn-outline-secondary" data-hitl-refresh data-scen-idx="${activeIdx}" ${refreshInterfacesDisabledAttr} ${interfacesRefreshBusy ? 'data-refresh-busy="1"' : ''}>${retryButtonLabel}</button>
                </div>
            </div>`;

    let coreVmOptionsMarkup = '';
    if (proxInventory.length) {
        const optionList = proxInventory.map(vm => {
            const vmKey = `${vm.node ?? ''}::${vm.vmid ?? ''}`;
            const vmDisplayName = vm.name ? String(vm.name) : `VM ${vm.vmid}`;
            const ifaceCount = Array.isArray(vm.interfaces) ? vm.interfaces.length : 0;
            const parts = [vmDisplayName];
            if (vm.node) parts.push(`node ${vm.node}`);
            if (vm.status) parts.push(`status ${vm.status}`);
            if (vm.vmid !== undefined && vm.vmid !== null) parts.push(`ID ${vm.vmid}`);
            if (ifaceCount) parts.push(`${ifaceCount} interface${ifaceCount === 1 ? '' : 's'}`);
            return `<option value="${escapeHtml(vmKey)}" ${vmKey === coreVmKey ? 'selected' : ''}>${escapeHtml(parts.join(' — '))}</option>`;
        });
        coreVmOptionsMarkup = ['<option value="">Select VM…</option>', ...optionList].join('');
    } else {
        coreVmOptionsMarkup = '<option value="">No VMs available</option>';
    }

    const selectedCoreVmDetailsHtml = (() => {
        if (!coreVmKey || !selectedCoreVm) {
            return '';
        }
        const name = escapeHtml(selectedCoreVm.name ? String(selectedCoreVm.name) : `VM ${selectedCoreVm.vmid}`);
        const node = escapeHtml(selectedCoreVm.node ? String(selectedCoreVm.node) : '—');
        const status = selectedCoreVm.status ? escapeHtml(String(selectedCoreVm.status)) : null;
        const vmid = selectedCoreVm.vmid !== undefined && selectedCoreVm.vmid !== null ? escapeHtml(String(selectedCoreVm.vmid)) : '—';
        const ifaceCount = Array.isArray(selectedCoreVm.interfaces) ? selectedCoreVm.interfaces.length : 0;
        const ifaceInfo = ifaceCount ? `${ifaceCount} interface${ifaceCount === 1 ? '' : 's'}` : 'No interfaces reported';
        const ifaceLabel = escapeHtml(ifaceInfo);
        return `
            <div class="border rounded p-3 bg-light small">
                <div class="d-flex justify-content-between align-items-center mb-2">
                    <span class="fw-semibold">${name}</span>
                    ${status ? `<span class="badge text-bg-secondary text-uppercase">${status}</span>` : ''}
                </div>
                <dl class="row mb-0">
                    <dt class="col-5 text-muted">Node</dt><dd class="col-7">${node}</dd>
                    <dt class="col-5 text-muted">VM ID</dt><dd class="col-7">${vmid}</dd>
                    <dt class="col-5 text-muted">Interfaces</dt><dd class="col-7">${ifaceLabel}</dd>
                </dl>
            </div>`;
    })();

    const coreStoredSummary = (core.stored_summary && typeof core.stored_summary === 'object') ? core.stored_summary : null;
    const coreStoredAtRaw = core.last_validated_at || (coreStoredSummary && coreStoredSummary.stored_at) || '';
    const testedAtDisplay = core.last_tested_at ? (() => {
        try { return new Date(core.last_tested_at).toLocaleString(); } catch (err) { return null; }
    })() : null;
    const storedAtDisplay = coreStoredAtRaw ? (() => {
        try { return new Date(coreStoredAtRaw).toLocaleString(); } catch (err) { return null; }
    })() : null;
    let coreStatusText = '';
    let coreStatusClass = 'text-muted';
    if (!proxValidated) {
        coreStatusText = 'Validate Proxmox credentials to choose a CORE VM.';
    } else if (!coreVmKey) {
        coreStatusText = 'Select a CORE VM to configure connection details.';
    } else if (!coreVmHasInterfaces) {
        coreStatusText = `Selected CORE VM exposes ${vmInterfaceCount || 0} network interface${vmInterfaceCount === 1 ? '' : 's'}. Add at least one interface to enable CORE connectivity.`;
        coreStatusClass = 'text-danger';
    } else if (!coreInputsComplete) {
        coreStatusText = 'Use Configure Connection to enter gRPC and SSH details, including credentials.';
        coreStatusClass = 'text-warning';
    } else if (!coreVmSupportsHitl) {
        if (coreHitlBlocked) {
            const vmNote = coreVmName ? ` • ${coreVmName}` : '';
            const storedNote = storedAtDisplay ? ` • Credentials stored ${storedAtDisplay}` : '';
            coreStatusText = `CORE connection verified${testedAtDisplay ? ` • Last tested ${testedAtDisplay}` : ''}${vmNote}${storedNote}. Add a second interface before enabling HITL mappings in Step 3.`;
        } else {
            coreStatusText = 'Selected CORE VM exposes only one interface. Add a second interface before enabling HITL mappings in Step 3.';
        }
        coreStatusClass = 'text-warning';
    } else if (coreReady) {
        const storedNote = storedAtDisplay ? ` • Credentials stored ${storedAtDisplay}` : '';
        const vmNote = coreVmName ? ` • ${coreVmName}` : '';
        coreStatusText = `CORE connection verified${testedAtDisplay ? ` • Last tested ${testedAtDisplay}` : ''}${vmNote}${storedNote}`;
        coreStatusClass = 'text-success';
    } else if (coreHasSecret && coreTestSuccess) {
        coreStatusText = 'Stored CORE credentials available. Re-test if connection details changed.';
        coreStatusClass = 'text-warning';
    } else if (core.last_tested_status === 'failure') {
        coreStatusText = core.last_tested_message ? `Last test failed: ${core.last_tested_message}` : 'CORE connection test failed.';
        coreStatusClass = 'text-danger';
    } else if (core.last_tested_status === 'success') {
        coreStatusText = 'CORE connection test succeeded for a different endpoint. Update details or re-test.';
        coreStatusClass = 'text-warning';
    } else {
        coreStatusText = 'Test the CORE connection to continue.';
        coreStatusClass = 'text-warning';
    }
    const coreStatusHtml = escapeHtml(coreStatusText);
    const coreInputsDisabled = !(proxValidated && coreVmKey);
    const testBtnDisabledAttr = coreTestable ? '' : 'disabled';
    const configureBtnDisabledAttr = (!coreVmKey || !proxValidated || proxInventoryBusy) ? 'disabled' : '';
        const coreConnectionSummaryHtml = (() => {
        const summarizeEndpoint = () => {
            if (!coreVmKey) return '';
            const grpcLabel = coreHost ? `${escapeHtml(coreHost)}:${corePort}` : '<span class="text-danger">Not set</span>';
            const sshHostLabel = coreSshHost ? escapeHtml(coreSshHost) : '<span class="text-danger">Not set</span>';
            const sshPortLabel = coreSshPort ? String(coreSshPort) : '<span class="text-danger">Not set</span>';
            const sshUserLabel = coreUser ? escapeHtml(coreUser) : '<span class="text-danger">Not set</span>';
            const pwdLabel = coreHasSecret
                ? '<span class="text-success">Stored securely</span>'
                : (corePasswordRaw ? '<span class="text-success">Provided</span>' : '<span class="text-danger">Not set</span>');
            return `
                <dl class="row small mb-0">
                    <dt class="col-5 text-muted">gRPC Endpoint</dt><dd class="col-7">${grpcLabel}</dd>
                    <dt class="col-5 text-muted">SSH Host</dt><dd class="col-7">${sshHostLabel}</dd>
                    <dt class="col-5 text-muted">SSH Port</dt><dd class="col-7">${sshPortLabel}</dd>
                    <dt class="col-5 text-muted">SSH Username</dt><dd class="col-7">${sshUserLabel}</dd>
                    <dt class="col-5 text-muted">Password</dt><dd class="col-7">${pwdLabel}</dd>
                </dl>`;
        };
        return `
            <div class="border rounded p-3 bg-light-subtle">
                <h6 class="text-uppercase small mb-2">Connection</h6>
                ${summarizeEndpoint()}
            </div>`;
    })();

    const hitlBody = `
        <div class="mb-4">
            <h6 class="mb-2">Step 1 — Proxmox Resource</h6>
            <div class="d-flex flex-wrap align-items-center justify-content-between gap-2">
                <div class="${proxSummaryClass} small" data-proxmox-summary="${activeIdx}">${proxSummaryHtml}</div>
                <div class="d-flex flex-wrap align-items-center gap-2">
                    <span class="badge rounded-pill text-bg-info" data-proxmox-refresh-badge="${activeIdx}" style="${proxInventoryBusy ? '' : 'display:none;'}">Refreshing vm list</span>
                    <button type="button" class="btn btn-sm btn-outline-primary" data-proxmox-assign data-scen-idx="${activeIdx}">${proxAssignLabel}</button>
                    <button type="button" class="btn btn-sm btn-outline-secondary" data-proxmox-refresh data-scen-idx="${activeIdx}" ${proxRefreshDisabledAttr}>Refresh VM List</button>
                    <button type="button" class="btn btn-sm btn-outline-danger" data-proxmox-clear data-scen-idx="${activeIdx}" ${proxHasAny ? '' : 'disabled'}>Clear Proxmox Resource</button>
                </div>
            </div>
            <div class="small text-muted mt-2" data-proxmox-inventory-status="${activeIdx}">${proxInventoryStatusHtml}</div>
        </div>
        <div class="mb-4">
            <div class="d-flex justify-content-between align-items-center gap-2 mb-2">
                <h6 class="m-0">Step 2 — CORE VM &amp; Credentials</h6>
                <button type="button" class="btn btn-sm btn-outline-secondary" data-hitl-core-clear data-scen-idx="${activeIdx}" ${(coreVmKey || coreHost || coreUser || coreHasSecret) ? '' : 'disabled'}>Clear CORE Settings</button>
            </div>
            ${!proxValidated
                ? '<div class="alert alert-warning small mb-0">Validate Proxmox credentials to unlock CORE VM selection.</div>'
                : proxInventoryBusy
                    ? '<div class="small text-muted">Loading Proxmox VM inventory…</div>'
                    : proxInventoryError
                        ? `<div class="alert alert-danger small mb-3">${escapeHtml(proxInventoryError)}</div>`
                        : ''}
            ${proxValidated && !proxInventoryBusy && !proxInventoryError
                ? `
                    <div class="row g-3 align-items-start">
                        <div class="col-md-6">
                            <label class="form-label small" for="hitlCoreVm_${activeIdx}">CORE VM</label>
                            <select class="form-select form-select-sm mt-1" id="hitlCoreVm_${activeIdx}" data-hitl-core-vm-select data-scen-idx="${activeIdx}" ${proxInventory.length && !proxInventoryBusy ? '' : 'disabled'}>
                                ${coreVmOptionsMarkup}
                            </select>
                            <button type="button" class="btn btn-sm btn-outline-primary mt-2" data-hitl-core-configure data-scen-idx="${activeIdx}" ${configureBtnDisabledAttr}>Configure Connection</button>
                            ${coreVmInterfaceWarning}
                        </div>
                        <div class="col-md-6">
                            <div data-hitl-core-summary="${activeIdx}">${selectedCoreVmDetailsHtml}</div>
                        </div>
                    </div>
                    <div class="mt-3" data-hitl-core-connection="${activeIdx}">${coreConnectionSummaryHtml}</div>
                    <div class="d-flex flex-wrap gap-2 mt-3">
                        <button type="button" class="btn btn-sm btn-outline-primary" data-hitl-core-test data-scen-idx="${activeIdx}" ${testBtnDisabledAttr}>Test CORE Connection</button>
                    </div>
                    <div class="small mt-2 ${coreStatusClass}" data-hitl-core-status="${activeIdx}">${coreStatusHtml}</div>
                ` : ''}
        </div>
        <div class="mb-4">
            <div class="d-flex justify-content-between align-items-center gap-2 mb-2">
                <h6 class="m-0">Step 3 — Hardware in the Loop</h6>
                <div class="form-check form-switch m-0" ${step3ToggleTooltipAttr}>
                    <input class="form-check-input" type="checkbox" id="hitlToggle_${activeIdx}" data-hitl-toggle data-scen-idx="${activeIdx}" ${step3ToggleCheckedAttr} ${step3ToggleDisabledAttr}>
                    <label class="form-check-label small" for="hitlToggle_${activeIdx}">Enable</label>
                </div>
            </div>
            ${(!hitlAuthReady && hitlToggleWasEnabled) ? '<div class="alert alert-warning py-2 px-3 small mb-3">HITL remains disabled until Steps 1 and 2 are authenticated again.</div>' : ''}
            <fieldset class="hitl-step-fieldset ${step3Disabled ? 'hitl-step-disabled' : ''}" ${step3Disabled ? 'disabled' : ''} data-hitl-step3-body>
                ${hitlInterfacesMarkup}
            </fieldset>
        </div>
        <div>
            <h6 class="mb-2">Step 4 — CTF Participant VM</h6>
            <div class="form-text mb-2">Choose a VM that will connect a participant to the scenario.</div>
            <fieldset class="hitl-step-fieldset ${step3Disabled ? 'hitl-step-disabled' : ''}" ${step3Disabled ? 'disabled' : ''} data-hitl-step4-body>
                ${step4Content}
            </fieldset>
            ${(() => {
                const applyDisabledAttr = (step4BlockingItems.length === 0) ? '' : 'disabled';
                return `
                    <div class="d-flex justify-content-end mt-2">
                        <button type="button" class="btn btn-primary" data-hitl-apply data-scen-idx="${activeIdx}" ${applyDisabledAttr}>Apply</button>
                    </div>`;
            })()}
        </div>`;
    hitlCard.innerHTML = `
        <div class="card-body">
            ${hitlBody}
            <div class="small text-muted mt-3" data-hitl-status="${activeIdx}"></div>
        </div>`;
    const ifxHitlContainer = document.getElementById('externalIfxHitlContainer');
    if (ifxHitlContainer) {
        ifxHitlContainer.appendChild(hitlCard);
    } else if (baseScenarioCard && baseScenarioCard.parentNode) {
        baseScenarioCard.parentNode.insertBefore(hitlCard, baseScenarioCard);
    } else {
        root.appendChild(hitlCard);
    }

    if (typeof setupPreviewCollapsers === 'function') {
        setupPreviewCollapsers();
    }

    try { updateProxmoxSummary(activeIdx); } catch (err) { console.warn('Failed to refresh Proxmox summary', err); }

    toggleExternalIfxModalBusy(proxInventoryFetchInFlight.size > 0);

    updateHitlStatusForScenario(activeIdx);
    // Prefer previously selected/available interfaces when Steps 1 and 2 are validated.
    // Only consider auto-refresh when explicitly enabled and no prior data exists.
    const shouldAutoRefreshHostIfx = HOST_INTERFACES_AUTO_REFRESH_ENABLED
        && !(hitlAuthReady && (hostInterfaces.length > 0 || hasHitlInterfaces));
    if (shouldAutoRefreshHostIfx) {
        scheduleAutoRefreshHostInterfaces(activeIdx);
    }

    const refreshCoreConnectionModal = (sidx) => {
        if (!coreConnectionModal) return;
        const scenario = state.scenarios?.[sidx];
        if (!scenario) return;
        const hitlState = ensureHitlStateForScenario(scenario);
        const proxState = hitlState.proxmox || {};
        const coreState = hitlState.core || (hitlState.core = {});
        const proxValidatedForScenario = !!(proxState.validated && proxState.secret_id);
        const hasVmSelection = !!coreState.vm_key;
        const inputsDisabled = !(proxValidatedForScenario && hasVmSelection);
        coreConnectionModal.setAttribute('data-scen-idx', String(sidx));
        if (coreConnectionForm) {
            coreConnectionForm.classList.remove('was-validated');
        }
        if (coreModalInputs.grpc_host) {
            coreModalInputs.grpc_host.value = coreState.grpc_host || '';
            coreModalInputs.grpc_host.disabled = inputsDisabled;
            coreModalInputs.grpc_host.setAttribute('data-scen-idx', String(sidx));
        }
        if (coreModalInputs.grpc_port) {
            const port = Number.isFinite(Number(coreState.grpc_port)) && Number(coreState.grpc_port) > 0 ? Number(coreState.grpc_port) : 50051;
            coreModalInputs.grpc_port.value = port;
            coreModalInputs.grpc_port.disabled = inputsDisabled;
            coreModalInputs.grpc_port.setAttribute('data-scen-idx', String(sidx));
        }
        if (coreModalInputs.ssh_host) {
            coreModalInputs.ssh_host.value = coreState.ssh_host || '';
            coreModalInputs.ssh_host.disabled = inputsDisabled;
            coreModalInputs.ssh_host.setAttribute('data-scen-idx', String(sidx));
        }
        if (coreModalInputs.ssh_port) {
            const sshPort = Number.isFinite(Number(coreState.ssh_port)) && Number(coreState.ssh_port) > 0 ? Number(coreState.ssh_port) : 22;
            coreModalInputs.ssh_port.value = sshPort;
            coreModalInputs.ssh_port.disabled = inputsDisabled;
            coreModalInputs.ssh_port.setAttribute('data-scen-idx', String(sidx));
        }
        if (coreModalInputs.ssh_username) {
            coreModalInputs.ssh_username.value = coreState.ssh_username || '';
            coreModalInputs.ssh_username.disabled = inputsDisabled;
            coreModalInputs.ssh_username.setAttribute('data-scen-idx', String(sidx));
        }
        if (coreModalInputs.ssh_password) {
            const pwdVal = coreState.ssh_password || '';
            coreModalInputs.ssh_password.value = pwdVal;
            if (coreState.core_secret_id && !pwdVal) {
                coreModalInputs.ssh_password.setAttribute('placeholder', 'Stored securely');
            } else {
                coreModalInputs.ssh_password.removeAttribute('placeholder');
            }
            coreModalInputs.ssh_password.disabled = inputsDisabled;
            coreModalInputs.ssh_password.setAttribute('data-scen-idx', String(sidx));
        }
        if (typeof setCoreConnectionHint === 'function') {
            if (!hasVmSelection) {
                setCoreConnectionHint('Select a CORE VM to configure connection details.', 'warning');
            } else if (!proxValidatedForScenario) {
                setCoreConnectionHint('Validate Proxmox credentials before editing CORE connection details.', 'warning');
            } else if (coreState.core_secret_id) {
                setCoreConnectionHint('Update SSH credentials to update stored secrets. Leave password blank to keep the existing vault record.', 'success');
            } else {
                setCoreConnectionHint('Provide gRPC host/port and SSH credentials. Passwords are stored securely after a successful test.', 'info');
            }
        }
    };

    window.refreshCoreConnectionModal = refreshCoreConnectionModal;

    refreshCoreConnectionModal(activeIdx);

    document.querySelectorAll('[data-hitl-core-configure]').forEach(btn => {
        btn.onclick = () => {
            const sidx = parseInt(btn.getAttribute('data-scen-idx'));
            if (isNaN(sidx) || !state.scenarios?.[sidx]) return;
            if (!coreConnectionModal || !window.bootstrap) {
                console.warn('CORE connection modal unavailable');
                return;
            }
            refreshCoreConnectionModal(sidx);
            const modalInstance = bootstrap.Modal.getInstance(coreConnectionModal) || new bootstrap.Modal(coreConnectionModal, { backdrop: true, keyboard: true });
            modalInstance.show();
            setTimeout(() => {
                try {
                    const primaryInput = coreModalInputs.grpc_host && !coreModalInputs.grpc_host.disabled
                        ? coreModalInputs.grpc_host
                        : coreModalInputs.ssh_username;
                    primaryInput?.focus();
                    primaryInput?.select?.();
                } catch (err) {}
            }, 150);
        };
    });

    wireCoreConnectionSaveButton();

    // --- Host density normalization for Node Information ---
    try {
        const ni = scen.sections && scen.sections['Node Information'];
        if (ni) {
            ni.items = ni.items || [];
            // Ensure at least one weight row (Random) exists for fallback if all removed
            let randomRow = ni.items.find(it => !(it.v_metric==='Count') && (it.selected||'').toLowerCase()==='random');
            if (!randomRow) {
                // Add with temporary factor 0 (will be set if needed)
                ni.items.unshift({ selected:'Random', factor: 0.0 });
                randomRow = ni.items[0];
            }
            // Mark the first Random weight row as protected residual; unmark any other Random weight rows
            randomRow._protected_random = true;
            ni.items.forEach(it => {
                if (it !== randomRow && (it.v_metric !== 'Count') && ((it.selected||'').toLowerCase()==='random')) {
                    if (it._protected_random) delete it._protected_random;
                }
            });
            const weightRows = ni.items.filter(it => !(it.v_metric==='Count'));
            weightRows.forEach(it => { let f = parseFloat(it.factor); if (isNaN(f) || f < 0) f = 0; it.factor = f; });
            // Sum excluding Random for decision
            const nonRandom = weightRows.filter(it => (it.selected||'').toLowerCase()!=='random');
            let nonRandomSum = nonRandom.reduce((a,b)=> a + (parseFloat(b.factor)||0), 0);
            if (nonRandom.length === 0) {
                // Only Random exists; set to 1.0
                randomRow.factor = 1.0; nonRandomSum = 0;
            } else {
                if (nonRandomSum >= 1.0) {
                    randomRow.factor = 0.0; // others define full density
                } else {
                    randomRow.factor = 1.0 - nonRandomSum;
                }
            }
            // Final normalization (should already sum to 1.0)
            const finalSum = weightRows.reduce((a,b)=> a + (parseFloat(b.factor)||0), 0);
            if (Math.abs(finalSum - 1.0) > 1e-6 && finalSum > 0) {
                // scale all
                weightRows.forEach(it => { it.factor = (parseFloat(it.factor)||0)/finalSum; });
            }
        }
    } catch(e) { console.warn('Normalization error', e); }
    // Load persisted section collapse state (per scenario + section)
    let collapseState = {};
    try { collapseState = JSON.parse(localStorage.getItem('sectionCollapseState') || '{}'); } catch(e) { collapseState = {}; }
    // No auto-insertion of Count rows for Node Information; totals should only include user-added Count rows
    // Scenario header with Count for Density (base host pool) restored
    const niSec = scen.sections['Node Information'] || { items: [] };
    const niItems = niSec.items || [];
    const niWeightRows = niItems.filter(it => (it.v_metric || (it.selected==='Specific'?'Count':'Weight')) === 'Weight');
    const niCountRows = niItems.filter(it => (it.v_metric || (it.selected==='Specific'?'Count':'Weight')) === 'Count');
    // Base removed: host total now purely additive Count rows when no base; or proportional part is implied but base count is scenario-level (not editable here)
    let densityCountVal = 10;
    try {
        if (scen.density_count !== undefined && scen.density_count !== null && scen.density_count !== '') {
            const parsed = parseInt(scen.density_count, 10);
            if (!isNaN(parsed)) densityCountVal = parsed;
        }
    } catch(e) { densityCountVal = 10; }
    if (densityCountVal < 0) densityCountVal = 0;
    const niBase = densityCountVal;
    const niAdd = niCountRows.reduce((a,it)=> a + (parseInt(it.v_count,10)||0), 0);
    const niTotal = niBase + niAdd;
    const niTitle = 'Hosts = Base (Count for Density) allocated by weight rows + additive Count rows';
    // Build allocation breakdown tooltip for weight rows
    let allocTip = niTitle;
    if (niWeightRows.length) {
        const wTotal = niWeightRows.reduce((a,it)=> a + (parseFloat(it.factor)||0), 0) || 0;
        if (wTotal > 0) {
            const parts = niWeightRows.map(it => {
                const f = parseFloat(it.factor)||0;
                const pct = wTotal ? ((f / wTotal) * 100).toFixed(1) : '0.0';
                const label = (it.selected || 'Row');
                return `${label}:${f}(${pct}%)`;
            });
            allocTip += ' | Weights: ' + parts.join(', ');
        }
    }
    const hostBadgeClass = (niWeightRows.length && niBase === 0 && niAdd > 0) ? 'text-bg-warning' : 'text-bg-primary';
    // Simplified host summary: remove ΣW badge, allocation popover, and auto-scale functionality
    const hostSummaryHtml = `<span class=\"badge rounded-pill ${hostBadgeClass} host-total-badge ms-2\" data-bs-toggle=\"tooltip\" title=\"${allocTip.replace(/"/g,'&quot;')}\">Hosts: ${niWeightRows.length ? (niBase + ' + ' + niAdd + ' = ' + niTotal) : (niAdd)}</span>`;
    const densityBaseHtml = `<div class=\"d-flex align-items-center gap-1\" title=\"Base host pool used only for weight-based density calculations; Count rows are additive beyond this.\"><label class=\"form-label mb-0\">Count for Density</label><input type=\"number\" min=\"0\" max=\"5000\" step=\"1\" class=\"form-control form-control-sm\" style=\"width:120px\" value=\"${densityCountVal}\" data-scen-idx=\"${activeIdx}\" data-field=\"scenario_density_count\" /></div>`;
    const headerRow = document.createElement('div');
    const rawSectionNames = Object.keys(scen.sections || {});
    const filteredSectionNames = rawSectionNames.filter(name => name !== 'Notes' && name !== 'Events' && name !== 'HITL');
    const secNames = [];
    if (filteredSectionNames.includes('Node Information')) {
        secNames.push('Node Information');
    }
    filteredSectionNames.forEach(name => {
        if (name !== 'Node Information') {
            secNames.push(name);
        }
    });
    // Base host pool for density-driven (weight) allocations comes from scenario.density_count
    const baseHostPool = (scen.density_count !== undefined && scen.density_count !== null && scen.density_count !== '' ? (parseInt(scen.density_count,10)||0) : 10);
    secNames.forEach(name => {
        const sec = scen.sections[name] || { items: [] };
    const hasNodes = (name === 'Node Information');
        const itemCount = (sec.items || []).length;
        // Determine if any weight rows exist in this section (used for Node Information behavior)
        const hasWeightRowsPre = hasNodes ? ((sec.items || []).some(it => ((it.v_metric || (it.selected==='Specific'? 'Count' : 'Weight')) === 'Weight'))) : false;
        // Always ensure density has a sensible default value
        if (!hasNodes) {
            if (sec.density === undefined || sec.density === null || isNaN(sec.density)) {
                sec.density = 0.5;
            }
        }
        const densVal = sec.density;
        const nodesVal = '';
        const extraNodeCount = hasNodes ? ((sec.items || []).reduce((acc, it) => {
            const metric = it.v_metric || (it.selected==='Specific'?'Count':'Weight');
            return acc + (metric === 'Count' ? (parseInt(it.v_count) || 0) : 0);
        }, 0)) : 0;
    const hasWeightRows = hasNodes ? hasWeightRowsPre : false;
    const totalNodeCount = hasNodes ? (extraNodeCount + (hasWeightRowsPre ? niBase : 0)) : 0;
    const totalNodesLabel = hasNodes ? (totalNodeCount === 1 ? 'Total Node' : 'Total Nodes') : '';
    // Define totalPlanned (was previously referenced but never declared, causing a ReferenceError that prevented section rendering)
    const totalPlanned = hasNodes ? totalNodeCount : 0;
        // Improved initial collapse behavior:
        // - Always expand Node Information (primary planning surface)
        // - Other sections start collapsed only if empty
        let collapsed;
        if (name === 'Node Information') collapsed = false; else collapsed = (itemCount === 0);
        // Override with persisted state if present
        const collapseKey = `${activeIdx}::${name}`;
        if (collapseState.hasOwnProperty(collapseKey)) {
            collapsed = !!collapseState[collapseKey];
        }
        const card = document.createElement('div');
        card.className = 'card mb-3';
        const collapseId = `collapse-${name.replace(/\s+/g,'-')}`;
        const iconHtml = itemCount > 0
            ? `<i class='bi bi-collection-fill text-success' data-bs-toggle="tooltip" data-bs-title="${itemCount} item(s)"></i>`
            : `<i class='bi bi-collection text-muted' data-bs-toggle="tooltip" data-bs-title="No items"></i>`;
        // Enhanced tooltip text clarifying how combined total is derived.
        const totalNodesTooltip = hasNodes ? 'Combined total = (sum of all Count-based row counts) + (Total Nodes if any Weight-based rows exist). Weight rows allocate Total Nodes by their weights; Count rows are absolute and do not affect weights.' : '';
        // Compute planned badges (hosts / routers / vulns) for this section
        let hostBadge = '';
        if (name === 'Node Information') {
            const basePart = hasWeightRows ? niBase : 0;
            const additivePart = extraNodeCount;
            const totalPlannedHosts = basePart + additivePart;
            if (hasWeightRows || additivePart > 0) {
                const display = hasWeightRows ? `${basePart} + ${additivePart} = ${totalPlannedHosts}` : `${additivePart}`;
                hostBadge = `<span class=\"badge rounded-pill text-bg-primary ms-2 host-total-badge\" data-bs-toggle=\"tooltip\" title=\"${allocTip.replace(/"/g,'&quot;')}\">Hosts: ${display}</span>`;
            }
        }
        const hostSummaryBlock = (name === 'Node Information' && (niBase > 0 || niAdd > 0 || hasWeightRows))
            ? `<div class="d-flex align-items-center gap-2">${hostSummaryHtml}</div>`
            : '';
        const nodeMetaHtml = (name === 'Node Information')
            ? `<div class="d-flex flex-wrap align-items-center justify-content-between gap-3 mb-3">
                    ${densityBaseHtml}
                    ${hostSummaryBlock}
               </div>`
            : '';
        let routingBadge = '';
        if (name === 'Routing') {
            const rItems = sec.items || [];
            const rRows = rItems.map(it => ({ metric: (it.v_metric || 'Weight'), it }));
            const rCountRows = rRows.filter(r => r.metric === 'Count');
            const rWeightRows = rRows.filter(r => r.metric === 'Weight');
            const densR = (typeof sec.density === 'number') ? sec.density : 0;
            const explicit = rCountRows.reduce((a,r)=> a + (parseInt(r.it.v_count,10)||0), 0);
            let derived = 0;
            if (rWeightRows.length && densR > 0) {
                const frac = Math.max(0, Math.min(1, densR));
                derived = Math.round(baseHostPool * frac);
            }
            const total = explicit + derived;
            if (total > 0) routingBadge = `<span class=\"badge rounded-pill text-bg-secondary ms-2\" title=\"Routers planned additively: Count rows + (Density * Base Hosts). Density constrained 0..1.\">Routers: ${total}</span>`;
        }
        let vulnBadge = '';
        if (name === 'Vulnerabilities') {
            const vItems = sec.items || [];
            const vRows = vItems.map(it => ({ metric: (it.v_metric || (it.selected==='Specific'?'Count':'Weight')), it }));
            const vCountRows = vRows.filter(r => r.metric === 'Count');
            const vWeightRows = vRows.filter(r => r.metric === 'Weight');
            const densV = (typeof sec.density === 'number') ? sec.density : 0;
            const explicit = vCountRows.reduce((a,r)=> a + (parseInt(r.it.v_count,10)||0), 0);
            let derived = 0;
            if (vWeightRows.length && densV > 0) derived = Math.round(baseHostPool * Math.min(1, densV));
            const total = explicit + derived;
            if (total > 0) vulnBadge = `<span class=\"badge rounded-pill text-bg-info ms-2\" title=\"Vulnerability assignments additive: Count rows + (Density * Base Hosts). Density clipped to 1.0 when fractional.\">Vulns: ${total}</span>`;
        }
    const badgeSpan = hostBadge + routingBadge + vulnBadge;
        card.innerHTML = `
            <div class="card-header d-flex align-items-center gap-2">
                ${iconHtml}
                <strong>${name}</strong>${badgeSpan}
                <div class="ms-auto d-flex gap-2">
                    <button class="btn btn-sm btn-outline-primary" data-action="add-item" data-scen-idx="${activeIdx}" data-sec="${name}">Add</button>
                    <button class="btn btn-sm btn-outline-secondary" type="button" data-action="toggle-collapse" data-target="#${collapseId}">${collapsed ? 'Expand' : 'Collapse'}</button>
                </div>
            </div>
            <div id="${collapseId}" class="card-body" style="display:${collapsed ? 'none':'block'};">
                ${nodeMetaHtml}
                                <div class="table-responsive">
                                                                                <table class="table table-sm align-middle">
                                                                                        <thead>
                                                                                            <tr>
                                                                                                <th style="width:280px"></th>
                                                                                                <th></th>
                                                                                                <th style="width:160px"></th>
                                                                                                <th style="width:80px"></th>
                                                                                            </tr>
                                                                                        </thead>
                                                                    <tbody>
                                                                                ${(() => {
                                                                                const items = sec.items || [];
                                                                                const rowsByMetric = items.map((it, iidx) => ({ it, iidx, metric: (it.v_metric || (name==='Vulnerabilities' && (it.selected||'Category')==='Specific' ? 'Count' : 'Weight')) }));
                                                                                const weights = rowsByMetric.filter(x => x.metric === 'Weight');
                                                                                const counts = rowsByMetric.filter(x => x.metric === 'Count');
                                                                                // If there are no remaining weight rows but a stale total_nodes exists, clear it (frontend-only cleanup)
                                                                                if (name === 'Node Information' && weights.length === 0) {
                                                                                    const secRef = state.scenarios[activeIdx].sections[name];
                                                                                    if (secRef && secRef.total_nodes) { secRef.total_nodes = 0; }
                                                                                }
                                                                                const parts = [];
                                                                                const showWeightHeader = (weights.length > 0);
                                        if (showWeightHeader) {
                                                                                    const densCtrl = (
                                                                                        name === 'Node Information'
                                                                                            ? `<div class=\"d-flex align-items-center justify-content-end gap-2 small text-muted\"><span>Density</span><input disabled class=\"form-control form-control-sm\" style=\"width:80px\" value=\"1.0\"></div>`
                                                                                                : (name === 'Routing'
                                                                                                                                                                                                ? `<div class=\"d-flex align-items-center justify-content-end gap-2\">`
                                                                                                                                                                                                        + `<span>Density</span>`
                                                                                                                                                                                                        + `<input type=\"number\" step=\"0.01\" min=\"0\" max=\"1\" class=\"form-control form-control-sm\" style=\"width:120px\" placeholder=\"e.g., 0.25\" value=\"${densVal}\" data-scen-idx=\"${activeIdx}\" data-sec=\"${name}\" data-field=\"density\">`
                                                                                                                                                                                                    + `</div>`
                                                                                                                                                                                                : (() => {
                                                                                                                                                                                                    const tooltip = (name === 'Services')
                                                                                                                                                                                                        ? 'Services: per-item Count overrides density; assigns exactly that many hosts the selected service.'
                                                                                                                                                                                                        : (name === 'Traffic')
                                                                                                                                                                                                            ? 'Traffic: per-item Count overrides density; creates exactly that many sender/receiver pairs.'
                                                                                                                                                                                                            : (name === 'Segmentation')
                                                                                                                                                                                                                ? 'Segmentation: per-item Count overrides density; plans exactly that many slots (NAT prioritized).'
                                                                                                                                                                                                                : '';
                                                                                                                                                                                                    let info = '';
                                                                                                                                                                                                    // Density tooltip removed
                                                                                                                                                                                                    return '<div class="d-flex align-items-center justify-content-end gap-2">'
                                                                                                                                                                                                        + '<span>Density</span>'
                                                                                                                                                                                                        + info
                                                                                                                                                                                                        + '<input type="number" step="0.01" min="0" max="1" class="form-control form-control-sm" style="width:100px" value="' + densVal + '" data-scen-idx="' + activeIdx + '" data-sec="' + name + '" data-field="density">'
                                                                                                                                                                                                    + '</div>';
                                                                                                                                                                                                })()
                                                                                                                                                                                            )
                                                                                                                                                                        );
                                                                                    parts.push(`<tr class=\"table-light\"><td colspan=\"2\"><strong>Weight-based</strong></td><td class=\"text-end\">${densCtrl}</td><td></td></tr>`);
                                                                                    if (weights.length) { parts.push(weights.map(x => renderItemRow(activeIdx, name, x.iidx, x.it)).join('')); }
                                                                                }
                                                                                if (counts.length) {
                                                                                    const countHdr = (name === 'Node Information') ? 'Count-based' : 'Count-based';
                                                                                    parts.push(`<tr class=\"table-light\"><td colspan=\"4\"><strong>${countHdr}</strong></td></tr>`);
                                                                                    parts.push(counts.map(x => renderItemRow(activeIdx, name, x.iidx, x.it)).join(''));
                                                                                }
                                                                                return parts.join('');
                                                                            })()}
                                                                    </tbody>
                    </table>
                </div>
                                        <div class="text-danger small mt-1 section-warning" data-scen-idx="${activeIdx}" data-sec="${name}" style="display:none">Weights must sum to 1.000</div>
                                        ${name==='Routing' ? `
                                        <div id="routingEdgesWarnings" class="alert alert-warning py-2 px-3 small mt-3 d-none"></div>
                                        <div class="d-flex flex-wrap align-items-center gap-3 mt-3 small" id="routingEdgesSummary" style="display:none;">
                                                <div><strong>Policy:</strong> <span data-role="edges-policy">(pending)</span></div>
                                        </div>
                                        ` : ''}
            </div>`;
        root.appendChild(card);
    });
    // Apply visibility rule for H/S bounds after DOM built
    updateHsBoundsVisibility();
        // activate tooltips for icons
        if(window.bootstrap){
            const tts = root.querySelectorAll('[data-bs-toggle="tooltip"]');
            tts.forEach(el => new bootstrap.Tooltip(el));
        }

    // Notes card (collapsible, collapsed by default)
    const notesCard = document.createElement('div');
    notesCard.className = 'card mb-3';
    const hasNotes = (scen.notes||'').trim().length>0;
    const collapseId = `notesCollapse_${activeIdx}`;
    notesCard.innerHTML = `
        <div class="card-header d-flex justify-content-between align-items-center">
            <button class="btn btn-sm btn-link text-decoration-none p-0 d-flex align-items-center gap-2" type="button" data-bs-toggle="collapse" data-bs-target="#${collapseId}" aria-expanded="false" aria-controls="${collapseId}">
                <span class="me-1">Notes</span>
                <span id="notesIndicator_${activeIdx}" class="d-inline-flex align-items-center" data-bs-toggle="tooltip" data-bs-title="${hasNotes? 'Notes present':'No notes'}">
                    ${hasNotes ? `<i class='bi bi-journal-text text-success'></i>` : `<i class='bi bi-journal text-muted'></i>`}
                </span>
            </button>
            <small class="text-muted">optional</small>
        </div>
        <div id="${collapseId}" class="collapse">
            <div class="card-body p-2">
                <textarea class="form-control" rows="3" data-scen-idx="${activeIdx}" data-field="notes" placeholder="Add scenario notes (markdown supported)">${scen.notes || ''}</textarea>
            </div>
        </div>`;
    root.appendChild(notesCard);

    wireHandlers();
    // Populate dynamic vuln selects after DOM paint
    populateVulnSelects();
    // Hook up Specific picker buttons
    document.querySelectorAll('[data-action="pick-specific"]').forEach(btn => {
        const handler = () => {
            const sidx = parseInt(btn.getAttribute('data-scen-idx'));
            const sec = btn.getAttribute('data-sec');
            const iidx = parseInt(btn.getAttribute('data-item-idx'));
            openVulnPicker(sidx, sec, iidx);
        };
        // Attach the click handler (fix: previously not wired)
        btn.addEventListener('click', handler);
    });
}

function updateHsBoundsVisibility(){
    try {
        document.querySelectorAll('[data-field="r2s_mode"]').forEach(selEl => {
            const modeVal = selEl.value;
            const wrapper = selEl.closest('.routing-edge-groups')?.querySelector('.hs-bounds-wrapper');
            if (wrapper) {
                if (modeVal === 'NonUniform') {
                    wrapper.classList.add('hs-show');
                } else {
                    wrapper.classList.remove('hs-show');
                }
            }
        });
    } catch(e) { /* ignore */ }
}

// renderSections was deprecated and removed; rendering is handled in renderMain()
function renderItemRow(sidx, secName, iidx, it) {
    // Build Selected options and current weight
    const weight = ((parseFloat(it.factor) || 0).toFixed(3));
    let opts = '';
    if (secName === 'Vulnerabilities') {
        const cur = it.selected || 'Category';
        const options = ['Category', 'Specific', 'Random'];
        opts = options.map(o => `<option ${o===cur?'selected':''}>${o}</option>`).join('');
    } else {
        const cur = it.selected || 'Random';
        // Per-section allowed options (excluding 'auto')
        let options = ['Random'];
        switch (secName) {
            case 'Node Information':
                options = ['Server', 'Workstation', 'PC', 'Random'];
                break;
            case 'Routing':
                options = ['RIP', 'RIPv2', 'BGP', 'OSPFv2', 'OSPFv3', 'Random'];
                break;
            case 'Services':
                options = ['SSH', 'HTTP', 'DHCPClient', 'Random'];
                break;
            case 'Traffic':
                options = ['Random', 'TCP', 'UDP', 'CUSTOM'];
                break;
            case 'Events':
                options = ['Script Path'];
                break;
            case 'Segmentation':
                options = ['Random', 'Firewall', 'NAT', 'CUSTOM'];
                break;
            default:
                options = ['Random'];
        }
        opts = options.map(o => `<option ${o===cur?'selected':''}>${o}</option>`).join('');
    }

    const extras = (() => {
        if (secName === 'Events') {
            return `<input class="form-control form-control-sm" placeholder="script path" value="${it.script_path || ''}" data-scen-idx="${sidx}" data-sec="${secName}" data-item-idx="${iidx}" data-field="script_path">`;
        }
        if (secName === 'Routing') {
            // Edges mode (Random/Min/Max/Exact). Random now acts like previous Auto (no extra links augmentation).
            const mode = it.r2r_mode || (it.r2r_edges !== undefined ? 'Exact' : 'Random');
            const val = (it.r2r_edges !== undefined && it.r2r_edges !== null) ? it.r2r_edges : '';
            const options = [
                {v:'Random', l:'Random'},
                {v:'Min', l:'Min'},
                {v:'Uniform', l:'Uniform'},
                {v:'Exact', l:'Exact'},
                {v:'NonUniform', l:'NonUniform'}
            ];
            const selHtml = `<select class="form-select form-select-sm routing-mode-select" style="width:105px" data-field="r2r_mode" data-scen-idx="${sidx}" data-sec="${secName}" data-item-idx="${iidx}">${options.map(o => `<option value="${o.v}" ${o.v===mode?'selected':''}>${o.l}</option>`).join('')}</select>`;
            // R-to-S (router to switch) connectivity policy (same option set)
            const r2sMode = it.r2s_mode || 'Random';
            const r2sVal = (it.r2s_edges !== undefined && it.r2s_edges !== null) ? it.r2s_edges : '';
            const r2sSel = `<select class="form-select form-select-sm routing-mode-select" style="width:105px" data-field="r2s_mode" data-scen-idx="${sidx}" data-sec="${secName}" data-item-idx="${iidx}">${options.map(o => `<option value="${o.v}" ${o.v===r2sMode?'selected':''}>${o.l}</option>`).join('')}</select>`;
            const r2sHostsMin = (it.r2s_hosts_min !== undefined && it.r2s_hosts_min !== null) ? it.r2s_hosts_min : 1;
            const r2sHostsMax = (it.r2s_hosts_max !== undefined && it.r2s_hosts_max !== null) ? it.r2s_hosts_max : 4;
            const showHsBounds = (r2sMode === 'NonUniform');
            return `
                <div class="d-flex flex-column gap-1 routing-edge-groups">
                    <div class="d-flex flex-wrap gap-2 align-items-center">
                        <label class="form-label mb-0 me-1" style="min-width:110px" title="Router-to-Router edge policy. Random = spanning tree; Min = chain; Uniform = balanced degrees; Exact = chain+augment to target; NonUniform = heterogeneous.">R-to-R Edges</label>
                        <div class="d-flex gap-3 align-items-end">
                            <div>${selHtml}</div>
                            <div class="edges-exact-input" style="display:${mode==='Exact'?'block':'none'};">
                                <input type="number" min="1" class="form-control form-control-sm edges-degree-input" style="width:110px" value="${val}" data-field="r2r_edges" data-scen-idx="${sidx}" data-sec="${secName}" data-item-idx="${iidx}" placeholder="Exact (e.g. 3)" aria-label="Exact router degree target" title="Target degree each router should attempt to reach (cannot reduce existing higher degrees).">
                            </div>
                        </div>
                    </div>
                    <div class="d-flex flex-wrap gap-2 align-items-center">
                        <label class="form-label mb-0 me-1" style="min-width:110px" title="Router-to-Switch attachment policy; controls how many distinct switches each router connects to.">R-to-S Edges</label>
                        <div class="d-flex gap-3 align-items-end flex-wrap align-items-center">
                            <div>${r2sSel}</div>
                            <div class="r2s-exact-input" style="display:${r2sMode==='Exact'?'block':'none'};">
                                <input type="number" min="1" class="form-control form-control-sm r2s-degree-input" style="width:110px" value="${r2sVal}" data-field="r2s_edges" data-scen-idx="${sidx}" data-sec="${secName}" data-item-idx="${iidx}" placeholder="Exact (e.g. 2)" aria-label="Exact router-to-switch target" title="Target number of switches per router (Exact mode).">
                            </div>
                            <div class="gap-2 align-items-end small hs-bounds-wrapper">
                                <div>
                                    <label class="form-label mb-0" style="font-size:0.7rem" title="Minimum hosts per created switch for this router row (preview & build).">H/S Min</label>
                                    <input type="number" min="1" max="32" class="form-control form-control-sm hs-min-input" style="width:70px" value="${r2sHostsMin}" data-field="r2s_hosts_min" data-scen-idx="${sidx}" data-sec="${secName}" data-item-idx="${iidx}" placeholder="min">
                                </div>
                                <div>
                                    <label class="form-label mb-0" style="font-size:0.7rem" title="Maximum hosts per created switch for this router row (preview & build).">H/S Max</label>
                                    <input type="number" min="1" max="64" class="form-control form-control-sm hs-max-input" style="width:70px" value="${r2sHostsMax}" data-field="r2s_hosts_max" data-scen-idx="${sidx}" data-sec="${secName}" data-item-idx="${iidx}" placeholder="max">
                                </div>
                            </div>
                        </div>
                    </div>
                </div>`;
        }
        if (secName === 'Traffic') {
            return `
                <div class="d-flex flex-wrap gap-2">
                    <div>
                        <label class="form-label mb-0">Payload</label>
                        <select class="form-select form-select-sm" data-field="content_type" data-scen-idx="${sidx}" data-sec="${secName}" data-item-idx="${iidx}">
                            ${['Random','text','photo','audio','video','gibberish'].map(ct => `<option value="${ct}" ${((it.content_type||'Random')===ct)?'selected':''}>${ct}</option>`).join('')}
                        </select>
                    </div>
                    <div class="traffic-config" style="display:${((it.content_type||'Random')==='Random')?'none':'block'};">
                        <label class="form-label mb-0">Pattern</label>
                        <select class="form-select form-select-sm" data-field="pattern" data-scen-idx="${sidx}" data-sec="${secName}" data-item-idx="${iidx}">
                            ${['continuous','periodic','burst','poisson','ramp'].map(p => `<option ${((it.pattern||'')===p)?'selected':''}>${p}</option>`).join('')}
                        </select>
                    </div>
                    <div class="traffic-config" style="display:${((it.content_type||'Random')==='Random')?'none':'block'};">
                        <label class="form-label mb-0">Rate (kbps)</label>
                        <input type="number" step="0.1" class="form-control form-control-sm" value="${it.rate_kbps ?? 64.0}" data-field="rate_kbps" data-scen-idx="${sidx}" data-sec="${secName}" data-item-idx="${iidx}">
                    </div>
                    <div class="traffic-config" style="display:${((it.content_type||'Random')==='Random')?'none':'block'};">
                        <label class="form-label mb-0">Period (s)</label>
                        <input type="number" step="0.1" class="form-control form-control-sm" value="${it.period_s ?? 1.0}" data-field="period_s" data-scen-idx="${sidx}" data-sec="${secName}" data-item-idx="${iidx}">
                    </div>
                    <div class="traffic-config" style="display:${((it.content_type||'Random')==='Random')?'none':'block'};">
                        <label class="form-label mb-0">Jitter (%)</label>
                        <input type="number" step="0.1" class="form-control form-control-sm" value="${it.jitter_pct ?? 10.0}" data-field="jitter_pct" data-scen-idx="${sidx}" data-sec="${secName}" data-item-idx="${iidx}">
                    </div>
                </div>`;
        }
        if (secName === 'Vulnerabilities') {
            const mode = it.selected || 'Type/Vector';
            if (mode === 'Specific') {
                const nm = it.v_name || '';
                // Try to obtain full description (prefer stored v_desc, else look up in catalog)
                let fullDesc = it.v_desc || '';
                if (!fullDesc && nm && window.VULN_CATALOG && Array.isArray(window.VULN_CATALOG.items)) {
                    const match = window.VULN_CATALOG.items.find(x => x.Name === nm && (!it.v_path || x.Path === it.v_path));
                    if (match && match.Description) { fullDesc = match.Description; }
                }
                const abbr = (s, n=80) => (s && s.length > n ? (s.slice(0, n-1) + '…') : (s||''));
                const esc = (s) => (s||'')
                    .replace(/&/g,'&amp;')
                    .replace(/</g,'&lt;')
                    .replace(/>/g,'&gt;')
                    .replace(/"/g,'&quot;')
                    .replace(/'/g,'&#39;');
                const descShort = abbr(fullDesc);
                const centerText = nm ? `${nm}${descShort ? ' — ' + descShort : ''}` : '<span class="text-muted">No selection</span>';
                return `<span class="small" ${fullDesc ? `data-bs-toggle="tooltip" data-bs-title="${esc(fullDesc)}"` : ''}>${centerText}</span>`;
            }
            return '';
        }
        return '';
    })();
    // Build first cell content, optionally augmenting Selected with Vulnerabilities controls
    const firstCell = (() => {
        const isProtectedRandom = (secName === 'Node Information') && ((it.selected||'').toLowerCase()==='random') && it._protected_random;
        const disabledAttr = isProtectedRandom ? 'disabled title="Residual Random row is auto-managed"' : '';
        const selectedCtl = `<select class="form-select form-select-sm" ${disabledAttr} data-field="selected" data-scen-idx="${sidx}" data-sec="${secName}" data-item-idx="${iidx}">${opts}</select>`;
        if (secName !== 'Vulnerabilities') return selectedCtl;
    const mode = it.selected || 'Category';
    if (mode === 'Category') {
            return `
            <div class="d-flex flex-wrap gap-2 align-items-end">
                <div style="min-width:160px">${selectedCtl}</div>
                <div>
                    <label class="form-label mb-0">Type</label>
                    <select class="form-select form-select-sm vuln-type" data-field="v_type" data-scen-idx="${sidx}" data-sec="${secName}" data-item-idx="${iidx}"></select>
                </div>
                <div>
                    <label class="form-label mb-0">Vector</label>
                    <select class="form-select form-select-sm vuln-vector" data-field="v_vector" data-scen-idx="${sidx}" data-sec="${secName}" data-item-idx="${iidx}"></select>
                </div>
            </div>`;
        } else if (mode === 'Specific') {
            const nm = it.v_name || '';
            // Try to obtain full description (prefer stored v_desc, else look up in catalog)
            let fullDesc = it.v_desc || '';
            if (!fullDesc && nm && window.VULN_CATALOG && Array.isArray(window.VULN_CATALOG.items)) {
                const match = window.VULN_CATALOG.items.find(x => x.Name === nm && (!it.v_path || x.Path === it.v_path));
                if (match && match.Description) { fullDesc = match.Description; }
            }
            const abbr = (s, n=80) => (s && s.length > n ? (s.slice(0, n-1) + '…') : (s||''));
            const esc = (s) => (s||'')
                .replace(/&/g,'&amp;')
                .replace(/</g,'&lt;')
                .replace(/>/g,'&gt;')
                .replace(/"/g,'&quot;')
                .replace(/'/g,'&#39;');
            const descShort = abbr(fullDesc);
            return `
            <div class="d-flex flex-wrap gap-2 align-items-center">
                <div style="min-width:160px">${selectedCtl}</div>
                <button type="button" class="btn btn-sm btn-outline-primary" data-action="pick-specific" data-scen-idx="${sidx}" data-sec="${secName}" data-item-idx="${iidx}">Choose...</button>
            </div>`;
        }
        return selectedCtl;
    })();
    // Right-most: Weight or Count cell
    const weightCell = (() => {
        if (secName === 'Vulnerabilities') {
            const mode = it.selected || 'Type/Vector';
            const metric = it.v_metric || (mode === 'Specific' ? 'Count' : 'Weight');
            const metricSel = `<select class="form-select form-select-sm" style="min-width: 140px" data-field="v_metric" data-scen-idx="${sidx}" data-sec="${secName}" data-item-idx="${iidx}"><option ${metric==='Weight'?'selected':''}>Weight</option><option ${metric==='Count'?'selected':''}>Count</option></select>`;
            if (metric === 'Count') {
                const count = (parseInt(it.v_count, 10) || 5);
                return `<div class="d-flex gap-2">${metricSel}<input type="number" min="1" step="1" class="form-control form-control-sm" style="min-width: 120px" value="${count}" data-field="v_count" data-scen-idx="${sidx}" data-sec="${secName}" data-item-idx="${iidx}"></div>`;
            }
            return `<div class="d-flex gap-2">${metricSel}<input type="number" step="0.01" min="0" max="1" class="form-control form-control-sm weight-input" style="min-width: 120px" value="${weight}" data-field="factor" data-scen-idx="${sidx}" data-sec="${secName}" data-item-idx="${iidx}"></div>`;
        }
        // For all other sections, provide a Count/Weight selector as well
        const metric = it.v_metric || 'Weight';
        const metricSel = `<select class="form-select form-select-sm" style="min-width: 140px" data-field="v_metric" data-scen-idx="${sidx}" data-sec="${secName}" data-item-idx="${iidx}"><option ${metric==='Weight'?'selected':''}>Weight</option><option ${metric==='Count'?'selected':''}>Count</option></select>`;
        if (metric === 'Count') {
            const count = (parseInt(it.v_count, 10) || 5);
            return `<div class="d-flex gap-2">${metricSel}<input type="number" min="1" step="1" class="form-control form-control-sm" style="min-width: 120px" value="${count}" data-field="v_count" data-scen-idx="${sidx}" data-sec="${secName}" data-item-idx="${iidx}"></div>`;
        }
    const isProtectedRandom = (secName === 'Node Information') && ((it.selected||'').toLowerCase()==='random') && it._protected_random;
    const metricDisabled = isProtectedRandom ? 'disabled title="Residual Random row metric locked"' : '';
    const metricSelProtected = `<select class="form-select form-select-sm" ${metricDisabled} style="min-width: 140px" data-field="v_metric" data-scen-idx="${sidx}" data-sec="${secName}" data-item-idx="${iidx}"><option ${metric==='Weight'?'selected':''}>Weight</option><option ${metric==='Count'?'selected':''}>Count</option></select>`;
    const ro = isProtectedRandom ? 'readonly class="form-control form-control-sm weight-input bg-light" title="Auto-adjusted to keep sum=1.0"' : 'class="form-control form-control-sm weight-input"';
    return `<div class="d-flex gap-2">${metricSelProtected}<input type="number" step="0.01" min="0" max="1" ${ro} style="min-width: 120px" value="${weight}" data-field="factor" data-scen-idx="${sidx}" data-sec="${secName}" data-item-idx="${iidx}"></div>`;
    })();
    const removeBtnHtml = ((secName === 'Node Information') && ((it.selected||'').toLowerCase()==='random') && it._protected_random)
        ? '<span class="text-muted small" title="Residual Random row">&mdash;</span>'
        : `<button type="button" class="btn btn-sm btn-outline-danger" data-action="remove-item" data-scen-idx="${sidx}" data-sec="${secName}" data-item-idx="${iidx}">Remove</button>`;
    return `
        <tr>
            <td>${firstCell}</td>
            <td>${extras}</td>
            <td>${weightCell}</td>
            <td>${removeBtnHtml}</td>
        </tr>`;
}
// Render Vulnerabilities rows grouped with two row-headers
function renderVulnRows(sidx, secName, items) {
    const withIdx = items.map((it, iidx) => ({ it, iidx }));
    const typeOrRandom = withIdx.filter(x => (x.it.selected || 'Category') !== 'Specific');
    const specifics = withIdx.filter(x => (x.it.selected || 'Category') === 'Specific');
    const parts = [];
    if (typeOrRandom.length) {
        parts.push(`<tr class="table-light"><td colspan="4"><strong>Category or Random</strong></td></tr>`);
        parts.push(typeOrRandom.map(x => renderItemRow(sidx, secName, x.iidx, x.it)).join(''));
    }
    if (specifics.length) {
        parts.push(`<tr class="table-light"><td colspan="4"><strong>Specific</strong></td></tr>`);
        parts.push(specifics.map(x => renderItemRow(sidx, secName, x.iidx, x.it)).join(''));
    }
    return parts.join('');
}

function wireHandlers() {
    // Count for Density input handler
    document.querySelectorAll('input[data-field="scenario_density_count"]').forEach(inp => {
        inp.addEventListener('change', () => {
            const idx = parseInt(inp.getAttribute('data-scen-idx'));
            let val = parseInt(inp.value, 10); if (isNaN(val) || val < 0) val = 0; if (val > 5000) val = 5000;
            state.scenarios[idx].density_count = val; // store at scenario level; do NOT mutate node rows
            if (val === '' || val === null) {
                // If cleared, revert to default 10 in UI but keep undefined so save omits and parser falls back.
                delete state.scenarios[idx].density_count;
            }
            renderMain();
        });
        // Prevent Enter key from triggering unintended form behavior (like adding a row)
        inp.addEventListener('keydown', (ev) => {
            if (ev.key === 'Enter') { ev.preventDefault(); inp.blur(); }
        });
    });
    document.querySelectorAll('[data-field]').forEach(el => {
        const sidx = parseInt(el.getAttribute('data-scen-idx'));
        const sec = el.getAttribute('data-sec');
        const field = el.getAttribute('data-field');
        const iidx = el.getAttribute('data-item-idx');
        const handler = (ev) => {
            if (field === 'scenario_base_hosts') { return; }
            if (sec) {
                if (iidx !== null) {
                    const item = state.scenarios[sidx].sections[sec].items[parseInt(iidx)];
                    if (['factor','rate_kbps','period_s','jitter_pct','total_nodes','density','r2r_edges','r2s_edges','r2s_hosts_min','r2s_hosts_max'].includes(field)) {
                        item ? (item[field] = parseFloat(el.value)) : state.scenarios[sidx].sections[sec][field] = parseFloat(el.value);
                        if ((field === 'edges' || field === 'r2s_edges') && (isNaN(item[field]) || el.value === '')) {
                            // Allow blank to mean "unset" so generator can apply defaults
                            delete item[field];
                        }
                        if ((field === 'r2s_hosts_min' || field === 'r2s_hosts_max')) {
                            const mn = parseInt(item.r2s_hosts_min || 1, 10);
                            const mx = parseInt(item.r2s_hosts_max || 4, 10);
                            if (!isNaN(mn) && !isNaN(mx) && mn > mx) {
                                item.r2s_hosts_max = mn;
                            }
                            persistEditorState();
                        }
                        if (field === 'factor') {
                            adjustWeightsProportionally(sidx, sec, parseInt(iidx));
                            updateWeightWarning(sidx, sec);
                            updateWeightInputsDisplay(sidx, sec);
                        }
                        if (field === 'edges' || field === 'r2s_edges') {
                            setTimeout(validateRoutingEdges, 20);
                        }
                    } else if (['pattern','content_type','selected','script_path','v_type','v_vector','v_name','v_path','v_count','v_metric','r2r_mode','r2s_mode'].includes(field)) {
                        const prev = item[field];
                        if (field === 'v_count') {
                            const n = parseInt(el.value, 10) || 1;
                            item[field] = n;
                        } else {
                            item[field] = el.value;
                        }
                        if(field === 'r2r_mode') {
                            item.r2r_mode = el.value;
                            if(el.value !== 'Exact') { delete item.edges; }
                            renderMain();
                            updateHsBoundsVisibility();
                            setTimeout(validateRoutingEdges, 50);
                        }
                        if(field === 'r2s_mode') {
                            item.r2s_mode = el.value;
                            if(el.value !== 'Exact') { delete item.r2s_edges; }
                            renderMain();
                            updateHsBoundsVisibility();
                            setTimeout(validateRoutingEdges, 50);
                        }
                        if (field === 'edges') {
                            setTimeout(validateRoutingEdges, 20);
                        } else if (field === 'content_type') {
                            // Re-render to reflect show/hide of traffic-config inputs when Random is selected
                            renderMain();
                        } else if (field === 'selected') {
                            if (item.selected === 'Specific') {
                                if (!item.v_count) item.v_count = 5;
                                if (!item.v_metric) item.v_metric = 'Count';
                            } else {
                                if (!item.v_metric) item.v_metric = 'Weight';
                            }
                            // Re-render to show/hide appropriate controls and recalc weight warnings
                            renderMain();
                        } else if (field === 'v_metric') {
                            // On metric toggle, normalize weights for current section and re-render
                            if (item.v_metric === 'Count' && (item.v_count === undefined || item.v_count === null || isNaN(parseInt(item.v_count, 10)))) {
                                item.v_count = 5;
                            }
                            redistributeEven(sidx, sec);
                            if (sec === 'Node Information') {
                                const secRef = state.scenarios[sidx].sections[sec];
                                const hasWeight = (secRef.items || []).some(it => (it.v_metric || 'Weight') === 'Weight');
                                if (!hasWeight && secRef.total_nodes) { secRef.total_nodes = 0; }
                            }
                            updateWeightWarning(sidx, sec);
                            renderMain();
                        } else if (field === 'v_count') {
                            // Count change affects Total Nodes label
                            renderMain();
                        }
                    } else {
                        state.scenarios[sidx].sections[sec][field] = el.value;
                    }
                } else {
                    if (field === 'density' || field === 'total_nodes') {
                        let v = parseFloat(el.value);
                        if (field === 'density') {
                            if (isNaN(v)) v = 0.0;
                            v = Math.max(0, Math.min(1, v)); // Clamp globally 0..1
                        }
                        state.scenarios[sidx].sections[sec][field] = v;
                        // keep hidden for submit and update any warnings
                        if (field === 'density') { updateWeightWarning(sidx, sec); }
                        // Ensure Total Nodes label refreshes on total_nodes edits
                        if (field === 'total_nodes') { renderMain(); }
                    } else {
                        state.scenarios[sidx].sections[sec][field] = el.value;
                    }
                }
            } else {
                if (field === 'name') {
                    const raw = el.value ?? '';
                    if (ev?.type === 'change') {
                        const trimmed = raw.trim();
                        const finalName = trimmed || `Scenario ${sidx + 1}`;
                        state.scenarios[sidx].name = finalName;
                        if (el.value !== finalName) {
                            el.value = finalName;
                        }
                        try { logInfo(`Scenario renamed to ${finalName}`); } catch(_) {}
                    } else {
                        state.scenarios[sidx].name = raw;
                    }
                }
                if (field === 'base-file') state.scenarios[sidx].base.filepath = el.value;
                if (field === 'notes') state.scenarios[sidx].notes = el.value;
                if(field === 'notes'){
                    try {
                        const ind = document.getElementById('notesIndicator_'+sidx);
                        if(ind){
                            const has = (el.value||'').trim().length>0;
                            ind.innerHTML = has ? `<i class='bi bi-journal-text text-success'></i>` : `<i class='bi bi-journal text-muted'></i>`;
                            ind.setAttribute('data-bs-title', has ? 'Notes present' : 'No notes');
                            if(window.bootstrap){ try { new bootstrap.Tooltip(ind); } catch(e){} }
                        }
                    } catch(e){}
                }
            }
            if (field === 'name') {
                renderSidebar();
            }
            // keep hidden for submit
            document.getElementById('scenarios_json').value = JSON.stringify({ scenarios: state.scenarios, active_index: activeIdx });
            // persist edits across navigation
            persistEditorState();
            logDebug(`Field change: scen=${sidx} sec=${sec||''} field=${field}`);
            try { previewState.dirty = true; updatePlanButtons(); } catch(e){}
        };
        el.addEventListener('input', handler);
        el.addEventListener('change', handler);
    });
    document.querySelectorAll('[data-action="remove-item"]').forEach(btn => {
        btn.onclick = () => {
            const sidx = parseInt(btn.getAttribute('data-scen-idx'));
            const sec = btn.getAttribute('data-sec');
            const iidx = parseInt(btn.getAttribute('data-item-idx'));
            state.scenarios[sidx].sections[sec].items.splice(iidx,1);
                        logInfo(`Removed item ${iidx} from ${sec}`);
              redistributeEven(sidx, sec);
              // Auto-clear total_nodes if Node Information loses its last weight-based row
              if (sec === 'Node Information') {
                  const secRef = state.scenarios[sidx].sections[sec];
                  const hasWeight = (secRef.items || []).some(it => (it.v_metric || 'Weight') === 'Weight');
                  if (!hasWeight && secRef.total_nodes) { secRef.total_nodes = 0; }
              }
              // Re-render to refresh totals and labels
                            renderMain();
                            persistEditorState();
                            try { previewState.dirty = true; updatePlanButtons(); } catch(e){}
        };
    });
    document.querySelectorAll('[data-action="add-item"]').forEach(btn => {
        btn.onclick = () => {
            const sidx = parseInt(btn.getAttribute('data-scen-idx'));
            const sec = btn.getAttribute('data-sec');
            // Default selection logic: for Routing we prefer the first concrete protocol (not Random) so
            // routers don't silently become 'Random' unless user explicitly chooses it. Other sections
            // still start at 'Random' (or specialized default) as before.
            let defaultSelected = 'Random';
            if (sec === 'Routing') {
                try {
                    const opts = dropdownsBySection['Routing'] || [];
                    // pick the first option that isn't 'Random'
                    const concrete = opts.find(o => o !== 'Random');
                    if (concrete) defaultSelected = concrete;
                } catch(e){}
            }
            const item = { selected: defaultSelected, factor: 1.0 };
            if (sec === 'Events') item.script_path = '';
            if (sec === 'Traffic') { item.pattern = 'continuous'; item.rate_kbps = 64.0; item.period_s = 1.0; item.jitter_pct = 10.0; item.content_type = 'Random'; }
            if (sec === 'Vulnerabilities') { item.selected = 'Category'; item.v_type = 'Random'; item.v_vector = 'Random'; }
            // Default new rows: Node Information -> Count; others -> Weight.
            if (sec === 'Node Information') { item.v_metric = 'Count'; item.v_count = 5; }
            else { item.v_metric = 'Weight'; }
            state.scenarios[sidx].sections[sec].items.push(item);
                        logInfo(`Added item to ${sec}`);
              redistributeEven(sidx, sec);
                            renderMain();
                            persistEditorState();
                            try { previewState.dirty = true; updatePlanButtons(); } catch(e){}
        };
    });
    document.querySelectorAll('[data-action="toggle-collapse"]').forEach(btn => {
        btn.onclick = () => {
            const targetSel = btn.getAttribute('data-target');
            const target = document.querySelector(targetSel);
            if (!target) return;
            const visible = target.style.display !== 'none';
            target.style.display = visible ? 'none' : 'block';
            btn.textContent = visible ? 'Expand' : 'Collapse';
            const secName = targetSel.replace('#collapse-','').replace(/-/g,' ');
            const collapseKey = `${activeIdx}::${secName}`;
            collapseState[collapseKey] = visible; // store collapsed state (true means now collapsed)
            try { localStorage.setItem('sectionCollapseState', JSON.stringify(collapseState)); } catch(e) {}
            logDebug(`Section toggle ${targetSel} -> ${visible ? 'collapsed':'expanded'}`);
        };
    });
    document.querySelectorAll('[data-hitl-toggle]').forEach(toggle => {
        toggle.addEventListener('change', () => {
            const sidx = parseInt(toggle.getAttribute('data-scen-idx'));
            if (isNaN(sidx) || !state.scenarios[sidx]) return;
            const hitlState = ensureHitlStateForScenario(state.scenarios[sidx]);
            hitlState.enabled = !!toggle.checked;
            logInfo(`HITL ${hitlState.enabled ? 'enabled' : 'disabled'} for scenario ${state.scenarios[sidx].name || sidx + 1}`);
            persistEditorState();
            const hidden = document.getElementById('scenarios_json');
            if (hidden) hidden.value = JSON.stringify({ scenarios: state.scenarios, active_index: activeIdx });
            renderMain();
        });
    });
    document.querySelectorAll('[data-hitl-add]').forEach(btn => {
        btn.addEventListener('click', () => {
            const sidx = parseInt(btn.getAttribute('data-scen-idx'));
            if (isNaN(sidx) || !state.scenarios[sidx]) return;
            const select = document.getElementById(`hitlAvailable_${sidx}`);
            if (!select) return;
            const chosen = Array.from(select.selectedOptions || []);
            if (!chosen.length) {
                try { showToast('Select one or more interfaces to add', { autohide: true, delay: 2000 }); } catch(e) {}
                return;
            }
            const hitlState = ensureHitlStateForScenario(state.scenarios[sidx]);
            const catalog = Array.isArray(state.host_interfaces) ? state.host_interfaces : [];
            const isVmbr0 = (entry) => {
                if (!entry) return false;
                const bridge = (entry.bridge || (entry.proxmox && entry.proxmox.bridge) || (entry.proxmox && entry.proxmox.raw && entry.proxmox.raw.bridge) || '').toString().trim().toLowerCase();
                return bridge === 'vmbr0';
            };
            let added = 0;
            let blocked = 0;
            chosen.forEach(opt => {
                const name = (opt.value || opt.textContent || '').trim();
                if (!name) return;
                if (hitlState.interfaces.some(entry => entry.name === name)) return;
                const hostInfo = catalog.find(entry => entry && entry.name === name);
                if (hostInfo && isVmbr0(hostInfo)) {
                    blocked += 1;
                    return;
                }
                const newEntry = { name, attachment: 'existing_router' };
                if (hostInfo) {
                    if (Array.isArray(hostInfo.ipv4)) newEntry.ipv4 = hostInfo.ipv4;
                    if (Array.isArray(hostInfo.ipv6)) newEntry.ipv6 = hostInfo.ipv6;
                    if (hostInfo.mac) newEntry.mac = hostInfo.mac;
                }
                hitlState.interfaces.push(newEntry);
                added += 1;
            });
            if (!added) {
                if (blocked) {
                    try { showToast('Interfaces on vmbr0 cannot be mapped for HITL.', { autohide: true, delay: 2500 }); } catch(e) {}
                } else {
                    try { showToast('Interfaces already selected', { autohide: true, delay: 2000 }); } catch(e) {}
                }
                return;
            }
            hitlState.enabled = true;
            logInfo(`Added ${added} HITL interface${added > 1 ? 's' : ''}`);
            if (blocked) {
                try { showToast('Skipped vmbr0 interfaces; they remain visible but unavailable.', { autohide: true, delay: 2500 }); } catch(e) {}
            }
            persistEditorState();
            const hidden = document.getElementById('scenarios_json');
            if (hidden) hidden.value = JSON.stringify({ scenarios: state.scenarios, active_index: activeIdx });
            renderMain();
        });
    });
    document.querySelectorAll('[data-hitl-attach]').forEach(select => {
        select.addEventListener('change', () => {
            const sidx = parseInt(select.getAttribute('data-scen-idx'));
            const ifaceIdx = parseInt(select.getAttribute('data-iface-index'));
            if (isNaN(sidx) || isNaN(ifaceIdx) || !state.scenarios[sidx]) return;
            const hitlState = ensureHitlStateForScenario(state.scenarios[sidx]);
            if (!Array.isArray(hitlState.interfaces) || !hitlState.interfaces[ifaceIdx]) return;
            const newValue = normalizeHitlAttachment(select.value);
            hitlState.interfaces[ifaceIdx].attachment = newValue;
            logInfo(`Updated HITL attachment for ${hitlState.interfaces[ifaceIdx].name || 'interface'} → ${newValue}`);
            persistEditorState();
            const hidden = document.getElementById('scenarios_json');
            if (hidden) hidden.value = JSON.stringify({ scenarios: state.scenarios, active_index: activeIdx });
            renderMain();
        });
    });
    document.querySelectorAll('[data-hitl-external-vm-select]').forEach(select => {
        select.addEventListener('change', () => {
            const sidx = parseInt(select.getAttribute('data-scen-idx'));
            const ifaceIdx = parseInt(select.getAttribute('data-iface-index'));
            if (isNaN(sidx) || isNaN(ifaceIdx) || !state.scenarios?.[sidx]) return;
            const scenario = state.scenarios[sidx];
            const hitlState = ensureHitlStateForScenario(scenario);
            if (!Array.isArray(hitlState.interfaces) || !hitlState.interfaces[ifaceIdx]) return;
            const ifaceEntry = hitlState.interfaces[ifaceIdx];
            const rawValue = (select.value || '').trim();
            const coreState = hitlState.core || {};
            const coreVmKeyCurrent = (coreState.vm_key || '').toString();
            const proxState = hitlState.proxmox || {};
            const inventory = proxState.inventory && Array.isArray(proxState.inventory.vms) ? proxState.inventory.vms : [];
            if (!rawValue) {
                delete ifaceEntry.external_vm;
                persistEditorState();
                const hidden = document.getElementById('scenarios_json');
                if (hidden) hidden.value = JSON.stringify({ scenarios: state.scenarios, active_index: activeIdx });
                renderMain();
                return;
            }
            if (rawValue === coreVmKeyCurrent) {
                logWarn('Ignoring selection of CORE VM for external connectivity');
                select.value = '';
                delete ifaceEntry.external_vm;
                try { showToast('Select a VM other than the CORE VM.', { autohide: true, delay: 2500 }); } catch (e) {}
                return;
            }
            const selectedVm = inventory.find(vm => `${vm.node ?? ''}::${vm.vmid ?? ''}` === rawValue);
            const [nodePart, vmidPartRaw] = rawValue.split('::');
            const vmidPart = vmidPartRaw && vmidPartRaw.trim() ? vmidPartRaw.trim() : '';
            const normalizedVmNode = selectedVm && selectedVm.node !== undefined && selectedVm.node !== null
                ? String(selectedVm.node).trim()
                : (nodePart || '').trim();
            const physicalInterfaces = selectedVm ? getPhysicalVmInterfaces(selectedVm) : [];
            const baseExternalVm = selectedVm
                ? {
                    vm_key: rawValue,
                    vm_node: normalizedVmNode,
                    vmid: selectedVm.vmid ?? vmidPart,
                    vm_name: selectedVm.name ?? '',
                    status: selectedVm.status ?? '',
                }
                : {
                    vm_key: rawValue,
                    vm_node: normalizedVmNode,
                    vmid: vmidPart,
                    vm_name: '',
                    status: '',
                };
            if (physicalInterfaces.length === 1) {
                const onlyIface = physicalInterfaces[0];
                const ifaceId = normalizeVmInterfaceId(onlyIface);
                if (ifaceId) {
                    baseExternalVm.interface_id = ifaceId;
                    baseExternalVm.interface_bridge = (onlyIface.bridge ?? '').toString().trim();
                    baseExternalVm.interface_mac = (onlyIface.macaddr ?? '').toString().trim();
                    baseExternalVm.interface_model = (onlyIface.model ?? '').toString().trim();
                }
            }
            ifaceEntry.external_vm = baseExternalVm;
            persistEditorState();
            const hidden = document.getElementById('scenarios_json');
            if (hidden) hidden.value = JSON.stringify({ scenarios: state.scenarios, active_index: activeIdx });
            renderMain();
            const labelParts = [];
            if (ifaceEntry.external_vm?.vm_name) labelParts.push(ifaceEntry.external_vm.vm_name);
            if (ifaceEntry.external_vm?.vm_node) labelParts.push(`node ${ifaceEntry.external_vm.vm_node}`);
            if (ifaceEntry.external_vm?.vmid !== undefined && ifaceEntry.external_vm?.vmid !== null && ifaceEntry.external_vm.vmid !== '') {
                labelParts.push(`ID ${ifaceEntry.external_vm.vmid}`);
            }
            if (ifaceEntry.external_vm?.interface_id) {
                labelParts.push(`iface ${ifaceEntry.external_vm.interface_id}`);
                if (ifaceEntry.external_vm.interface_bridge) labelParts.push(`bridge ${ifaceEntry.external_vm.interface_bridge}`);
            }
            try { showToast(`Linked ${ifaceEntry.name || 'interface'} to ${labelParts.join(' • ') || 'selected VM'}`, { autohide: true, delay: 2200 }); } catch (e) {}
        });
    });
    document.querySelectorAll('[data-hitl-external-vm-iface-select]').forEach(select => {
        select.addEventListener('change', () => {
            const sidx = parseInt(select.getAttribute('data-scen-idx'));
            const ifaceIdx = parseInt(select.getAttribute('data-iface-index'));
            if (isNaN(sidx) || isNaN(ifaceIdx) || !state.scenarios?.[sidx]) return;
            const scenario = state.scenarios[sidx];
            const hitlState = ensureHitlStateForScenario(scenario);
            if (!Array.isArray(hitlState.interfaces) || !hitlState.interfaces[ifaceIdx]) return;
            const ifaceEntry = hitlState.interfaces[ifaceIdx];
            if (!ifaceEntry.external_vm || typeof ifaceEntry.external_vm !== 'object') return;
            const rawValue = (select.value || '').trim();
            const proxState = hitlState.proxmox || {};
            const inventory = proxState.inventory && Array.isArray(proxState.inventory.vms) ? proxState.inventory.vms : [];
            const externalVmKey = ifaceEntry.external_vm.vm_key || '';
            const selectedVm = inventory.find(vm => `${vm.node ?? ''}::${vm.vmid ?? ''}` === externalVmKey);
            const physicalInterfaces = selectedVm ? getPhysicalVmInterfaces(selectedVm) : [];
            if (!rawValue) {
                delete ifaceEntry.external_vm.interface_id;
                delete ifaceEntry.external_vm.interface_bridge;
                delete ifaceEntry.external_vm.interface_mac;
                delete ifaceEntry.external_vm.interface_model;
                persistEditorState();
                const hidden = document.getElementById('scenarios_json');
                if (hidden) hidden.value = JSON.stringify({ scenarios: state.scenarios, active_index: activeIdx });
                renderMain();
                try { showToast(`Cleared external interface for ${ifaceEntry.name || 'interface'}.`, { autohide: true, delay: 2000 }); } catch (e) {}
                return;
            }
            const matchedIface = physicalInterfaces.find(vmIface => normalizeVmInterfaceId(vmIface) === rawValue) || null;
            ifaceEntry.external_vm.interface_id = rawValue;
            ifaceEntry.external_vm.interface_bridge = matchedIface && matchedIface.bridge ? String(matchedIface.bridge).trim() : '';
            ifaceEntry.external_vm.interface_mac = matchedIface && matchedIface.macaddr ? String(matchedIface.macaddr).trim() : '';
            ifaceEntry.external_vm.interface_model = matchedIface && matchedIface.model ? String(matchedIface.model).trim() : '';
            persistEditorState();
            const hidden = document.getElementById('scenarios_json');
            if (hidden) hidden.value = JSON.stringify({ scenarios: state.scenarios, active_index: activeIdx });
            renderMain();
            const labelParts = [];
            if (ifaceEntry.external_vm?.vm_name) labelParts.push(ifaceEntry.external_vm.vm_name);
            if (ifaceEntry.external_vm?.vm_node) labelParts.push(`node ${ifaceEntry.external_vm.vm_node}`);
            labelParts.push(`iface ${rawValue}`);
            if (ifaceEntry.external_vm.interface_bridge) labelParts.push(`bridge ${ifaceEntry.external_vm.interface_bridge}`);
            try { showToast(`Mapped ${ifaceEntry.name || 'interface'} to ${labelParts.join(' • ')}`, { autohide: true, delay: 2200 }); } catch (e) {}
        });
    });
    document.querySelectorAll('[data-hitl-step4-refresh]').forEach(btn => {
        btn.addEventListener('click', async () => {
            if (btn.disabled) return;
            const sidx = parseInt(btn.getAttribute('data-scen-idx'));
            if (isNaN(sidx) || !state.scenarios?.[sidx]) return;
            btn.disabled = true;
            const originalLabel = btn.innerHTML;
            btn.innerHTML = 'Refreshing…';
            try { showToast('Refreshing Proxmox interfaces…', { autohide: true, delay: 1800 }); } catch (e) {}
            try {
                await fetchProxmoxInventory(sidx, { force: true });
            } finally {
                // renderMain will rebuild the button; restore label in case this element persists before re-render
                btn.innerHTML = originalLabel;
            }
        });
    });
    document.querySelectorAll('[data-hitl-remove]').forEach(btn => {
        btn.addEventListener('click', () => {
            const sidx = parseInt(btn.getAttribute('data-scen-idx'));
            const ifaceName = btn.getAttribute('data-iface');
            if (isNaN(sidx) || !state.scenarios[sidx] || !ifaceName) return;
            const hitlState = ensureHitlStateForScenario(state.scenarios[sidx]);
            const idx = hitlState.interfaces.findIndex(entry => entry.name === ifaceName);
            if (idx === -1) return;
            hitlState.interfaces.splice(idx, 1);
            logInfo(`Removed HITL interface ${ifaceName}`);
            persistEditorState();
            const hidden = document.getElementById('scenarios_json');
            if (hidden) hidden.value = JSON.stringify({ scenarios: state.scenarios, active_index: activeIdx });
            renderMain();
        });
    });
    document.querySelectorAll('[data-proxmox-refresh]').forEach(btn => {
        btn.addEventListener('click', async () => {
            if (btn.disabled) return;
            const sidx = parseInt(btn.getAttribute('data-scen-idx'));
            if (Number.isNaN(sidx)) return;
            const originalHtml = btn.innerHTML;
            btn.disabled = true;
            btn.innerHTML = '<span class="spinner-border spinner-border-sm me-1" role="status" aria-hidden="true"></span>Refreshing VMs';
            try {
                await fetchProxmoxInventory(sidx, { force: true });
            } finally {
                if (document.body.contains(btn)) {
                    btn.disabled = false;
                    btn.innerHTML = originalHtml;
                }
            }
        });
    });
    document.querySelectorAll('[data-hitl-apply]').forEach(btn => {
        btn.addEventListener('click', async () => {
            if (btn.disabled) return;
            const sidx = parseInt(btn.getAttribute('data-scen-idx'));
            if (Number.isNaN(sidx)) return;
            // Open the External IFX modal to display progress/status if available
            try {
                const modalEl = document.getElementById('externalIfxModal');
                if (modalEl && window.bootstrap && window.bootstrap.Modal) {
                    const modalInstance = window.bootstrap.Modal.getOrCreateInstance(modalEl);
                    modalInstance.show();
                }
            } catch (e) { /* no-op */ }
            // Delegate to existing apply handler
            try {
                await handleExternalIfxApply();
            } catch (err) {
                console.warn('HITL apply failed', err);
            }
        });
    });
    document.querySelectorAll('[data-hitl-core-vm-select]').forEach(select => {
        select.addEventListener('change', () => {
            const sidx = parseInt(select.getAttribute('data-scen-idx'));
            if (isNaN(sidx) || !state.scenarios?.[sidx]) return;
            const hitlState = ensureHitlStateForScenario(state.scenarios[sidx]);
            const coreState = hitlState.core || (hitlState.core = {});
            const rawValue = select.value || '';
            const resetCoreSelection = () => {
                coreState.vm_key = '';
                coreState.vm_name = '';
                coreState.vm_node = '';
                coreState.last_tested_status = null;
                coreState.last_tested_message = null;
                coreState.last_tested_at = null;
                coreState.last_tested_host = null;
                coreState.last_tested_port = null;
                coreState.core_secret_id = null;
                coreState.validated = false;
                coreState.last_validated_at = null;
                coreState.stored_summary = null;
                coreState.internal_bridge = '';
                coreState.internal_bridge_owner = '';
            };
            if (!rawValue) {
                resetCoreSelection();
                persistEditorState();
                const pwdInput = document.querySelector(`[data-hitl-core-field="ssh_password"][data-scen-idx="${sidx}"]`);
                if (pwdInput) pwdInput.removeAttribute('placeholder');
                const hidden = document.getElementById('scenarios_json');
                if (hidden) hidden.value = JSON.stringify({ scenarios: state.scenarios, active_index: activeIdx });
                renderMain();
                return;
            }
            const proxState = hitlState.proxmox || {};
            const inventory = proxState.inventory && Array.isArray(proxState.inventory.vms) ? proxState.inventory.vms : [];
            const selectedVm = inventory.find(vm => `${vm.node ?? ''}::${vm.vmid ?? ''}` === rawValue) || null;
            const [nodePart, vmidPartRaw] = rawValue.split('::');
            resetCoreSelection();
            coreState.vm_key = rawValue;
            coreState.vm_name = selectedVm && selectedVm.name ? String(selectedVm.name) : '';
            coreState.vm_node = selectedVm && selectedVm.node !== undefined && selectedVm.node !== null
                ? String(selectedVm.node)
                : (nodePart || '').trim();
            if (!coreState.vm_name && coreState.vm_node && vmidPartRaw && vmidPartRaw.trim()) {
                coreState.vm_name = `${coreState.vm_node}::${vmidPartRaw.trim()}`;
            }
            persistEditorState();
            const pwdInput = document.querySelector(`[data-hitl-core-field="ssh_password"][data-scen-idx="${sidx}"]`);
            if (pwdInput) pwdInput.removeAttribute('placeholder');
            const hidden = document.getElementById('scenarios_json');
            if (hidden) hidden.value = JSON.stringify({ scenarios: state.scenarios, active_index: activeIdx });
            renderMain();
        });
    });
    document.querySelectorAll('[data-hitl-core-field]').forEach(input => {
        if (input.closest('#coreConnectionModal')) return;
        input.addEventListener('input', () => handleCoreFieldUpdate(input, { rerender: false }));
        input.addEventListener('change', () => handleCoreFieldUpdate(input, { rerender: true }));
    });
    document.querySelectorAll('[data-hitl-core-test]').forEach(btn => {
        btn.addEventListener('click', async () => {
            if (btn.disabled) return;
            const sidx = parseInt(btn.getAttribute('data-scen-idx'));
            await validateCoreConnection(sidx, {
                triggerButton: btn,
                workingLabel: 'Testing…',
            });
        });
    });
    document.querySelectorAll('[data-hitl-core-clear]').forEach(btn => {
        btn.addEventListener('click', () => {
            const sidx = parseInt(btn.getAttribute('data-scen-idx'));
            if (isNaN(sidx) || !state.scenarios?.[sidx]) return;
            const hitlState = ensureHitlStateForScenario(state.scenarios[sidx]);
            const existingSecretId = hitlState.core && typeof hitlState.core.core_secret_id === 'string' ? hitlState.core.core_secret_id : null;
            if (existingSecretId) {
                try {
                    const payload = {
                        core_secret_id: existingSecretId,
                        scenario_index: sidx,
                        scenario_name: state.scenarios?.[sidx]?.name || '',
                    };
                    fetch('/api/core/credentials/clear', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        credentials: 'same-origin',
                        body: JSON.stringify(payload),
                    }).catch(err => logError(`Failed to clear stored CORE credentials: ${err}`));
                } catch (err) {
                    logError(`Exception during CORE credential clear: ${err}`);
                }
            }
            hitlState.core = {
                vm_key: '',
                vm_name: '',
                vm_node: '',
                grpc_host: '',
                grpc_port: 50051,
                ssh_host: '',
                ssh_port: 22,
                ssh_username: '',
                ssh_password: '',
                core_secret_id: null,
                validated: false,
                last_validated_at: null,
                stored_summary: null,
                last_tested_at: null,
                last_tested_status: null,
                last_tested_message: null,
                last_tested_host: null,
                last_tested_port: null,
                internal_bridge: '',
                internal_bridge_owner: '',
                last_interfaces_refresh: null,
                last_interfaces_attempt: null,
                interfaces_refresh_inflight: false,
                last_interfaces_error: null,
            };
            persistEditorState();
            const hidden = document.getElementById('scenarios_json');
            if (hidden) hidden.value = JSON.stringify({ scenarios: state.scenarios, active_index: activeIdx });
            const pwdInput = document.querySelector(`[data-hitl-core-field="ssh_password"][data-scen-idx="${sidx}"]`);
            if (pwdInput) pwdInput.removeAttribute('placeholder');
            renderMain();
        });
    });
    document.querySelectorAll('[data-hitl-refresh]').forEach(btn => {
        btn.addEventListener('click', async () => {
            const sidx = parseInt(btn.getAttribute('data-scen-idx'));
            if (Number.isNaN(sidx)) return;
            const originalHtml = btn.innerHTML;
            btn.disabled = true;
            btn.setAttribute('data-refresh-busy', '1');
            btn.innerHTML = '<span class="spinner-border spinner-border-sm me-2" role="status" aria-hidden="true"></span>Refreshing…';
            try {
                await refreshHostInterfacesForScenario(sidx, { reason: 'manual' });
            } finally {
                if (document.body.contains(btn)) {
                    btn.disabled = false;
                    btn.innerHTML = originalHtml;
                    btn.removeAttribute('data-refresh-busy');
                }
            }
        });
    });
    const proxAssignModal = document.getElementById('proxmoxAssignModal');
    const proxAssignHint = document.getElementById('proxmoxAssignHint');
    const proxAssignError = document.getElementById('proxmoxAssignError');
    const proxAssignForm = document.getElementById('proxmoxAssignForm');
    const proxUrlInput = document.getElementById('proxmoxUrl');
    const proxPortInput = document.getElementById('proxmoxPort');
    const proxUserInput = document.getElementById('proxmoxUsername');
    const proxPassInput = document.getElementById('proxmoxPassword');
    const proxVerifyInput = document.getElementById('proxmoxVerifySsl');
    const setProxAssignHint = (message, tone = 'info') => {
        if (!proxAssignHint) return;
        proxAssignHint.textContent = message || '';
        proxAssignHint.style.display = message ? '' : 'none';
        proxAssignHint.classList.remove('alert-info', 'alert-success', 'alert-danger');
        const klass = tone === 'success' ? 'alert-success' : tone === 'danger' ? 'alert-danger' : 'alert-info';
        proxAssignHint.classList.add(klass);
    };
    window.setProxAssignHint = setProxAssignHint;
    coreConnectionModal = document.getElementById('coreConnectionModal');
    coreConnectionForm = document.getElementById('coreConnectionForm');
    coreConnectionHint = document.getElementById('coreConnectionHint');
    coreConnectionSaveBtn = document.getElementById('coreConnectionSaveBtn');
    coreModalInputs.grpc_host = document.getElementById('coreGrpcHost');
    coreModalInputs.grpc_port = document.getElementById('coreGrpcPort');
    coreModalInputs.ssh_host = document.getElementById('coreSshHost');
    coreModalInputs.ssh_port = document.getElementById('coreSshPort');
    coreModalInputs.ssh_username = document.getElementById('coreSshUsername');
    coreModalInputs.ssh_password = document.getElementById('coreSshPassword');
    setCoreConnectionHint = (message, tone = 'info') => {
        if (!coreConnectionHint) return;
        coreConnectionHint.textContent = message || '';
        coreConnectionHint.style.display = message ? '' : 'none';
        coreConnectionHint.classList.toggle('d-none', !message);
        coreConnectionHint.classList.remove('alert-info', 'alert-success', 'alert-warning', 'alert-danger');
        const klass = tone === 'success'
            ? 'alert-success'
            : tone === 'warning'
                ? 'alert-warning'
                : tone === 'danger'
                    ? 'alert-danger'
                    : 'alert-info';
        coreConnectionHint.classList.add(klass);
    };
    window.setCoreConnectionHint = setCoreConnectionHint;
    wireCoreConnectionSaveButton();
    document.querySelectorAll('[data-proxmox-assign]').forEach(btn => {
        btn.addEventListener('click', () => {
            const sidx = parseInt(btn.getAttribute('data-scen-idx'));
            if (isNaN(sidx) || !state.scenarios?.[sidx]) return;
            if (!proxAssignModal || !window.bootstrap) {
                console.warn('Proxmox modal not available');
                return;
            }
            const scenario = state.scenarios[sidx];
            const hitlState = ensureHitlStateForScenario(scenario);
            const prox = hitlState.proxmox || { url: '', port: 8006, username: '' };
            proxAssignModal.setAttribute('data-scen-idx', String(sidx));
            const scenName = (scenario?.name || '').trim() || `Scenario ${sidx + 1}`;
            if (proxAssignError) {
                proxAssignError.textContent = '';
                proxAssignError.classList.add('d-none');
            }
            if (proxAssignForm) {
                proxAssignForm.classList.remove('was-validated');
            }
            if (proxVerifyInput) {
                if (typeof prox.verify_ssl === 'boolean') {
                    proxVerifyInput.checked = prox.verify_ssl;
                } else if (prox.url) {
                    proxVerifyInput.checked = /^https:/i.test(prox.url);
                } else {
                    proxVerifyInput.checked = true;
                }
            }
            if (proxUrlInput) proxUrlInput.value = prox.url || '';
            if (proxPortInput) proxPortInput.value = prox.port ?? 8006;
            if (proxUserInput) proxUserInput.value = prox.username || '';
            if (proxPassInput) proxPassInput.value = '';
            if (proxVerifyInput) {
                if (typeof prox.verify_ssl === 'boolean') {
                    proxVerifyInput.checked = prox.verify_ssl;
                } else {
                    proxVerifyInput.checked = true;
                }
            }
            let validatedStamp = 'a previous run';
            if (prox.last_validated_at) {
                try {
                    const dtTemp = new Date(prox.last_validated_at);
                    if (!Number.isNaN(dtTemp.getTime())) {
                        validatedStamp = dtTemp.toLocaleString();
                    }
                } catch (err) {
                    validatedStamp = 'a previous run';
                }
            }
            const msg = prox.validated && prox.secret_id
                ? `Validated on ${validatedStamp}. Re-enter password to re-validate.`
                : 'Enter credentials to validate and store securely.';
            setProxAssignHint(`Configure Proxmox resources for ${scenName}. ${msg}`, prox.validated && prox.secret_id ? 'success' : 'info');
            const modalObj = bootstrap.Modal.getInstance(proxAssignModal) || new bootstrap.Modal(proxAssignModal, { backdrop: true, keyboard: true });
            modalObj.show();
            setTimeout(() => {
                try {
                    proxUrlInput?.focus();
                    proxUrlInput?.select?.();
                } catch(e){}
            }, 150);
        });
    });
    document.querySelectorAll('[data-proxmox-clear]').forEach(btn => {
        btn.addEventListener('click', async () => {
            const sidx = parseInt(btn.getAttribute('data-scen-idx'));
            if (isNaN(sidx) || !state.scenarios?.[sidx]) return;
            const scenario = state.scenarios[sidx];
            const hitlState = ensureHitlStateForScenario(scenario);
            const prox = hitlState.proxmox || {};
            const hasAny = !!(prox.secret_id || prox.url || prox.username);
            if (!hasAny) {
                try { showToast('No Proxmox credentials to clear', { autohide: true, delay: 2000 }); } catch(e) {}
                return;
            }
            const confirmClear = window.confirm('Clear saved Proxmox credentials for this scenario?');
            if (!confirmClear) return;
            const originalLabel = btn.textContent;
            btn.disabled = true;
            btn.dataset.busy = 'true';
            btn.textContent = 'Clearing…';
            try {
                const resp = await fetch('/api/proxmox/clear', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    credentials: 'same-origin',
                    body: JSON.stringify({
                        scenario_index: sidx,
                        scenario_name: scenario?.name || '',
                        secret_id: prox.secret_id || null,
                    }),
                });
                let data = null;
                try { data = await resp.json(); } catch(err) { data = null; }
                if (!resp.ok || (data && data.success === false)) {
                    const message = (data && (data.error || data.message)) || `Failed to clear credentials (HTTP ${resp.status})`;
                    throw new Error(message);
                }
                hitlState.proxmox = {
                    url: '',
                    port: 8006,
                    username: '',
                    verify_ssl: true,
                    secret_id: null,
                    validated: false,
                    last_validated_at: null,
                    last_message: 'Proxmox credentials cleared.',
                };
                if (Array.isArray(hitlState.interfaces)) {
                    hitlState.interfaces = hitlState.interfaces.map(entry => {
                        if (!entry || typeof entry !== 'object') return entry;
                        if ('proxmox_target' in entry) {
                            delete entry.proxmox_target;
                        }
                        const attachment = entry.attachment ? normalizeHitlAttachment(entry.attachment) : '';
                        if (attachment === 'proxmox_vm') {
                            entry.attachment = DEFAULT_HITL_ATTACHMENT;
                        }
                        return entry;
                    });
                }
                persistEditorState();
                const hidden = document.getElementById('scenarios_json');
                if (hidden) hidden.value = JSON.stringify({ scenarios: state.scenarios, active_index: activeIdx });
                updateProxmoxSummary(sidx);
                renderMain();
                try { showToast('Proxmox credentials cleared', { autohide: true, delay: 2500 }); } catch(e) {}
                logInfo('Cleared Proxmox credentials for scenario');
            } catch (err) {
                const message = err instanceof Error ? err.message : 'Failed to clear Proxmox credentials';
                logError(message);
                try { showToast(message, { autohide: false }); } catch(e) {}
            } finally {
                btn.disabled = false;
                btn.textContent = originalLabel || 'Clear Proxmox Resource';
                delete btn.dataset.busy;
            }
        });
    });
    // Export preview handler
    const previewBtn = document.querySelector('[data-action="preview-plan"]');
    if (previewBtn) {
        previewBtn.onclick = () => {
            const scen = state.scenarios[activeIdx];
            if (!scen) return;
            const ni = scen.sections['Node Information'] || { items: [], total_nodes:0 };
            const weightRows = (ni.items||[]).filter(it => (it.v_metric || (it.selected==='Specific'? 'Count':'Weight'))==='Weight');
            const countRows = (ni.items||[]).filter(it => (it.v_metric || (it.selected==='Specific'? 'Count':'Weight'))==='Count');
            const base = weightRows.length ? (parseInt(scen.density_count || 0) || 0) : 0;
            const addHosts = countRows.reduce((a,it)=> a + (parseInt(it.v_count,10)||0),0);
            const totalHosts = base + addHosts;
            let allocTable = [];
            if (base>0 && weightRows.length) {
                const sumW = weightRows.reduce((a,it)=> a + (parseFloat(it.factor)||0),0) || 1;
                const temp = weightRows.map(it => {
                    const f = parseFloat(it.factor)||0; const share = sumW? f/sumW:0; const raw = base*share; const alloc = Math.floor(raw);
                    return { it, share, raw, alloc, frac: raw - alloc };
                });
                let assigned = temp.reduce((a,r)=> a + r.alloc,0);
                let remain = base - assigned;
                temp.sort((a,b)=> b.frac - a.frac);
                for (let i=0;i<temp.length && remain>0;i++) { temp[i].alloc += 1; remain--; }
                allocTable = temp.sort((a,b)=> (ni.items.indexOf(a.it) - ni.items.indexOf(b.it))).map(r => ({ label: r.it.selected || 'Row', weight: (parseFloat(r.it.factor)||0), percent: (r.share*100), alloc: r.alloc }));
            }
            const routing = scen.sections['Routing'] || { items: [], density: 0 };
            const rWeight = (routing.items||[]).filter(it => (it.v_metric||'Weight')==='Weight');
            const rCount = (routing.items||[]).filter(it => (it.v_metric||'Weight')==='Count');
            const rExplicit = rCount.reduce((a,it)=> a + (parseInt(it.v_count,10)||0),0);
            let rDerived = 0; if (rWeight.length) { const d = parseFloat(routing.density)||0; rDerived = (d>=1)? d : Math.round((totalHosts - addHosts) * d); }
            const totalRouters = rExplicit + rDerived;
            const vulns = scen.sections['Vulnerabilities'] || { items: [], density: 0 };
            const vWeight = (vulns.items||[]).filter(it => (it.v_metric || (it.selected==='Specific'?'Count':'Weight'))==='Weight');
            const vCount = (vulns.items||[]).filter(it => (it.v_metric || (it.selected==='Specific'?'Count':'Weight'))==='Count');
            const vExplicit = vCount.reduce((a,it)=> a + (parseInt(it.v_count,10)||0),0);
            let vDerived = 0; if (vWeight.length) { const d = Math.min(1, Math.max(0, parseFloat(vulns.density)||0)); vDerived = Math.round((totalHosts - addHosts) * d); }
            const totalVulns = vExplicit + vDerived;
            const rowsHtml = allocTable.length ? allocTable.map(r => `<tr><td>${r.label}</td><td>${r.weight.toFixed(3)}</td><td>${r.percent.toFixed(1)}%</td><td>${r.alloc}</td></tr>`).join('') : '<tr><td colspan="4" class="text-muted">No weight allocation</td></tr>';
            const modalHtml = `
<div class=\"modal fade\" id=\"previewModal\" tabindex=\"-1\" aria-hidden=\"true\">\n  <div class=\"modal-dialog modal-lg modal-dialog-scrollable\">\n    <div class=\"modal-content\">\n      <div class=\"modal-header\">\n        <h5 class=\"modal-title\">Plan Preview: ${scen.name}</h5>\n        <button type=\"button\" class=\"btn-close\" data-bs-dismiss=\"modal\" aria-label=\"Close\"></button>\n      </div>\n      <div class=\"modal-body\">\n        <div class=\"progress mb-3 d-none\" id=\"previewExecuteProgress\">\n          <div class=\"progress-bar progress-bar-striped progress-bar-animated\" id=\"previewExecuteProgressBar\" style=\"width:100%\">Running…</div>\n        </div>\n        <div class=\"row mb-3\">\n          <div class=\"col-md-4\"><div class=\"card card-body p-2\"><small class=\"text-muted\">Hosts Total</small><div class=\"fs-5\">${totalHosts}</div><div class=\"small text-muted\">Base ${base} + Add ${addHosts}</div></div></div>\n          <div class=\"col-md-4\"><div class=\"card card-body p-2\"><small class=\"text-muted\">Routers</small><div class=\"fs-5\">${totalRouters}</div><div class=\"small text-muted\">Explicit ${rExplicit} + Derived ${rDerived}</div></div></div>\n          <div class=\"col-md-4\"><div class=\"card card-body p-2\"><small class=\"text-muted\">Vulns</small><div class=\"fs-5\">${totalVulns}</div><div class=\"small text-muted\">Explicit ${vExplicit} + Derived ${vDerived}</div></div></div>\n        </div>\n        <h6>Host Weight Allocation</h6>\n        <div class=\"table-responsive\">\n          <table class=\"table table-sm\">\n            <thead><tr><th>Row</th><th>Weight</th><th>%</th><th>Alloc</th></tr></thead>\n            <tbody>${rowsHtml}</tbody>\n          </table>\n        </div>\n      </div>\n      <div class=\"modal-footer\">\n        <button type=\"button\" class=\"btn btn-sm btn-warning\" id=\"previewModalExecuteBtn\">Execute</button>\n        <button type=\"button\" class=\"btn btn-sm btn-outline-secondary\" data-bs-dismiss=\"modal\">Close</button>\n      </div>\n    </div>\n  </div>\n</div>`;
            let container = document.getElementById('previewModalContainer');
            if (!container) { container = document.createElement('div'); container.id = 'previewModalContainer'; document.body.appendChild(container); }
            container.innerHTML = modalHtml;
            const modalEl = container.querySelector('#previewModal');
            let modalInstance = null;
            if (window.bootstrap) {
                try {
                    modalInstance = new bootstrap.Modal(modalEl);
                } catch(e) {
                    alert('Bootstrap modal failed; see console');
                    console.error(e);
                }
            } else {
                alert('Bootstrap not loaded.');
            }
            setupPreviewModalExecute(modalEl, modalInstance);
            try { modalInstance?.show(); } catch(e) {}
        };
    }
    // Initialize popovers & tooltips (Bootstrap 5)
    if (window.bootstrap) {
        document.querySelectorAll('[data-bs-toggle="popover"]').forEach(el => { try { new bootstrap.Popover(el); } catch(e) {} });
        document.querySelectorAll('[data-bs-toggle="tooltip"]').forEach(el => { try { new bootstrap.Tooltip(el); } catch(e) {} });
    }
    // Flash animation on Base input change
    document.querySelectorAll('.base-input').forEach(inp => {
        inp.addEventListener('change', () => {
            const badge = document.querySelector('.host-total-badge');
            if (!badge) return;
            badge.classList.add('pulse-change');
            setTimeout(()=> badge.classList.remove('pulse-change'), 900);
        });
    });
    document.querySelectorAll('[data-action="remove-scenario"]').forEach(btn => {
        btn.onclick = async (ev) => {
            if (ev && typeof ev.preventDefault === 'function') ev.preventDefault();
            if (ev && typeof ev.stopPropagation === 'function') ev.stopPropagation();
            const sidx = parseInt(btn.getAttribute('data-scen-idx'));
            const scen = state.scenarios[sidx];
            if (!scen) { return; }
            let runCount = 0;
            try {
                const resp = await fetch('/reports_data');
                if (resp.ok) {
                    const data = await resp.json();
                    runCount = (data.history || []).filter(r => (r.scenario_names || []).includes(scen.name)).length;
                }
            } catch (e) {}
            const lines = [];
            lines.push(`Delete scenario "${scen.name}"?`);
            if (runCount > 0) {
                lines.push("");
                lines.push(`WARNING: ${runCount} run history entr${runCount===1?'y':'ies'} and their artifact files (XML, report, pre-session XML) will be permanently deleted.`);
            }
            lines.push("");
            lines.push("This action cannot be undone.");
            lines.push("");
            lines.push("Proceed?");
            const msg = lines.join('\n');
            if (!window.confirm(msg)) { return; }

            // Remove scenario
            state.scenarios.splice(sidx, 1);
            // Leave list empty if last scenario removed
            activeIdx = state.scenarios.length === 0 ? 0 : Math.min(sidx, state.scenarios.length - 1);
            // Persist immediately before re-render so state survives any navigation
            const hidden = document.getElementById('scenarios_json');
            if (hidden) hidden.value = JSON.stringify({ scenarios: state.scenarios });
            persistEditorState();
            logInfo(`Deleted scenario: ${scen.name}`);
            // Re-render UI
            render();
            try { showToast(`Scenario "${scen.name}" deleted`); } catch(e){}

            // Purge matching run history and artifacts in background
            if (runCount > 0) {
                try {
                    await fetch('/purge_history_for_scenario', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ name: scen.name })
                    });
                } catch (e) {}
            }
        };
    });
    // keep hidden JSON synced
    const aiHidden = document.getElementById('active_index'); if(aiHidden) aiHidden.value = String(activeIdx);
    document.getElementById('scenarios_json').value = JSON.stringify({ scenarios: state.scenarios, active_index: activeIdx });
    persistEditorState();
        // Initialize warnings per section
        const scen = state.scenarios[activeIdx];
        if (scen) {
            ['Node Information','Routing','Services','Traffic','Events','Vulnerabilities','Segmentation'].forEach(sec => updateWeightWarning(activeIdx, sec));
        }
}
// Routing edges validation utilities
function validateRoutingEdges(){
    const scen = state.scenarios[activeIdx]; if(!scen) return;
    const routing = (scen.sections && scen.sections['Routing'] && scen.sections['Routing'].items) || [];
    const warn = [];
    routing.forEach((r,i)=>{ const m = r.r2r_mode; if(m==='Exact' && !(r.edges>=1)) warn.push(`Row ${i+1}: Exact mode requires a degree ≥ 1`); });
    routing.forEach((r,i)=>{ if(r.r2s_mode==='Exact' && !(r.r2s_edges>=1)) warn.push(`Row ${i+1}: R-to-S Exact requires a value ≥ 1`); });
    // Highlight inputs
    document.querySelectorAll('.edges-degree-input').forEach(inp => {
        const v = parseInt(inp.value,10); const tr = inp.closest('tr');
    const sel = tr ? tr.querySelector('[data-field="r2r_mode"]') : null;
        const mode = sel ? sel.value : '';
        if(mode==='Exact' && !(v>=1)) inp.classList.add('is-invalid'); else inp.classList.remove('is-invalid');
    });
    document.querySelectorAll('.r2s-degree-input').forEach(inp => {
        const v = parseInt(inp.value,10); const tr = inp.closest('tr');
        const sel = tr ? tr.querySelector('[data-field="r2s_mode"]') : null;
        const mode = sel ? sel.value : '';
        if(mode==='Exact' && !(v>=1)) inp.classList.add('is-invalid'); else inp.classList.remove('is-invalid');
    });
    // If a separate warning container existed we could populate it here later.
    computeRoutingEdgePolicyPreview();
}
setTimeout(validateRoutingEdges, 500);

// Derive a lightweight preview (pre-generation) of intended policy and an estimated degree band
function computeRoutingEdgePolicyPreview(){
    const scen = state.scenarios[activeIdx]; if(!scen) return;
    const routing = (scen.sections && scen.sections['Routing'] && scen.sections['Routing'].items) || [];
    const summaryEl = document.getElementById('routingEdgesSummary');
    if(!summaryEl) return;
    if(!routing.length){ summaryEl.style.display='none'; return; }
    // Determine target policy: Exact avg > Max > Min > Random (mirrors backend)
    const exactVals = routing.filter(r=> r.r2r_mode==='Exact' && r.edges>=1).map(r=>r.edges);
    let mode='Random'; let target=0;
    if(exactVals.length){
        target = Math.round(exactVals.reduce((a,b)=>a+b,0)/exactVals.length);
        if(target<1) target=1; mode='Exact';
    } else {
    const modes = routing.map(r=> r.r2r_mode).filter(Boolean);
    if(modes.includes('Uniform')) mode='Uniform';
        else if(modes.includes('Min')) mode='Min';
        else if(modes.includes('NonUniform')) mode='NonUniform';
        else mode='Random';
    }
    // Determine predominant R-to-S mode (simple precedence similar to R-to-R)
    let r2sMode = 'Random';
    const r2sExactVals = routing.filter(r=>r.r2s_mode==='Exact' && r.r2s_edges>=1).map(r=>r.r2s_edges);
    if(r2sExactVals.length){
        r2sMode = 'Exact';
    } else {
        const r2sModes = routing.map(r=>r.r2s_mode).filter(Boolean);
    if(r2sModes.includes('Uniform')) r2sMode='Uniform';
        else if(r2sModes.includes('Min')) r2sMode='Min';
        else if(r2sModes.includes('NonUniform')) r2sMode='NonUniform';
        else r2sMode='Random';
    }
    const policySpan = summaryEl.querySelector('[data-role="edges-policy"]');
    if(policySpan){ policySpan.textContent = `R-R: ${mode}${mode==='Exact'?`(≈${target})`:''} | R-S: ${r2sMode}`; }
    // Estimate degree distribution preview (pure heuristic):
    let minD=0, avgD=0, maxD=0;
    if(mode==='Exact'){ minD=target; avgD=target+1; maxD=target+2; }
    else if(mode==='Uniform'){ minD=4; avgD=4; maxD=5; }
    else if(mode==='NonUniform'){ minD=1; avgD=3; maxD=8; }
    else if(mode==='Min'){ minD=2; avgD=3; maxD=4; }
    else { minD=1; avgD=2; maxD=4; }
    // Removed Min/Avg/Max and sparkline visualization per request
    // Resource warning for Uniform (previously Max) mode – still warn if near-dense
	const warnEl = document.getElementById('routingEdgesWarnings');
	if(warnEl){
	    warnEl.classList.add('d-none');
	    warnEl.innerHTML='';
        if(mode==='Uniform'){
	        // Approximate router count: we don't know exact until build; use routing item count as lower bound
	        let approxRouters = routing.length || 0;
	        // If scenario embeds an explicit router count in future, prefer it; attempt common field names
	        if(typeof scen.router_count === 'number' && scen.router_count > approxRouters) approxRouters = scen.router_count;
	        if(typeof scen.routers_total === 'number' && scen.routers_total > approxRouters) approxRouters = scen.routers_total;
	        // Compute full mesh edges estimate
	        const estEdges = approxRouters > 1 ? (approxRouters * (approxRouters - 1) / 2) : 0;
	        // Thresholds: warn if routers >= 25 OR estimated edges >= 300
	        if(approxRouters >= 25 || estEdges >= 300){
	            const edgesFmt = estEdges.toLocaleString();
                warnEl.innerHTML = `<strong>Uniform Mode:</strong> balanced high degree connectivity can grow ~O(n²). With ~${approxRouters} routers this implies about ${edgesFmt} potential links. This may increase session startup time and resource usage.`;
	            warnEl.classList.remove('d-none');
	        } else {
	            // Light advisory (still show something so users understand cost) for smaller counts
	            if(approxRouters >= 10){
                    warnEl.innerHTML = `<strong>Heads up:</strong> Uniform mode aims for evenly high degrees (approaches dense graph). Routers: ~${approxRouters}.`;
	                warnEl.classList.remove('d-none');
	            }
	        }
	    }
	}
    summaryEl.style.display='flex';
}

function prepareRunCli() {
    // prefer the last saved XML path or result_path if it's XML
    const rp = state.result_path || '';
    if (!rp.endsWith('.xml')) {
        alert('Please save XML first.');
        logWarn('Run CLI blocked: no saved XML');
        return false;
    }
    // confirmation dialog warning user a CORE scenario will be created and started
    const confirmMsg = 'This action will generate a new CORE scenario and attempt to start it using the provided daemon connection.\n\nProceed?';
    if (!window.confirm(confirmMsg)) {
        logInfo('Run CLI cancelled by user at confirmation');
        return false;
    }
    document.getElementById('xml_path').value = rp;
    logInfo('Running CLI sync');
    // Preserve scroll so after the round trip we land where we were
    try { saveScrollBeforeNav(); } catch(e){}
    return true;
}

let coreConnectionModal = null;
let coreConnectionForm = null;
let coreConnectionHint = null;
let coreConnectionSaveBtn = null;
const coreModalInputs = {
    grpc_host: null,
    grpc_port: null,
    ssh_host: null,
    ssh_port: null,
    ssh_username: null,
    ssh_password: null,
};
let setCoreConnectionHint = null;

render();

// Restore scroll position if previously saved before a Save XML navigation
function restoreScrollIfAny() {
    try {
        const y = parseInt(sessionStorage.getItem('coretg_saved_scroll_y') || '', 10);
        if (!isNaN(y)) {
            window.scrollTo(0, y);
            sessionStorage.removeItem('coretg_saved_scroll_y');
        }
    } catch (e) { /* ignore */ }
}
// Use load to ensure layout (including dock sizing) has been applied
window.addEventListener('load', restoreScrollIfAny);

// Small helper to persist current scroll position prior to any navigation (form post or link)
function saveScrollBeforeNav(){
    try { sessionStorage.setItem('coretg_saved_scroll_y', String(window.scrollY || window.pageYOffset || 0)); } catch (e) { /* ignore */ }
}

// Always serialize state just before submitting the Save XML form
const editorForm = document.getElementById('editorForm');

if (editorForm) {
    editorForm.addEventListener('submit', () => {
        // preserve current scroll so we can restore after the server round-trip
        try { sessionStorage.setItem('coretg_saved_scroll_y', String(window.scrollY || window.pageYOffset || 0)); } catch (e) { /* ignore */ }
    document.getElementById('scenarios_json').value = JSON.stringify({ scenarios: state.scenarios, active_index: activeIdx });
        const coreJsonInput = document.getElementById('core_json');
        if (coreJsonInput) {
            coreJsonInput.value = JSON.stringify(getCoreConfig(true));
        }
        persistEditorState();
    });
}

// Enable Bootstrap tooltips globally
document.addEventListener('DOMContentLoaded', () => {
    const tooltipTriggerList = [].slice.call(document.querySelectorAll('[data-bs-toggle="tooltip"]'));
    tooltipTriggerList.forEach(el => {
        // Bootstrap 5 throws if title option resolves to null; normalize to empty string
        const dt = el.getAttribute('data-bs-title') || el.getAttribute('title');
        if (dt === null) {
            // skip creating tooltip entirely if no title is present
            return;
        }
        if (dt.trim() === '') {
            el.setAttribute('data-bs-title', '');
        }
        try { new bootstrap.Tooltip(el); } catch (e) { /* ignore */ }
    });
    const proxAssignModal = document.getElementById('proxmoxAssignModal');
    const proxAssignSave = document.getElementById('proxmoxAssignSave');
    const proxAssignError = document.getElementById('proxmoxAssignError');
    const proxAssignHint = document.getElementById('proxmoxAssignHint');
    const proxAssignForm = document.getElementById('proxmoxAssignForm');
    const proxUrlInput = document.getElementById('proxmoxUrl');
    const proxPortInput = document.getElementById('proxmoxPort');
    const proxUserInput = document.getElementById('proxmoxUsername');
    const proxPassInput = document.getElementById('proxmoxPassword');
    const clearProxError = () => {
        if (!proxAssignError) return;
        proxAssignError.textContent = '';
        proxAssignError.classList.add('d-none');
    };
    const showProxError = (message) => {
        if (!proxAssignError) return;
        proxAssignError.textContent = message;
        proxAssignError.classList.remove('d-none');
    };
    const setProxAssignBusy = (busy) => {
        if (!proxAssignSave) return;
        if (!proxAssignSave.dataset.defaultLabel) {
            proxAssignSave.dataset.defaultLabel = proxAssignSave.innerHTML;
        }
        if (busy) {
            proxAssignSave.disabled = true;
            proxAssignSave.innerHTML = '<span class="spinner-border spinner-border-sm me-1" role="status" aria-hidden="true"></span>Validating…';
        } else {
            proxAssignSave.disabled = false;
            proxAssignSave.innerHTML = proxAssignSave.dataset.defaultLabel;
        }
        if (proxAssignForm) {
            proxAssignForm.querySelectorAll('input').forEach(inp => {
                if (busy) {
                    inp.setAttribute('data-prox-disabled-prev', inp.disabled ? '1' : '0');
                    inp.disabled = true;
                } else {
                    const prev = inp.getAttribute('data-prox-disabled-prev');
                    inp.disabled = prev === '1';
                    inp.removeAttribute('data-prox-disabled-prev');
                }
            });
        }
    };
    const setProxAssignHint = window.setProxAssignHint || ((message, tone = 'info') => {
        if (!proxAssignHint) return;
        proxAssignHint.textContent = message || '';
        proxAssignHint.style.display = message ? '' : 'none';
        proxAssignHint.classList.remove('alert-info', 'alert-success', 'alert-danger');
        const klass = tone === 'success' ? 'alert-success' : tone === 'danger' ? 'alert-danger' : 'alert-info';
        proxAssignHint.classList.add(klass);
    });
    if (!window.setProxAssignHint) {
        window.setProxAssignHint = setProxAssignHint;
    }
    proxAssignSave?.addEventListener('click', async () => {
        if (!proxAssignModal) return;
        const sidx = parseInt(proxAssignModal.getAttribute('data-scen-idx') || '', 10);
        if (isNaN(sidx) || !state.scenarios?.[sidx]) {
            showProxError('Scenario context unavailable.');
            return;
        }
    if (!proxAssignForm) return;
        if (!proxAssignForm.checkValidity()) {
            proxAssignForm.reportValidity();
            return;
        }
        clearProxError();
        const urlVal = (proxUrlInput?.value || '').trim();
        if (!/^https?:\/\//i.test(urlVal)) {
            showProxError('URL must start with http:// or https://');
            proxUrlInput?.focus();
            return;
        }
        const portVal = parseInt(proxPortInput?.value || '8006', 10);
        if (!Number.isFinite(portVal) || portVal < 1 || portVal > 65535) {
            showProxError('Port must be between 1 and 65535');
            proxPortInput?.focus();
            return;
        }
        const userVal = (proxUserInput?.value || '').trim();
        if (!userVal) {
            showProxError('Username is required.');
            proxUserInput?.focus();
            return;
        }
        const scenario = state.scenarios[sidx];
        const hitlState = ensureHitlStateForScenario(scenario);
        const prox = hitlState.proxmox || {};
        const passVal = proxPassInput?.value ?? '';
        if (!passVal && !prox.secret_id) {
            showProxError('Password is required.');
            proxPassInput?.focus();
            return;
        }
        const verifyInput = document.getElementById('proxmoxVerifySsl');
        const verifySsl = verifyInput ? !!verifyInput.checked : /^https:/i.test(urlVal);
        setProxAssignBusy(true);
        setProxAssignHint('Validating credentials with Proxmox…', 'info');
        let data = null;
        try {
            const resp = await fetch('/api/proxmox/validate', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                credentials: 'same-origin',
                body: JSON.stringify({
                    url: urlVal,
                    port: portVal,
                    username: userVal,
                    password: passVal,
                    reuse_secret_id: !passVal && prox.secret_id ? prox.secret_id : undefined,
                    verify_ssl: verifySsl,
                    scenario_index: sidx,
                    scenario_name: scenario?.name || '',
                    timeout: 8.0,
                }),
            });
            try {
                data = await resp.json();
            } catch (err) {
                data = null;
            }
            if (!resp.ok || !data || data.success === false) {
                const errMsg = (data && data.error) ? data.error : `Validation failed (HTTP ${resp.status})`;
                throw new Error(errMsg);
            }
        } catch (err) {
            const message = err instanceof Error ? err.message : 'Unknown error during validation';
            showProxError(message);
            setProxAssignHint('', 'info');
            setProxAssignBusy(false);
            return;
        }
        try {
            const summary = data?.summary || {};
            hitlState.proxmox = {
                ...hitlState.proxmox,
                url: urlVal,
                port: summary.port ?? portVal,
                username: summary.username ?? userVal,
                verify_ssl: summary.verify_ssl ?? verifySsl,
                secret_id: data?.secret_id || summary.identifier || hitlState.proxmox?.secret_id || null,
                validated: true,
                last_validated_at: summary.stored_at || new Date().toISOString(),
                last_message: data?.message || 'Credentials validated.',
            };
            if ('password' in hitlState.proxmox) {
                delete hitlState.proxmox.password;
            }
            updateProxmoxSummary(sidx);
            persistEditorState();
            const hidden = document.getElementById('scenarios_json');
            if (hidden) hidden.value = JSON.stringify({ scenarios: state.scenarios, active_index: activeIdx });
            try { showToast('Refreshing Proxmox VM inventory…', { autohide: true, delay: 1500 }); } catch (e) {}
            await fetchProxmoxInventory(sidx, { force: true });
            if (proxPassInput) proxPassInput.value = '';
            setProxAssignHint(data?.message || 'Proxmox credentials validated and stored securely.', 'success');
            try { showToast(data?.message || 'Proxmox credentials validated', { autohide: true, delay: 2500 }); } catch(e) {}
            const modalInstance = window.bootstrap ? bootstrap.Modal.getInstance(proxAssignModal) : null;
            setTimeout(() => { modalInstance?.hide(); }, 400);
        } catch (err) {
            const message = err instanceof Error ? err.message : 'Failed to persist Proxmox state locally';
            showProxError(message);
            setProxAssignHint('', 'info');
        } finally {
            setProxAssignBusy(false);
        }
    });
    if (proxAssignModal && window.bootstrap) {
        proxAssignModal.addEventListener('hidden.bs.modal', () => {
            proxAssignModal.removeAttribute('data-scen-idx');
            clearProxError();
            setProxAssignHint('', 'info');
            if (proxPassInput) proxPassInput.value = '';
            const verifyInput = document.getElementById('proxmoxVerifySsl');
            if (verifyInput) verifyInput.checked = true;
        });
    }
    if (coreConnectionModal && window.bootstrap) {
        coreConnectionModal.addEventListener('hidden.bs.modal', () => {
            coreConnectionModal.removeAttribute('data-scen-idx');
            if (coreConnectionForm) {
                coreConnectionForm.classList.remove('was-validated');
            }
            if (coreModalInputs.ssh_password) {
                coreModalInputs.ssh_password.value = '';
                coreModalInputs.ssh_password.removeAttribute('placeholder');
            }
            if (typeof setCoreConnectionHint === 'function') {
                setCoreConnectionHint('', 'info');
            }
        });
    }
    const externalIfxModal = document.getElementById('externalIfxModal');
    if (externalIfxModal) {
        externalIfxModal.addEventListener('hide.bs.modal', () => {
            const active = document.activeElement;
            if (active && externalIfxModal.contains(active) && typeof active.blur === 'function') {
                active.blur();
            }
        });
        externalIfxModal.addEventListener('hidden.bs.modal', () => {
            clearExternalIfxStatus();
            setExternalIfxApplyBusy(false);
            const triggerBtn = document.querySelector('[data-bs-target="\#externalIfxModal"]');
            if (triggerBtn && typeof triggerBtn.focus === 'function') {
                triggerBtn.focus();
            }
        });
    }
    const externalIfxApplyBtn = document.getElementById('externalIfxApplyBtn');
    if (externalIfxApplyBtn) {
        externalIfxApplyBtn.addEventListener('click', () => {
            if (externalIfxApplyBtn.disabled) return;
            handleExternalIfxApply();
        });
    }
    // Wire Download XML button
    const dlBtn = document.getElementById('downloadXmlBtn');
    if (dlBtn) {
        dlBtn.addEventListener('click', () => {
            const rp = state.result_path || '';
            if (!rp || !rp.endsWith('.xml')) { alert('Please Save XML first.'); return; }
            window.location.href = window.location.origin + '/download_report?path=' + encodeURIComponent(rp);
        });
        // Initial state based on state.result_path
        const rp0 = state.result_path || '';
        if (rp0 && rp0.endsWith('.xml')) { dlBtn.removeAttribute('disabled'); dlBtn.classList.remove('pe-none'); dlBtn.setAttribute('title',''); }
    }
    // Capture any server-rendered logs before we render from storage
    let __serverLogsAtLoad = '';
    try { __serverLogsAtLoad = (document.getElementById('logsPre')?.textContent || '').trim(); } catch(e){}
    setupVulnCatalog();
});

// Vulnerability catalog and UI helpers
async function setupVulnCatalog(){
        try {
                const res = await fetch('/vuln_catalog');
        if(res.ok){ window.VULN_CATALOG = await res.json(); }
    } catch(e) { window.VULN_CATALOG = { types: [], vectors: [], items: [] }; }
}

function populateVulnSelects() {
        document.querySelectorAll('.vuln-type').forEach(sel => {
                const sidx = parseInt(sel.getAttribute('data-scen-idx'));
                const sec = sel.getAttribute('data-sec');
                const iidx = parseInt(sel.getAttribute('data-item-idx'));
                const cur = (state.scenarios[sidx].sections[sec].items[iidx].v_type) || 'Random';
                const opts = ['Random', ...(window.VULN_CATALOG?.types || [])];
                sel.innerHTML = opts.map(o => `<option ${o===cur?'selected':''}>${o}</option>`).join('');
        });
        document.querySelectorAll('.vuln-vector').forEach(sel => {
                const sidx = parseInt(sel.getAttribute('data-scen-idx'));
                const sec = sel.getAttribute('data-sec');
                const iidx = parseInt(sel.getAttribute('data-item-idx'));
                const cur = (state.scenarios[sidx].sections[sec].items[iidx].v_vector) || 'Random';
                const opts = ['Random', ...(window.VULN_CATALOG?.vectors || [])];
                sel.innerHTML = opts.map(o => `<option ${o===cur?'selected':''}>${o}</option>`).join('');
        });
}

// Modal for Specific selection
function ensureVulnModal(){
        if(document.getElementById('vulnModal')) return;
        const modal = document.createElement('div');
        modal.className = 'modal fade';
        modal.id = 'vulnModal';
        modal.innerHTML = `
        <div class="modal-dialog modal-lg">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title">Select Vulnerability</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
                </div>
                <div class="modal-body">
                    <div id="vulnLoadingWrap" class="mb-3" style="display:none;">
                        <div class="d-flex align-items-center gap-2 mb-2 text-muted small">
                            <div class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></div>
                            <span id="vulnLoadMeta">Loading eligible items…</span>
                        </div>
                        <div class="progress" style="height: 14px;">
                            <div class="progress-bar" id="vulnLoadProgressBar" role="progressbar" style="width:0%" aria-valuenow="0" aria-valuemin="0" aria-valuemax="100">0%</div>
                        </div>
                    </div>
                    <div class="d-flex align-items-start gap-2 mb-2">
                        <div class="flex-grow-1">
                            <input class="form-control" placeholder="Filter (string or /regex/)" id="vulnFilter">
                            <div class="invalid-feedback" id="vulnFilterError">Invalid regex</div>
                        </div>
                        <button class="btn btn-outline-secondary" type="button" id="vulnFilterClear" title="Clear filter">Clear</button>
                    </div>
                    <div class="text-muted small mb-2" id="vulnFilterMeta"></div>
                    <div class="table-responsive" id="vulnTableWrap" style="max-height:50vh; overflow:auto; display:none;">
                        <table class="table table-sm">
                            <thead><tr><th>Name</th><th>Type</th><th>Vector</th><th>Path</th></tr></thead>
                            <tbody id="vulnList"></tbody>
                        </table>
                    </div>
                </div>
                <div class="modal-footer">
                    <button class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
                </div>
            </div>
        </div>`;
        document.body.appendChild(modal);
}

async function openVulnPicker(sidx, secName, iidx){
    ensureVulnModal();
    const modalEl = document.getElementById('vulnModal');
    if (!modalEl) {
        logError('Vulnerability modal element not found');
        return;
    }
    const modalObj = window.bootstrap ? (bootstrap.Modal.getInstance(modalEl) || new bootstrap.Modal(modalEl, { backdrop: true, keyboard: true })) : null;
    const filterInput = modalEl.querySelector('#vulnFilter');
    const filterClearBtn = modalEl.querySelector('#vulnFilterClear');
    const filterMeta = modalEl.querySelector('#vulnFilterMeta');
    const filterError = modalEl.querySelector('#vulnFilterError');
    const tbody = modalEl.querySelector('#vulnList');
    const tblWrap = modalEl.querySelector('#vulnTableWrap');
    const loadWrap = modalEl.querySelector('#vulnLoadingWrap');
    const loadBar = modalEl.querySelector('#vulnLoadProgressBar');
    const loadMeta = modalEl.querySelector('#vulnLoadMeta');
    const row = state.scenarios[sidx].sections[secName].items[iidx] || {};
    const selVector = (row.v_vector || 'Random');
    // Base: docker-compose only
    const all = (window.VULN_CATALOG?.items || []);
    let base = all.filter(it => (it.Type||'').toLowerCase() === 'docker-compose');
    if (selVector && selVector !== 'Random') {
        const vv = selVector.toLowerCase();
        base = base.filter(it => (it.Vector||'').toLowerCase() === vv);
    }
    // Do not compute eligibility; show immediately
    let eligible = base;
    try {
        if (modalObj) modalObj.show();
        if (loadWrap) loadWrap.style.display = 'none';
        if (tblWrap) tblWrap.style.display = '';
    } catch(e){}
    let current = eligible;
    const renderRows = () => {
        tbody.innerHTML = '';
        if (!current || current.length === 0) {
            const tr = document.createElement('tr');
            const td = document.createElement('td');
            td.colSpan = 4;
            td.className = 'text-center text-muted py-3';
            td.textContent = 'No results';
            tr.appendChild(td);
            tbody.appendChild(tr);
            return;
        }
        current.forEach((it) => {
            const tr = document.createElement('tr');
            tr.innerHTML = `<td>${it.Name}</td><td>${it.Type}</td><td>${it.Vector}</td><td>${it.Path}</td>`;
            tr.style.cursor = 'pointer';
            tr.onclick = () => {
                const item = state.scenarios[sidx].sections[secName].items[iidx];
                item.v_name = it.Name;
                item.v_path = it.Path;
                item.v_type = it.Type;
                item.v_vector = it.Vector;
                if (it.Description) item.v_desc = it.Description;
                // also set selected to Specific defensively
                item.selected = 'Specific';
                document.getElementById('scenarios_json').value = JSON.stringify({ scenarios: state.scenarios, active_index: activeIdx });
                try { if(window.bootstrap){ bootstrap.Modal.getInstance(modalEl)?.hide(); } } catch(e) {}
                renderMain();
            };
            tbody.appendChild(tr);
        });
    };
    const applyFilter = () => {
        const raw = (filterInput.value||'').trim();
        try { localStorage.setItem('vulnPickerFilter', raw); } catch(e){}
        filterInput.classList.remove('is-invalid');
        if (filterError) filterError.style.display = '';
        if(!raw){
            current = eligible;
            renderRows();
            if (filterMeta) filterMeta.textContent = `${current.length}/${eligible.length} shown`;
            return;
        }
        let matcher = null;
        if (raw.startsWith('/') && raw.endsWith('/') && raw.length >= 2) {
            try { matcher = new RegExp(raw.slice(1, -1), 'i'); } catch(e){ matcher = null; }
            if (!matcher) {
                filterInput.classList.add('is-invalid');
                if (filterMeta) filterMeta.textContent = `Invalid regex`;
                return;
            }
            current = eligible.filter((it) => {
                const haystack = `${it.Name||''} ${it.Type||''} ${it.Vector||''} ${it.Path||''}`;
                return matcher.test(haystack);
            });
        } else {
            const needle = raw.toLowerCase();
            current = eligible.filter((it) => {
                return [it.Name, it.Type, it.Vector, it.Path].some(val => (val||'').toLowerCase().includes(needle));
            });
        }
        renderRows();
        if (filterMeta) filterMeta.textContent = `${current.length}/${eligible.length} shown`;
    };
    filterInput.oninput = applyFilter;
    filterClearBtn.onclick = () => { filterInput.value = ''; applyFilter(); };
    // Load last-used filter, if any
    try {
        const saved = localStorage.getItem('vulnPickerFilter');
        if (saved) filterInput.value = saved;
    } catch(e){}
    // Render immediately and show counts
    try {
        renderRows();
        applyFilter();
    } catch(e){}
}


async function runAsync() {
    let rp = state.result_path || '';
    if (!rp.endsWith('.xml')) {
        const go = window.confirm('Your XML has not been saved. Save now and then run?');
        if (!go) { logInfo('Async run cancelled by user (declined save)'); return; }
        try {
            const ok = await saveXmlAjax();
            if (!ok) { logWarn('Save failed; aborting async run'); return; }
            rp = state.result_path || '';
            if (!rp.endsWith('.xml')) { logWarn('Save did not produce an XML path; aborting async run'); return; }
        } catch(e){ logError('Exception during auto-save; aborting async run'); return; }
    }
    const confirmMsg = 'This action will generate a new CORE scenario and attempt to start it asynchronously using the daemon connection.\n\nProceed?';
    if (!window.confirm(confirmMsg)) { logInfo('Async run cancelled by user at confirmation'); return; }
    const form = new FormData();
    form.append('xml_path', rp);
    appendScenarioContextToFormData(form);
    try {
        form.append('core_json', JSON.stringify(getCoreConfig(true)));
    } catch (err) {
        form.append('core_json', '{}');
    }
        const res = await fetch("{{ url_for('run_cli_async') }}", { method: 'POST', body: form });
    if (!res.ok) { alert('Failed to start run'); return; }
    const { run_id } = await res.json();
    logInfo(`Async run started id=${run_id}`);
    startLogStream(run_id);
    pollRunStatus(run_id);
}

// Save XML via JSON API without navigation
async function saveXmlAjax(){
    try {
        const payload = { scenarios: state.scenarios, core: getCoreConfig(true), active_index: activeIdx };
        if (state.base_upload) {
            payload.base_upload = state.base_upload;
        }
        const res = await fetch('/save_xml_api', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload)
        });
        if (!res.ok) { try { const err = await res.json(); logWarn('Save failed: ' + (err?.error || res.status)); } catch(e){ logWarn('Save failed'); } return false; }
        const data = await res.json();
        if (data && data.ok) {
            if (data.core) {
                state.core = normalizeCoreState(data.core, true);
                storeCorePasswordInSession();
            }
            if (data.result_path) {
                state.result_path = data.result_path;
            }
            persistEditorState();
            if (data.result_path) {
                logInfo('Scenarios saved to ' + data.result_path);
            } else {
                logInfo('Scenarios saved');
            }
            // Refresh XML preview lazily
            try {
                const xmlPre = document.getElementById('xmlPre');
                if (xmlPre && data.result_path) {
                    const txt = await (await fetch('/download_report?path=' + encodeURIComponent(data.result_path))).text();
                    xmlPre.textContent = txt;
                }
            } catch(e){}
            return true;
        }
        logWarn('Save did not return a valid path');
        return false;
    } catch(e) { logError('Save threw an exception'); return false; }
}
let evtSrc = null;
function startLogStream(runId) {
    if (evtSrc) { try { evtSrc.close(); } catch(e){} }
    evtSrc = new EventSource('/stream/' + runId);
    // keep existing logs; do not auto-clear
    // Ensure dock is visible so users can see live logs
    try {
        const showBtn = document.getElementById('dockShowBtn');
        if (showBtn && !showBtn.classList.contains('d-none')) { showBtn.click(); }
    } catch(e){}
    // Toggle buttons
    document.getElementById('runAsyncBtn').classList.add('d-none');
    document.getElementById('runSyncBtn').classList.add('disabled');
    document.getElementById('cancelRunBtn').classList.remove('d-none');
    evtSrc.onmessage = (ev) => {
        const raw = ev.data || '';
        let lvl = 'INFO';
        if (/\bERROR\b/.test(raw)) lvl = 'ERROR';
        else if (/\bWARN(ING)?\b/.test(raw)) lvl = 'WARN';
        else if (/\bDEBUG\b/.test(raw)) lvl = 'DEBUG';
    appendLog(raw, lvl);
    };
    evtSrc.addEventListener('end', () => {
        evtSrc.close();
        document.getElementById('runAsyncBtn').classList.remove('d-none');
        document.getElementById('runSyncBtn').classList.remove('disabled');
        document.getElementById('cancelRunBtn').classList.add('d-none');
        logInfo('Async run ended');
    });
}

async function pollRunStatus(runId) {
    const xmlPre = document.getElementById('xmlPre');
    try {
    const res = await fetch('/run_status/' + runId);
        if (!res.ok) return;
        const data = await res.json();
        // Update download link
        const rp = data.report_path || data.xml_path;
        if (rp) { state.result_path = rp; persistEditorState(); }
        // Refresh XML preview if we have the xml path and it's changed
        if (data.xml_path && xmlPre && !xmlPre.textContent.trim()) {
                    try {
                        const txt = await (await fetch('/download_report?path=' + encodeURIComponent(data.xml_path))).text();
                        xmlPre.textContent = txt;
                    } catch(e){}
        }
        if (!data.done) {
            setTimeout(() => pollRunStatus(runId), 1000);
        } else {
            if (data.returncode === 0) {
                setTimeout(() => { window.location.href = "{{ url_for('reports_page') }}"; }, 500);
            }
        }
    } catch(e) {
        // ignore transient errors
        setTimeout(() => pollRunStatus(runId), 1500);
    }
}

    async function cancelRun() {
        if (!evtSrc) return;
        // Extract runId from the EventSource URL
        const url = evtSrc.url;
        const runId = url.split('/').pop();
        try {
            await fetch('/cancel_run/' + runId, { method: 'POST' });
        } catch(e) {}
    try { evtSrc.close(); } catch(e){}
        document.getElementById('runAsyncBtn').classList.remove('d-none');
        document.getElementById('runSyncBtn').classList.remove('disabled');
        document.getElementById('cancelRunBtn').classList.add('d-none');
    logInfo('Run cancelled by user');
    }

// --- Run CLI via modal (async under the hood) ---
function ensureRunProgressModal(){
    if(!runProgressModalInst){
        const el = document.getElementById('runProgressModal');
        if(el){ runProgressModalInst = new bootstrap.Modal(el, { backdrop: 'static', keyboard: false }); }
    }
    return runProgressModalInst;
}
function runProgressLogLine(s){
    const pre = document.getElementById('runProgressLog');
    if(!pre) return;
    const line = (s||'');
    // Level detection first so we only log once with correct level
    let lvl = 'INFO';
    try {
        if(/\bERROR\b/.test(line)) lvl='ERROR';
        else if(/\bWARN(ING)?\b/.test(line)) lvl='WARN';
        else if(/\bDEBUG\b/.test(line)) lvl='DEBUG';
    } catch(e){}
    try {
        const text = line + '\n';
        if(typeof pre.append === 'function'){ pre.append(text); }
        else { pre.appendChild(document.createTextNode(text)); }
    } catch(e){}
    appendLog(line, lvl);
    pre.parentElement?.scrollTo({ top: pre.parentElement.scrollHeight });
}
function detectLocalEmulation(){
    const normalizeHost = (raw) => {
        if(raw === null || raw === undefined) return '';
        let h = String(raw).trim().toLowerCase();
        if(!h) return '';
        if(h.startsWith('[') && h.endsWith(']')){
            h = h.slice(1, -1);
        }
        if(h.startsWith('::ffff:') && /^::ffff:\d+\.\d+\.\d+\.\d+$/.test(h)){
            h = h.replace('::ffff:', '');
        }
        return h;
    };
    try {
        const hostRaw = (state?.core && state.core.host !== undefined) ? state.core.host : (initialPayload?.core?.host ?? 'localhost');
        let hostStr = (typeof hostRaw === 'string' && hostRaw.trim()) ? hostRaw.trim() : String(hostRaw ?? 'localhost');
        if(!hostStr) hostStr = 'localhost';
        const normHost = normalizeHost(hostStr);
        const isLoopback = !normHost || normHost === 'localhost' || normHost === '::1' || normHost === '0:0:0:0:0:0:0:1' || /^127(?:\.\d{1,3}){3}$/.test(normHost);
        const portRaw = (state?.core && state.core.port !== undefined) ? state.core.port : (initialPayload?.core?.port ?? 50051);
        const portNum = parseInt(portRaw, 10);
        const port = Number.isFinite(portNum) && portNum > 0 ? portNum : 50051;
        const testedHostRaw = (state?.core_tested_host !== undefined && state.core_tested_host !== null)
            ? state.core_tested_host
            : (initialPayload?.core_tested_host ?? null);
        const testedPortRaw = (state?.core_tested_port !== undefined && state.core_tested_port !== null)
            ? state.core_tested_port
            : (initialPayload?.core_tested_port ?? null);
        const normTestedHost = normalizeHost(testedHostRaw);
        const testedPortNum = parseInt(testedPortRaw ?? '', 10);
        const testedPort = Number.isFinite(testedPortNum) && testedPortNum > 0 ? testedPortNum : port;
        const testedMatches = !!normTestedHost && normTestedHost === normHost && testedPort === port;
        const hasVerifiedCore = !!state?.core_ok && testedMatches;
        const shouldFake = isLoopback && !hasVerifiedCore;
        return {
            shouldFake,
            isLoopback: !!isLoopback,
            verified: hasVerifiedCore,
            host: hostStr,
            port
        };
    } catch(e){
        return { shouldFake: false, isLoopback: false, verified: false, host: 'localhost', port: 50051 };
    }
}
function setRunProgressModeHint(message){
    const hintEl = document.getElementById('runProgressModeHint');
    if(!hintEl) return;
    if(message){
        hintEl.textContent = message;
        hintEl.classList.remove('d-none');
    } else {
        hintEl.textContent = '';
        hintEl.classList.add('d-none');
    }
}
function maybeShowLocalEmulationHint(){
    const info = detectLocalEmulation();
    if(info.shouldFake){
        setRunProgressModeHint(`LOCAL EMULATION • NO CONNECTED CORE SESSION`);
    } else if(info.verified){
        setRunProgressModeHint(`CONNECTED • CORE ${info.host}:${info.port}`);
    } else {
        setRunProgressModeHint('');
    }
}
function openRunProgress(title){
    const modalEl = document.getElementById('runProgressModal');
    ensureRunProgressModal();
    try {
        if(title) document.querySelector('#runProgressModal .modal-title').textContent = title;
        document.getElementById('runProgressStatus').textContent = 'Starting…';
        document.getElementById('runProgressMeta').textContent = '';
        document.getElementById('runProgressBar').classList.add('progress-bar-animated');
        setRunProgressModeHint('');
        const logEl = document.getElementById('runProgressLog');
        if(logEl) logEl.textContent = '';
    // Do NOT clear persistent log buffer; just re-render existing lines
    if(typeof renderDockLog === 'function'){ renderDockLog(); }
        // Reset footer buttons to default state
        const hideBtn = document.getElementById('runProgressHideBtn');
        if (hideBtn) {
            hideBtn.textContent = 'Hide';
            hideBtn.onclick = null; // remove any prior navigation handler
        }
        runProgressModalInst?.show();
    } catch(e){}
    try {
        if(modalEl && !modalEl.classList.contains('show')){
            modalEl.style.display = 'block';
            modalEl.removeAttribute('aria-hidden');
            modalEl.classList.add('show');
            if(!document.body.classList.contains('modal-open')){
                document.body.classList.add('modal-open');
                document.body.style.removeProperty('paddingRight');
                document.body.style.removeProperty('overflow');
            }
            if(!document.querySelector('.modal-backdrop')){
                const backdrop = document.createElement('div');
                backdrop.className = 'modal-backdrop fade show';
                document.body.appendChild(backdrop);
            }
        }
    } catch(e){}
}
function closeRunProgress(){
    try { if(runProgressEvtSrc) runProgressEvtSrc.close(); } catch(e){}
    runProgressEvtSrc = null;
    runProgressRunId = null;
    try { runProgressModalInst?.hide(); } catch(e){}
    try {
        const modalEl = document.getElementById('runProgressModal');
        if(modalEl){
            modalEl.classList.remove('show');
            modalEl.style.removeProperty('display');
            modalEl.setAttribute('aria-hidden','true');
        }
        const openModals = document.querySelectorAll('.modal.show');
        if(openModals.length === 0){
            document.querySelectorAll('.modal-backdrop').forEach(b => {
                try { b.remove(); } catch(_e){}
            });
            document.body.classList.remove('modal-open');
            document.body.style.removeProperty('paddingRight');
            document.body.style.removeProperty('overflow');
        }
    } catch(e){}
}
async function runSyncWithModal(arg){
    let opts = {};
    if(arg && typeof arg === 'object' && typeof arg.preventDefault === 'function'){
        arg.preventDefault();
    } else if(arg && typeof arg === 'object'){
        opts = arg;
    }
    const showProgressModal = opts.showProgressModal !== false;
    const skipConfirm = opts.skipConfirm === true;
    // Validate saved XML
    let rp = state.result_path || '';
    if (!rp.endsWith('.xml')) {
        const go = window.confirm('Your XML has not been saved. Save now and then run?');
        if (!go) { logInfo('Run CLI cancelled by user (declined save)'); return false; }
        try {
            const ok = await saveXmlAjax();
            if (!ok) { logWarn('Save failed; aborting run'); return false; }
            rp = state.result_path || '';
            if (!rp.endsWith('.xml')) { logWarn('Save did not produce an XML path; aborting run'); return false; }
        } catch(e){ logError('Exception during auto-save; aborting run'); return false; }
    }
    const execInfo = detectLocalEmulation();
    const confirmMsg = execInfo.shouldFake
        ? 'CORE not connected; will run with fake local emulation. Proceed?'
        : 'This will generate a CORE scenario and attempt to start it. Proceed?';
    if (!skipConfirm && !window.confirm(confirmMsg)) { logInfo('Run CLI cancelled by user at confirmation'); return false; }
    if(showProgressModal){
        openRunProgress('Running CLI…');
        maybeShowLocalEmulationHint();
    }
    try {
        // Ensure dock is visible
        try {
            const showBtn = document.getElementById('dockShowBtn');
            if (showBtn && !showBtn.classList.contains('d-none')) { showBtn.click(); }
        } catch(e){}
        const form = new FormData();
        form.append('xml_path', rp);
        appendScenarioContextToFormData(form);
        try {
            form.append('core_json', JSON.stringify(getCoreConfig(true)));
        } catch (e) {
            form.append('core_json', '{}');
        }
        const res = await fetch("{{ url_for('run_cli_async') }}", { method: 'POST', body: form });
        if(!res.ok){
            runProgressLogLine('Failed to start CLI');
            if(showProgressModal){
                try {
                    const statusEl = document.getElementById('runProgressStatus');
                    if(statusEl) statusEl.textContent = 'Failed to start';
                    const metaEl = document.getElementById('runProgressMeta');
                    if(metaEl) metaEl.textContent = 'HTTP ' + res.status;
                    const bar = document.getElementById('runProgressBar');
                    if(bar){ bar.classList.remove('progress-bar-animated'); bar.textContent = 'Error'; }
                } catch(e){}
            }
            try { opts.onError?.(new Error('Failed to start CLI')); } catch(e){}
            return false;
        }
        const dataInit = await res.json();
        const run_id = dataInit?.run_id;
        runProgressRunId = run_id;
        if(!run_id){
            runProgressLogLine('Execution start response missing run_id');
            if(showProgressModal){
                try {
                    const statusEl = document.getElementById('runProgressStatus');
                    if(statusEl) statusEl.textContent = 'Failed to start';
                    const metaEl = document.getElementById('runProgressMeta');
                    if(metaEl) metaEl.textContent = 'Missing run id';
                    const bar = document.getElementById('runProgressBar');
                    if(bar){ bar.classList.remove('progress-bar-animated'); bar.textContent = 'Error'; }
                } catch(e){}
            }
            try { opts.onError?.(new Error('Missing run id')); } catch(e){}
            return false;
        }
        // No Cancel button in modal; runs cannot be cancelled here
        // Start SSE stream into modal
        try { if(runProgressEvtSrc) runProgressEvtSrc.close(); } catch(e){}
        runProgressEvtSrc = new EventSource('/stream/' + run_id);
        runProgressEvtSrc.onmessage = (ev)=>{ runProgressLogLine(ev.data||''); };
        runProgressEvtSrc.addEventListener('end', ()=>{ try { runProgressEvtSrc.close(); } catch(e){} logInfo('Run (modal) ended'); });
        // Poll for completion and update meta
        return await new Promise((resolve) => {
            (async function poll(){
                try{
                    const r = await fetch('/run_status/' + run_id);
                    if(!r.ok){ setTimeout(poll, 1200); return; }
                    const data = await r.json();
                    if(data.report_path || data.xml_path){
                        state.result_path = data.report_path || data.xml_path;
                        persistEditorState();
                    }
                    if(showProgressModal){
                        const metaEl = document.getElementById('runProgressMeta');
                        if(metaEl){ metaEl.textContent = data.done ? (data.returncode===0 ? 'Completed' : 'Failed') : 'Running…'; }
                    } else {
                        try { opts.onTick?.(data); } catch(e){}
                    }
                    if(!data.done){ setTimeout(poll, 1000); return; }
                    if(showProgressModal){
                        document.getElementById('runProgressStatus').textContent = (data.returncode===0) ? 'Scenario started' : 'Finished with errors';
                        document.getElementById('runProgressBar').classList.remove('progress-bar-animated');
                    }
                    try { opts.onComplete?.(data); } catch(e){}
                    try {
                        if (data.returncode === 0) {
                            setTimeout(() => { window.location.href = "{{ url_for('reports_page') }}"; }, 500);
                        }
                    } catch(e){}
                    resolve(data);
                } catch(e){ setTimeout(poll, 1500); }
            })();
        });
    } catch(e){
        runProgressLogLine('Exception starting CLI');
        try { if(!showProgressModal) opts.onError?.(e); } catch(_){}
        throw e;
    }
}

// Run deterministically with a seed (preview seed or input)
async function runWithSeedBuild(){
    // Ensure XML is saved
    let rp = state.result_path || '';
    if(!rp.endsWith('.xml')){
        const go = window.confirm('XML not saved yet. Save now?');
        if(!go) return;
        const saved = await saveXmlAjax();
        if(!saved){ alert('Auto-save failed; cannot run.'); return; }
        rp = state.result_path || '';
        if(!rp.endsWith('.xml')){ alert('Saved XML path unresolved.'); return; }
    }
    // Derive seed: prefer explicit input, else current preview seed
    // seedInputEl removed
    let seedVal = null;
    if(seedInputEl && seedInputEl.value.trim()){
        const num = parseInt(seedInputEl.value.trim(),10); if(!isNaN(num) && num>0) seedVal = num;
    } else if(previewState.fullPreview && previewState.fullPreview.seed){
        seedVal = previewState.fullPreview.seed;
    }
    if(seedVal===null){
        alert('Enter a seed or generate a Full Preview (which records a seed) first.');
        return;
    }
    const execInfo = detectLocalEmulation();
    const confirmMsg = execInfo.shouldFake
        ? `CORE not connected; will run with fake local emulation (seed=${seedVal}). Proceed?`
        : `Run CLI with seed=${seedVal}? This will start a CORE session.`;
    if(!window.confirm(confirmMsg)) return;
    openRunProgress('Running CLI (seed='+seedVal+')…');
    maybeShowLocalEmulationHint();
    try {
        // Show dock logs
        try { const showBtn=document.getElementById('dockShowBtn'); if(showBtn && !showBtn.classList.contains('d-none')) showBtn.click(); } catch(e){}
        const payload = enrichPayloadWithScenarioContext({ xml_path: rp, seed: seedVal, core: getCoreConfig(true) });
        const res = await fetch("{{ url_for('run_cli_async') }}", {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload)
        });
        if(!res.ok){ runProgressLogLine('Failed to start seeded run'); return; }
        const { run_id } = await res.json();
        runProgressRunId = run_id;
        // Stream logs
        try { if(runProgressEvtSrc) runProgressEvtSrc.close(); } catch(e){}
        runProgressEvtSrc = new EventSource('/stream/' + run_id);
        runProgressEvtSrc.onmessage = (ev)=> runProgressLogLine(ev.data||'');
        runProgressEvtSrc.addEventListener('end', ()=>{ try { runProgressEvtSrc.close(); } catch(e){} });
        // Poll status similar to runSyncWithModal
        (async function poll(){
            try{
                const r = await fetch('/run_status/' + run_id);
                if(!r.ok){ setTimeout(poll, 1200); return; }
                const data = await r.json();
                if(data.report_path || data.xml_path){ state.result_path = data.report_path || data.xml_path; persistEditorState(); }
                const metaEl = document.getElementById('runProgressMeta'); if(metaEl) metaEl.textContent = data.done ? (data.returncode===0 ? 'Completed' : 'Failed') : 'Running…';
                if(!data.done){ setTimeout(poll, 1000); return; }
                document.getElementById('runProgressStatus').textContent = (data.returncode===0) ? 'Scenario started' : 'Finished with errors';
                document.getElementById('runProgressBar').classList.remove('progress-bar-animated');
                if(data.returncode===0){ setTimeout(()=>{ window.location.href = "{{ url_for('reports_page') }}"; }, 600); }
            } catch(e){ setTimeout(poll, 1500); }
        })();
    } catch(e){ runProgressLogLine('Exception starting seeded run'); }
}

    function redistributeEven(sidx, secName) {
        const items = state.scenarios[sidx].sections[secName].items;
        const n = items.length;
        if (n === 0) return;
    const weightIdxs = items.map((it,i) => ({i,it})).filter(x => ((x.it.v_metric|| (x.it.selected==='Specific'?'Count':'Weight')) === 'Weight')).map(x => x.i);
    const m = weightIdxs.length;
    if (m === 0) { return; }
    const even = Math.round((1.0 / m) * 1000) / 1000;
    weightIdxs.slice(0, -1).forEach(i => { items[i].factor = even; });
        // last item gets the residual to hit 1.0
    const sumOther = weightIdxs.slice(0, -1).reduce((a, i) => a + (parseFloat(items[i].factor)||0), 0);
    const lastIdx = weightIdxs[weightIdxs.length - 1];
    items[lastIdx].factor = Math.max(0, Math.round((1.0 - sumOther) * 1000) / 1000);
        updateWeightWarning(sidx, secName);
    }

    function adjustWeightsProportionally(sidx, secName, changedIdx) {
        const items = state.scenarios[sidx].sections[secName].items;
        const n = items.length;
    const weightIdxs = items.map((it,i) => ({i,it})).filter(x => ((x.it.v_metric|| (x.it.selected==='Specific'?'Count':'Weight')) === 'Weight')).map(x => x.i);
        const m = weightIdxs.length;
        if (m <= 1) { if (m === 1) items[weightIdxs[0]].factor = 1.0; return; }
        // clamp changed value
        items[changedIdx].factor = Math.max(0, Math.min(1, parseFloat(items[changedIdx].factor)||0));
        const targetSum = 1.0;
        const changed = parseFloat(items[changedIdx].factor)||0;
        const others = weightIdxs.map(i => i !== changedIdx ? (parseFloat(items[i].factor)||0) : 0);
        const sumOthers = others.reduce((a,b) => a + b, 0);
        const residual = Math.max(0, targetSum - changed);
        if (sumOthers <= 0) {
            // Distribute evenly across others
            const even = residual / (m - 1);
            weightIdxs.forEach(i => { if (i !== changedIdx) items[i].factor = Math.round(even * 1000) / 1000; });
        } else {
            // Scale others proportionally to keep overall sum 1.0
            weightIdxs.forEach((i, idx) => {
                if (i === changedIdx) return;
                const ratio = others[idx] / sumOthers;
                items[i].factor = Math.round((residual * ratio) * 1000) / 1000;
            });
        }
        // Final normalization to exact 1.000 with 3 decimals
        normalizeToThousandths(sidx, secName);
    }

    function updateWeightWarning(sidx, secName) {
        const items = state.scenarios[sidx].sections[secName].items;
    // Exempt Node Information from weight validation (single Random item default)
    if (secName === 'Node Information') return;
    if (!items || items.length === 0) return;
        const sum = Math.round(items.reduce((a,b) => {
            const metric = b.v_metric || (b.selected==='Specific'?'Count':'Weight');
            return a + (metric==='Weight' ? (parseFloat(b.factor)||0) : 0);
        }, 0) * 1000) / 1000;
    const warn = document.querySelector(".section-warning[data-scen-idx='" + sidx + "'][data-sec='" + secName + "']");
        if (warn) {
            const density = parseFloat((state.scenarios[sidx].sections[secName]||{}).density);
            const weightCount = items.filter(b => (b.v_metric || (b.selected==='Specific'?'Count':'Weight')) === 'Weight').length;
            const badWeights = weightCount > 0 ? (Math.abs(sum - 1.0) > 0.005) : false;
            // Routing density: allow any density >= 0 (>=1 means absolute router count)
            // Other sections: keep 0..1 constraint
            const badDensity = isNaN(density) ? false : (
                secName === 'Routing' ? (density < 0) : (density < 0 || density > 1)
            );
            warn.style.display = (badWeights || badDensity) ? 'block' : 'none';
            let msgs = [];
            if (badWeights) msgs.push('Weights must sum to 1.000 (current: ' + sum.toFixed(3) + ')');
            if (badDensity) {
                if (secName === 'Routing') {
                    msgs.push('Routing density must be >= 0 (current: ' + density.toFixed(2) + '). Tip: < 1 = fraction of hosts; ≥ 1 = absolute router count.');
                } else {
                    msgs.push('Density must be between 0 and 1 (current: ' + density.toFixed(2) + ')');
                }
            }
            warn.textContent = msgs.join(' • ');
        }
    }

    function normalizeToThousandths(sidx, secName) {
        const items = state.scenarios[sidx].sections[secName].items;
        if (!items || items.length === 0) return;
        const vals = items.map(it => {
            const metric = it.v_metric || (it.selected==='Specific'?'Count':'Weight');
            const v = Math.max(0, Math.min(1, parseFloat(it.factor)||0));
            return metric==='Weight' ? v : 0;
        });
        // Convert to thousandths without rounding first
        const thousandthsRaw = vals.map(v => v * 1000);
        const floors = thousandthsRaw.map(v => Math.floor(v));
        let sumFloors = floors.reduce((a,b) => a + b, 0);
        let remainder = 1000 - sumFloors;
        if (remainder > 0) {
            // Distribute +1 to largest fractional parts
            const remainders = thousandthsRaw.map((v, i) => ({ idx: i, frac: v - floors[i] }));
            remainders.sort((a,b) => b.frac - a.frac);
            for (let k = 0; k < remainders.length && remainder > 0; k++) {
                floors[remainders[k].idx] += 1; remainder -= 1;
            }
        } else if (remainder < 0) {
            // Remove -1 from largest values to reduce sum to 1000
            const order = floors.map((v,i) => ({ idx: i, v }));
            order.sort((a,b) => b.v - a.v);
            while (remainder < 0) {
                for (let k = 0; k < order.length && remainder < 0; k++) {
                    const i = order[k].idx;
                    if (floors[i] > 0) { floors[i] -= 1; remainder += 1; }
                }
                if (order.length === 0) break;
            }
        }
        for (let i = 0; i < items.length; i++) {
            const metric = items[i].v_metric || (items[i].selected==='Specific'?'Count':'Weight');
            items[i].factor = (metric==='Weight') ? (floors[i] / 1000.0) : (items[i].factor||0);
        }
    }

    function updateWeightInputsDisplay(sidx, secName) {
        const items = state.scenarios[sidx].sections[secName].items;
    document.querySelectorAll("input.weight-input[data-scen-idx='" + sidx + "'][data-sec='" + secName + "']").forEach(input => {
            const iidx = parseInt(input.getAttribute('data-item-idx'));
            if (!isNaN(iidx) && items[iidx]) {
                input.value = (parseFloat(items[iidx].factor) || 0).toFixed(3);
            }
        });
    }

    // Dock setup handled by partial
</script>
</body>
<!-- Toast container -->
<div aria-live="polite" aria-atomic="true" class="position-fixed" style="z-index: 1080; right: 12px; bottom: 12px;">
    <div id="toastContainer" class="toast-container"></div>
    <template id="toastTemplate">
        <div class="toast align-items-center text-bg-dark border-0" role="alert" aria-live="assertive" aria-atomic="true">
            <div class="d-flex">
                <div class="toast-body">Action completed.</div>
                <button type="button" class="btn-close btn-close-white me-2 m-auto" data-bs-dismiss="toast" aria-label="Close"></button>
            </div>
        </div>
    </template>
    <script>
        function showToast(message, opts){
            try {
                const container = document.getElementById('toastContainer');
                const tmpl = document.getElementById('toastTemplate');
                if(!container || !tmpl) return;
                const node = tmpl.content.firstElementChild.cloneNode(true);
                node.querySelector('.toast-body').textContent = message || 'Done';
                container.appendChild(node);
                const t = new bootstrap.Toast(node, Object.assign({ delay: 2500, autohide: true }, (opts||{})));
                t.show();
                node.addEventListener('hidden.bs.toast', () => { try { node.remove(); } catch(e){} });
            } catch(e){}
        }
    </script>
</div>
<!-- Success Modal -->
<div class="modal fade" id="runSuccessModal" tabindex="-1" aria-hidden="true">
    <div class="modal-dialog modal-dialog-centered">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title">Run Completed</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <p class="mb-1" id="runSuccessBody">Generation complete.</p>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
            </div>
        </div>
    </div>
</div>
<script>
function showRunSuccessModal(msg){
    try { if(msg) document.getElementById('runSuccessBody').textContent = msg; new bootstrap.Modal(document.getElementById('runSuccessModal')).show(); } catch(e){}
}
document.addEventListener('DOMContentLoaded', () => {
    if (window.runSuccessFlag) {
        setTimeout(() => { window.location.href = "{{ url_for('reports_page') }}"; }, 300);
    }
});
// Capture server-provided flag (injected if present)
// Inject run success flag
window.runSuccessFlag = ("{{ '1' if (run_success is defined and run_success) else '0' }}" === '1');
// Wrap pollRunStatus to detect async completion success
function installRunSuccessHook(){
    const original = window.pollRunStatus;
    if (typeof original !== 'function') {
        console.warn('pollRunStatus hook skipped: function unavailable');
        return;
    }
    if (original.__runSuccessWrapped) {
        return;
    }
    const wrapped = async function(runId){
        await original(runId);
        try {
            const res = await fetch('/run_status/' + runId);
            if(!res.ok) return;
            const data = await res.json();
            if(data.done && data.returncode === 0){
                showRunSuccessModal('Asynchronous run completed successfully.');
            } else if(!data.done) {
                setTimeout(() => pollRunStatus(runId), 800);
            }
        } catch(e){}
    };
    wrapped.__runSuccessWrapped = true;
    window.pollRunStatus = wrapped;
}
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', installRunSuccessHook);
} else {
    installRunSuccessHook();
}
</script>
{% endblock %}
