{% extends 'layout.html' %}
{% block title %}Scenarios - CORE TopoGen{% endblock %}
{% block active_page %}{% set active_page = 'scenarios' %}{% endblock %}
{% block extra_head %}
<style>
    body { padding-bottom: 42vh; }
    .pulse-change { animation: pulseHighlight .9s ease-in-out; }
    @keyframes pulseHighlight { 0% { box-shadow:0 0 0 0 rgba(13,110,253,.7); transform:scale(1);} 40% { box-shadow:0 0 0 6px rgba(13,110,253,.0); transform:scale(1.03);} 100% { box-shadow:0 0 0 0 rgba(13,110,253,0); transform:scale(1); } }
    .popover { max-width: 420px; }
    .host-total-badge + .badge, .host-total-badge + button { margin-left: .25rem; }
    /* Hide H/S bounds by default; JS adds .hs-show to display them */
    .hs-bounds-wrapper { display: none; }
    .hs-bounds-wrapper.hs-show { display: flex; }
    .form-switch.form-switch-sm .form-check-input {
        height: 1rem;
        width: 2rem;
        transform: scale(0.85);
        margin-top: 0.15rem;
    }
    .form-switch.form-switch-sm .form-check-label {
        padding-left: .35rem;
    }
    fieldset.hitl-step-fieldset {
        border: 0;
        padding: 0;
        margin: 0;
        min-width: 0;
    }
    fieldset.hitl-step-fieldset[disabled] {
        opacity: 0.6;
        pointer-events: none;
    }
    .hitl-step-disabled {
        filter: grayscale(0.3);
        opacity: 0.85;
    }
    #executeConfirmModal .modal-dialog {
        max-width: min(960px, 95vw);
    }
    #executeConfirmModal .modal-content {
        min-height: auto;
    }
    #executeProgressWrap .progress {
        height: 18px;
    }
    #executeProgressLog {
        height: 320px;
    }
</style>
{% endblock %}
<!-- hs-bounds-wrapper styles moved into style block above -->
{% set is_builder_view = (ui_view_mode == 'builder') %}
{% block content %}
    <div class="row">
        <div class="col-md-3 mb-3">
            <div class="card shadow-sm h-100 d-flex flex-column">
                <div class="card-header d-flex justify-content-between align-items-center">
                    <span class="fw-bold">Scenarios</span>
                    <div class="btn-toolbar gap-2 align-items-center">
                        {% if not is_builder_view %}
                        <button type="button" class="btn btn-sm btn-outline-secondary" id="importBtn" title="Import scenarios XML">Import</button>
                        <button type="button" class="btn btn-sm btn-outline-info" id="exportBtn" title="Export last saved XML">Export</button>
                        <div class="btn-group" role="group" aria-label="Bulk scenario actions">
                            <button type="button" class="btn btn-sm btn-outline-secondary" id="selectAllScenariosBtn" title="Select all (or clear if all selected)">All</button>
                            <button type="button" class="btn btn-sm btn-outline-danger" id="deleteSelectedScenariosBtn" title="Delete selected scenarios" disabled>Delete</button>
                        </div>
                        {% endif %}
                    </div>
                </div>
                <div class="list-group list-group-flush flex-grow-1 overflow-auto" id="scenarioList" style="min-height:0;"></div>
                <form id="hiddenLoadForm" class="d-none" action="{{ url_for('load_xml') }}" method="post" enctype="multipart/form-data">
                    <input type="file" name="scenarios_xml" id="hiddenLoadInput" accept=".xml">
                </form>
                {% if not is_builder_view %}
                <div class="card-footer" style="position: sticky; bottom: 0; background: #fff; z-index: 1;">
                    <button type="button" class="btn btn-sm btn-primary w-100" id="appendScenarioBtn">New Scenario</button>
                </div>
                {% endif %}
            </div>
        </div>
        <div class="col-md-9">
            <div class="card shadow mt-3">
                <div class="card-body">
                    {% with messages = get_flashed_messages() %}
                        {% if messages %}
                            <div class="alert alert-info">{{ messages[0] }}</div>
                        {% endif %}
                    {% endwith %}

                    <div class="card mb-3" id="baseCoreScenarioCard">
                        <div class="card-header d-flex justify-content-between align-items-center">
                            <strong>Base CORE Scenario</strong>
                            <div class="d-flex align-items-center gap-2" id="baseScenarioControls">
                                {% set has_base = payload.base_upload is defined and payload.base_upload %}
                                {% if is_builder_view %}
                                <a id="baseDetailsLink" class="btn btn-sm btn-outline-secondary {% if not has_base %}d-none{% endif %}" href="{% if has_base %}{{ url_for('core_details') }}?path={{ payload.base_upload.path | urlencode }}{% else %}#{% endif %}" target="_blank" data-base-url="{{ url_for('core_details') }}?path=">Details</a>
                                {% else %}
                                <span id="baseValidityBadge" class="badge {% if not has_base %}d-none{% else %}{% if payload.base_upload.valid %}text-bg-success{% else %}text-bg-danger{% endif %}{% endif %}">
                                    {% if has_base %}{% if payload.base_upload.valid %}VALID{% else %}INVALID{% endif %}{% else %}VALID{% endif %}
                                </span>
                                <a id="baseDetailsLink" class="btn btn-sm btn-outline-secondary {% if not has_base %}d-none{% endif %}" href="{% if has_base %}{{ url_for('core_details') }}?path={{ payload.base_upload.path | urlencode }}{% else %}#{% endif %}" target="_blank" data-base-url="{{ url_for('core_details') }}?path=">Details</a>
                                <form action="{{ url_for('remove_base') }}" method="post" class="d-inline {% if not has_base %}d-none{% endif %}" id="baseRemoveForm" onsubmit="saveScrollBeforeNav(); document.getElementById('scenarios_json').value = JSON.stringify({ scenarios: state.scenarios });">
                                    <button type="submit" class="btn btn-sm btn-outline-danger">Remove</button>
                                </form>
                                <button class="btn btn-sm btn-outline-secondary" type="button" id="baseCoreCollapseBtn" data-preview-collapse="baseCoreScenarioBody" data-label-collapse="Collapse" data-label-expand="Expand">Collapse</button>
                                {% endif %}
                            </div>
                        </div>
                        <div class="card-body collapse show" id="baseCoreScenarioBody">
                            {% if is_builder_view %}
                            <div class="mb-0">
                                <label class="form-label mb-1">Base Scenario File</label>
                                <input class="form-control" id="baseFileInput" readonly>
                            </div>
                            {% else %}
                            <div class="mb-3">
                                <label class="form-label d-flex align-items-center justify-content-between">
                                    <span>Base Scenario File</span>
                                </label>
                                <input class="form-control" id="baseFileInput" readonly>
                                <div class="form-text">Shows the uploaded file name; full path is stored internally.</div>
                            </div>
                            <form class="d-flex gap-2" action="{{ url_for('upload_base') }}" method="post" enctype="multipart/form-data" onsubmit="saveScrollBeforeNav()">
                                <input type="file" class="form-control" name="base_xml" accept=".xml" required>
                                <button type="submit" class="btn btn-primary">{% if payload.base_upload %}Update{% else %}Upload{% endif %}</button>
                            </form>
                            {% if payload.base_upload and not payload.base_upload.valid and logs %}
                                <div class="alert alert-danger mt-3 mb-0" style="white-space: pre-wrap;">{{ logs }}</div>
                            {% endif %}
                            {% endif %}
                        </div>
                    </div>

                    <div class="card mt-3" id="scenarioEditorCard">
                        <div class="card-header d-flex justify-content-between align-items-center flex-wrap gap-2">
                            <strong>Scenario Editor</strong>
                            <div class="d-flex flex-wrap align-items-center gap-2">
                                {% if not is_builder_view %}
                                <div class="btn-group btn-group-sm" role="group" aria-label="HITL setup actions">
                                    <button class="btn btn-outline-primary" type="button" id="selectCoreVmBtn">Select CORE VM</button>
                                    <button class="btn btn-primary" type="button" id="configHitlBtn" disabled title="Complete Steps 1 and 2 first.">Config HITL</button>
                                </div>
                                {% else %}
                                <span class="badge text-bg-secondary">HITL settings managed by admin</span>
                                {% endif %}
                            </div>
                        </div>
                        <div class="card-body">
                            <form id="editorForm" action="{{ url_for('save_xml') }}" method="post">
                                <input type="hidden" name="scenarios_json" id="scenarios_json">
                                <input type="hidden" name="active_index" id="active_index" value="0">
                                <input type="hidden" name="core_json" id="core_json">
                                <input type="hidden" name="project_key_hint" id="project_key_hint">
                                <input type="hidden" name="scenario_query" id="scenario_query_input">
                                <div id="editorRoot"></div>
                                <div class="d-flex gap-2 mt-3">
                                    <button type="submit" class="btn btn-success" id="saveXmlBtn">Save XML</button>
                                    <button type="button" class="btn btn-outline-info" id="downloadXmlBtn" disabled title="Save XML first">Download XML</button>
                                </div>
                            </form>
                        </div>
                    </div>

                    <!-- Planning Workflow card visually removed but retained (d-none) for underlying JS functionality -->
                    <div class="card mt-3 d-none" id="planWorkflowCard">
                        <div class="card-header d-flex justify-content-between align-items-center">
                            <strong>Planning Workflow</strong>
                            <div id="planStatusBadge" class="badge text-bg-secondary">No Preview</div>
                        </div>
                        <div class="card-body">
                            <div class="d-flex flex-wrap gap-2 align-items-center mb-2">
                                <button class="btn btn-sm btn-outline-primary" type="button" id="planPreviewBtn" title="Generate full preview (routers, IPs, services)" disabled>Full Preview</button>
                                <!-- Run (Seed) workflow removed: deterministic seed input and run button eliminated -->
                                <!-- Single Full Preview button (above) is authoritative; secondary button and strict checkbox removed -->
                            </div>
                            <div class="small text-muted" id="planHint">Save XML and test CORE connection to enable planning.</div>
                            <pre id="planPreviewJson" class="small bg-light p-2 border rounded d-none" style="max-height:260px;overflow:auto;font-size:0.65rem;"></pre>
                            <div id="fullPreviewStructured" class="mt-2 d-none">
                                <div class="d-flex flex-wrap gap-2 align-items-center mb-2">
                                    <div class="btn-group btn-group-sm" role="group" aria-label="Full preview sections" id="fullPreviewSectionTabs"></div>
                                    <button type="button" class="btn btn-sm btn-outline-secondary" id="toggleRawFullPreviewBtn" title="Toggle raw JSON / structured view">Raw JSON</button>
                                    <!-- Copy seed button removed -->
                                </div>
                                <div id="fullPreviewSectionContent" class="border rounded p-2 bg-white small" style="max-height:300px; overflow:auto; font-size:.7rem;"></div>
                            </div>
                            <div id="planViolationsWrap" class="d-none mt-2">
                                <div class="alert alert-warning py-2 mb-0"><strong>Violations</strong><ul id="planViolationsList" class="mb-0 small"></ul></div>
                            </div>
                        </div>
                    </div>
                    <!-- Run form repurposed: Run CLI now triggers Full Preview (no direct execution here) -->
                    <form class="d-flex gap-2 mt-3 align-items-center" action="javascript:void(0)" id="runLegacyForm">
                        <input type="hidden" name="xml_path" id="xml_path">
                        <span class="d-inline-block" tabindex="0" id="runSyncWrap" data-bs-toggle="tooltip" data-bs-title="Runs CLI using current XML">
                            <button class="btn btn-warning" type="button" id="runSyncBtn" disabled title="Generates a Full Preview (no execution)">Generate</button>
                        </span>
                        <button class="btn btn-outline-danger d-none" type="button" id="cancelRunBtn" onclick="cancelRun()">Cancel</button>
                    </form>
                </div>
            </div>

        </div>
    </div>
    <!-- Run Progress Modal -->
<div class="modal fade" id="runProgressModal" tabindex="-1" aria-hidden="true">
    <div class="modal-dialog modal-dialog-centered modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title">Running CLI…</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <div class="d-flex justify-content-between align-items-center mb-2 small text-muted">
                    <div id="runProgressStatus">Starting…</div>
                    <div id="runProgressMeta"></div>
                </div>
                <div id="runProgressModeHint" class="mb-2 fw-bold text-warning d-none"></div>
                <div class="progress mb-2">
                    <div class="progress-bar progress-bar-striped progress-bar-animated" id="runProgressBar" style="width: 100%">Working…</div>
                </div>
                <div class="border rounded" style="max-height: 260px; overflow: auto;">
                    <pre class="m-0 p-2 small" id="runProgressLog" style="white-space: pre-wrap;"></pre>
                </div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" id="runProgressHideBtn" data-bs-dismiss="modal">Hide</button>
            </div>
        </div>
    </div>
</div>
{% set xml_preview_enabled = True %}
{% set xml_preview_text = xml_preview %}

<!-- CORE VM Selection Modal -->
<div class="modal fade" id="coreVmSelectModal" tabindex="-1" aria-hidden="true">
    <div class="modal-dialog modal-lg modal-dialog-scrollable">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title">Select CORE VM</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <p class="small text-muted">Complete Steps 1 and 2 to choose a Proxmox resource and CORE VM with credentials.</p>
                <div id="coreVmSelectContainer" class="d-flex flex-column gap-3"></div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-outline-secondary" data-bs-dismiss="modal">Cancel</button>
                <button type="button" class="btn btn-primary" id="coreVmModalSaveBtn">Save Scenario</button>
            </div>
        </div>
    </div>
</div>
<!-- Config HITL Modal (Steps 3 & 4) -->
<div class="modal fade" id="externalIfxModal" tabindex="-1" aria-hidden="true">
    <div class="modal-dialog modal-lg modal-dialog-scrollable">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title">Config HITL</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <p class="small text-muted">Configure Steps 3 &amp; 4: enable HITL interfaces and map participant VMs.</p>
                <div id="externalIfxBusyNotice" class="alert alert-info small d-none" role="status" aria-live="polite"></div>
                <div id="externalIfxHitlContainer" class="d-flex flex-column gap-3"></div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-outline-secondary" data-bs-dismiss="modal">Cancel</button>
                <button type="button" class="btn btn-primary" id="externalIfxModalSaveBtn">Save Scenario</button>
            </div>
        </div>
    </div>
</div>
<!-- Proxmox Assignment Modal -->
<div class="modal fade" id="proxmoxAssignModal" tabindex="-1" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title">Assign Proxmox Resource</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <div class="alert alert-info small" id="proxmoxAssignHint" style="display:none;"></div>
                <form id="proxmoxAssignForm">
                    <div class="mb-3">
                        <label for="proxmoxUrl" class="form-label">URL</label>
                        <input type="url" class="form-control" id="proxmoxUrl" placeholder="https://proxmox.example.local" autocomplete="url" required>
                        <div class="form-text">Provide the base URL to the Proxmox API (https://host.domain).</div>
                    </div>
                    <div class="mb-3">
                        <label for="proxmoxPort" class="form-label">Port</label>
                        <input type="number" class="form-control" id="proxmoxPort" placeholder="8006" min="1" max="65535" autocomplete="on" required>
                    </div>
                    <div class="form-check form-switch mb-3">
                        <input class="form-check-input" type="checkbox" role="switch" id="proxmoxVerifySsl" checked>
                        <label class="form-check-label" for="proxmoxVerifySsl">Enforce SSL certificate verification</label>
                        <div class="form-text">Uncheck when connecting to Proxmox with self-signed or invalid certificates.</div>
                    </div>
                    <div class="mb-3">
                        <label for="proxmoxUsername" class="form-label">Username</label>
                        <input type="text" class="form-control" id="proxmoxUsername" placeholder="root@pam" autocomplete="username" required>
                    </div>
                    <div class="mb-3">
                        <label for="proxmoxPassword" class="form-label">Password</label>
                        <input type="password" class="form-control" id="proxmoxPassword" placeholder="••••••" autocomplete="current-password">
                    </div>
                    <div class="form-check form-switch mb-3">
                        <input class="form-check-input" type="checkbox" id="proxmoxRememberCreds" checked>
                        <label class="form-check-label" for="proxmoxRememberCreds">Save credentials after validation</label>
                        <div class="form-text">Disable to validate against Proxmox without storing secrets in the vault.</div>
                    </div>
                </form>
                <div class="alert alert-danger d-none" id="proxmoxAssignError"></div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-outline-secondary" data-bs-dismiss="modal">Cancel</button>
                <button type="button" class="btn btn-primary" id="proxmoxAssignSave">Validate &amp; Save</button>
            </div>
        </div>
    </div>
</div>
<!-- CORE Connection Modal -->
<div class="modal fade" id="coreConnectionModal" tabindex="-1" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title">CORE Connection</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <div class="alert alert-info small d-none" id="coreConnectionHint"></div>
                <form id="coreConnectionForm" class="needs-validation" novalidate>
                    <div class="row g-2">
                        <div class="col-md-8">
                            <div class="mb-3">
                                <label for="coreSshHost" class="form-label">SSH Host</label>
                                <input type="text" class="form-control" id="coreSshHost" placeholder="Defaults to gRPC host" data-hitl-core-field="ssh_host" autocomplete="off">
                            </div>
                        </div>
                        <div class="col-md-4">
                            <div class="mb-3">
                                <label for="coreSshPort" class="form-label">SSH Port</label>
                                <input type="number" class="form-control" id="coreSshPort" min="1" max="65535" data-hitl-core-field="ssh_port" autocomplete="off">
                            </div>
                        </div>
                    </div>
                    <div class="row g-2">
                        <div class="col-md-6">
                            <div class="mb-3">
                                <label for="coreSshUsername" class="form-label">SSH Username</label>
                                <input type="text" class="form-control" id="coreSshUsername" data-hitl-core-field="ssh_username" autocomplete="username" required>
                            </div>
                        </div>
                        <div class="col-md-6">
                            <div class="mb-3">
                                <label for="coreSshPassword" class="form-label">SSH Password</label>
                                <input type="password" class="form-control" id="coreSshPassword" data-hitl-core-field="ssh_password" autocomplete="current-password">
                                <div class="form-text">Passwords are stored in the secure credential vault after a successful test.</div>
                            </div>
                        </div>
                    </div>
                    <div class="form-check form-switch mb-3">
                        <input class="form-check-input" type="checkbox" id="coreRememberCreds" checked>
                        <label class="form-check-label" for="coreRememberCreds">Save username &amp; password after validation</label>
                        <div class="form-text">Disable to require manual entry each time; secrets remain only in the vault.</div>
                    </div>
                    <div class="form-check form-switch mb-3">
                        <input class="form-check-input" type="checkbox" id="coreAutoStartDaemon">
                        <label class="form-check-label" for="coreAutoStartDaemon">Auto-start core-daemon if not running</label>
                        <div class="form-text">Runs 'sudo core-daemon -d' on the CORE VM during connection validation.</div>
                    </div>
                    <div class="mt-4">
                        <button class="btn btn-link p-0" type="button" data-bs-toggle="collapse" data-bs-target="#coreConnAdvanced" aria-expanded="false" aria-controls="coreConnAdvanced">Advanced</button>
                        <div class="collapse" id="coreConnAdvanced">
                            <div class="border rounded p-2 mt-2">
                                <div class="small text-muted mb-2">Usually you don’t need to change these.</div>
                                <div class="mb-3">
                                    <label for="coreGrpcHost" class="form-label">gRPC Host</label>
                                    <input type="text" class="form-control" id="coreGrpcHost" placeholder="core-host.example" data-hitl-core-field="grpc_host" autocomplete="off" required>
                                </div>
                                <div class="mb-1">
                                    <label for="coreGrpcPort" class="form-label">gRPC Port</label>
                                    <input type="number" class="form-control" id="coreGrpcPort" min="1" max="65535" data-hitl-core-field="grpc_port" autocomplete="off" required>
                                </div>
                                <div class="mb-1">
                                    <label for="coreVenvBin" class="form-label">Remote CORE venv bin</label>
                                    <input type="text" class="form-control" id="coreVenvBin" placeholder="/opt/core/venv/bin" data-hitl-core-field="venv_bin" autocomplete="off">
                                    <div class="form-text">Python commands run over SSH will use this directory (include the <code>/bin</code> path inside the CORE virtualenv).</div>
                                </div>
                                <div class="d-flex align-items-center gap-2 mb-1">
                                    <button type="button" class="btn btn-outline-secondary btn-sm" id="coreTestVenvBtn">Test Venv</button>
                                    <div id="coreVenvTestStatus" class="form-text mb-0 text-muted">Not tested.</div>
                                </div>
                            </div>
                        </div>
                    </div>
                </form>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-outline-secondary" data-bs-dismiss="modal">Cancel</button>
                <button type="button" class="btn btn-primary" id="coreConnectionSaveBtn">Save &amp; Validate</button>
            </div>
        </div>
    </div>
</div>

<!-- CORE Nav Blocked Modal (missing Proxmox setup) -->
<div class="modal fade" id="coreNavBlockedModal" tabindex="-1" aria-hidden="true">
    <div class="modal-dialog modal-dialog-centered">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title">CORE</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                You must first select a CORE VM in the Scenarios Page to view this page.
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
            </div>
        </div>
    </div>
</div>
{% include 'partials/dock.html' %}

<!-- Toasts removed (requested). Keep a no-op helper so legacy call sites don't error. -->
<script>
    function showToast(_message, _opts){
        return null;
    }
</script>

<!-- Graph libraries for Full Preview Modal -->
<script src="https://cdn.jsdelivr.net/npm/d3@7/dist/d3.min.js"></script>
<script src="{{ url_for('static', filename='core_graph.js') }}"></script>

<!-- Toast container removed (requested) -->
<!-- Success Modal -->
<div class="modal fade" id="runSuccessModal" tabindex="-1" aria-hidden="true">
    <div class="modal-dialog modal-dialog-centered">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title">Run Completed</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <p class="mb-1" id="runSuccessBody">Generation complete.</p>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
            </div>
        </div>
    </div>
</div>
<!-- Execute Confirm Modal -->
<div class="modal fade" id="executeConfirmModal" tabindex="-1" aria-hidden="true">
    <div class="modal-dialog modal-dialog-centered">
        <div class="modal-content">
            <div class="modal-header">
                <div>
                    <h5 class="modal-title mb-0">Execute Scenario</h5>
                    <div class="small text-muted" id="executePhaseHeader">Phase: —</div>
                </div>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <p class="mb-3" id="executeConfirmMessage">Execute this scenario now?</p>
                <div class="alert alert-warning small d-none" id="executeConfirmAlert"></div>
                <div class="border rounded-3 p-3 bg-body-tertiary mb-3">
                    <div class="d-flex flex-wrap align-items-center justify-content-between gap-3">
                        <div class="flex-grow-1">
                            <div class="text-uppercase small text-muted fw-semibold">Execution Mode</div>
                        </div>
                        <div class="form-check form-switch m-0" id="executeUpdateRemoteToggleWrap">
                            <input class="form-check-input" type="checkbox" role="switch" id="executeConfirmUpdateRemoteToggle">
                            <label class="form-check-label fw-semibold" for="executeConfirmUpdateRemoteToggle">Generate on Remote CORE VM</label>
                        </div>
                    </div>
                    <div class="small text-muted mt-2" id="executeConfirmUpdateRemoteHelp">Emulation mode runs locally on this workstation.</div>
                    <div class="d-flex flex-wrap align-items-center justify-content-between gap-3 mt-3 d-none" id="executeCoreNotConfiguredRow">
                        <div class="flex-grow-1">
                            <div class="text-uppercase small text-muted fw-semibold">Remote CORE Connection</div>
                            <div class="small text-danger" id="executeCoreNotConfiguredStatus">CORE VM not configured.</div>
                        </div>
                        <button type="button" class="btn btn-outline-primary btn-sm" id="executeSelectCoreVmBtn">Select CORE VM</button>
                    </div>
                    <div class="d-flex flex-wrap align-items-center justify-content-between gap-3 mt-3 d-none" id="executeCoreTestRow">
                        <div class="flex-grow-1">
                            <div class="text-uppercase small text-muted fw-semibold">Remote CORE Connection</div>
                            <div class="small text-muted" id="executeCoreStatus">Connection status unknown.</div>
                        </div>
                        <button type="button" class="btn btn-outline-primary btn-sm" id="executeCoreTestBtn">Test Connection</button>
                    </div>
                    <div class="form-check form-switch mt-3 d-none" id="executePushUpdateToggleWrap">
                        <input class="form-check-input" type="checkbox" role="switch" id="executeConfirmPushUpdateToggle">
                        <label class="form-check-label fw-semibold" for="executeConfirmPushUpdateToggle">Push updated backend</label>
                        <div class="form-text" id="executeConfirmPushUpdateHelp">Sync the current repository snapshot to your CORE VM before execution.</div>
                    </div>
                </div>

                <details class="border rounded-3 p-3 bg-body-tertiary mb-3 d-none" id="executeAdvancedWrap">
                    <summary class="fw-semibold">Advanced</summary>
                    <div class="small text-muted mt-2">Applies to remote execution only.</div>
                    <div class="mt-3 d-grid gap-2">
                        <div class="form-check">
                            <input class="form-check-input" type="checkbox" id="executeAdvFixDockerDaemon">
                            <label class="form-check-label" for="executeAdvFixDockerDaemon">Fix Docker daemon for CORE (disable default bridge + iptables)</label>
                        </div>
                        <div class="form-check">
                            <input class="form-check-input" type="checkbox" id="executeAdvRunCoreCleanup">
                            <label class="form-check-label" for="executeAdvRunCoreCleanup">Run core-cleanup</label>
                        </div>
                        <div class="form-check">
                            <input class="form-check-input" type="checkbox" id="executeAdvCheckCoreVersion">
                            <label class="form-check-label" for="executeAdvCheckCoreVersion">Check CORE version is 9.2.1</label>
                        </div>
                        <div class="form-check">
                            <input class="form-check-input" type="checkbox" id="executeAdvRestartCoreDaemon">
                            <label class="form-check-label" for="executeAdvRestartCoreDaemon">Restart core-daemon</label>
                        </div>
                        <div class="form-check">
                            <input class="form-check-input" type="checkbox" id="executeAdvAutoKillSessions">
                            <label class="form-check-label" for="executeAdvAutoKillSessions">Auto-kill any running sessions</label>
                        </div>
                    </div>
                </details>

                <div class="border rounded p-3 mt-3 bg-body-tertiary d-none" id="executeProgressWrap">
                    <div class="d-flex align-items-center gap-2">
                        <div class="spinner-border spinner-border-sm text-primary" role="status" aria-hidden="true" id="executeProgressSpinner"></div>
                        <div class="flex-grow-1">
                            <div class="fw-semibold" id="executeProgressStatus">Preparing…</div>
                            <div class="small text-muted" id="executeProgressMeta"></div>
                        </div>
                        <button type="button" class="btn btn-sm btn-outline-secondary d-none" id="executeProgressPopoutBtn">Open run logs</button>
                    </div>
                    <div class="progress mt-3" style="height: 12px;">
                        <div class="progress-bar progress-bar-striped" id="executeProgressBar" role="progressbar" style="width: 0%" aria-valuemin="0" aria-valuemax="100">0%</div>
                    </div>
                    <pre class="form-control bg-dark text-white border-0 mt-3 small" id="executeProgressLog" style="height: 190px; overflow:auto; font-family: SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace;"></pre>
                </div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-outline-secondary" data-bs-dismiss="modal" id="executeConfirmCancelBtn">Cancel</button>
                <button type="button" class="btn btn-primary" id="executeConfirmRunBtn">Execute</button>
            </div>
        </div>
    </div>
</div>
<!-- Full Preview Modal -->
<div class="modal fade" id="fullPreviewModal" tabindex="-1" aria-hidden="true">
    <div class="modal-dialog modal-fullscreen-lg-down modal-xl modal-dialog-scrollable">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title">Full Preview <span class="text-muted small" id="fpModalSeed"></span></h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <div class="row g-3">
                    <div class="col-lg-8">
                        <div class="card" id="fpGraphCard">
                            <div class="card-header d-flex justify-content-between align-items-center">
                                <strong>Graph</strong>
                                <div class="d-flex align-items-center gap-2">
                                    <div class="form-check form-switch form-switch-sm mb-0">
                                        <input class="form-check-input" type="checkbox" role="switch" id="fpGraphLabelsToggle">
                                        <label class="form-check-label small" for="fpGraphLabelsToggle">Show labels</label>
                                    </div>
                                    <div class="btn-group btn-group-sm">
                                        <button class="btn btn-outline-secondary" type="button" id="fpGraphResetBtn">Reset</button>
                                        <button class="btn btn-outline-secondary" type="button" id="fpGraphPngBtn">PNG</button>
                                        <button class="btn btn-outline-secondary" type="button" id="fpOpenStandaloneBtn">Open Page</button>
                                    </div>
                                </div>
                            </div>
                            <div class="card-body p-2">
                                <div id="fpGraph" style="height:480px; position:relative; background:#fafafa; border:1px solid #e0e0e0; border-radius:4px; overflow:hidden;">
                                    <div class="position-absolute top-50 start-50 translate-middle text-muted" id="fpGraphLoading">Rendering...</div>
                                </div>
                                <div class="form-text mt-1">Drag to reposition nodes. Hover for details. PNG exports current view.</div>
                            </div>
                        </div>
                        <div class="card mt-3">
                            <div class="card-header d-flex justify-content-between align-items-center">
                                <strong>Routers</strong>
                                <button class="btn btn-sm btn-outline-secondary" type="button" data-preview-collapse="fpRoutersWrap" data-label-collapse="Collapse" data-label-expand="Expand">Collapse</button>
                            </div>
                            <div class="card-body collapse p-2" id="fpRoutersWrap"><div class="text-muted small">No data</div></div>
                        </div>
                        <div class="card mt-3">
                            <div class="card-header d-flex justify-content-between align-items-center">
                                <strong>Hosts</strong>
                                <button class="btn btn-sm btn-outline-secondary" type="button" data-preview-collapse="fpHostsWrap" data-label-collapse="Collapse" data-label-expand="Expand">Collapse</button>
                            </div>
                            <div class="card-body collapse p-2" id="fpHostsWrap"><div class="text-muted small">No data</div></div>
                        </div>
                        <div class="card mt-3">
                            <div class="card-header d-flex justify-content-between align-items-center">
                                <strong>Switches</strong>
                                <button class="btn btn-sm btn-outline-secondary" type="button" data-preview-collapse="fpSwitchesWrap" data-label-collapse="Collapse" data-label-expand="Expand">Collapse</button>
                            </div>
                            <div class="card-body collapse p-2" id="fpSwitchesWrap"><div class="text-muted small">No data</div></div>
                        </div>
                        <div class="card mt-3">
                            <div class="card-header d-flex justify-content-between align-items-center">
                                <strong>Node Sections</strong>
                                <button class="btn btn-sm btn-outline-secondary" type="button" data-preview-collapse="fpNodeSectionsWrap" data-label-collapse="Collapse" data-label-expand="Expand">Collapse</button>
                            </div>
                            <div class="card-body collapse p-2" style="max-height:240px;overflow:auto;" id="fpNodeSectionsWrap"><div class="text-muted small">No data</div></div>
                        </div>
                    </div>
                    <div class="col-lg-4">
                        <div class="card mb-3">
                            <div class="card-header d-flex justify-content-between align-items-center">
                                <strong>Counts</strong>
                                <button class="btn btn-sm btn-outline-secondary" type="button" data-preview-collapse="fpCounts" data-label-collapse="Collapse" data-label-expand="Expand">Collapse</button>
                            </div>
                            <div class="card-body collapse p-2" id="fpCounts"></div>
                        </div>
                        <div class="card mb-3">
                            <div class="card-header d-flex justify-content-between align-items-center">
                                <strong>R2R Policy</strong>
                                <button class="btn btn-sm btn-outline-secondary" type="button" data-preview-collapse="fpR2RPolicyBody" data-label-collapse="Collapse" data-label-expand="Expand">Collapse</button>
                            </div>
                            <div class="card-body collapse p-2" id="fpR2RPolicyBody"><pre class="small mb-0" id="fpR2RPolicy" style="max-height:160px; overflow:auto;"></pre></div>
                        </div>
                        <div class="card mb-3">
                            <div class="card-header d-flex justify-content-between align-items-center">
                                <strong>R2S Policy</strong>
                                <button class="btn btn-sm btn-outline-secondary" type="button" data-preview-collapse="fpR2SPolicyBody" data-label-collapse="Collapse" data-label-expand="Expand">Collapse</button>
                            </div>
                            <div class="card-body collapse p-2" id="fpR2SPolicyBody"><pre class="small mb-0" id="fpR2SPolicy" style="max-height:160px; overflow:auto;"></pre></div>
                        </div>
                        <div class="card mb-3">
                            <div class="card-header d-flex justify-content-between align-items-center">
                                <strong>Segmentation Plan</strong>
                                <button class="btn btn-sm btn-outline-secondary" type="button" data-preview-collapse="fpSegmentationCardBody" data-label-collapse="Collapse" data-label-expand="Expand">Collapse</button>
                            </div>
                            <div class="card-body collapse p-2" id="fpSegmentationCardBody">
                                <div class="small mb-2" id="fpSegmentationTypes" hidden></div>
                                <pre class="small mb-0" id="fpSegmentation" style="max-height:220px; overflow:auto;"></pre>
                                <div class="mt-2" id="fpSegmentationRuntimeWrap" hidden>
                                    <h6 class="small text-uppercase text-muted mb-1">Runtime Segmentation Summary (segmentation_summary.json)</h6>
                                    <pre class="small bg-light p-2 mb-0" id="fpSegmentationRuntime" style="max-height:220px; overflow:auto;"></pre>
                                </div>
                                <div class="small text-muted mt-2" id="fpSegmentationHash" hidden></div>
                            </div>
                        </div>
                        <div class="card mb-3">
                            <div class="card-header d-flex justify-content-between align-items-center">
                                <strong>Router Plan</strong>
                                <button class="btn btn-sm btn-outline-secondary" type="button" data-preview-collapse="fpRouterPlanBody" data-label-collapse="Collapse" data-label-expand="Expand">Collapse</button>
                            </div>
                            <div class="card-body collapse p-2" id="fpRouterPlanBody"><pre class="small mb-0" id="fpRouterPlan" style="max-height:160px; overflow:auto;"></pre></div>
                        </div>
                        <div class="card mb-3">
                            <div class="card-header d-flex justify-content-between align-items-center">
                                <strong>Services Plan</strong>
                                <button class="btn btn-sm btn-outline-secondary" type="button" data-preview-collapse="fpServicesPlanBody" data-label-collapse="Collapse" data-label-expand="Expand">Collapse</button>
                            </div>
                            <div class="card-body collapse p-2" id="fpServicesPlanBody"><pre class="small mb-0" id="fpServicesPlan" style="max-height:160px; overflow:auto;"></pre></div>
                        </div>
                        <div class="card mb-3">
                            <div class="card-header d-flex justify-content-between align-items-center">
                                <strong>Vulnerabilities Plan</strong>
                                <button class="btn btn-sm btn-outline-secondary" type="button" data-preview-collapse="fpVulnPlanBody" data-label-collapse="Collapse" data-label-expand="Expand">Collapse</button>
                            </div>
                            <div class="card-body collapse p-2" id="fpVulnPlanBody"><pre class="small mb-0" id="fpVulnPlan" style="max-height:160px; overflow:auto;"></pre></div>
                        </div>
                        <div class="card mb-3">
                            <div class="card-header d-flex justify-content-between align-items-center">
                                <strong>Traffic Plan</strong>
                                <button class="btn btn-sm btn-outline-secondary" type="button" data-preview-collapse="fpTrafficPlanBody" data-label-collapse="Collapse" data-label-expand="Expand">Collapse</button>
                            </div>
                            <div class="card-body collapse p-2" id="fpTrafficPlanBody"><pre class="small mb-0" id="fpTrafficPlan" style="max-height:160px; overflow:auto;"></pre></div>
                        </div>
                        <!-- Removed History, Role Distribution, Service Distribution cards -->
                        <!-- Drift card removed (no approved plan concept) -->
                    </div>
                </div>
            </div>
            <div class="modal-footer d-flex justify-content-between align-items-center">
                <div class="d-flex gap-2">
                    <button class="btn btn-warning" type="button" id="fpExecuteBtn" title="Execute scenario now">Execute</button>
                </div>
                <button class="btn btn-secondary" data-bs-dismiss="modal" type="button">Close</button>
            </div>
        </div>
    </div>
</div>
<!-- Planning Semantics Modal -->
<div class="modal fade" id="planningSemanticsModal" tabindex="-1" aria-hidden="true">
    <div class="modal-dialog modal-lg modal-dialog-scrollable">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" data-i18n="modal.planningSemantics.title">Planning Semantics</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <div class="spinner-border text-primary d-none" id="planningSemanticsSpinner" role="status"><span class="visually-hidden">Loading...</span></div>
                <div id="planningSemanticsContent" class="small"></div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal" data-i18n="common.close">Close</button>
            </div>
        </div>
    </div>
</div>
{% endblock %}
{% block extra_scripts %}
<script id="payload-data" type="application/json">{{ payload | tojson }}</script>
<script id="current-user-meta" type="application/json">{{ {'username': current_user.username, 'role': current_user.role}|tojson }}</script>
<script>
// --- BEGIN PAGE JS ---
const payloadDataEl = document.getElementById('payload-data');
let initialPayload = null;
try {
    initialPayload = JSON.parse(payloadDataEl?.textContent || 'null');
} catch (err) {
    console.warn('Failed to parse payload data', err);
    initialPayload = null;
}
const currentUserDataEl = document.getElementById('current-user-meta');
let currentUserMeta = null;
try {
    currentUserMeta = JSON.parse(currentUserDataEl?.textContent || 'null');
} catch (e) {
    currentUserMeta = null;
}
const CORETG_USERNAME = (currentUserMeta && typeof currentUserMeta.username === 'string') ? currentUserMeta.username : '';
const CORETG_USER_ROLE = (currentUserMeta && typeof currentUserMeta.role === 'string') ? currentUserMeta.role : '';
window.CORETG_USERNAME = CORETG_USERNAME;
window.CORETG_USER_ROLE = CORETG_USER_ROLE;
const IS_BUILDER_VIEW = (window.CORETG_VIEW_MODE || '') === 'builder';
const USE_LOCAL_EDITOR_STATE = !IS_BUILDER_VIEW;
const BUILDER_BACKEND_UNAVAILABLE_MESSAGE = 'Backend temporarily unavailable. Please ask an admin.';
window.IS_BUILDER_VIEW = IS_BUILDER_VIEW;
const DEFAULT_INTERNAL_BRIDGE_NAME = 'corebridge';
function computeInternalBridgeName(usernameValue) {
    const base = (usernameValue || window.CORETG_USERNAME || '').toString().trim();
    if (!base) return DEFAULT_INTERNAL_BRIDGE_NAME;
    let normalized = base.replace(/[^A-Za-z0-9]+/g, '-').replace(/-+/g, '-').replace(/^-|-$/g, '');
    if (!normalized) {
        normalized = base.replace(/\s+/g, '').replace(/[^A-Za-z0-9]/g, '');
    }
    if (!normalized) return DEFAULT_INTERNAL_BRIDGE_NAME;
    normalized = normalized.toLowerCase();
    let truncated = normalized.slice(0, 10);
    if (!truncated) return DEFAULT_INTERNAL_BRIDGE_NAME;
    let trimmed = truncated.replace(/[-_]+$/g, '');
    if (!trimmed) {
        trimmed = truncated.replace(/[-_]+/g, '');
    }
    if (!trimmed) return DEFAULT_INTERNAL_BRIDGE_NAME;
    return trimmed;
}
// Prevent TDZ: define catalog early on window
window.VULN_CATALOG = window.VULN_CATALOG || { types: [], vectors: [], items: [] };
// Prevent TDZ: define catalog early on window
window.VULN_CATALOG = window.VULN_CATALOG || { types: [], vectors: [], items: [] };
function setupPreviewCollapsers(){
    const toggles = document.querySelectorAll('[data-preview-collapse]');
    toggles.forEach(btn => {
        if(btn.dataset.collapserBound) return;
        const targetId = btn.getAttribute('data-preview-collapse');
        const target = document.getElementById(targetId);
        if(!target) return;
        btn.dataset.collapserBound = '1';
        const collapseLabel = btn.dataset.labelCollapse || 'Collapse';
        const expandLabel = btn.dataset.labelExpand || 'Expand';
        const hasBootstrap = !!(window.bootstrap && bootstrap.Collapse);
        if(hasBootstrap){
            const instance = bootstrap.Collapse.getOrCreateInstance(target, { toggle: false });
            const updateLabel = () => {
                btn.textContent = target.classList.contains('show') ? collapseLabel : expandLabel;
            };
            target.addEventListener('shown.bs.collapse', updateLabel);
            target.addEventListener('hidden.bs.collapse', updateLabel);
            if(!target.classList.contains('show')){
                instance.show();
            }
            updateLabel();
            btn.addEventListener('click', ev => {
                ev.preventDefault();
                if(target.classList.contains('show')){
                    instance.hide();
                } else {
                    instance.show();
                }
            });
        } else {
            const updateLabel = () => {
                btn.textContent = target.classList.contains('d-none') ? expandLabel : collapseLabel;
            };
            target.classList.remove('d-none');
            updateLabel();
            btn.addEventListener('click', ev => {
                ev.preventDefault();
                target.classList.toggle('d-none');
                updateLabel();
            });
        }
    });
}
window.setupPreviewCollapsers = setupPreviewCollapsers;
if(document.readyState === 'loading'){ document.addEventListener('DOMContentLoaded', () => setupPreviewCollapsers()); }
else { setupPreviewCollapsers(); }
const DENSITY_COUNT_MIN = 1;
const DENSITY_COUNT_MAX = 5000;
const NODE_COUNT_MIN = 1;
const NODE_COUNT_MAX = 5000;
const initialScenarioQuery = (initialPayload && typeof initialPayload.scenario_query === 'string')
    ? initialPayload.scenario_query.trim()
    : '';
const LEGACY_EDITOR_STATE_STORAGE_KEY = 'coretg_editor_state';
const PROJECT_STATE_STORAGE_KEY = 'coretg_project_state_map_v1';
const PROJECT_ACTIVE_IDX_STORAGE_KEY = 'coretg_active_idx_map_v1';
const LAST_PROJECT_KEY_STORAGE_KEY = 'coretg_last_project_key';
const DEFAULT_PROJECT_KEY = '__default_project__';

function readLastProjectKeyFromStorage() {
    try {
        const raw = localStorage.getItem(LAST_PROJECT_KEY_STORAGE_KEY);
        return raw ? raw.trim() : '';
    } catch (err) {
        return '';
    }
}

function readJsonFromLocalStorage(key, fallback) {
    try {
        const raw = localStorage.getItem(key);
        if (raw === null || raw === undefined) return fallback;
        const parsed = JSON.parse(raw);
        return (parsed && typeof parsed === 'object') ? parsed : fallback;
    } catch (err) {
        return fallback;
    }
}

function writeJsonToLocalStorage(key, value) {
    try {
        localStorage.setItem(key, JSON.stringify(value));
    } catch (err) {}
}

function deriveProjectKey(snapshot, fallbackKey = DEFAULT_PROJECT_KEY) {
    if (!snapshot || typeof snapshot !== 'object') return fallbackKey;
    const candidates = [];
    const pushCandidate = (val) => {
        if (typeof val !== 'string') return;
        const normalized = val.trim();
        if (normalized) candidates.push(normalized);
    };
    pushCandidate(snapshot.project_key_hint);
    pushCandidate(snapshot.scenario_query);
    pushCandidate(snapshot.result_path || snapshot.resultPath);
    const resolvedScenarioToken = resolveScenarioQueryHintFromSource(snapshot);
    if (resolvedScenarioToken) pushCandidate(resolvedScenarioToken);
    const baseUpload = (snapshot.base_upload && typeof snapshot.base_upload === 'object') ? snapshot.base_upload : null;
    if (baseUpload) pushCandidate(baseUpload.path);
    if (Array.isArray(snapshot.scenarios)) {
        const basePaths = snapshot.scenarios
            .map(scen => (scen && typeof scen === 'object' && scen.base && typeof scen.base === 'object') ? scen.base.filepath : '')
            .filter(val => typeof val === 'string' && val.trim());
        basePaths.forEach(pushCandidate);
        if (!basePaths.length) {
            const scenarioNames = snapshot.scenarios
                .map(scen => (scen && typeof scen === 'object' && typeof scen.name === 'string') ? scen.name.trim() : '')
                .filter(Boolean);
            if (scenarioNames.length) {
                pushCandidate(`scenarios:${scenarioNames.join('|')}`);
            }
        }
    }
    return candidates.find(Boolean) || fallbackKey;
}

function resolveScenarioQueryHintFromSource(source) {
    if (!source) return '';
    try {
        const token = (source.scenario_query || '').trim();
        if (token) return token;
        return deriveScenarioSignature(source);
    } catch (err) {
        return '';
    }
}

function deriveScenarioSignature(source) {
    const scenarios = Array.isArray(source)
        ? source
        : (source && Array.isArray(source.scenarios) ? source.scenarios : []);
    if (!Array.isArray(scenarios) || !scenarios.length) {
        return '';
    }
    const scenarioNames = scenarios
        .map(scen => (scen && typeof scen.name === 'string') ? scen.name.trim() : '')
        .filter(Boolean);
    if (scenarioNames.length) {
        return `names:${scenarioNames.join('|')}`;
    }
    const basePaths = scenarios
        .map(scen => {
            if (!scen || typeof scen !== 'object') return '';
            const base = scen.base && typeof scen.base === 'object' ? scen.base : null;
            return base && typeof base.filepath === 'string' ? base.filepath.trim() : '';
        })
        .filter(Boolean);
    if (basePaths.length) {
        return `base:${basePaths.join('|')}`;
    }
    return '';
}

function scrubScenarioTransientErrors(scenario) {
    if (!scenario || typeof scenario !== 'object') return;
    const hitlState = (scenario.hitl && typeof scenario.hitl === 'object') ? scenario.hitl : null;
    if (!hitlState) return;
    const prox = (hitlState.proxmox && typeof hitlState.proxmox === 'object') ? hitlState.proxmox : null;
    if (!prox) return;
    if (Object.prototype.hasOwnProperty.call(prox, 'inventory_error')) {
        delete prox.inventory_error;
    }
}

function scrubSnapshotTransientErrors(snapshot) {
    if (!snapshot || typeof snapshot !== 'object') return snapshot;
    const scenarios = Array.isArray(snapshot.scenarios) ? snapshot.scenarios : null;
    if (scenarios) {
        scenarios.forEach(scrubScenarioTransientErrors);
    }
    return snapshot;
}

function cloneScenariosForSnapshot(source) {
    if (!Array.isArray(source)) return [];
    if (typeof structuredClone === 'function') {
        try {
            return structuredClone(source);
        } catch (err) {
            // fall through to JSON-based clone
        }
    }
    try {
        return JSON.parse(JSON.stringify(source));
    } catch (err) {
        return source.map(item => {
            if (!item || typeof item !== 'object') return item;
            try {
                return JSON.parse(JSON.stringify(item));
            } catch (nestedErr) {
                return { ...item };
            }
        });
    }
}

let projectStateMap = readJsonFromLocalStorage(PROJECT_STATE_STORAGE_KEY, {});
if (!projectStateMap || typeof projectStateMap !== 'object') projectStateMap = {};
let legacyEditorState = readJsonFromLocalStorage(LEGACY_EDITOR_STATE_STORAGE_KEY, null);
legacyEditorState = scrubSnapshotTransientErrors(legacyEditorState);
const lastProjectKeyFromStorage = readLastProjectKeyFromStorage();
const legacyProjectKeyHint = legacyEditorState ? deriveProjectKey(legacyEditorState, DEFAULT_PROJECT_KEY) : '';
try {
    Object.keys(projectStateMap).forEach(key => {
        const entry = projectStateMap[key];
        if (!entry || typeof entry !== 'object') return;
        projectStateMap[key] = scrubSnapshotTransientErrors(entry);
    });
} catch (err) {}
let currentProjectKey = deriveProjectKey(initialPayload, DEFAULT_PROJECT_KEY);
if ((!currentProjectKey || currentProjectKey === DEFAULT_PROJECT_KEY) && legacyProjectKeyHint) {
    currentProjectKey = legacyProjectKeyHint;
}
let activeIdxMap = readJsonFromLocalStorage(PROJECT_ACTIVE_IDX_STORAGE_KEY, {});
if (!activeIdxMap || typeof activeIdxMap !== 'object') activeIdxMap = {};
const serverEditorSnapshot = (initialPayload && typeof initialPayload.editor_snapshot === 'object')
    ? initialPayload.editor_snapshot
    : null;
const serverProjectKeyHint = (serverEditorSnapshot && typeof serverEditorSnapshot.project_key_hint === 'string')
    ? serverEditorSnapshot.project_key_hint.trim()
    : '';
const serverScenarioQuery = (serverEditorSnapshot && typeof serverEditorSnapshot.scenario_query === 'string')
    ? serverEditorSnapshot.scenario_query.trim()
    : '';
let serverSnapshotKey = '';
if (serverEditorSnapshot && typeof serverEditorSnapshot === 'object') {
    try {
        const cloned = JSON.parse(JSON.stringify(serverEditorSnapshot));
        const sanitized = scrubSnapshotTransientErrors(cloned);
        const candidateKey = deriveProjectKey(
            sanitized,
            serverProjectKeyHint || currentProjectKey || DEFAULT_PROJECT_KEY
        );
        if (candidateKey) {
            const existing = projectStateMap[candidateKey];
            const serverSignature = resolveScenarioQueryHintFromSource(sanitized);
            const existingSignature = resolveScenarioQueryHintFromSource(existing);
            const serverResult = (sanitized && typeof sanitized.result_path === 'string')
                ? sanitized.result_path.trim()
                : '';
            const existingResult = (existing && typeof existing.result_path === 'string')
                ? existing.result_path.trim()
                : '';
            const needsSync = !existing
                || (serverResult && serverResult !== existingResult)
                || (serverSignature && serverSignature !== existingSignature);
            if (needsSync) {
                try {
                    const localScenarios = existing && Array.isArray(existing.scenarios) ? existing.scenarios : null;
                    const serverScenarios = Array.isArray(sanitized.scenarios) ? sanitized.scenarios : null;
                    if (localScenarios && serverScenarios) {
                        mergePersistedHitlStateIntoScenarios(serverScenarios, localScenarios);
                    }
                } catch (mergeErr) {
                    console.warn('Editor snapshot merge failed; falling back to server snapshot', mergeErr);
                }
                projectStateMap[candidateKey] = sanitized;
                legacyEditorState = sanitized;
                writeJsonToLocalStorage(LEGACY_EDITOR_STATE_STORAGE_KEY, legacyEditorState);
                writeJsonToLocalStorage(PROJECT_STATE_STORAGE_KEY, projectStateMap);
            }
            serverSnapshotKey = candidateKey;
        }
    } catch (err) {
        console.warn('Unable to sync server snapshot into local cache', err);
    }
}
const derivedInitialSignature =
    deriveScenarioSignature(initialPayload)
    || deriveScenarioSignature(serverEditorSnapshot)
    || deriveScenarioSignature(legacyEditorState)
    || '';
let scenarioQueryToken = (initialScenarioQuery || serverScenarioQuery || derivedInitialSignature || '').trim();
if ((!currentProjectKey || currentProjectKey === DEFAULT_PROJECT_KEY) && serverProjectKeyHint) {
    currentProjectKey = serverProjectKeyHint;
}
if ((!currentProjectKey || currentProjectKey === DEFAULT_PROJECT_KEY) && scenarioQueryToken) {
    currentProjectKey = `${DEFAULT_PROJECT_KEY}::${scenarioQueryToken.toLowerCase()}`;
}
if ((!currentProjectKey || currentProjectKey === DEFAULT_PROJECT_KEY) && serverSnapshotKey) {
    currentProjectKey = serverSnapshotKey;
}
if (!currentProjectKey || !projectStateMap[currentProjectKey]) {
    if (lastProjectKeyFromStorage && projectStateMap[lastProjectKeyFromStorage]) {
        currentProjectKey = lastProjectKeyFromStorage;
    } else if (legacyProjectKeyHint && projectStateMap[legacyProjectKeyHint]) {
        currentProjectKey = legacyProjectKeyHint;
    }
}
if (!currentProjectKey) currentProjectKey = DEFAULT_PROJECT_KEY;
const serverResultPath = (initialPayload && typeof initialPayload.result_path === 'string')
    ? initialPayload.result_path.trim()
    : '';
if (serverResultPath) {
    try {
        const keyProbe = {
            project_key_hint: (initialPayload && initialPayload.project_key_hint) || serverResultPath,
            result_path: serverResultPath,
        };
        const serverKeyCandidate = deriveProjectKey(keyProbe, serverResultPath) || serverResultPath;
        if (serverKeyCandidate && projectStateMap[serverKeyCandidate]) {
            currentProjectKey = serverKeyCandidate;
        }
    } catch (err) {
        console.warn('Failed to align project key with server result path', err);
    }
}

let persistedState = null;
if (USE_LOCAL_EDITOR_STATE) {
    const keyedStateForCurrentProject = projectStateMap[currentProjectKey];
    if (keyedStateForCurrentProject) {
        persistedState = keyedStateForCurrentProject;
    }
}
const CORE_DEFAULT_VENV_BIN = (initialPayload && typeof initialPayload.core === 'object' && typeof initialPayload.core.venv_bin === 'string' && initialPayload.core.venv_bin.trim())
    ? initialPayload.core.venv_bin.trim()
    : '/opt/core/venv/bin';
const PARTICIPANT_STATUS_EMPTY_TEXT = 'No Participant UI URL saved yet. Apply one to expose the Participant UI tab during HITL runs.';
const PARTICIPANT_STATUS_SAVED_TEXT = 'Participant UI link saved. The navigation tab is enabled for this scenario.';
// If server provides a fresh result_path (e.g., after Save XML), reflect it in localStorage early
try {
    if (USE_LOCAL_EDITOR_STATE && serverResultPath) {
        const existingSnapshot = projectStateMap[currentProjectKey] || legacyEditorState || {};
        const persisted = { ...existingSnapshot };
        const existingCoreSnapshot = (existingSnapshot && existingSnapshot.core)
            ? normalizeCoreState(existingSnapshot.core, true)
            : null;
        persisted.result_path = serverResultPath;
        if (initialPayload.core) {
            const serverCoreSnapshot = normalizeCoreState(initialPayload.core, true);
            persisted.core = existingCoreSnapshot
                ? mergeCoreSnapshots(serverCoreSnapshot, existingCoreSnapshot)
                : serverCoreSnapshot;
        } else if (existingCoreSnapshot) {
            persisted.core = existingCoreSnapshot;
        }
        projectStateMap[currentProjectKey] = persisted;
        legacyEditorState = persisted;
        writeJsonToLocalStorage(LEGACY_EDITOR_STATE_STORAGE_KEY, persisted);
        writeJsonToLocalStorage(PROJECT_STATE_STORAGE_KEY, projectStateMap);
    }
} catch(e){}

function defaultScenario(name) {
    return {
        name: name || `Scenario ${document.querySelectorAll('.scenario-card').length + 1}`,
        base: { filepath: '' },
        hitl: { enabled: false, interfaces: [] },
        density_count: 10,
        sections: {
            // Default: one Count-based row; weight-based nodes/density start at 0
            'Node Information': { total_nodes: 0, density: 0, items: [ { selected: 'Random', factor: 1.0, v_metric: 'Count', v_count: 5 } ] },
            'Routing': { density: 0.5, items: [] },
            'Services': { density: 0.5, items: [] },
            'Traffic': { density: 0.5, items: [] },
            'Events': { density: 0.5, items: [] },
            'Vulnerabilities': { density: 0.5, items: [] },
            'Segmentation': { density: 0.5, items: [] }
        },
        notes: ''
    };
}

const HITL_ATTACHMENT_CHOICES = [
    { value: 'existing_router', label: 'Existing Router' },
    { value: 'existing_switch', label: 'Existing Switch' },
    { value: 'new_router', label: 'New Router' },
];

const HITL_ATTACHMENT_ALLOWED = new Set(HITL_ATTACHMENT_CHOICES.map(opt => opt.value));
const DEFAULT_HITL_ATTACHMENT = 'existing_router';

const NULLISH_TEXT_SENTINELS = new Set(['none', 'null', 'undefined', 'no error', 'ok', 'success']);

function normalizeOptionalMessage(value) {
    if (typeof value !== 'string') return null;
    const trimmed = value.trim();
    if (!trimmed) return null;
    const lowered = trimmed.toLowerCase();
    if (NULLISH_TEXT_SENTINELS.has(lowered)) return null;
    return trimmed;
}

function normalizeHostInterfaceName(value) {
    if (value === null || value === undefined) return '';
    let normalized = String(value).trim();
    if (!normalized) return '';
    normalized = normalized.replace(/^hitl-/i, '').trim() || normalized;
    return normalized;
}

function normalizeHitlAttachment(value) {
    if (value === null || value === undefined) return DEFAULT_HITL_ATTACHMENT;
    let normalized = String(value).trim().toLowerCase();
    if (!normalized) return DEFAULT_HITL_ATTACHMENT;
    normalized = normalized.replace(/[\s-]+/g, '_');
    return HITL_ATTACHMENT_ALLOWED.has(normalized) ? normalized : DEFAULT_HITL_ATTACHMENT;
}

function prettyHitlAttachment(value) {
    const normalized = normalizeHitlAttachment(value);
    const match = HITL_ATTACHMENT_CHOICES.find(opt => opt.value === normalized);
    return match ? match.label : 'Existing Router';
}

function normalizeParticipantProxmoxHref(value) {
    if (value === undefined || value === null) return '';
    let trimmed = String(value).trim();
    if (!trimmed) return '';
    if (!/^https?:\/\//i.test(trimmed)) {
        trimmed = `https://${trimmed}`;
    }
    try {
        const parsed = new URL(trimmed);
        if (parsed.protocol !== 'http:' && parsed.protocol !== 'https:') {
            return '';
        }
        return parsed.toString();
    } catch (err) {
        return '';
    }
}


function hitlAttachmentAttemptOrder(preference) {
    const normalized = normalizeHitlAttachment(preference);
    switch (normalized) {
        case 'existing_router':
            return ['existing_router', 'existing_switch', 'new_router'];
        case 'existing_switch':
            return ['existing_switch', 'existing_router', 'new_router'];
        case 'new_router':
        default:
            return ['new_router', 'existing_router', 'existing_switch'];
    }
}

function ensureHitlStateForScenario(scen) {
    if (!scen || typeof scen !== 'object') return { enabled: false, interfaces: [] };
    if (!scen.hitl || typeof scen.hitl !== 'object') {
        scen.hitl = { enabled: false, interfaces: [] };
    }
    const normalizeAddrList = (value) => {
        if (Array.isArray(value)) {
            return value.map(v => (v ?? '').toString().trim()).filter(Boolean);
        }
        if (typeof value === 'string') {
            return value.split(',').map(v => v.trim()).filter(Boolean);
        }
        return [];
    };
    if (!Array.isArray(scen.hitl.interfaces)) {
        const raw = scen.hitl.interfaces;
        if (typeof raw === 'string' && raw.trim()) {
            scen.hitl.interfaces = [{ name: raw.trim() }];
        } else if (raw && typeof raw === 'object' && raw.name) {
            scen.hitl.interfaces = [{ ...raw }];
        } else {
            scen.hitl.interfaces = [];
        }
    }
    scen.hitl.interfaces = scen.hitl.interfaces.map((entry, idx) => {
        if (!entry) return null;
        if (typeof entry === 'string') {
            const name = normalizeHostInterfaceName(entry);
            return name ? { name } : null;
        }
        if (typeof entry !== 'object') return null;
        const clone = { ...entry };
        const derivedName = clone.name ?? clone.interface ?? clone.iface ?? clone.id ?? `iface-${idx + 1}`;
        clone.name = normalizeHostInterfaceName(derivedName);
        if (!clone.name) {
            return null;
        }
        if (clone.alias && !clone.description) clone.description = clone.alias;
        if (clone.display && !clone.description) clone.description = clone.display;
        if (clone.summary && !clone.description) clone.description = clone.summary;
        if (clone.ipv4 !== undefined) clone.ipv4 = normalizeAddrList(clone.ipv4);
        if (clone.ipv6 !== undefined) clone.ipv6 = normalizeAddrList(clone.ipv6);
        if (clone.proxmox_target && typeof clone.proxmox_target === 'object') {
            const target = clone.proxmox_target;
            const node = (target.node ?? '').toString().trim();
            const vmid = target.vmid;
            const ifaceId = (target.interface_id ?? target.interface ?? target.id ?? '').toString().trim();
            const macaddr = (target.macaddr ?? target.mac ?? '').toString();
            const bridge = (target.bridge ?? '').toString();
            const model = (target.model ?? '').toString();
            const vmName = (target.vm_name ?? target.name ?? '').toString();
            const label = (target.label ?? '').toString();
            clone.proxmox_target = {
                node,
                vmid,
                interface_id: ifaceId,
                macaddr,
                bridge,
                model,
                vm_name: vmName,
                label,
            };
        } else {
            delete clone.proxmox_target;
        }
        if (clone.external_vm && typeof clone.external_vm === 'object') {
            const ext = clone.external_vm;
            const vmKey = (ext.vm_key ?? ext.key ?? '').toString();
            const vmNode = (ext.vm_node ?? ext.node ?? '').toString();
            const vmName = (ext.vm_name ?? ext.name ?? '').toString();
            const status = (ext.status ?? '').toString();
            let vmid = ext.vmid ?? ext.id ?? '';
            if (typeof vmid === 'string') vmid = vmid.trim();
            const ifaceIdRaw = (ext.interface_id ?? ext.iface ?? '').toString().trim();
            const ifaceBridgeRaw = (ext.interface_bridge ?? ext.bridge ?? '').toString().trim();
            const ifaceMacRaw = (ext.interface_mac ?? ext.macaddr ?? ext.mac ?? '').toString().trim();
            const ifaceModelRaw = (ext.interface_model ?? ext.model ?? '').toString().trim();
            if (vmKey) {
                const normalized = {
                    vm_key: vmKey,
                    vm_node: vmNode,
                    vm_name: vmName,
                    vmid,
                    status,
                };
                if (ifaceIdRaw) normalized.interface_id = ifaceIdRaw;
                if (ifaceBridgeRaw) normalized.interface_bridge = ifaceBridgeRaw;
                if (ifaceMacRaw) normalized.interface_mac = ifaceMacRaw;
                if (ifaceModelRaw) normalized.interface_model = ifaceModelRaw;
                clone.external_vm = normalized;
            } else {
                delete clone.external_vm;
            }
        } else {
            delete clone.external_vm;
        }
        clone.attachment = normalizeHitlAttachment(clone.attachment);
        return clone;
    }).filter(Boolean);
    const participantUrlRaw = (scen.hitl.participant_proxmox_url ?? '').toString();
    scen.hitl.participant_proxmox_url = participantUrlRaw.trim();
    scen.hitl.enabled = !!scen.hitl.enabled;
    if (!scen.hitl.core || typeof scen.hitl.core !== 'object') {
        scen.hitl.core = {
            vm_key: '',
            vm_name: '',
            vm_node: '',
            grpc_host: 'localhost',
            grpc_port: 50051,
            ssh_host: '',
            ssh_port: 22,
            ssh_username: '',
            ssh_password: '',
            core_secret_id: null,
            validated: false,
            last_validated_at: null,
            stored_summary: null,
            last_tested_at: null,
            last_tested_status: null,
            last_tested_message: null,
            last_tested_host: null,
            last_tested_port: null,
            internal_bridge: '',
            internal_bridge_owner: '',
            last_interfaces_refresh: null,
            last_interfaces_attempt: null,
            interfaces_refresh_inflight: false,
            last_interfaces_error: null,
            remember_credentials: true,
            auto_start_daemon: false,
        };
    } else {
        const core = scen.hitl.core;
        core.vm_key = (core.vm_key ?? '').toString();
        core.vm_name = (core.vm_name ?? '').toString();
        core.vm_node = (core.vm_node ?? '').toString();
        core.grpc_host = (core.grpc_host ?? '').toString().trim();
        if (!core.grpc_host) core.grpc_host = 'localhost';
        core.ssh_host = (core.ssh_host ?? '').toString();
        const sshPort = parseInt(core.ssh_port, 10);
        core.ssh_port = Number.isFinite(sshPort) && sshPort > 0 ? sshPort : 22;
        const grpcPort = parseInt(core.grpc_port, 10);
        core.grpc_port = Number.isFinite(grpcPort) && grpcPort > 0 ? grpcPort : 50051;
        core.ssh_username = (core.ssh_username ?? '').toString();
        core.ssh_password = (core.ssh_password ?? '').toString();
        core.internal_bridge = (core.internal_bridge ?? '').toString().trim();
        core.internal_bridge_owner = (core.internal_bridge_owner ?? '').toString().trim();
        if (typeof core.last_tested_at !== 'string') core.last_tested_at = null;
        if (typeof core.last_tested_status !== 'string') core.last_tested_status = null;
        if (typeof core.last_tested_message !== 'string') core.last_tested_message = null;
        if (typeof core.last_tested_host !== 'string') core.last_tested_host = null;
        const testedPort = parseInt(core.last_tested_port, 10);
        core.last_tested_port = Number.isFinite(testedPort) && testedPort > 0 ? testedPort : null;
        if (typeof core.core_secret_id === 'string') {
            core.core_secret_id = core.core_secret_id.trim() || null;
        } else if (core.core_secret_id == null) {
            core.core_secret_id = null;
        } else {
            core.core_secret_id = null;
        }
        core.validated = !!(core.validated || core.core_secret_id);
        if (typeof core.last_validated_at !== 'string') core.last_validated_at = null;
        if (!core.stored_summary || typeof core.stored_summary !== 'object') {
            core.stored_summary = null;
        }
        if (typeof core.last_interfaces_refresh !== 'string') core.last_interfaces_refresh = null;
        if (typeof core.last_interfaces_attempt !== 'string') core.last_interfaces_attempt = null;
        core.interfaces_refresh_inflight = core.interfaces_refresh_inflight === true;
        if (typeof core.last_interfaces_error === 'string') {
            core.last_interfaces_error = normalizeOptionalMessage(core.last_interfaces_error);
        } else {
            core.last_interfaces_error = null;
        }
    }
    if (typeof scen.hitl.core.remember_credentials !== 'boolean') {
        scen.hitl.core.remember_credentials = true;
    }
    if (typeof scen.hitl.core.auto_start_daemon !== 'boolean') {
        scen.hitl.core.auto_start_daemon = false;
    }
    const coreVmKeyCurrent = (scen.hitl.core?.vm_key ?? '').toString();
    const coreVmNodeCurrent = (scen.hitl.core?.vm_node ?? '').toString().trim();
    if (coreVmKeyCurrent) {
        scen.hitl.interfaces.forEach(iface => {
            if (iface && iface.external_vm && iface.external_vm.vm_key === coreVmKeyCurrent) {
                delete iface.external_vm;
            }
        });
    }
    if (coreVmNodeCurrent) {
        scen.hitl.interfaces.forEach(iface => {
            const vmNode = iface?.external_vm?.vm_node ? String(iface.external_vm.vm_node).trim() : '';
            if (vmNode && vmNode !== coreVmNodeCurrent) {
                delete iface.external_vm;
            }
        });
    }
    if (!scen.hitl.proxmox || typeof scen.hitl.proxmox !== 'object') {
        scen.hitl.proxmox = {
            url: '',
            port: 8006,
            username: '',
            verify_ssl: true,
            secret_id: null,
            validated: false,
            last_validated_at: null,
            last_message: '',
            inventory: { fetched_at: null, vms: [] },
            inventory_error: null,
            remember_credentials: true,
        };
    } else {
        const prox = scen.hitl.proxmox;
        prox.url = (prox.url ?? '').toString().trim();
        const parsedPort = parseInt(prox.port, 10);
        prox.port = Number.isFinite(parsedPort) && parsedPort > 0 ? parsedPort : 8006;
        prox.username = (prox.username ?? '').toString().trim();
        if ('password' in prox) {
            delete prox.password;
        }
        prox.verify_ssl = prox.verify_ssl === false ? false : true;
        if (typeof prox.secret_id === 'string') {
            const trimmedSecret = prox.secret_id.trim();
            prox.secret_id = trimmedSecret || null;
        } else {
            prox.secret_id = null;
        }
        prox.validated = !!(prox.validated || prox.secret_id);
        prox.last_validated_at = prox.last_validated_at || null;
        prox.last_message = (prox.last_message ?? '').toString();
        prox.inventory_error = prox.inventory_error ? prox.inventory_error.toString() : null;
        if (!prox.inventory || typeof prox.inventory !== 'object') {
            prox.inventory = { fetched_at: null, vms: [] };
        } else {
            const inv = prox.inventory;
            inv.fetched_at = inv.fetched_at || null;
            const vms = Array.isArray(inv.vms) ? inv.vms : [];
            inv.vms = vms.map(vm => {
                if (!vm || typeof vm !== 'object') return null;
                const node = (vm.node ?? vm.host ?? '').toString();
                const vmid = vm.vmid;
                const name = (vm.name ?? '').toString();
                const status = (vm.status ?? '').toString();
                const interfaces = Array.isArray(vm.interfaces) ? vm.interfaces : [];
                const safeIfaces = interfaces.map(iface => {
                    if (!iface || typeof iface !== 'object') return null;
                    const id = (iface.id ?? '').toString();
                    const macaddr = (iface.macaddr ?? iface.mac ?? '').toString();
                    const bridge = (iface.bridge ?? '').toString();
                    const model = (iface.model ?? '').toString();
                    const tag = (iface.tag ?? '').toString();
                    const raw = (iface.raw ?? '').toString();
                    if (!id) return null;
                    return { id, macaddr, bridge, model, tag, raw };
                }).filter(Boolean);
                if (!node || vmid === undefined || safeIfaces.length === 0) {
                    return {
                        node,
                        vmid,
                        name,
                        status,
                        interfaces: safeIfaces,
                    };
                }
                return {
                    node,
                    vmid,
                    name,
                    status,
                    interfaces: safeIfaces,
                };
            }).filter(Boolean);
        }
    }
    if (typeof scen.hitl.proxmox.remember_credentials !== 'boolean') {
        scen.hitl.proxmox.remember_credentials = true;
    }
    applyDefaultProxmoxFields(scen.hitl.proxmox);
    return scen.hitl;
}

function _structuredCloneSafe(value) {
    if (value === null || typeof value !== 'object') return null;
    if (typeof structuredClone === 'function') {
        try { return structuredClone(value); } catch (err) { /* fallback */ }
    }
    try {
        return JSON.parse(JSON.stringify(value));
    } catch (err) {
        return null;
    }
}

function _normalizeScenarioLookupKey(raw) {
    if (raw === undefined || raw === null) return '';
    return String(raw).trim().toLowerCase();
}

function _hitlInterfaceKey(entry, fallbackIndex = null) {
    if (entry && typeof entry === 'object') {
        const nameCandidate = entry.name ?? entry.interface ?? entry.id;
        if (nameCandidate !== undefined && nameCandidate !== null) {
            const normalized = String(nameCandidate).trim().toLowerCase();
            if (normalized) return normalized;
        }
    }
    if (fallbackIndex === null || fallbackIndex === undefined) return '';
    return `idx:${fallbackIndex}`;
}

function mergePersistedHitlState(targetScenario, persistedScenario) {
    if (!targetScenario || !persistedScenario) return;
    const targetHitl = ensureHitlStateForScenario(targetScenario);
    const persistedClone = _structuredCloneSafe(persistedScenario);
    if (!persistedClone) return;
    const sourceHitl = ensureHitlStateForScenario(persistedClone);
    if (sourceHitl.proxmox && typeof sourceHitl.proxmox === 'object') {
        const targetProx = targetHitl.proxmox || {};
        const mergedProx = { ...targetProx, ...sourceHitl.proxmox };
        const targetInv = targetProx.inventory;
        const sourceInv = sourceHitl.proxmox.inventory;
        if (targetInv && Array.isArray(targetInv.vms) && targetInv.vms.length) {
            mergedProx.inventory = targetInv;
        } else if (sourceInv) {
            mergedProx.inventory = sourceInv;
        }
        targetHitl.proxmox = mergedProx;
    }
    if (sourceHitl.core && typeof sourceHitl.core === 'object') {
        const targetCore = targetHitl.core || {};
        const volatileFields = {
            interfaces_refresh_inflight: targetCore.interfaces_refresh_inflight,
            last_interfaces_error: targetCore.last_interfaces_error,
            last_interfaces_attempt: targetCore.last_interfaces_attempt,
            last_interfaces_refresh: targetCore.last_interfaces_refresh,
        };
        const mergedCore = { ...targetCore, ...sourceHitl.core };
        Object.entries(volatileFields).forEach(([key, value]) => {
            if (value !== undefined) {
                mergedCore[key] = value;
            }
        });
        targetHitl.core = mergedCore;
    }
    if (Array.isArray(sourceHitl.interfaces) && sourceHitl.interfaces.length) {
        if (!Array.isArray(targetHitl.interfaces)) {
            targetHitl.interfaces = [];
        }
        const targetInterfaces = targetHitl.interfaces;
        const targetLookup = new Map();
        targetInterfaces.forEach((entry, idx) => {
            const key = _hitlInterfaceKey(entry, idx);
            if (key) targetLookup.set(key, entry);
        });
        sourceHitl.interfaces.forEach((entry, idx) => {
            if (!entry || typeof entry !== 'object') return;
            const cloneEntry = _structuredCloneSafe(entry) || { ...entry };
            const key = _hitlInterfaceKey(cloneEntry, idx);
            let targetEntry = key ? targetLookup.get(key) : null;
            if (!targetEntry) {
                const insertIdx = targetInterfaces.length;
                targetInterfaces.push(cloneEntry);
                const insertKey = key || _hitlInterfaceKey(cloneEntry, insertIdx) || `idx:${insertIdx}`;
                targetLookup.set(insertKey, cloneEntry);
                return;
            }
            if (cloneEntry.attachment !== undefined) {
                targetEntry.attachment = cloneEntry.attachment;
            }
            if (Array.isArray(cloneEntry.ipv4) && (!Array.isArray(targetEntry.ipv4) || !targetEntry.ipv4.length)) {
                targetEntry.ipv4 = cloneEntry.ipv4.slice();
            }
            if (Array.isArray(cloneEntry.ipv6) && (!Array.isArray(targetEntry.ipv6) || !targetEntry.ipv6.length)) {
                targetEntry.ipv6 = cloneEntry.ipv6.slice();
            }
            if (cloneEntry.mac && !targetEntry.mac) {
                targetEntry.mac = cloneEntry.mac;
            }
            if (cloneEntry.proxmox_target && !targetEntry.proxmox_target) {
                targetEntry.proxmox_target = cloneEntry.proxmox_target;
            }
            if (cloneEntry.external_vm && typeof cloneEntry.external_vm === 'object') {
                const externalClone = _structuredCloneSafe(cloneEntry.external_vm) || { ...cloneEntry.external_vm };
                targetEntry.external_vm = externalClone;
            }
        });
    }
    if (typeof sourceHitl.participant_proxmox_url === 'string') {
        targetHitl.participant_proxmox_url = sourceHitl.participant_proxmox_url;
    }
    if (sourceHitl.enabled && !targetHitl.enabled) {
        targetHitl.enabled = true;
    }
}

function mergePersistedHitlStateIntoScenarios(currentScenarios, persistedScenarios) {
    if (!Array.isArray(currentScenarios) || !Array.isArray(persistedScenarios)) return;
    const lookup = {
        bySid: new Map(),
        byBase: new Map(),
        byName: new Map(),
        byIndex: new Map(),
    };
    persistedScenarios.forEach((scen, idx) => {
        if (!scen || typeof scen !== 'object') return;
        lookup.byIndex.set(idx, scen);
        if (scen._sid) lookup.bySid.set(String(scen._sid), scen);
        if (scen.base && typeof scen.base === 'object' && scen.base.filepath) {
            const baseKey = _normalizeScenarioLookupKey(scen.base.filepath);
            if (baseKey) lookup.byBase.set(baseKey, scen);
        }
        const nameKey = _normalizeScenarioLookupKey(scen.name);
        if (nameKey && !lookup.byName.has(nameKey)) {
            lookup.byName.set(nameKey, scen);
        }
    });

    currentScenarios.forEach((scen, idx) => {
        if (!scen || typeof scen !== 'object') return;
        const sid = scen._sid ? String(scen._sid) : '';
        const baseKey = scen.base && typeof scen.base === 'object' && scen.base.filepath
            ? _normalizeScenarioLookupKey(scen.base.filepath)
            : '';
        const nameKey = _normalizeScenarioLookupKey(scen.name);
        let persistedMatch = null;
        if (sid && lookup.bySid.has(sid)) {
            persistedMatch = lookup.bySid.get(sid);
        } else if (baseKey && lookup.byBase.has(baseKey)) {
            persistedMatch = lookup.byBase.get(baseKey);
        } else if (nameKey && lookup.byName.has(nameKey)) {
            persistedMatch = lookup.byName.get(nameKey);
        } else if (lookup.byIndex.has(idx)) {
            persistedMatch = lookup.byIndex.get(idx);
        }
        if (!persistedMatch) return;
        if (!scen._sid && persistedMatch._sid) {
            scen._sid = persistedMatch._sid;
        }
        mergePersistedHitlState(scen, persistedMatch);
    });
}

function shouldRememberProxmox(hitlState) {
    if (!hitlState || !hitlState.proxmox) return true;
    return hitlState.proxmox.remember_credentials !== false;
}

const PROXMOX_DEFAULTS_STORAGE_KEY = 'coretg_proxmox_defaults';

function normalizeProxmoxDefaults(raw) {
    if (!raw || typeof raw !== 'object') return {};
    const result = {};
    if (typeof raw.url === 'string' && raw.url.trim()) {
        result.url = raw.url.trim();
    }
    const portVal = parseInt(raw.port, 10);
    if (Number.isFinite(portVal) && portVal >= 1 && portVal <= 65535) {
        result.port = portVal;
    }
    if (typeof raw.username === 'string' && raw.username.trim()) {
        result.username = raw.username.trim();
    }
    if (typeof raw.verify_ssl === 'boolean') {
        result.verify_ssl = raw.verify_ssl;
    }
    return result;
}

function getSavedProxmoxDefaults() {
    try {
        const raw = JSON.parse(localStorage.getItem(PROXMOX_DEFAULTS_STORAGE_KEY) || 'null');
        return normalizeProxmoxDefaults(raw);
    } catch (err) {
        return {};
    }
}

function persistSavedProxmoxDefaults(partial) {
    if (!partial || typeof partial !== 'object') return;
    const current = getSavedProxmoxDefaults();
    const merged = { ...current };
    if (typeof partial.url === 'string' && partial.url.trim()) {
        merged.url = partial.url.trim();
    }
    if (partial.port !== undefined) {
        const portVal = parseInt(partial.port, 10);
        if (Number.isFinite(portVal) && portVal >= 1 && portVal <= 65535) {
            merged.port = portVal;
        }
    }
    if (typeof partial.username === 'string' && partial.username.trim()) {
        merged.username = partial.username.trim();
    }
    if (typeof partial.verify_ssl === 'boolean') {
        merged.verify_ssl = partial.verify_ssl;
    }
    const normalized = normalizeProxmoxDefaults(merged);
    try {
        localStorage.setItem(PROXMOX_DEFAULTS_STORAGE_KEY, JSON.stringify(normalized));
    } catch (err) {
        console.warn('Failed to persist Proxmox defaults', err);
    }
}

function applyDefaultProxmoxFields(target) {
    if (!target || typeof target !== 'object') return;
    const defaults = getSavedProxmoxDefaults();
    if (!defaults || Object.keys(defaults).length === 0) return;
    if (!target.url && defaults.url) {
        target.url = defaults.url;
    }
    if ((!target.port || target.port === 8006) && defaults.port) {
        target.port = defaults.port;
    }
    if (!target.username && defaults.username) {
        target.username = defaults.username;
    }
    if (typeof target.verify_ssl !== 'boolean' && typeof defaults.verify_ssl === 'boolean') {
        target.verify_ssl = defaults.verify_ssl;
    }
}

function shouldRememberCore(hitlState) {
    if (!hitlState || !hitlState.core) return true;
    return hitlState.core.remember_credentials !== false;
}

const proxmoxSecretCache = new Map();

async function fetchStoredProxmoxCredentials(secretId) {
    if (!secretId) return null;
    if (proxmoxSecretCache.has(secretId)) {
        return proxmoxSecretCache.get(secretId);
    }
    const resp = await fetch('/api/proxmox/credentials/get', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        credentials: 'same-origin',
        body: JSON.stringify({ secret_id: secretId }),
    });
    let data = null;
    try {
        data = await resp.json();
    } catch (err) {
        data = null;
    }
    if (!resp.ok || !data || data.success === false) {
        const message = (data && data.error) ? data.error : `HTTP ${resp.status}`;
        throw new Error(message);
    }
    const creds = data.credentials || null;
    proxmoxSecretCache.set(secretId, creds);
    return creds;
}

const coreSecretCache = new Map();

async function fetchStoredCoreCredentials(secretId) {
    if (!secretId) return null;
    if (coreSecretCache.has(secretId)) {
        return coreSecretCache.get(secretId);
    }
    const resp = await fetch('/api/core/credentials/get', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        credentials: 'same-origin',
        body: JSON.stringify({ core_secret_id: secretId }),
    });
    let data = null;
    try {
        data = await resp.json();
    } catch (err) {
        data = null;
    }
    if (!resp.ok || !data || data.success === false) {
        const message = (data && data.error) ? data.error : `HTTP ${resp.status}`;
        throw new Error(message);
    }
    const creds = data.credentials || null;
    coreSecretCache.set(secretId, creds);
    return creds;
}

function describeConfigHitlGate({ proxValidated, coreHasSecret, coreVmKey }) {
    if (!proxValidated) return 'Validate Proxmox credentials (Step 1) to continue.';
    if (!coreVmKey) return 'Select a CORE VM in Step 2 to continue.';
    if (!coreHasSecret) return 'Store CORE credentials (Step 2) to continue.';
    return '';
}

function updateHitlEntryButtons({ hitlAuthReady, proxValidated, coreHasSecret, coreVmKey }) {
    const configBtn = document.getElementById('configHitlBtn');
    if (configBtn) {
        const ready = !!hitlAuthReady;
        configBtn.disabled = !ready;
        const hint = ready
            ? 'Configure HITL interfaces and participant VMs (Steps 3 & 4).'
            : describeConfigHitlGate({ proxValidated, coreHasSecret, coreVmKey }) || 'Complete Steps 1 and 2 first.';
        configBtn.setAttribute('title', hint);
        configBtn.dataset.hitlReady = ready ? '1' : '0';
        configBtn.dataset.hitlHint = hint;
    }
}

function updateProxmoxSummary(sidx) {
    try {
        const scenario = state.scenarios?.[sidx];
        if (!scenario) return;
        const hitl = ensureHitlStateForScenario(scenario);
        const prox = hitl.proxmox || { url: '', port: 8006, username: '' };
        const proxPort = prox.port ?? 8006;
        const proxHasCreds = !!(prox.url && prox.username);
        const proxValidated = !!(prox.validated && prox.secret_id);
        const normalizeHost = (raw) => {
            if (!raw && raw !== 0) return '';
            let text = String(raw).trim().toLowerCase();
            if (text.startsWith('[') && text.endsWith(']')) text = text.slice(1, -1);
            if (text.startsWith('::ffff:') && /^::ffff:\d+\.\d+\.\d+\.\d+$/.test(text)) {
                text = text.replace('::ffff:', '');
            }
            return text;
        };
        const core = hitl.core || {};
        const coreVmKey = (core.vm_key || '').toString();
        const coreHost = (core.grpc_host || '').toString().trim();
        const corePort = Number.isFinite(Number(core.grpc_port)) && Number(core.grpc_port) > 0 ? Number(core.grpc_port) : 50051;
        const coreSshHostRaw = (core.ssh_host || '').toString().trim();
        const coreSshHost = coreSshHostRaw || coreHost;
        const coreSshPort = Number.isFinite(Number(core.ssh_port)) && Number(core.ssh_port) > 0 ? Number(core.ssh_port) : 22;
        const coreUser = (core.ssh_username || '').toString().trim();
        const coreSecretId = typeof core.core_secret_id === 'string' ? core.core_secret_id.trim() : '';
        const coreHasSecret = !!coreSecretId;
        const corePasswordRaw = (core.ssh_password || '').toString();
        const corePasswordAvailable = !!corePasswordRaw || coreHasSecret;
        const vmKeyParts = coreVmKey ? coreVmKey.split('::') : [];
        const vmKeyNodePart = (vmKeyParts[0] || '').trim();
        const vmKeyIdPart = (vmKeyParts[1] || '').trim();
        const cachedVmInterfaceCount = Number.isFinite(Number(core.cached_vm_interface_count))
            ? Number(core.cached_vm_interface_count)
            : null;
        const liveSelectedVm = (() => {
            const inventory = hitl.proxmox?.inventory;
            const vms = inventory && Array.isArray(inventory.vms) ? inventory.vms : [];
            return vms.find(vm => `${vm.node ?? ''}::${vm.vmid ?? ''}` === coreVmKey) || null;
        })();
        const fallbackCoreVm = (!liveSelectedVm && coreVmKey)
            ? {
                name: core.vm_name || '',
                node: core.vm_node || vmKeyNodePart || '',
                status: core.cached_vm_status || '',
                vmid: vmKeyIdPart || '',
                interface_count_hint: cachedVmInterfaceCount,
            }
            : null;
        const resolvedCoreVm = liveSelectedVm
            ? { ...liveSelectedVm, cached: false }
            : (fallbackCoreVm ? { ...fallbackCoreVm, cached: true } : null);
        const resolvedVmInterfaceCount = (() => {
            if (resolvedCoreVm && Array.isArray(resolvedCoreVm.interfaces)) {
                return resolvedCoreVm.interfaces.length;
            }
            if (resolvedCoreVm && Number.isFinite(resolvedCoreVm.interface_count_hint)) {
                return Number(resolvedCoreVm.interface_count_hint);
            }
            if (cachedVmInterfaceCount !== null) {
                return cachedVmInterfaceCount;
            }
            return null;
        })();
        const interfaceCountKnown = resolvedVmInterfaceCount !== null;
        const coreVmHasInterfaces = !coreVmKey || !interfaceCountKnown || resolvedVmInterfaceCount >= 1;
        const coreVmSupportsHitl = !coreVmKey || !interfaceCountKnown || resolvedVmInterfaceCount >= 2;
        const coreInputsComplete = !!(coreVmKey && coreHost && corePort && coreSshHost && coreSshPort && coreUser && corePasswordAvailable);
        const coreTestSuccess = core.last_tested_status === 'success';
        const coreTestMatches = coreTestSuccess
            && !!core.last_tested_host
            && normalizeHost(core.last_tested_host) === normalizeHost(coreHost)
            && Number(core.last_tested_port) === Number(corePort);
        const coreConnectionReady = proxValidated && coreInputsComplete && coreVmHasInterfaces && coreTestMatches;
        const coreReady = coreConnectionReady && coreVmSupportsHitl;
        const coreHitlBlocked = coreConnectionReady && !coreVmSupportsHitl;
        const coreTestable = proxValidated && coreInputsComplete && coreVmHasInterfaces;
    const hitlAuthReady = proxValidated && coreHasSecret && !!coreVmKey;

        const summaryEl = document.querySelector(`[data-proxmox-summary="${sidx}"]`);
        if (summaryEl) {
            const detailParts = [];
            if (proxHasCreds) {
                if (prox.last_message) {
                    detailParts.push(prox.last_message);
                } else if (proxValidated && prox.last_validated_at) {
                    try {
                        const dt = new Date(prox.last_validated_at);
                        if (!Number.isNaN(dt.getTime())) {
                            detailParts.push(`Last checked ${dt.toLocaleString()}`);
                        }
                    } catch (e) { /* ignore */ }
                }
                detailParts.push(prox.verify_ssl === false ? 'SSL verify off' : 'SSL verify on');
            }
            const proxSummary = proxHasCreds
                ? (proxValidated
                    ? `Proxmox validated for ${prox.username} @ ${prox.url}:${proxPort}`
                    : `Proxmox pending validation for ${prox.username} @ ${prox.url}:${proxPort}`)
                : 'Proxmox resource not assigned.';
            const detailsText = detailParts.length ? ` • ${detailParts.join(' • ')}` : '';
            summaryEl.textContent = `${proxSummary}${detailsText}`;
            summaryEl.classList.remove('text-success', 'text-warning', 'text-muted', 'text-danger');
            if (proxValidated) summaryEl.classList.add('text-success');
            else if (proxHasCreds) summaryEl.classList.add('text-warning');
            else summaryEl.classList.add('text-muted');
        }

        const assignBtn = document.querySelector(`[data-proxmox-assign][data-scen-idx="${sidx}"]`);
        if (assignBtn) {
            assignBtn.textContent = prox.secret_id ? 'Update Proxmox Resource' : 'Assign Proxmox Resource';
        }
        const proxClearBtn = document.querySelector(`[data-proxmox-clear][data-scen-idx="${sidx}"]`);
        if (proxClearBtn) {
            const hasAny = !!(prox.secret_id || proxHasCreds);
            proxClearBtn.disabled = !hasAny;
        }
        const inventoryStatusEl = document.querySelector(`[data-proxmox-inventory-status="${sidx}"]`);
        if (inventoryStatusEl) {
            const loading = proxInventoryFetchInFlight.has(sidx);
            let statusText = '';
            if (!proxHasCreds) {
                statusText = 'Assign credentials to load VM inventory.';
            } else if (!proxValidated) {
                statusText = 'Validate credentials to load VM inventory.';
            } else if (loading) {
                statusText = 'Fetching Proxmox VM inventory…';
            } else {
                const inv = prox.inventory && typeof prox.inventory === 'object' ? prox.inventory : { vms: [] };
                const vms = Array.isArray(inv.vms) ? inv.vms : [];
                if (vms.length) {
                    const fetchedAt = inv.fetched_at ? (() => {
                        try { return new Date(inv.fetched_at).toLocaleString(); } catch (err) { return null; }
                    })() : null;
                    statusText = `Loaded ${vms.length} VM${vms.length === 1 ? '' : 's'}${fetchedAt ? ` • Last fetched ${fetchedAt}` : ''}`;
                } else if (prox.inventory_error) {
                    statusText = `Inventory error: ${prox.inventory_error}`;
                } else {
                    statusText = 'No VMs reported. Refresh to retry.';
                }
            }
            inventoryStatusEl.textContent = statusText;
            inventoryStatusEl.classList.toggle('text-danger', !!prox.inventory_error);
        }
        const refreshBtn = document.querySelector(`[data-proxmox-refresh][data-scen-idx="${sidx}"]`);
        if (refreshBtn) {
            const loading = proxInventoryFetchInFlight.has(sidx);
            const canRefresh = proxValidated && !loading;
            refreshBtn.disabled = !canRefresh;
            refreshBtn.textContent = loading ? 'Refreshing VMs' : 'Refresh VM List';
        }
        const refreshBadge = document.querySelector(`[data-proxmox-refresh-badge="${sidx}"]`);
        if (refreshBadge) {
            const loading = proxInventoryFetchInFlight.has(sidx);
            refreshBadge.style.display = loading ? '' : 'none';
            refreshBadge.textContent = 'Refreshing vm list';
        }
        const coreStatusEl = document.querySelector(`[data-hitl-core-status="${sidx}"]`);
        if (coreStatusEl) {
            let statusText = '';
            let className = 'text-muted';
            if (!proxValidated) {
                statusText = 'Validate Proxmox credentials to choose a CORE VM.';
            } else if (!coreVmKey) {
                statusText = 'Select a CORE VM to configure connection details.';
            } else if (!coreVmHasInterfaces) {
                const count = resolvedVmInterfaceCount || 0;
                const plural = count === 1 ? '' : 's';
                statusText = `Selected CORE VM exposes ${count} network interface${plural}. Add at least one interface to enable CORE connectivity.`;
                className = 'text-danger';
            } else if (!coreInputsComplete) {
                statusText = 'Enter gRPC and SSH connection details, including credentials.';
                className = 'text-warning';
            } else if (!coreVmSupportsHitl) {
                if (coreHitlBlocked) {
                    statusText = 'CORE connection verified. Add a second interface before enabling HITL mappings in Step 3.';
                } else {
                    statusText = 'Selected CORE VM exposes only one interface. Add a second interface before enabling HITL mappings in Step 3.';
                }
                className = 'text-warning';
            } else if (coreReady) {
                const testedAt = core.last_tested_at ? (() => {
                    try { return new Date(core.last_tested_at).toLocaleString(); } catch (err) { return null; }
                })() : null;
                const storedAt = core.last_validated_at ? (() => {
                    try { return new Date(core.last_validated_at).toLocaleString(); } catch (err) { return null; }
                })() : null;
                const storedNote = storedAt ? ` • Credentials stored ${storedAt}` : '';
                statusText = `CORE connection verified${testedAt ? ` • Last tested ${testedAt}` : ''}${storedNote}`;
                className = 'text-success';
            } else if (coreHasSecret && coreTestSuccess) {
                statusText = 'Stored CORE credentials available. Re-test if connection details changed.';
                className = 'text-warning';
            } else if (core.last_tested_status === 'failure') {
                statusText = core.last_tested_message ? `Last test failed: ${core.last_tested_message}` : 'CORE connection test failed.';
                className = 'text-danger';
            } else if (core.last_tested_status === 'success') {
                statusText = 'CORE connection test succeeded for a different endpoint. Update details or re-test.';
                className = 'text-warning';
            } else {
                statusText = 'Test the CORE connection to continue.';
                className = 'text-warning';
            }
            coreStatusEl.textContent = statusText;
            coreStatusEl.classList.remove('text-success', 'text-warning', 'text-muted', 'text-danger');
            coreStatusEl.classList.add(className);
        }
        const testBtn = document.querySelector(`[data-hitl-core-test][data-scen-idx="${sidx}"]`);
        if (testBtn) {
            testBtn.disabled = !coreTestable;
        }
        const coreClearBtn = document.querySelector(`[data-hitl-core-clear][data-scen-idx="${sidx}"]`);
        if (coreClearBtn) {
            coreClearBtn.disabled = !(coreVmKey || coreHost || coreUser || corePasswordRaw || coreSshHostRaw || coreHasSecret);
        }
        const summaryDetailEl = document.querySelector(`[data-hitl-core-summary="${sidx}"]`);
        if (summaryDetailEl) {
            const selectedVm = resolvedCoreVm;
            const sanitize = (value) => {
                return String(value ?? '').replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&#39;');
            };
            if (!coreVmKey || !selectedVm) {
                summaryDetailEl.innerHTML = '';
            } else {
                const name = sanitize(selectedVm.name ? String(selectedVm.name) : `VM ${selectedVm.vmid}`);
                const node = sanitize(selectedVm.node ? String(selectedVm.node) : '—');
                const status = selectedVm.status ? sanitize(String(selectedVm.status)) : null;
                const vmid = selectedVm.vmid !== undefined && selectedVm.vmid !== null ? sanitize(String(selectedVm.vmid)) : '—';
                const ifaceCount = Array.isArray(selectedVm.interfaces) ? selectedVm.interfaces.length : 0;
                const ifaceInfo = ifaceCount ? `${ifaceCount} interface${ifaceCount === 1 ? '' : 's'}` : 'No interfaces reported';
                const ifaceLabel = sanitize(ifaceInfo);
                summaryDetailEl.innerHTML = `
                    <div class="border rounded p-3 bg-light small">
                        <div class="d-flex justify-content-between align-items-center mb-2">
                            <span class="fw-semibold">${name}</span>
                            ${status ? `<span class="badge text-bg-secondary text-uppercase">${status}</span>` : ''}
                        </div>
                        <dl class="row mb-0">
                            <dt class="col-5 text-muted">Node</dt><dd class="col-7">${node}</dd>
                            <dt class="col-5 text-muted">VM ID</dt><dd class="col-7">${vmid}</dd>
                            <dt class="col-5 text-muted">Interfaces</dt><dd class="col-7">${ifaceLabel}</dd>
                        </dl>
                    </div>`;
            }
        }
        const step3Enabled = hitl.enabled && hitlAuthReady;
        const gateNotice = document.querySelector(`[data-hitl-interface-gate="${sidx}"]`);
        if (gateNotice) {
            const shouldHide = step3Enabled && coreReady;
            gateNotice.classList.toggle('d-none', shouldHide);
            gateNotice.classList.remove('alert-info', 'alert-warning', 'alert-danger');
            let gateText = 'Complete steps 1 and 2 to map this interface.';
            if (!hitlAuthReady) {
                gateNotice.classList.add('alert-warning');
                if (!proxValidated) gateText = 'Validate Proxmox credentials (Step 1) to unlock HITL interface mappings.';
                else if (!coreHasSecret) gateText = 'Store CORE credentials (Step 2) to unlock HITL interface mappings.';
                else if (!coreVmKey) gateText = 'Select a CORE VM in Step 2 to unlock HITL interface mappings.';
                else gateText = 'Authenticate Steps 1 and 2 to manage HITL interface mappings.';
            } else if (!step3Enabled) {
                gateNotice.classList.add('alert-info');
                gateText = 'Enable Hardware in the Loop to manage HITL interface mappings.';
            } else if (!coreVmKey) {
                gateNotice.classList.add('alert-info');
            } else if (!coreVmHasInterfaces) {
                gateNotice.classList.add('alert-danger');
                gateText = 'Selected CORE VM must expose at least one interface before mapping HITL interfaces.';
            } else if (!coreVmSupportsHitl) {
                gateNotice.classList.add('alert-warning');
                gateText = 'Selected CORE VM exposes only one interface. HITL cannot be used until a second interface is added.';
            } else {
                gateNotice.classList.add('alert-info');
            }
            gateNotice.textContent = gateText;
        }
        const availableSelect = document.querySelector(`[data-hitl-available][data-scen-idx="${sidx}"]`);
        if (availableSelect) {
            availableSelect.disabled = !(coreReady && step3Enabled);
        }
        const hostInterfaces = Array.isArray(state.host_interfaces) ? state.host_interfaces : [];
        const selectedNames = new Set((Array.isArray(hitl.interfaces) ? hitl.interfaces : []).map(entry => (entry && entry.name) ? String(entry.name) : '').filter(Boolean));
        const selectableInterfaces = hostInterfaces.filter(entry => {
            if (!entry || !entry.name || selectedNames.has(entry.name)) return false;
            const bridge = (entry.bridge || (entry.proxmox && entry.proxmox.bridge) || (entry.proxmox && entry.proxmox.raw && entry.proxmox.raw.bridge) || '').toString().trim().toLowerCase();
            return bridge !== 'vmbr0';
        });
        const availableCount = selectableInterfaces.length;
        document.querySelectorAll(`[data-hitl-add][data-scen-idx="${sidx}"]`).forEach(btn => {
            btn.disabled = !(coreReady && step3Enabled) || availableCount === 0;
        });
        document.querySelectorAll(`[data-hitl-attach][data-scen-idx="${sidx}"]`).forEach(selectEl => {
            selectEl.disabled = !(coreReady && step3Enabled);
        });
    } catch (e) {
        console.warn('updateProxmoxSummary failed', e);
    }
}

async function fetchProxmoxInventory(sidx, options = {}) {
    const force = !!options.force;
    if (Number.isNaN(sidx) || sidx === null || sidx === undefined) return null;
    const scenario = state.scenarios?.[sidx];
    if (!scenario) return null;
    const hitlState = ensureHitlStateForScenario(scenario);
    const prox = hitlState.proxmox || {};
    const hasSecret = !!prox.secret_id;
    const isValidated = !!(prox.validated && prox.secret_id);
    if (!hasSecret || !isValidated) {
        return null;
    }
    const existingInv = prox.inventory && Array.isArray(prox.inventory.vms) ? prox.inventory.vms : [];
    if (existingInv.length && prox.inventory?.fetched_at && !force) {
        proxInventoryFetchInFlight.delete(sidx);
        if (proxInventoryFetchInFlight.size === 0) {
            toggleEditorBusy(false);
        }
        toggleExternalIfxModalBusy(proxInventoryFetchInFlight.size > 0);
        return prox.inventory;
    }
    if (proxInventoryFetchInFlight.has(sidx)) {
        return null;
    }
    proxInventoryFetchInFlight.add(sidx);
    toggleEditorBusy(true);
    toggleExternalIfxModalBusy(true);
    updateProxmoxSummary(sidx);
    let shouldRerender = false;
    try {
        logInfo(`Fetching Proxmox VM inventory for scenario ${sidx}`);
        const resp = await fetch('/api/proxmox/vms', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            credentials: 'same-origin',
            body: JSON.stringify({ secret_id: prox.secret_id }),
        });
        let data = null;
        try { data = await resp.json(); } catch (err) { data = null; }
        if (!resp.ok || !data || data.success === false) {
            const message = (data && data.error) ? data.error : `Failed to load VM inventory (HTTP ${resp.status})`;
            throw new Error(message);
        }
        const inventory = data.inventory || {};
        const cleanedInventory = {
            fetched_at: inventory.fetched_at || new Date().toISOString(),
            vms: Array.isArray(inventory.vms) ? inventory.vms : [],
        };
        hitlState.proxmox.inventory = cleanedInventory;
        hitlState.proxmox.inventory_error = null;
        persistEditorState();
        const hidden = document.getElementById('scenarios_json');
        if (hidden) hidden.value = JSON.stringify({ scenarios: state.scenarios, active_index: activeIdx });
        const vmCount = cleanedInventory.vms.length;
        try { showToast(`Loaded ${vmCount} Proxmox VM${vmCount === 1 ? '' : 's'}`, { autohide: true, delay: 2500 }); } catch (e) {}
        shouldRerender = true;
        return cleanedInventory;
    } catch (err) {
        const message = err instanceof Error ? err.message : 'Failed to load Proxmox VM inventory';
        hitlState.proxmox.inventory_error = message;
        hitlState.proxmox.inventory = { fetched_at: null, vms: [] };
        persistEditorState();
        const hidden = document.getElementById('scenarios_json');
        if (hidden) hidden.value = JSON.stringify({ scenarios: state.scenarios, active_index: activeIdx });
        logError(message);
        try { showToast(message, { autohide: false }); } catch (e) {}
        shouldRerender = true;
        return null;
    } finally {
        proxInventoryFetchInFlight.delete(sidx);
        if (proxInventoryFetchInFlight.size === 0) {
            toggleEditorBusy(false);
        }
        toggleExternalIfxModalBusy(proxInventoryFetchInFlight.size > 0);
        updateProxmoxSummary(sidx);
        if (shouldRerender) {
            renderMain();
        }
    }
}

const HITL_PREVIEW_CACHE = new WeakMap();

const _sha256K = new Uint32Array([
    0x428a2f98,0x71374491,0xb5c0fbcf,0xe9b5dba5,0x3956c25b,0x59f111f1,0x923f82a4,0xab1c5ed5,
    0xd807aa98,0x12835b01,0x243185be,0x550c7dc3,0x72be5d74,0x80deb1fe,0x9bdc06a7,0xc19bf174,
    0xe49b69c1,0xefbe4786,0x0fc19dc6,0x240ca1cc,0x2de92c6f,0x4a7484aa,0x5cb0a9dc,0x76f988da,
    0x983e5152,0xa831c66d,0xb00327c8,0xbf597fc7,0xc6e00bf3,0xd5a79147,0x06ca6351,0x14292967,
    0x27b70a85,0x2e1b2138,0x4d2c6dfc,0x53380d13,0x650a7354,0x766a0abb,0x81c2c92e,0x92722c85,
    0xa2bfe8a1,0xa81a664b,0xc24b8b70,0xc76c51a3,0xd192e819,0xd6990624,0xf40e3585,0x106aa070,
    0x19a4c116,0x1e376c08,0x2748774c,0x34b0bcb5,0x391c0cb3,0x4ed8aa4a,0x5b9cca4f,0x682e6ff3,
    0x748f82ee,0x78a5636f,0x84c87814,0x8cc70208,0x90befffa,0xa4506ceb,0xbef9a3f7,0xc67178f2,
]);

const _sha256Init = new Uint32Array([
    0x6a09e667,0xbb67ae85,0x3c6ef372,0xa54ff53a,0x510e527f,0x9b05688c,0x1f83d9ab,0x5be0cd19,
]);

function _utf8ToBytes(str){
    if(typeof TextEncoder !== 'undefined'){
        return new TextEncoder().encode(str);
    }
    const bytes = [];
    for(let i=0;i<str.length;i++){
        let code = str.charCodeAt(i);
        if(code < 0x80){
            bytes.push(code);
        } else if(code < 0x800){
            bytes.push(0xc0 | (code >> 6));
            bytes.push(0x80 | (code & 0x3f));
        } else if(code < 0xd800 || code >= 0xe000){
            bytes.push(0xe0 | (code >> 12));
            bytes.push(0x80 | ((code >> 6) & 0x3f));
            bytes.push(0x80 | (code & 0x3f));
        } else {
            i++;
            code = 0x10000 + (((code & 0x3ff) << 10) | (str.charCodeAt(i) & 0x3ff));
            bytes.push(0xf0 | (code >> 18));
            bytes.push(0x80 | ((code >> 12) & 0x3f));
            bytes.push(0x80 | ((code >> 6) & 0x3f));
            bytes.push(0x80 | (code & 0x3f));
        }
    }
    return new Uint8Array(bytes);
}

function _sha256Bytes(message){
    const msg = message instanceof Uint8Array ? message : new Uint8Array(message || []);
    const l = msg.length;
    const bitLenHi = Math.floor((l >>> 29));
    const bitLenLo = (l << 3) >>> 0;
    const paddedLen = ((l + 9 + 63) >> 6) << 6;
    const padded = new Uint8Array(paddedLen);
    padded.set(msg);
    padded[l] = 0x80;
    const view = new DataView(padded.buffer);
    view.setUint32(paddedLen - 8, bitLenHi >>> 0, false);
    view.setUint32(paddedLen - 4, bitLenLo >>> 0, false);
    const w = new Uint32Array(64);
    const H = new Uint32Array(_sha256Init);
    for(let offset=0; offset<paddedLen; offset+=64){
        for(let i=0;i<16;i++){
            w[i] = view.getUint32(offset + (i<<2), false);
        }
        for(let i=16;i<64;i++){
            const s0 = ((w[i-15] >>> 7) | (w[i-15] << 25)) ^ ((w[i-15] >>> 18) | (w[i-15] << 14)) ^ (w[i-15] >>> 3);
            const s1 = ((w[i-2] >>> 17) | (w[i-2] << 15)) ^ ((w[i-2] >>> 19) | (w[i-2] << 13)) ^ (w[i-2] >>> 10);
            w[i] = (((w[i-16] + s0) >>> 0) + ((w[i-7] + s1) >>> 0)) >>> 0;
        }
        let a=H[0],b=H[1],c=H[2],d=H[3],e=H[4],f=H[5],g=H[6],h=H[7];
        for(let i=0;i<64;i++){
            const S1 = ((e>>>6)|(e<<26)) ^ ((e>>>11)|(e<<21)) ^ ((e>>>25)|(e<<7));
            const ch = (e & f) ^ ((~e) & g);
            const temp1 = (h + S1 + ch + _sha256K[i] + w[i]) >>> 0;
            const S0 = ((a>>>2)|(a<<30)) ^ ((a>>>13)|(a<<19)) ^ ((a>>>22)|(a<<10));
            const maj = (a & b) ^ (a & c) ^ (b & c);
            const temp2 = (S0 + maj) >>> 0;
            h = g;
            g = f;
            f = e;
            e = (d + temp1) >>> 0;
            d = c;
            c = b;
            b = a;
            a = (temp1 + temp2) >>> 0;
        }
        H[0] = (H[0] + a) >>> 0;
        H[1] = (H[1] + b) >>> 0;
        H[2] = (H[2] + c) >>> 0;
        H[3] = (H[3] + d) >>> 0;
        H[4] = (H[4] + e) >>> 0;
        H[5] = (H[5] + f) >>> 0;
        H[6] = (H[6] + g) >>> 0;
        H[7] = (H[7] + h) >>> 0;
    }
    const out = new Uint8Array(32);
    const outView = new DataView(out.buffer);
    for(let i=0;i<8;i++){
        outView.setUint32(i<<2, H[i], false);
    }
    return out;
}

function makeDeterministicRng(seed) {
    const base = _sha256Bytes(_utf8ToBytes(String(seed || '')));
    let counter = 0;
    const counterBytes = new Uint8Array(8);
    const counterView = new DataView(counterBytes.buffer);
    return () => {
        counterView.setUint32(0, counter >>> 0, true);
        counterView.setUint32(4, Math.floor(counter / 0x100000000) >>> 0, true);
        counter += 1;
        const combined = new Uint8Array(base.length + counterBytes.length);
        combined.set(base, 0);
        combined.set(counterBytes, base.length);
        const digest = _sha256Bytes(combined);
        let value = 0n;
        for(let i=0;i<8;i++){
            value = (value << 8n) | BigInt(digest[i]);
        }
        return Number(value) / 18446744073709551616;
    };
}

function intToIpv4(value) {
    const num = (Number(value) >>> 0);
    const part1 = (num >>> 24) & 0xff;
    const part2 = (num >>> 16) & 0xff;
    const part3 = (num >>> 8) & 0xff;
    const part4 = num & 0xff;
    return `${part1}.${part2}.${part3}.${part4}`;
}

function slugifyHitlName(rawValue, fallback) {
    let value = '';
    if (typeof rawValue === 'string') {
        value = rawValue.trim().toLowerCase();
    } else if (rawValue !== null && rawValue !== undefined) {
        value = String(rawValue).trim().toLowerCase();
    }
    if (!value) {
        value = (fallback || '').toString().trim().toLowerCase();
    }
    const cleaned = [];
    for (const ch of value) {
        if (/^[a-z0-9]$/.test(ch)) {
            cleaned.push(ch);
        } else if (ch === '-' || ch === '_') {
            cleaned.push(ch);
        } else {
            cleaned.push('-');
        }
    }
    let slug = cleaned.join('').replace(/^[-_]+|[-_]+$/g, '');
    if (!slug) {
        slug = ((fallback || '').toString().trim().toLowerCase()).replace(/^[-_]+|[-_]+$/g, '') || 'iface';
    }
    if (slug.length > 48) slug = slug.slice(0, 48);
    return slug;
}

function computeHitlPreviewLinkIps(scenarioKey, ifaceName, ordinal, prefixLen = 24) {
    try {
        const sanitizedPrefix = Number.isFinite(prefixLen) ? Math.min(Math.max(Math.trunc(prefixLen), 0), 32) : 24;
        const baseNetworkInt = (10 << 24) | (254 << 16); // 10.254.0.0
        const addressSpaceSize = 1 << 16; // /16 block span
        const hostBlock = sanitizedPrefix >= 32 ? 1 : (1 << Math.max(0, 32 - sanitizedPrefix));
        if (hostBlock < 8) {
                const pwdInput = document.querySelector(`[data-hitl-core-field="ssh_password"][data-scen-idx="${sidx}"]`);
                if (pwdInput) pwdInput.removeAttribute('placeholder');
            // Need at least 3 usable hosts (existing router, new router, RJ45)
            return null;
        }
        const subnetSpan = Math.max(0, sanitizedPrefix - 16);
        const totalSubnets = Math.max(1, Math.pow(2, subnetSpan));
        const seed = `${scenarioKey || '__default__'}|${ifaceName || ordinal}|${ordinal}|hitl-link`;
        const rng = makeDeterministicRng(seed);
        const subnetIndex = Math.floor(rng() * totalSubnets) % totalSubnets;
        let networkAddressInt = (baseNetworkInt + (subnetIndex * hostBlock)) >>> 0;
        const maxAddressInt = (baseNetworkInt + addressSpaceSize - 1) >>> 0;
        if (networkAddressInt > maxAddressInt) {
            networkAddressInt = (baseNetworkInt + (networkAddressInt % addressSpaceSize)) >>> 0;
        }
        let broadcastInt = (networkAddressInt + hostBlock - 1) >>> 0;
        if (broadcastInt > maxAddressInt) {
            broadcastInt = (baseNetworkInt + (broadcastInt % addressSpaceSize)) >>> 0;
        }
        const hostInts = [];
        for (let addr = (networkAddressInt + 1) >>> 0; addr < broadcastInt; addr = (addr + 1) >>> 0) {
            hostInts.push(addr >>> 0);
        }
        if (hostInts.length < 3) {
            return null;
        }
        const netmaskInt = sanitizedPrefix === 0 ? 0 : ((0xffffffff << (32 - sanitizedPrefix)) >>> 0);
        const pool = hostInts.slice();
        const selections = [];
        for (let i = 0; i < 3; i++) {
            if (!pool.length) break;
            const choiceIdx = Math.floor(rng() * pool.length) % pool.length;
            selections.push(pool.splice(choiceIdx, 1)[0]);
        }
        if (selections.length < 3) {
            return null;
        }
        return {
            network: intToIpv4(networkAddressInt),
            network_cidr: `${intToIpv4(networkAddressInt)}/${sanitizedPrefix}`,
            prefix_len: sanitizedPrefix,
            netmask: intToIpv4(netmaskInt),
            broadcast_ip4: intToIpv4(broadcastInt),
            existing_router_ip4: intToIpv4(selections[0]),
            new_router_ip4: intToIpv4(selections[1]),
            rj45_ip4: intToIpv4(selections[2]),
        };
    } catch (err) {
        console.warn('HITL: failed to compute preview link IPs', err);
        return null;
    }
}

function deriveHitlLinkMeta(iface, ordinal, totalCount, scenarioKey) {
    if (!iface || typeof iface !== 'object') {
        return {};
    }
    const previewRouter = iface.preview_router || iface.previewRouter || null;
    const previewMetadata = (previewRouter && previewRouter.metadata) || {};
    const result = {
        network: iface.link_network || iface.linkNetwork || null,
        networkCidr: iface.link_network_cidr || iface.linkNetworkCidr || null,
        prefixLen: Number.isFinite(iface.prefix_len) ? Number(iface.prefix_len) : null,
        netmask: iface.netmask || null,
        existingRouterIp4: iface.existing_router_ip4 || null,
        newRouterIp4: iface.new_router_ip4 || null,
        rj45Ip4: iface.rj45_ip4 || null,
        broadcastIp4: iface.broadcast_ip4 || null,
    };
    if (!result.network && previewMetadata.link_network) result.network = previewMetadata.link_network;
    if (!result.networkCidr && previewMetadata.link_network) result.networkCidr = previewMetadata.link_network;
    if (!result.prefixLen && Number.isFinite(previewMetadata.prefix_len)) result.prefixLen = Number(previewMetadata.prefix_len);
    if (!result.netmask && previewMetadata.netmask) result.netmask = previewMetadata.netmask;
    if (!result.existingRouterIp4 && previewMetadata.existing_router_ip4) result.existingRouterIp4 = previewMetadata.existing_router_ip4;
    if (!result.newRouterIp4 && previewMetadata.new_router_ip4) result.newRouterIp4 = previewMetadata.new_router_ip4;
    if (!result.rj45Ip4 && previewMetadata.rj45_ip4) result.rj45Ip4 = previewMetadata.rj45_ip4;
    if (!result.broadcastIp4 && previewMetadata.broadcast_ip4) result.broadcastIp4 = previewMetadata.broadcast_ip4;
    if (previewRouter && typeof previewRouter.ip4 === 'string' && !result.newRouterIp4) {
        result.newRouterIp4 = previewRouter.ip4;
    }
    if (result.newRouterIp4 && typeof result.newRouterIp4 === 'string' && result.newRouterIp4.includes('/')) {
        const parts = result.newRouterIp4.split('/', 2);
        result.newRouterIp4 = parts[0];
        if (!result.prefixLen && parts[1]) {
            const parsed = parseInt(parts[1], 10);
            if (!Number.isNaN(parsed)) {
                result.prefixLen = parsed;
            }
        }
    }
    if (!result.networkCidr && result.network && Number.isFinite(result.prefixLen)) {
        result.networkCidr = `${result.network}/${result.prefixLen}`;
    }
    const needsFallback = !result.networkCidr || !result.newRouterIp4 || !result.rj45Ip4 || !result.existingRouterIp4;
    if (needsFallback) {
        const fallback = computeHitlPreviewLinkIps(scenarioKey, iface.name || `iface-${ordinal + 1}`, ordinal);
        if (fallback) {
            result.network = result.network || fallback.network;
            result.networkCidr = result.networkCidr || fallback.network_cidr || fallback.network;
            result.prefixLen = result.prefixLen || fallback.prefix_len;
            result.netmask = result.netmask || fallback.netmask;
            result.existingRouterIp4 = result.existingRouterIp4 || fallback.existing_router_ip4;
            result.newRouterIp4 = result.newRouterIp4 || fallback.new_router_ip4;
            result.rj45Ip4 = result.rj45Ip4 || fallback.rj45_ip4;
            result.broadcastIp4 = result.broadcastIp4 || fallback.broadcast_ip4;
        }
    }
    if (result.network && Number.isFinite(result.prefixLen) && !result.netmask) {
        const prefix = Math.min(Math.max(Number(result.prefixLen), 0), 32);
        const maskInt = prefix === 0 ? 0 : ((0xffffffff << (32 - prefix)) >>> 0);
        result.netmask = intToIpv4(maskInt);
    }
    if (result.network && Number.isFinite(result.prefixLen) && !result.networkCidr) {
        result.networkCidr = `${result.network}/${result.prefixLen}`;
    }
    return result;
}

function deriveHitlPreviewArtifacts(full) {
    if (!full || typeof full !== 'object') return null;
    if (HITL_PREVIEW_CACHE.has(full)) {
        return HITL_PREVIEW_CACHE.get(full) || null;
    }
    const scenario = Array.isArray(state?.scenarios) ? state.scenarios[activeIdx] : null;
    if (!scenario) {
        HITL_PREVIEW_CACHE.set(full, null);
        return null;
    }
    const hitlState = ensureHitlStateForScenario(scenario);
    if (!hitlState.enabled) {
        HITL_PREVIEW_CACHE.set(full, null);
        return null;
    }
    const scenarioName = (scenario && typeof scenario.name === 'string') ? scenario.name : '';
    const scenarioSeed = scenarioName && scenarioName.trim() ? scenarioName.trim() : '__preview__';
    const rawInterfaces = (hitlState.interfaces || []).filter(entry => entry && typeof entry === 'object' && entry.name);
    if (!rawInterfaces.length) {
        HITL_PREVIEW_CACHE.set(full, null);
        return null;
    }
    const normalizeList = (value) => {
        if (Array.isArray(value)) {
            return value.map(v => (v ?? '').toString().trim()).filter(Boolean);
        }
        if (typeof value === 'string') {
            return value.split(',').map(v => v.trim()).filter(Boolean);
        }
        return [];
    };
    const totalInterfaces = rawInterfaces.length;
    const hitlScenarioKey = (typeof hitlState.scenario_key === 'string' && hitlState.scenario_key.trim())
        ? hitlState.scenario_key.trim()
        : scenarioSeed;
    const interfaces = rawInterfaces.map((entry, idx) => {
        const clone = { ...entry };
        clone.name = (clone.name || '').toString();
        clone.alias = clone.alias ?? clone.description ?? clone.display;
        clone.ipv4 = normalizeList(clone.ipv4);
        clone.ipv6 = normalizeList(clone.ipv6);
        clone.attachment = normalizeHitlAttachment(clone.attachment);
        const fallbackSlug = `iface-${idx + 1}`;
        const slug = slugifyHitlName(clone.name, fallbackSlug);
        clone.slug = slug;
        clone.ordinal = idx;
        const linkMeta = deriveHitlLinkMeta(clone, idx, totalInterfaces, hitlScenarioKey) || {};
        clone.hitl_link_meta = linkMeta;
        if (linkMeta.rj45Ip4 && !clone.rj45_ip4) {
            clone.rj45_ip4 = linkMeta.rj45Ip4;
        }
        if (linkMeta.newRouterIp4 && !clone.new_router_ip4) {
            clone.new_router_ip4 = linkMeta.newRouterIp4;
        }
        if (linkMeta.existingRouterIp4 && !clone.existing_router_ip4) {
            clone.existing_router_ip4 = linkMeta.existingRouterIp4;
        }
        if (linkMeta.networkCidr && !clone.link_network_cidr) {
            clone.link_network_cidr = linkMeta.networkCidr;
        }
        if (linkMeta.netmask && !clone.netmask) {
            clone.netmask = linkMeta.netmask;
        }
        return clone;
    });
    const normalizeName = (raw, idx) => {
        let base = (raw || `iface-${idx}`).toString().trim().toLowerCase();
        base = base.replace(/[^a-z0-9_-]+/g, '-').replace(/-+/g, '-').replace(/^-|-$/g, '');
        if (!base) base = `iface-${idx}`;
        if (base.length > 48) base = base.slice(0, 48);
        return base;
    };
    const existingIds = new Set();
    const noteExisting = val => {
        if (val === undefined || val === null) return;
        existingIds.add(String(val));
    };
    (full.routers || []).forEach(r => noteExisting(r?.node_id ?? r?.id));
    (full.hosts || []).forEach(h => noteExisting(h?.node_id ?? h?.id));
    (full.switches_detail || []).forEach(sw => noteExisting(sw?.switch_id ?? sw?.id));
    const basePreview = full.base_bridge_preview || {};
    noteExisting(basePreview?.bridge_router_id);
    noteExisting(basePreview?.internal_peer_router_id);
    const routerPeers = Array.isArray(full.routers)
        ? full.routers.filter(r => r && r.node_id !== undefined && r.node_id !== null)
        : [];
    routerPeers.sort((a, b) => {
        const aid = Number(a?.node_id ?? a?.id ?? 0);
        const bid = Number(b?.node_id ?? b?.id ?? 0);
        return aid - bid;
    });
    const routerPeerMap = new Map();
    routerPeers.forEach(peer => {
        const peerId = peer?.node_id ?? peer?.id;
        if(peerId !== undefined && peerId !== null){
            routerPeerMap.set(String(peerId), peer);
        }
    });
    const hostPeers = Array.isArray(full.hosts)
        ? full.hosts.filter(h => h && h.node_id !== undefined && h.node_id !== null)
        : [];
    hostPeers.sort((a, b) => {
        const aid = Number(a?.node_id ?? a?.id ?? 0);
        const bid = Number(b?.node_id ?? b?.id ?? 0);
        return aid - bid;
    });
    const existingSubnets = Array.isArray(full.switches_detail)
        ? full.switches_detail.filter(sw => sw && sw.switch_id !== undefined && sw.switch_id !== null).sort((a, b) => {
            const aid = Number(a?.switch_id ?? a?.id ?? 0);
            const bid = Number(b?.switch_id ?? b?.id ?? 0);
            return aid - bid;
        })
        : [];
    const hitlSwitchLookup = new Map();
    existingSubnets.forEach(detail => {
        if (!detail || typeof detail !== 'object') return;
        const meta = (detail.metadata && typeof detail.metadata === 'object') ? detail.metadata : {};
        const slugKey = meta.hitl_slug || meta.hitl_switch_slug || meta.hitl_interface_slug;
        if (slugKey) {
            hitlSwitchLookup.set(`slug:${String(slugKey)}`, detail);
        }
        const ifaceName = meta.hitl_interface_name || meta.interface_name || detail.interface_name;
        if (ifaceName) {
            hitlSwitchLookup.set(`name:${String(ifaceName).toLowerCase().trim()}`, detail);
        }
    });
    const nodes = [];
    const links = [];
    const makeUniqueId = (base) => {
        let candidate = base;
        let suffix = 2;
        while (existingIds.has(String(candidate))) {
            candidate = `${base}-${suffix}`;
            suffix += 1;
        }
        existingIds.add(String(candidate));
        return candidate;
    };
    const includedRouterNodeIds = new Set();
    const includedSwitchNodeIds = new Set();
    const routerOverlayMap = new Map();
    const switchOverlayMap = new Map();
    const routerSwitchInterfaceMap = new Map();

    const registerRouterOverlayNode = (node) => {
        if(!node) return;
        const key = String(node.id ?? node.node_id);
        if(!key) return;
        routerOverlayMap.set(key, node);
    };

    const getOrCreateRouterOverlayNode = (routerId, fallbackLabel = null) => {
        if(routerId === null || routerId === undefined) return null;
        const key = String(routerId);
        if(routerOverlayMap.has(key)){
            return routerOverlayMap.get(key);
        }
        let node = nodes.find(existing => String(existing.id ?? existing.node_id) === key);
        if(!node){
            const basePeer = routerPeerMap.get(key);
            const label = fallbackLabel || basePeer?.name || `Router ${routerId}`;
            node = {
                id: routerId,
                node_id: routerId,
                type: 'router',
                label,
                name: label,
                isHitlRouter: true,
            };
            nodes.push(node);
            includedRouterNodeIds.add(routerId);
        }
        registerRouterOverlayNode(node);
        return node;
    };

    const registerSwitchOverlayNode = (node) => {
        if(!node) return;
        const key = String(node.switch_id ?? node.id);
        if(!key) return;
        switchOverlayMap.set(key, node);
    };

    const registerRouterSwitchInterface = (routerId, entry) => {
        if(routerId === null || routerId === undefined) return;
        const key = String(routerId);
        const list = routerSwitchInterfaceMap.get(key) || [];
        list.push(entry);
        routerSwitchInterfaceMap.set(key, list);
    };
    interfaces.forEach((iface, idx) => {
        const linkMeta = iface.hitl_link_meta || deriveHitlLinkMeta(iface, idx, totalInterfaces, hitlScenarioKey) || {};
        const previewRouterMeta = iface.preview_router || iface.previewRouter || null;
        const baseName = normalizeName(iface.name, idx);
        const attachmentPref = normalizeHitlAttachment(iface.attachment);
        const nodeId = makeUniqueId(baseName);
        const alias = iface.alias;
        const labelParts = [];
        if (iface.name) labelParts.push(iface.name);
        if (alias && alias !== iface.name) {
            labelParts.push(alias);
        } else if (iface.mac) {
            labelParts.push(iface.mac);
        }
        const nodeLabel = labelParts.filter(Boolean).join(' · ') || iface.name || `HITL ${idx + 1}`;
        const hitlNode = {
            id: nodeId,
            type: 'rj45',
            label: nodeLabel,
            name: nodeLabel,
            isHitl: true,
            hitlInterface: iface,
            attachment: attachmentPref,
        };
        if (linkMeta && linkMeta.rj45Ip4) {
            hitlNode.ip4 = linkMeta.rj45Ip4;
        } else if (Array.isArray(iface.ipv4) && iface.ipv4.length) {
            hitlNode.ip4 = iface.ipv4[0];
        }
        if (linkMeta && (linkMeta.networkCidr || linkMeta.network)) {
            hitlNode.linkNetwork = linkMeta.networkCidr || linkMeta.network;
        }
        if (linkMeta && Number.isFinite(linkMeta.prefixLen)) {
            hitlNode.prefixLen = Number(linkMeta.prefixLen);
        }
        if (linkMeta && linkMeta.newRouterIp4) {
            hitlNode.peerRouterIp4 = linkMeta.newRouterIp4;
        }
        if (linkMeta && linkMeta.existingRouterIp4) {
            hitlNode.existingRouterIp4 = linkMeta.existingRouterIp4;
        }
        if (linkMeta && linkMeta.netmask) {
            hitlNode.netmask = linkMeta.netmask;
        }
        if (linkMeta && linkMeta.broadcastIp4) {
            hitlNode.broadcastIp4 = linkMeta.broadcastIp4;
        }
        hitlNode.hitlLinkMeta = linkMeta;
        nodes.push(hitlNode);
        const rng = makeDeterministicRng(`${scenarioSeed}|${iface.name}|${idx}|${interfaces.length}`);
        const attempts = hitlAttachmentAttemptOrder(attachmentPref);
        let targetId = null;
        let assignment = null;
        let linkKind = 'hitl-peer';
        let uplinkRouterId = null;
        const pickRouterPeer = () => {
            if (!routerPeers.length) return null;
            const peer = routerPeers[Math.floor(rng() * routerPeers.length)];
            const peerId = peer?.node_id ?? peer?.id;
            return (peerId !== undefined && peerId !== null) ? peerId : null;
        };
        const pickSwitchPeer = () => {
            if (!existingSubnets.length) return null;
            const subnet = existingSubnets[Math.floor(rng() * existingSubnets.length)];
            const candidateId = subnet?.switch_id ?? subnet?.id;
            return (candidateId !== undefined && candidateId !== null) ? candidateId : null;
        };
        const createNewRouter = () => {
            const matchPreviewRouter = () => {
                if (previewRouterMeta && (previewRouterMeta.node_id ?? previewRouterMeta.nodeId ?? previewRouterMeta.id) !== undefined) {
                    return previewRouterMeta;
                }
                return routerPeers.find(peer => {
                    if (!peer) return false;
                    const meta = peer.metadata || peer.meta || peer.details || null;
                    if (!meta || meta.hitl_preview !== true) return false;
                    if (iface.slug && typeof meta.hitl_slug === 'string' && meta.hitl_slug === iface.slug) return true;
                    const ifaceNameLower = (iface.name || '').toString().trim().toLowerCase();
                    if (ifaceNameLower && typeof meta.hitl_interface_name === 'string' && meta.hitl_interface_name.trim().toLowerCase() === ifaceNameLower) {
                        return true;
                    }
                    if (Number.isFinite(meta.ordinal) && meta.ordinal === idx) return true;
                    return false;
                }) || null;
            };

            const previewRouter = matchPreviewRouter();
            if (previewRouter) {
                const routerId = previewRouter.node_id ?? previewRouter.nodeId ?? previewRouter.id;
                if (routerId !== undefined && routerId !== null) {
                    noteExisting(routerId);
                    const routerLabel = previewRouter.name || `HITL Router ${idx + 1}`;
                    const meta = previewRouter.metadata || previewRouter.meta || {};
                    if (meta && meta.uplink_router_node_id !== undefined && meta.uplink_router_node_id !== null) {
                        uplinkRouterId = meta.uplink_router_node_id;
                    } else if (meta && meta.uplinkRouterId !== undefined && meta.uplinkRouterId !== null) {
                        uplinkRouterId = meta.uplinkRouterId;
                    }
                    const prefixCandidate = Number.isFinite(linkMeta?.prefixLen) ? Number(linkMeta.prefixLen) : Number.isFinite(meta?.prefix_len) ? Number(meta.prefix_len) : null;
                    const routerNode = getOrCreateRouterOverlayNode(routerId, routerLabel);
                    if (routerNode) {
                        const assignIfMissing = (key, value) => {
                            if (value === undefined || value === null) return;
                            if (routerNode[key] === undefined || routerNode[key] === null) {
                                routerNode[key] = value;
                            }
                        };
                        assignIfMissing('label', routerLabel);
                        assignIfMissing('name', routerLabel);
                        routerNode.isHitlRouter = true;
                        routerNode.attachment = routerNode.attachment || attachmentPref;
                        routerNode.previewRouter = routerNode.previewRouter || previewRouter;
                        routerNode.hitlInterface = routerNode.hitlInterface || iface;
                        if (linkMeta && !routerNode.hitlLinkMeta) {
                            routerNode.hitlLinkMeta = linkMeta;
                        }
                        if (meta && meta.new_router_ip4) {
                            const value = prefixCandidate && !String(meta.new_router_ip4).includes('/')
                                ? `${meta.new_router_ip4}/${prefixCandidate}`
                                : meta.new_router_ip4;
                            assignIfMissing('ip4', value);
                        } else if (linkMeta && linkMeta.newRouterIp4) {
                            const value = prefixCandidate && !String(linkMeta.newRouterIp4).includes('/')
                                ? `${linkMeta.newRouterIp4}/${prefixCandidate}`
                                : linkMeta.newRouterIp4;
                            assignIfMissing('ip4', value);
                        } else if (typeof previewRouter.ip4 === 'string') {
                            assignIfMissing('ip4', previewRouter.ip4);
                        }
                        if (meta && meta.existing_router_ip4) {
                            assignIfMissing('peerRouterIp4', meta.existing_router_ip4);
                        } else if (linkMeta && linkMeta.existingRouterIp4) {
                            assignIfMissing('peerRouterIp4', linkMeta.existingRouterIp4);
                        }
                        if (linkMeta && (linkMeta.networkCidr || linkMeta.network)) {
                            assignIfMissing('linkNetwork', linkMeta.networkCidr || linkMeta.network);
                        } else if (meta && meta.link_network) {
                            assignIfMissing('linkNetwork', meta.link_network);
                        }
                        if (Number.isFinite(prefixCandidate)) {
                            assignIfMissing('prefixLen', prefixCandidate);
                        }
                        if (uplinkRouterId !== null && (routerNode.uplinkRouterId === undefined || routerNode.uplinkRouterId === null)) {
                            routerNode.uplinkRouterId = uplinkRouterId;
                        }
                        registerRouterOverlayNode(routerNode);
                    }
                    if (!routerPeers.some(peer => String(peer?.node_id ?? peer?.id) === String(routerId))) {
                        routerPeers.push(previewRouter);
                    }
                    routerPeerMap.set(String(routerId), previewRouter);
                    return routerId;
                }
            }

            const routerId = makeUniqueId(`hitl-router-${baseName}`);
            const routerLabel = `HITL Router ${idx + 1}`;
            const routerNode = getOrCreateRouterOverlayNode(routerId, routerLabel);
            if (routerNode) {
                const assignIfMissing = (key, value) => {
                    if (value === undefined || value === null) return;
                    if (routerNode[key] === undefined || routerNode[key] === null) {
                        routerNode[key] = value;
                    }
                };
                assignIfMissing('label', routerLabel);
                assignIfMissing('name', routerLabel);
                routerNode.isHitlRouter = true;
                routerNode.hitlInterface = routerNode.hitlInterface || iface;
                routerNode.attachment = routerNode.attachment || attachmentPref;
                if (linkMeta && !routerNode.hitlLinkMeta) {
                    routerNode.hitlLinkMeta = linkMeta;
                }
                if (linkMeta && linkMeta.newRouterIp4) {
                    const withPrefix = Number.isFinite(linkMeta.prefixLen) && !String(linkMeta.newRouterIp4).includes('/')
                        ? `${linkMeta.newRouterIp4}/${linkMeta.prefixLen}`
                        : linkMeta.newRouterIp4;
                    assignIfMissing('ip4', withPrefix);
                }
                if (linkMeta && (linkMeta.networkCidr || linkMeta.network)) {
                    assignIfMissing('linkNetwork', linkMeta.networkCidr || linkMeta.network);
                }
                if (linkMeta && Number.isFinite(linkMeta.prefixLen)) {
                    assignIfMissing('prefixLen', Number(linkMeta.prefixLen));
                }
                if (linkMeta && linkMeta.existingRouterIp4) {
                    assignIfMissing('peerRouterIp4', linkMeta.existingRouterIp4);
                }
                registerRouterOverlayNode(routerNode);
            }
            const routerCandidates = routerPeers.length ? routerPeers.slice() : [];
            if (routerCandidates.length) {
                const chosen = routerCandidates[Math.floor(rng() * routerCandidates.length) % routerCandidates.length];
                const chosenId = chosen?.node_id ?? chosen?.id;
                if (chosenId !== undefined && chosenId !== null) {
                    uplinkRouterId = chosenId;
                    if (routerNode && (routerNode.uplinkRouterId === undefined || routerNode.uplinkRouterId === null)) {
                        routerNode.uplinkRouterId = chosenId;
                    }
                    noteExisting(chosenId);
                    links.push({ sourceId: routerId, targetId: chosenId, kind: 'hitl-router-uplink', attachment: attachmentPref, assignment: 'uplink_router', linkMeta });
                }
            }
            routerPeers.push({ node_id: routerId, id: routerId, name: routerLabel, type: 'router', isHitlRouter: true });
            routerPeerMap.set(String(routerId), { node_id: routerId, id: routerId, name: routerLabel, type: 'router', isHitlRouter: true });
            noteExisting(routerId);
            return routerId;
        };
        const createNewSwitch = () => {
            const previewSwitchMetaRaw = iface.preview_switch || iface.previewSwitch || null;
            const previewSwitchId = previewSwitchMetaRaw && (previewSwitchMetaRaw.node_id ?? previewSwitchMetaRaw.nodeId ?? previewSwitchMetaRaw.id);
            if (previewSwitchMetaRaw && previewSwitchId !== undefined && previewSwitchId !== null) {
                const switchId = previewSwitchId;
                const switchLabel = previewSwitchMetaRaw.name || `HITL Switch ${idx + 1}`;
                noteExisting(switchId);
                let switchNode = switchOverlayMap.get(String(switchId));
                if (!switchNode) {
                    switchNode = {
                        id: switchId,
                        switch_id: switchId,
                        type: 'switch',
                        label: switchLabel,
                        name: switchLabel,
                        isHitlSwitch: true,
                        hitlInterface: iface,
                        attachment: attachmentPref,
                        previewSwitch: previewSwitchMetaRaw,
                    };
                    nodes.push(switchNode);
                    includedSwitchNodeIds.add(switchId);
                    registerSwitchOverlayNode(switchNode);
                } else {
                    if (!switchNode.label) switchNode.label = switchLabel;
                    if (!switchNode.name) switchNode.name = switchLabel;
                    switchNode.isHitlSwitch = true;
                    switchNode.hitlInterface = switchNode.hitlInterface || iface;
                    switchNode.attachment = switchNode.attachment || attachmentPref;
                    switchNode.previewSwitch = switchNode.previewSwitch || previewSwitchMetaRaw;
                    registerSwitchOverlayNode(switchNode);
                }
                if (linkMeta && !switchNode.hitlLinkMeta) {
                    switchNode.hitlLinkMeta = linkMeta;
                }
                if (!existingSubnets.some(sw => String(sw?.switch_id ?? sw?.id) === String(switchId))) {
                    existingSubnets.push({ switch_id: switchId, id: switchId, name: switchLabel, isHitlSwitch: true });
                }
                const hintedRouterId = iface.targetRouterId ?? previewSwitchMetaRaw.router_id ?? previewSwitchMetaRaw.routerId ?? null;
                if (hintedRouterId !== null && hintedRouterId !== undefined) {
                    uplinkRouterId = hintedRouterId;
                    if (switchNode.router_id === undefined || switchNode.router_id === null) {
                        switchNode.router_id = hintedRouterId;
                    }
                    if (switchNode.uplinkRouterId === undefined || switchNode.uplinkRouterId === null) {
                        switchNode.uplinkRouterId = hintedRouterId;
                    }
                }
                return switchId;
            }
            const slugKey = iface.slug ? `slug:${iface.slug}` : null;
            const nameKey = iface.name ? `name:${String(iface.name).toLowerCase().trim()}` : null;
            const matchedDetail = (slugKey && hitlSwitchLookup.get(slugKey)) || (nameKey && hitlSwitchLookup.get(nameKey)) || null;
            let switchId;
            let switchLabel;
            if (matchedDetail && matchedDetail.switch_id !== undefined && matchedDetail.switch_id !== null) {
                switchId = matchedDetail.switch_id;
                const meta = (matchedDetail.metadata && typeof matchedDetail.metadata === 'object') ? matchedDetail.metadata : {};
                switchLabel = matchedDetail.name || matchedDetail.label || meta.name || `sw-${switchId}`;
            } else {
                switchId = makeUniqueId(`hitl-switch-${baseName}`);
                switchLabel = `HITL Switch ${idx + 1}`;
            }
            let switchNode = switchOverlayMap.get(String(switchId));
            if (!switchNode) {
                switchNode = {
                    id: switchId,
                    switch_id: switchId,
                    type: 'switch',
                    label: switchLabel,
                    name: switchLabel,
                    isHitlSwitch: true,
                    hitlInterface: iface,
                    attachment: attachmentPref,
                };
                nodes.push(switchNode);
                includedSwitchNodeIds.add(switchId);
            } else {
                if (!switchNode.label) switchNode.label = switchLabel;
                if (!switchNode.name) switchNode.name = switchLabel;
                switchNode.isHitlSwitch = true;
                switchNode.hitlInterface = switchNode.hitlInterface || iface;
                switchNode.attachment = switchNode.attachment || attachmentPref;
            }
            registerSwitchOverlayNode(switchNode);
            const assignSwitchIfMissing = (key, value) => {
                if (value === undefined || value === null) return;
                if (switchNode[key] === undefined || switchNode[key] === null) {
                    switchNode[key] = value;
                }
            };
            if (matchedDetail) {
                assignSwitchIfMissing('router_id', matchedDetail.router_id ?? (matchedDetail.metadata && matchedDetail.metadata.target_router_id));
                assignSwitchIfMissing('uplinkRouterId', matchedDetail.router_id ?? (matchedDetail.metadata && matchedDetail.metadata.target_router_id));
                assignSwitchIfMissing('switch_ip', matchedDetail.switch_ip);
                assignSwitchIfMissing('router_ip', matchedDetail.router_ip);
                assignSwitchIfMissing('link_network_cidr', matchedDetail.rsw_subnet);
                assignSwitchIfMissing('link_network', matchedDetail.rsw_subnet || matchedDetail.lan_subnet);
                if (matchedDetail.host_if_ips && matchedDetail.host_if_ips.rj45 && (!switchNode.host_if_ips || !switchNode.host_if_ips.rj45)) {
                    switchNode.host_if_ips = switchNode.host_if_ips || {};
                    switchNode.host_if_ips.rj45 = matchedDetail.host_if_ips.rj45;
                }
            }
            if (linkMeta) {
                switchNode.hitlLinkMeta = switchNode.hitlLinkMeta || linkMeta;
                assignSwitchIfMissing('switch_ip', linkMeta.rj45Ip4 || null);
                assignSwitchIfMissing('router_ip', linkMeta.newRouterIp4 || null);
                assignSwitchIfMissing('link_network_cidr', linkMeta.networkCidr || null);
                assignSwitchIfMissing('link_network', linkMeta.network || null);
            }
            let routerLinkEstablished = false;
            const routerCandidates = routerPeers.length ? routerPeers.slice() : [];
            if (routerCandidates.length) {
                const chosen = routerCandidates[Math.floor(rng() * routerCandidates.length) % routerCandidates.length];
                const chosenId = chosen?.node_id ?? chosen?.id;
                if (chosenId !== undefined && chosenId !== null) {
                    uplinkRouterId = chosenId;
                    assignSwitchIfMissing('router_id', chosenId);
                    switchNode.uplinkRouterId = switchNode.uplinkRouterId ?? chosenId;
                    noteExisting(chosenId);
                    links.push({ sourceId: switchId, targetId: chosenId, kind: 'hitl-switch-uplink', attachment: attachmentPref, assignment: 'uplink_switch' });
                    routerLinkEstablished = true;
                }
            }
            if (!routerLinkEstablished) {
                const fallbackRouterId = createNewRouter();
                if (fallbackRouterId !== null && fallbackRouterId !== undefined) {
                    uplinkRouterId = fallbackRouterId;
                    assignSwitchIfMissing('router_id', fallbackRouterId);
                    switchNode.uplinkRouterId = fallbackRouterId;
                    noteExisting(fallbackRouterId);
                    links.push({ sourceId: switchId, targetId: fallbackRouterId, kind: 'hitl-switch-uplink', attachment: attachmentPref, assignment: 'uplink_switch' });
                    routerLinkEstablished = true;
                }
            }
            if (!matchedDetail) {
                existingSubnets.push({ switch_id: switchId, id: switchId, name: switchLabel, isHitlSwitch: true });
            }
            noteExisting(switchId);
            return switchId;
        };
        for (const attempt of attempts) {
            if (attempt === 'existing_router') {
                const candidate = pickRouterPeer();
                if (candidate !== null) {
                    targetId = candidate;
                    assignment = 'existing_router';
                    linkKind = 'hitl-router';
                    noteExisting(candidate);
                    uplinkRouterId = candidate;
                    break;
                }
            } else if (attempt === 'existing_switch') {
                const candidate = pickSwitchPeer();
                if (candidate !== null) {
                    targetId = candidate;
                    assignment = 'existing_switch';
                    linkKind = 'hitl-switch';
                    noteExisting(candidate);
                    break;
                }
            } else if (attempt === 'new_router') {
                const newRouterId = createNewRouter();
                if (newRouterId !== null) {
                    targetId = newRouterId;
                    assignment = 'new_router';
                    linkKind = 'hitl-router';
                    break;
                }
            }
        }
        if (targetId === null) {
            const fallbackRouter = pickRouterPeer();
            if (fallbackRouter !== null) {
                targetId = fallbackRouter;
                assignment = assignment ?? 'existing_router';
                linkKind = 'hitl-router';
                noteExisting(fallbackRouter);
                uplinkRouterId = fallbackRouter;
            }
        }
        if (targetId === null && hostPeers.length) {
            const peer = hostPeers[Math.floor(rng() * hostPeers.length)];
            const peerId = peer?.node_id ?? peer?.id;
            if (peerId !== undefined && peerId !== null) {
                targetId = peerId;
                assignment = assignment ?? 'existing_host';
                linkKind = 'hitl-host';
                noteExisting(peerId);
            }
        }
        if (targetId === null) {
            const networkId = makeUniqueId(`hitl-net-${baseName}`);
            const networkLabel = `HITL Network ${idx + 1}`;
            nodes.push({
                id: networkId,
                type: 'network',
                label: networkLabel,
                name: networkLabel,
                isHitlNetwork: true,
                hitlInterface: iface,
                attachment: attachmentPref,
            });
            targetId = networkId;
            assignment = assignment ?? 'network';
            linkKind = 'hitl-network';
        }
        if (targetId !== null) {
            hitlNode.peerNodeId = targetId;
            hitlNode.assignment = assignment || attachmentPref;
            if (uplinkRouterId !== null) {
                hitlNode.uplinkRouterId = uplinkRouterId;
            }
            links.push({
                sourceId: nodeId,
                targetId,
                kind: linkKind,
                attachment: attachmentPref,
                assignment: assignment || attachmentPref,
                linkMeta,
            });
        }
    });
    routerSwitchInterfaceMap.forEach((entries, key) => {
        const routerNode = getOrCreateRouterOverlayNode(key);
        if (routerNode) {
            routerNode.hitlSwitchInterfaces = entries;
        }
    });
    const result = nodes.length ? { nodes, links, interfaces, hitlState } : null;
    HITL_PREVIEW_CACHE.set(full, result);
    return result;
}

function normalizeBaseUpload(meta) {
    if (!meta || typeof meta !== 'object') return null;
    const safe = {};
    if (typeof meta.path === 'string') safe.path = meta.path;
    if (typeof meta.display_name === 'string') safe.display_name = meta.display_name;
    if (Object.prototype.hasOwnProperty.call(meta, 'valid')) safe.valid = !!meta.valid;
    return Object.keys(safe).length ? safe : null;
}

const ROUTER_NODE_TYPES = new Set(['router', 'prouter', 'mdr', 'core-router', 'gateway']);
const SWITCH_NODE_TYPES = new Set(['switch', 'lanswitch', 'l3switch', 'bridge', 'core-switch']);
const HOST_NODE_TYPES = new Set(['host', 'pc', 'server', 'workstation', 'client', 'desktop', 'lxc', 'xterm', 'generic', 'terminal', 'laptop']);
const NETWORK_NODE_TYPES = new Set(['network', 'lan', 'wan']);
const WIRELESS_NODE_TYPES = new Set(['wireless', 'wirelesslan', 'wireless-lan', 'wlan', 'wifi']);
const RJ45_NODE_TYPES = new Set(['rj45']);
const HUB_NODE_TYPES = new Set(['hub', 'ethernet', 'tap']);

const NODE_TYPE_STYLE_PRESETS = {
    router: { label: 'Router', color: '#ff7043', radius: 11 },
    switch: { label: 'Switch', color: '#17a2b8', radius: 8 },
    host: { label: 'Host', color: '#ffc107', radius: 5 },
    network: { label: 'Network', color: '#6c757d', radius: 7 },
    hub: { label: 'Hub', color: '#7952b3', radius: 6 },
    rj45: { label: 'RJ45', color: '#20c997', radius: 6, shape: 'square' },
    wireless: { label: 'Wireless', color: '#0dcaf0', radius: 6 },
    wlan: { label: 'WLAN', color: '#0dcaf0', radius: 6 },
    tap: { label: 'TAP', color: '#6f42c1', radius: 6 },
};

function canonicalNodeType(raw) {
    if (raw === null || raw === undefined) return 'host';
    const key = String(raw).trim().toLowerCase();
    if (!key) return 'host';
    if (ROUTER_NODE_TYPES.has(key)) return 'router';
    if (SWITCH_NODE_TYPES.has(key)) return 'switch';
    if (RJ45_NODE_TYPES.has(key)) return 'rj45';
    if (WIRELESS_NODE_TYPES.has(key)) return 'wireless';
    if (NETWORK_NODE_TYPES.has(key)) return 'network';
    if (HUB_NODE_TYPES.has(key)) return 'hub';
    if (HOST_NODE_TYPES.has(key)) return 'host';
    return key;
}

function formatNodeTypeLabel(key) {
    if (!key) return 'Node';
    return key.replace(/[-_]/g, ' ').replace(/\b\w/g, c => c.toUpperCase());
}

function nodeStyleForType(rawType) {
    const key = canonicalNodeType(rawType);
    const preset = NODE_TYPE_STYLE_PRESETS[key];
    if (preset) {
        const radius = Number.isFinite(preset.radius) ? preset.radius : 6;
        const shape = preset.shape || 'circle';
        return { ...preset, radius, shape };
    }
    return {
        label: formatNodeTypeLabel(key),
        color: '#adb5bd',
        radius: 6,
        shape: 'circle',
    };
}

function coerceBool(value) {
    if (typeof value === 'boolean') return value;
    if (typeof value === 'number') return value !== 0;
    if (typeof value === 'string') {
        const val = value.trim().toLowerCase();
        return ['1', 'true', 'yes', 'on', 'y'].includes(val);
    }
    return false;
}

function toPositiveInt(value, fallback) {
    if (typeof value === 'number' && Number.isFinite(value) && value > 0) {
        return Math.round(value);
    }
    if (typeof value === 'string') {
        const trimmed = value.trim();
        if (trimmed) {
            const parsed = parseInt(trimmed, 10);
            if (!Number.isNaN(parsed) && parsed > 0) {
                return parsed;
            }
        }
    }
    return fallback;
}

function normalizeCoreState(raw, includePassword = true) {
    const serverDefaults = (initialPayload && typeof initialPayload.core === 'object') ? initialPayload.core : {};
    const defaults = {
        host: (typeof serverDefaults.host === 'string' && serverDefaults.host.trim()) ? serverDefaults.host.trim() : 'localhost',
        port: toPositiveInt(serverDefaults.port, 50051),
        ssh_enabled: true,
        ssh_host: (typeof serverDefaults.ssh_host === 'string' && serverDefaults.ssh_host.trim()) ? serverDefaults.ssh_host.trim() : '',
        ssh_port: toPositiveInt(serverDefaults.ssh_port, 22),
        ssh_username: (typeof serverDefaults.ssh_username === 'string') ? serverDefaults.ssh_username : '',
        auto_start_daemon: !!serverDefaults.auto_start_daemon,
    };
    const serverDefaultVenv = (typeof serverDefaults.venv_bin === 'string' && serverDefaults.venv_bin.trim()) ? serverDefaults.venv_bin.trim() : '';
    const defaultVenvBin = serverDefaultVenv || CORE_DEFAULT_VENV_BIN;
    if (!defaults.ssh_host) defaults.ssh_host = defaults.host;
    const source = (raw && typeof raw === 'object') ? raw : {};
    const out = {
        host: defaults.host,
        port: defaults.port,
        ssh_enabled: true,
        ssh_host: defaults.ssh_host,
        ssh_port: defaults.ssh_port,
        ssh_username: defaults.ssh_username,
        venv_bin: defaultVenvBin,
        auto_start_daemon: defaults.auto_start_daemon,
    };
    if ('host' in source && String(source.host).trim()) {
        out.host = String(source.host).trim();
    }
    out.port = toPositiveInt(source.port, out.port);
    out.ssh_enabled = true;
    if ('ssh_host' in source && String(source.ssh_host).trim()) {
        out.ssh_host = String(source.ssh_host).trim();
    }
    if (!out.ssh_host) {
        out.ssh_host = out.host;
    }
    out.ssh_port = toPositiveInt(source.ssh_port, out.ssh_port);
    if ('ssh_username' in source) {
        out.ssh_username = String(source.ssh_username || '');
    }
    if (includePassword) {
        if ('ssh_password' in source) {
            out.ssh_password = source.ssh_password === null ? '' : String(source.ssh_password);
        } else if (source && typeof source.ssh === 'object' && source.ssh && 'password' in source.ssh) {
            out.ssh_password = String(source.ssh.password || '');
        } else {
            out.ssh_password = '';
        }
    }
    if (!out.ssh_port || !Number.isFinite(out.ssh_port)) {
        out.ssh_port = 22;
    }
    const venvSource = (source.venv_bin ?? source.core_venv_bin);
    if (typeof venvSource === 'string' && venvSource.trim()) {
        out.venv_bin = venvSource.trim();
    }
    if (!out.venv_bin) {
        out.venv_bin = defaultVenvBin;
    }
    out.auto_start_daemon = !!(source.auto_start_daemon ?? out.auto_start_daemon);
    return out;
}

function sanitizeCoreForPersist(coreState) {
    return normalizeCoreState(coreState, false);
}

function mergeCoreSnapshots(primary, secondary) {
    const merged = { ...(primary || {}) };
    if (!secondary || typeof secondary !== 'object') {
        return merged;
    }
    Object.keys(secondary).forEach((key) => {
        const value = secondary[key];
        if (value === undefined) return;
        if (typeof value === 'string') {
            if (!value.trim() && key !== 'ssh_password') return;
            merged[key] = value;
            return;
        }
        if (typeof value === 'number') {
            if (!Number.isFinite(value)) return;
            merged[key] = value;
            return;
        }
        if (typeof value === 'boolean') {
            merged[key] = value;
            return;
        }
        if (value && typeof value === 'object') {
            merged[key] = Array.isArray(value) ? value.slice() : { ...value };
            return;
        }
        merged[key] = value;
    });
    return merged;
}

function restoreCorePasswordFromSession(coreState) {
    const cfg = normalizeCoreState(coreState, true);
    try {
        const stored = sessionStorage.getItem('coretg_core_pw');
        if (stored !== null) {
            cfg.ssh_password = stored;
        }
    } catch (e) {
        /* ignore */
    }
    return cfg;
}

function storeCorePasswordInSession() {
    try {
        const pw = state?.core?.ssh_password ?? '';
        if (pw) {
            sessionStorage.setItem('coretg_core_pw', pw);
        } else {
            sessionStorage.removeItem('coretg_core_pw');
        }
    } catch (e) {
        /* ignore */
    }
}

function getCoreConfig(includePassword = true) {
    const normalized = normalizeCoreState(state?.core || {}, includePassword);
    if (!includePassword && 'ssh_password' in normalized) {
        delete normalized.ssh_password;
    }
    return normalized;
}

function syncGlobalCoreConnection(coreState, testedHost = null, testedPort = null) {
    if (!coreState || typeof coreState !== 'object') return;
    const host = (coreState.grpc_host || '').toString().trim() || 'localhost';
    const portRaw = Number(coreState.grpc_port);
    const port = Number.isFinite(portRaw) && portRaw > 0 ? Number(portRaw) : 50051;
    const sshHostCandidate = (coreState.ssh_host || '').toString().trim();
    const sshHost = sshHostCandidate || host;
    const sshPortRaw = Number(coreState.ssh_port);
    const sshPort = Number.isFinite(sshPortRaw) && sshPortRaw > 0 ? Number(sshPortRaw) : 22;
    const sshUser = (coreState.ssh_username || '').toString();
    const venvBin = (coreState.venv_bin || '').toString().trim();
    const normalized = normalizeCoreState({
        host,
        port,
        ssh_host: sshHost,
        ssh_port: sshPort,
        ssh_username: sshUser,
        venv_bin: venvBin,
        ssh_password: '',
    }, true);
    normalized.ssh_password = '';
    state.core = normalized;
    state.core_ok = true;
    const testedPortNumber = Number(testedPort);
    state.core_tested_host = (testedHost || host || '').toString();
    state.core_tested_port = Number.isFinite(testedPortNumber) && testedPortNumber > 0 ? Number(testedPortNumber) : port;
    try {
        refreshExecuteRemoteToggleState();
    } catch (err) { /* ignore until modal initialized */ }
}

function markGlobalCoreDisconnected() {
    state.core_ok = false;
    state.core_tested_host = null;
    state.core_tested_port = null;
    try {
        refreshExecuteRemoteToggleState();
    } catch (err) { /* ignore until modal initialized */ }
}

function getActiveScenarioContext() {
    const scenarios = Array.isArray(state?.scenarios) ? state.scenarios : [];
    const idx = Number.isInteger(activeIdx) && activeIdx >= 0 && activeIdx < scenarios.length ? activeIdx : null;
    const scenario = (idx !== null) ? scenarios[idx] : null;
    const name = (scenario && typeof scenario.name === 'string') ? scenario.name.trim() : '';
    return { idx, scenario, name };
}

function getActiveScenarioName() {
    return (getActiveScenarioContext().name || '').trim();
}

function buildScenarioAwareUrl(baseUrl, scenarioName = null) {
    if (!baseUrl || typeof baseUrl !== 'string') return baseUrl;
    const sourceName = scenarioName !== null ? scenarioName : getActiveScenarioName();
    const trimmed = (sourceName || '').trim();
    if (!trimmed) return baseUrl;
    try {
        const isAbsolute = /^https?:/i.test(baseUrl);
        const url = new URL(baseUrl, window.location.origin);
        url.searchParams.set('scenario', trimmed);
        return isAbsolute ? url.toString() : `${url.pathname}${url.search}${url.hash}`;
    } catch (e) {
        const sep = baseUrl.includes('?') ? '&' : '?';
        return `${baseUrl}${sep}scenario=${encodeURIComponent(trimmed)}`;
    }
}

function updateActiveScenarioQueryParam() {
    try {
        const { name } = getActiveScenarioContext();
        const trimmed = (name || '').trim();
        const url = new URL(window.location.href);
        const current = (url.searchParams.get('scenario') || '').trim();
        if (trimmed) {
            if (current === trimmed) {
                return;
            }
            url.searchParams.set('scenario', trimmed);
        } else {
            if (!current) {
                return;
            }
            url.searchParams.delete('scenario');
        }
        window.history.replaceState({}, '', url.toString());
    } catch (err) {
        /* ignore */
    }
}

function scheduleScenarioRedirect(baseUrl, options = {}) {
    const delay = Number(options.delay) || 0;
    const scenarioName = typeof options.scenarioName === 'string' ? options.scenarioName : null;
    const targetUrl = buildScenarioAwareUrl(baseUrl, scenarioName) || baseUrl;
    const navigate = () => { window.location.href = targetUrl; };
    if (delay > 0) { setTimeout(navigate, delay); } else { navigate(); }
}

function cloneScenarioCoreFromScenario(scenario, includePassword = true) {
    if (!scenario) return null;
    const hitlState = ensureHitlStateForScenario(scenario);
    if (!hitlState || typeof hitlState !== 'object' || !hitlState.core || typeof hitlState.core !== 'object') {
        return null;
    }
    let clone;
    try {
        clone = JSON.parse(JSON.stringify(hitlState.core));
    } catch (err) {
        clone = { ...hitlState.core };
    }
    if (!includePassword) {
        delete clone.ssh_password;
    }
    return clone;
}

function cloneScenarioCoreByIndex(idx, includePassword = true) {
    if (!Number.isInteger(idx)) return null;
    const scenarios = Array.isArray(state?.scenarios) ? state.scenarios : [];
    if (idx < 0 || idx >= scenarios.length) return null;
    return cloneScenarioCoreFromScenario(scenarios[idx], includePassword);
}

function cloneActiveScenarioCore(includePassword = true) {
    const { scenario } = getActiveScenarioContext();
    return cloneScenarioCoreFromScenario(scenario, includePassword);
}

function formatBytes(value) {
    const num = Number(value);
    if (!Number.isFinite(num) || num <= 0) {
        return '0 B';
    }
    const units = ['B', 'KiB', 'MiB', 'GiB', 'TiB'];
    let idx = 0;
    let current = num;
    while (current >= 1024 && idx < units.length - 1) {
        current /= 1024;
        idx += 1;
    }
    const precision = current >= 10 || idx === 0 ? 0 : 1;
    return `${current.toFixed(precision)} ${units[idx]}`;
}

function appendScenarioContextToFormData(form, options = {}) {
    const { includeCore = true, scenarioIndex = null } = options;
    const { idx: activeIdx, name: activeName } = getActiveScenarioContext();
    const idx = Number.isInteger(scenarioIndex) ? scenarioIndex : activeIdx;
    const scenarios = Array.isArray(state?.scenarios) ? state.scenarios : [];
    const scenario = Number.isInteger(idx) && idx >= 0 && idx < scenarios.length ? scenarios[idx] : null;
    const name = scenario && typeof scenario.name === 'string' ? scenario.name : activeName;
    if (Number.isInteger(idx)) {
        form.append('scenario_index', String(idx));
    }
    if (name) {
        form.append('scenario_name', name);
        form.append('scenario', name);
    }
    if (includeCore) {
        const scenarioCore = cloneScenarioCoreFromScenario(scenario, true);
        if (scenarioCore) {
            form.append('hitl_core_json', JSON.stringify(scenarioCore));
        }
    }
}

function enrichPayloadWithScenarioContext(payload, options = {}) {
    const {
        includeCore = true,
        scenarioIndex = null,
        scenarioOverride = null,
    } = options;
    const scenarios = Array.isArray(state?.scenarios) ? state.scenarios : [];
    let idx = Number.isInteger(scenarioIndex) ? scenarioIndex : null;
    let scenario = scenarioOverride;
    if (!scenario) {
        if (idx !== null && idx >= 0 && idx < scenarios.length) {
            scenario = scenarios[idx];
        } else {
            const { idx: activeIdx, scenario: activeScenario } = getActiveScenarioContext();
            idx = activeIdx;
            scenario = activeScenario;
        }
    }
    if (Number.isInteger(idx)) {
        payload.scenario_index = idx;
    }
    const scenarioName = scenario && typeof scenario.name === 'string' ? scenario.name : '';
    if (scenarioName) {
        payload.scenario = scenarioName;
        payload.scenario_name = scenarioName;
    }
    if (includeCore) {
        const scenarioCore = cloneScenarioCoreFromScenario(scenario, true);
        if (scenarioCore) {
            payload.hitl_core = scenarioCore;
        }
    }
    return payload;
}

function enableAutoStartDaemonPreference() {
    let changed = false;
    if (!state.core) {
        state.core = normalizeCoreState({ auto_start_daemon: true }, true);
        changed = true;
    } else if (!state.core.auto_start_daemon) {
        state.core.auto_start_daemon = true;
        changed = true;
    }
    const { scenario } = getActiveScenarioContext();
    if (scenario) {
        const hitlState = ensureHitlStateForScenario(scenario);
        if (hitlState?.core && hitlState.core.auto_start_daemon !== true) {
            hitlState.core.auto_start_daemon = true;
            changed = true;
        }
    }
    if (changed) {
        try {
            persistEditorState();
            const hidden = document.getElementById('scenarios_json');
            if (hidden) {
                hidden.value = JSON.stringify({ scenarios: state.scenarios, active_index: activeIdx });
            }
        } catch (err) {
            console.warn('Failed to persist auto-start preference', err);
        }
    }
    return true;
}

let persistedActiveIdx = 0;
if (USE_LOCAL_EDITOR_STATE) {
    // Restore persisted editor state (scenarios and last saved xml) and active index from localStorage
    persistedState = projectStateMap[currentProjectKey];
    if (!persistedState && currentProjectKey !== DEFAULT_PROJECT_KEY) {
        persistedState = projectStateMap[DEFAULT_PROJECT_KEY];
    }
    if (!persistedState && scenarioQueryToken) {
        try {
            const matchingKey = Object.keys(projectStateMap || {}).find(key => {
                const entry = projectStateMap[key];
                if (!entry || typeof entry !== 'object') return false;
                const entryScenario = typeof entry.scenario_query === 'string' ? entry.scenario_query.trim() : '';
                return entryScenario && entryScenario === scenarioQueryToken;
            });
            if (matchingKey) {
                persistedState = projectStateMap[matchingKey];
                currentProjectKey = matchingKey;
            }
        } catch (err) {}
    }
    if (!persistedState) {
        const signatureFallback = resolveScenarioQueryHintFromSource(serverEditorSnapshot || initialPayload) || scenarioQueryToken;
        if (signatureFallback) {
            try {
                const signatureKey = `${DEFAULT_PROJECT_KEY}::${signatureFallback.toLowerCase()}`;
                if (projectStateMap[signatureKey]) {
                    currentProjectKey = signatureKey;
                    persistedState = projectStateMap[signatureKey];
                }
            } catch (err) {}
        }
    }
    if (!persistedState) {
        if (serverEditorSnapshot) {
            try {
                persistedState = JSON.parse(JSON.stringify(serverEditorSnapshot));
            } catch (err) {
                persistedState = serverEditorSnapshot;
            }
        }
    }
    const serverSnapshotHasScenarios = Array.isArray(serverEditorSnapshot?.scenarios) && serverEditorSnapshot.scenarios.length > 0;
    const persistedMissingScenarios = (
        !persistedState ||
        !Array.isArray(persistedState.scenarios) ||
        !persistedState.scenarios.length
    );
    if (persistedMissingScenarios && serverSnapshotHasScenarios) {
        try {
            const snapshotClone = JSON.parse(JSON.stringify(serverEditorSnapshot));
            if (snapshotClone) {
                persistedState = snapshotClone;
            }
        } catch (err) {
            persistedState = serverEditorSnapshot;
        }
    }
    if (!persistedState) {
        persistedState = legacyEditorState;
    }
    persistedState = scrubSnapshotTransientErrors(persistedState);
    const activeIdxCandidateRaw = activeIdxMap[currentProjectKey];
    if (activeIdxCandidateRaw !== undefined) {
        const parsedIdx = parseInt(activeIdxCandidateRaw, 10);
        if (!isNaN(parsedIdx)) persistedActiveIdx = parsedIdx;
    } else {
        try { const v = parseInt(localStorage.getItem('coretg_active_idx')||'0',10); if(!isNaN(v)) persistedActiveIdx = v; } catch(e){}
    }
} else {
    persistedState = null;
}

// Base state is from server payload or default
let state = initialPayload ?? { scenarios: [ defaultScenario('Scenario 1') ], result_path: null };
if (!Array.isArray(state.host_interfaces)) {
    if (Array.isArray(initialPayload?.host_interfaces)) {
        state.host_interfaces = initialPayload.host_interfaces;
    } else if (USE_LOCAL_EDITOR_STATE && Array.isArray(persistedState?.host_interfaces)) {
        state.host_interfaces = persistedState.host_interfaces;
    } else {
        state.host_interfaces = [];
    }
}
const persistedHostMeta = USE_LOCAL_EDITOR_STATE ? persistedState : null;
state.host_interfaces_source = initialPayload?.host_interfaces_source ?? persistedHostMeta?.host_interfaces_source ?? state.host_interfaces_source ?? null;
state.host_interfaces_metadata = initialPayload?.host_interfaces_metadata ?? persistedHostMeta?.host_interfaces_metadata ?? state.host_interfaces_metadata ?? null;
state.host_interfaces_fetched_at = initialPayload?.host_interfaces_fetched_at ?? persistedHostMeta?.host_interfaces_fetched_at ?? state.host_interfaces_fetched_at ?? null;
// If server provided a concrete result_path (save/load/run), prefer server scenarios; else, restore from localStorage if available
const serverHasResult = !!(initialPayload && initialPayload.result_path);
const serverScenarioBases = Array.isArray(initialPayload?.scenarios)
    ? initialPayload.scenarios.map(s => {
        if (!s || typeof s !== 'object' || !s.base || typeof s.base !== 'object') return undefined;
        const meta = {};
        if (typeof s.base.filepath === 'string') meta.filepath = s.base.filepath;
        if (typeof s.base.display_name === 'string') meta.display_name = s.base.display_name;
        return Object.keys(meta).length ? meta : undefined;
    })
    : [];
if (USE_LOCAL_EDITOR_STATE && !serverHasResult && persistedState && Array.isArray(persistedState.scenarios) && persistedState.scenarios.length) {
    state.scenarios = persistedState.scenarios;
    if (persistedState.result_path) state.result_path = persistedState.result_path;
    if (serverScenarioBases.length) {
        serverScenarioBases.forEach((serverMeta, idx) => {
            if (!serverMeta) return;
            if (!state.scenarios[idx]) return;
            const scen = state.scenarios[idx];
            if (!scen.base || typeof scen.base !== 'object') scen.base = {};
            scen.base.filepath = (serverMeta.filepath || '');
            if ('display_name' in serverMeta) {
                scen.base.display_name = serverMeta.display_name;
            } else if (scen.base.display_name) {
                delete scen.base.display_name;
            }
        });
    }
}

if (USE_LOCAL_EDITOR_STATE && persistedState && Array.isArray(persistedState.scenarios) && Array.isArray(state.scenarios)) {
    mergePersistedHitlStateIntoScenarios(state.scenarios, persistedState.scenarios);
}
const serverBaseUpload = normalizeBaseUpload(initialPayload?.base_upload);
const persistedBaseUpload = USE_LOCAL_EDITOR_STATE ? normalizeBaseUpload(persistedState?.base_upload) : null;
if (USE_LOCAL_EDITOR_STATE && !serverHasResult && persistedBaseUpload && (!state.base_upload || !state.base_upload.path)) {
    if (state.scenarios?.[0] && state.scenarios[0].base && (state.scenarios[0].base.filepath || state.scenarios[0].base.display_name)) {
        state.base_upload = { ...persistedBaseUpload };
    }
}
if (serverBaseUpload) {
    state.base_upload = { ...serverBaseUpload };
}
if (state.base_upload && state.scenarios?.[0]) {
    const scenBase = (typeof state.scenarios[0].base === 'object' && state.scenarios[0].base) ? state.scenarios[0].base : (state.scenarios[0].base = {});
    if (!scenBase.filepath && state.base_upload.path) {
        scenBase.filepath = state.base_upload.path;
    }
    if (!scenBase.display_name) {
        if (state.base_upload.display_name) scenBase.display_name = state.base_upload.display_name;
        else if (scenBase.filepath) scenBase.display_name = scenBase.filepath.split(/[/\\]/).pop() || '';
    }
}
if (state.base_upload) {
    if (!state.base_upload.display_name) {
        const fallback = state.scenarios?.[0]?.base?.display_name || (state.base_upload.path ? state.base_upload.path.split(/[/\\]/).pop() : '');
        if (fallback) state.base_upload.display_name = fallback;
    }
    if (!state.base_upload.path && state.scenarios?.[0]?.base?.filepath) {
        state.base_upload.path = state.scenarios[0].base.filepath;
    }
}

function getScenarioByIndex(idx) {
    const scenarios = Array.isArray(state?.scenarios) ? state.scenarios : [];
    if (!Number.isInteger(idx) || idx < 0 || idx >= scenarios.length) {
        return null;
    }
    return scenarios[idx];
}

function resolveScenarioQueryHint() {
    try {
        const token = (scenarioQueryToken || '').trim();
        if (token) return token;
        const signature = deriveScenarioSignature(state);
        if (signature) {
            scenarioQueryToken = signature;
            return signature;
        }
    } catch (err) {
        /* ignore */
    }
    return (scenarioQueryToken || '').trim();
}

const resolveScenarioQueryHintFromSnapshot = resolveScenarioQueryHintFromSource;

(state.scenarios || []).forEach(ensureHitlStateForScenario);
// Clear any stale in-flight flags persisted from a previous session/tab so UI doesn't show a busy state on load
try {
    (state.scenarios || []).forEach((scen) => {
        if (!scen || typeof scen !== 'object') return;
        const hitl = scen.hitl && typeof scen.hitl === 'object' ? scen.hitl : null;
        const core = hitl && typeof hitl.core === 'object' ? hitl.core : null;
        if (core && core.interfaces_refresh_inflight === true) {
            core.interfaces_refresh_inflight = false;
        }
    });
} catch (e) { /* ignore */ }

// Preview workflow state (in-memory only; persisted history handled separately)
let serverSnapshotPendingPayload = null;
let serverSnapshotTimerId = null;
let serverSnapshotDisabled = false;

async function transmitEditorSnapshotToServer(payload) {
    if (!payload || serverSnapshotDisabled) return;
    try {
        const resp = await fetch('/api/editor_snapshot', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            credentials: 'same-origin',
            body: JSON.stringify(payload),
        });
        if (resp.status === 401) {
            serverSnapshotDisabled = true;
            return;
        }
        if (!resp.ok) {
            const detail = await resp.text().catch(() => '');
            throw new Error(detail || `HTTP ${resp.status}`);
        }
    } catch (err) {
        console.warn('Failed to persist editor snapshot on server', err);
    }
}

function scheduleServerSnapshotPersist(snapshot) {
    if (!snapshot || typeof snapshot !== 'object') {
        return;
    }
    if (serverSnapshotDisabled) {
        return;
    }
    try {
        serverSnapshotPendingPayload = JSON.parse(JSON.stringify(snapshot));
    } catch (err) {
        console.warn('Unable to serialize editor snapshot for server persistence', err);
        return;
    }
    if (serverSnapshotTimerId) {
        window.clearTimeout(serverSnapshotTimerId);
    }
    serverSnapshotTimerId = window.setTimeout(() => {
        const payload = serverSnapshotPendingPayload;
        serverSnapshotPendingPayload = null;
        serverSnapshotTimerId = null;
        if (!payload) {
            return;
        }
        transmitEditorSnapshotToServer(payload);
    }, 900);
}

let previewState = {
    fullPreview: null,
    fullPreviewHistory: [],
    xmlSaved: !!(state.result_path),
    dirty: false,
    coreTested: false
};
const FULL_PREVIEW_ARTIFACT_VERSION = 2;

function safeClone(value){
    if(value === null || typeof value !== 'object') return value;
    try { return structuredClone(value); }
    catch(e){
        try { return JSON.parse(JSON.stringify(value)); }
        catch(err){ return value; }
    }
}

function summarizeSegRule(rule){
    if(!rule) return '';
    const type = rule.type || rule.action || '';
    if(type === 'nat'){
        const mode = rule.mode ? `${rule.mode} ` : '';
        const internal = rule.internal || rule.internal_subnet || '';
        const external = rule.external || rule.external_subnet || '';
        return `${mode}${internal}${(internal && external)?' -> ':''}${external}`.trim();
    }
    if(type === 'host_block'){
        const src = rule.src || rule.source || '';
        const dst = rule.dst || rule.destination || '';
        return `${src} X ${dst}`.trim();
    }
    if(type === 'custom'){
        return rule.description || 'custom';
    }
    if(type){
        const src = rule.src || rule.source;
        const dst = rule.dst || rule.destination;
        if(src || dst){
            return `${type}: ${src || '*'} -> ${dst || '*'}`;
        }
        return type;
    }
    return '';
}

function buildSegmentationArtifacts(full){
    const seg = (full && full.segmentation_preview) || {};
    const rawRules = Array.isArray(seg.rules) ? seg.rules : [];
    const meta = safeClone(seg);
    if(meta && typeof meta === 'object') delete meta.rules;
    if(!rawRules.length){
        return {
            rows: [],
            tableRows: [],
            table_rows: [],
            json: {
                rules_count: 0,
                types_summary: {},
                rules: [],
                metadata: meta || null
            }
        };
    }
    const summaries = [];
    const tableRows = [];
    const typeCounts = {};
    for(const rawEntry of rawRules){
        const entry = safeClone(rawEntry);
        if(!entry || typeof entry !== 'object') continue;
        const rule = ('rule' in entry && entry.rule) ? safeClone(entry.rule) : safeClone(entry);
        if(!rule || typeof rule !== 'object') continue;
        const nodeId = (entry.node_id !== undefined) ? entry.node_id : (rule.node_id !== undefined ? rule.node_id : null);
        const typeRaw = (rule.type !== undefined && rule.type !== null) ? rule.type : rule.action;
        const type = (typeRaw !== undefined && typeRaw !== null) ? String(typeRaw) : null;
        const summary = summarizeSegRule(rule);
        const src = (rule.src !== undefined && rule.src !== null) ? rule.src : rule.source;
        const dst = (rule.dst !== undefined && rule.dst !== null) ? rule.dst : rule.destination;
        const internal = (rule.internal !== undefined && rule.internal !== null) ? rule.internal : rule.internal_subnet;
        const external = (rule.external !== undefined && rule.external !== null) ? rule.external : rule.external_subnet;
        const proto = (rule.proto !== undefined && rule.proto !== null) ? rule.proto : rule.protocol;
        const port = (rule.port !== undefined) ? rule.port : null;
        const scriptPath = typeof entry.script === 'string' ? entry.script : (typeof rule.script === 'string' ? rule.script : null);
        const scriptName = scriptPath ? scriptPath.split('/').pop() : null;
        const tableRow = {
            node_id: nodeId,
            type,
            summary,
            src: src ?? null,
            dst: dst ?? null,
            subnet: rule.subnet ?? null,
            internal: internal ?? null,
            external: external ?? null,
            proto: proto ?? null,
            port,
            script_path: scriptPath || null,
            script_name: scriptName || null,
            detail: rule
        };
        tableRows.push(tableRow);
        summaries.push({ node_id: nodeId, type, summary });
        const key = type || 'unknown';
        typeCounts[key] = (typeCounts[key] || 0) + 1;
    }
    return {
        rows: summaries,
        tableRows,
        table_rows: tableRows,
        json: {
            rules_count: tableRows.length,
            types_summary: typeCounts,
            rules: tableRows.map(row => ({ node_id: row.node_id, type: row.type, summary: row.summary, detail: safeClone(row.detail) })),
            metadata: meta || null
        }
    };
}

function buildFullPreviewArtifacts(full){
    if(!full) return { segmentation: buildSegmentationArtifacts(full) };
    if(full.__displayArtifactsVersion === FULL_PREVIEW_ARTIFACT_VERSION && full.__displayArtifacts){
        return full.__displayArtifacts;
    }
    let artifacts = null;
    if(full.display_artifacts_version === FULL_PREVIEW_ARTIFACT_VERSION && full.display_artifacts){
        artifacts = safeClone(full.display_artifacts);
    }
    if(!artifacts || !artifacts.segmentation){
        artifacts = { segmentation: buildSegmentationArtifacts(full) };
    } else {
        const seg = artifacts.segmentation;
        if(!seg.tableRows || !seg.table_rows || !Array.isArray(seg.rows)){
            artifacts.segmentation = buildSegmentationArtifacts(full);
        }
    }
    artifacts.__version = FULL_PREVIEW_ARTIFACT_VERSION;
    try {
        Object.defineProperty(full, '__displayArtifacts', { value: artifacts, enumerable: false, configurable: true, writable: true });
        Object.defineProperty(full, '__displayArtifactsVersion', { value: FULL_PREVIEW_ARTIFACT_VERSION, enumerable: false, configurable: true, writable: true });
    } catch(e){
        full.__displayArtifacts = artifacts;
        full.__displayArtifactsVersion = FULL_PREVIEW_ARTIFACT_VERSION;
    }
    return artifacts;
}
// Core settings: prefer server-provided if present; otherwise restore from persisted
// ---------------- Plan Workflow State -----------------
// (Legacy alias cleanup left intentionally blank. Using previewState below.)

// ---------- Full Preview History Persistence ----------
function loadFullPreviewHistory(){
    try { previewState.fullPreviewHistory = JSON.parse(localStorage.getItem('coretg_full_preview_history')||'[]'); } catch(e){ previewState.fullPreviewHistory = []; }
    if(!Array.isArray(previewState.fullPreviewHistory)) previewState.fullPreviewHistory = [];
}
function saveFullPreviewHistory(){
    try { localStorage.setItem('coretg_full_preview_history', JSON.stringify(previewState.fullPreviewHistory.slice(-25))); } catch(e){}
}
loadFullPreviewHistory();

// Run progress modal state (hoisted early to avoid TDZ issues)
let runProgressModalInst = null;
let runProgressEvtSrc = null;
let runProgressRunId = null;

function setupPreviewModalExecute(modalEl, modalInstance){
    if(!modalEl) return;
    const execBtn = modalEl.querySelector('#previewModalExecuteBtn');
    if(!execBtn) return;
    if(execBtn.dataset.enhanced === '1') return;
    execBtn.dataset.enhanced = '1';
    execBtn.addEventListener('click', async () => {
        if(execBtn.disabled) return;
        execBtn.disabled = true;
        execBtn.classList.add('disabled');
        let modalHidden = false;
        const forceHideModal = () => {
            try { modalInstance?.hide(); } catch(e){}
            if(modalEl){
                modalEl.classList.remove('show');
                modalEl.setAttribute('aria-hidden','true');
                modalEl.style.display = 'none';
            }
            // Remove any lingering backdrop only if no other modals remain visible
            const openModals = document.querySelectorAll('.modal.show');
            if(openModals.length === 0){
                document.querySelectorAll('.modal-backdrop').forEach(b => {
                    try { b.remove(); } catch(e){}
                });
                document.body.classList.remove('modal-open');
                document.body.style.removeProperty('paddingRight');
                document.body.style.removeProperty('overflow');
            }
        };
        const restoreModal = () => {
            try {
                if(modalInstance){
                    modalInstance.show();
                } else if(modalEl){
                    modalEl.style.display = 'block';
                    modalEl.classList.add('show');
                    document.body.classList.add('modal-open');
                }
            } catch(e){}
        };
        const hideModalForConfirm = async () => {
            if(modalHidden) return;
            forceHideModal();
            modalHidden = true;
            await new Promise(resolve => requestAnimationFrame(() => resolve()));
        };
        const restoreModalIfHidden = () => {
            if(!modalHidden) return;
            modalHidden = false;
            restoreModal();
        };
        const waitForPaint = async () => {
            await new Promise(resolve => requestAnimationFrame(() => resolve()));
        };
        try {
            const execInfo = detectLocalEmulation();
            const confirmMsg = 'Execute this scenario now? This will start a CORE session.';
            const { idx: scenarioIdx } = getActiveScenarioContext();
            await hideModalForConfirm();
            const confirmResult = await promptExecuteConfirmation({
                message: confirmMsg,
                scenarioIndex: scenarioIdx,
                alertMessage: '',
                alertTone: 'info',
                keepOpenOnConfirm: true,
            });
            const updateRemoteRepo = !!confirmResult?.updateRemote;
            if(!confirmResult?.confirmed){
                restoreModalIfHidden();
                execBtn.disabled = false;
                execBtn.classList.remove('disabled');
                return;
            }
            await waitForPaint();
            await new Promise(resolve => setTimeout(resolve, 0));
            showExecuteProgressPanel(
                execInfo.shouldFake ? 'Local emulation run' : 'Preparing CORE run…',
                execInfo.shouldFake
                    ? 'CORE connection unavailable; running locally.'
                    : (IS_BUILDER_VIEW ? 'Remote CORE backend managed by admin.' : `CORE ${execInfo.host}:${execInfo.port}`)
            );
            try {
                const showBtn = document.getElementById('dockShowBtn');
                if(showBtn && !showBtn.classList.contains('d-none')) showBtn.click();
            } catch(e){}

            let launchFailed = false;
            const result = await runSyncWithModal({
                showProgressModal: false,
                skipConfirm: true,
                scenarioIndex: scenarioIdx,
                updateRemoteRepo,
                confirmResult,
                advanced: confirmResult?.advanced,
                onRunId: (runId) => {
                    bindExecuteProgressToRun(runId);
                },
                onTick: (data) => {
                    if(data && !data.done){
                        setExecuteProgressStatus('Running CLI…', 'Streaming logs…');
                    }
                },
                onComplete: (data) => {
                    if(data?.returncode === 0){
                        completeExecuteProgressPanel(true, 'Scenario started', 'Redirecting to reports…');
                        try {
                            setTimeout(()=>{
                                if(executeConfirmModalEl && window.bootstrap){
                                    bootstrap.Modal.getOrCreateInstance(executeConfirmModalEl).hide();
                                }
                            }, 200);
                        } catch(e){}
                        try {
                            scheduleScenarioRedirect("{{ url_for('reports_page') }}", { delay: 500 });
                        } catch(e){}
                    } else {
                        completeExecuteProgressPanel(false, 'Finished with errors', 'Check logs for details.');
                    }
                    try {
                        if(data?.returncode !== 0){
                            restoreModal();
                        }
                    } catch(e){}
                },
                onError: (err) => {
                    const detail = (err && err.message) ? err.message : 'Unable to launch CLI';
                    completeExecuteProgressPanel(false, 'Failed to start', detail);
                    launchFailed = true;
                    restoreModal();
                },
            });
            if(result === false){
                if(!launchFailed){
                    completeExecuteProgressPanel(false, 'Failed to start', 'Request aborted');
                    restoreModal();
                }
                return;
            }
        } catch(err){
            console.error('Preview execute failed', err);
            closeRunProgress();
            restoreModal();
        } finally {
            execBtn.disabled = false;
            execBtn.classList.remove('disabled');
        }
    });
}

function updatePlanButtons(){
    const previewBtn = document.getElementById('planPreviewBtn');
    const statusBadge = document.getElementById('planStatusBadge');
    const hint = document.getElementById('planHint');
    const genBtn = document.getElementById('runSyncBtn');
    const xmlPathVal = (state.result_path || '').trim();
    previewState.xmlSaved = !!xmlPathVal;
    const canPreview = previewState.xmlSaved || previewState.dirty;
    if(previewBtn) previewBtn.disabled = !canPreview;
    if(genBtn) genBtn.disabled = !canPreview;
    if(hint){
    if(!previewState.xmlSaved) hint.textContent = 'Save XML to enable planning.';
    else hint.textContent = previewState.fullPreview ? 'Full preview ready.' : 'Generate a full preview.';
    }
    if(statusBadge){
    statusBadge.className = 'badge ' + (previewState.fullPreview ? 'text-bg-info' : 'text-bg-secondary');
    statusBadge.textContent = previewState.fullPreview ? 'Preview' : 'No Preview';
    }
}


function showPlanSummary(summary){
    const pre = document.getElementById('planPreviewJson');
    if(!pre) return;
    pre.classList.remove('d-none');
    try{ pre.textContent = JSON.stringify(summary, null, 2); }catch(e){ pre.textContent='(error displaying plan)'; }
}

async function computePlanPreview(){
    // Deprecated lightweight preview replaced by full preview; delegate
    return computeFullPlanPreview();
}

// Approval functions removed

function onCoreTestedSuccess(){ previewState.coreTested = true; updatePlanButtons(); }

// Hook into existing CORE test result update
const originalUpdateCoreStatus = window.updateCoreStatus; // if defined later, we patch after definition
window.updateCoreStatus = function(success, msg){
    if(typeof originalUpdateCoreStatus === 'function') originalUpdateCoreStatus(success, msg);
    if(success) onCoreTestedSuccess();
};

document.addEventListener('DOMContentLoaded', () => {
    document.getElementById('planPreviewBtn')?.addEventListener('click', computePlanPreview);
    // Repurpose Run CLI button to invoke Full Preview logic
    document.getElementById('runSyncBtn')?.addEventListener('click', ()=>{
        // Mirror enablement guard from preview button
        if(document.getElementById('planPreviewBtn')?.disabled){
            logWarn('Full Preview disabled; cannot run');
            return;
        }
        computePlanPreview();
    });
    try { updatePlanButtons(); } catch(e){}
});

async function computeFullPlanPreview(){
    const xmlPathVal = (state.result_path || '').trim();
    if(!xmlPathVal){
        try { await autoSaveXml(); } catch(e){ alert('Auto-save failed: '+e); return; }
    }
    const newXmlPath = (state.result_path || '').trim();
    if(!newXmlPath){ alert('XML path still unavailable after save.'); return; }
    const btn = document.getElementById('planPreviewBtn');
    const pre = document.getElementById('planPreviewJson');
    btn.disabled = true; btn.dataset.prevLabel = btn.textContent; btn.textContent='Full preview...';
    pre.classList.remove('d-none'); pre.textContent='Computing full preview...';
    try {
    // Collect routing row host-per-switch overrides (min/max)
    let r2sHostsMinList = [];
    let r2sHostsMaxList = [];
    try {
        const scen = state.scenarios[0];
        if (scen && scen.sections && scen.sections['Routing']) {
            (scen.sections['Routing'].items || []).forEach(it => {
                    if (id) {
                        const escapedId = (window.CSS && typeof window.CSS.escape === 'function') ? window.CSS.escape(id) : id;
                        const lbl = coreConnectionForm.querySelector(`label[for="${escapedId}"]`);
                }
            });
        }
                    coreState.core_secret_id = null;
                    coreState.validated = false;
                    coreState.last_validated_at = null;
                    coreState.stored_summary = null;
    } catch(e) { /* ignore */ }
    const body = enrichPayloadWithScenarioContext({ xml_path: newXmlPath, r2s_hosts_min_list: r2sHostsMinList, r2s_hosts_max_list: r2sHostsMaxList, core: getCoreConfig(true) });
        const res = await fetch('/api/plan/preview_full', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(body) });
        const data = await res.json();
        try {
            if(window.logLine){ window.logLine('INFO', 'Preview: response received; parsing plan summary'); }
        } catch(e){}
    if(!data.ok){ pre.textContent='Full preview failed: '+(data.error||''); previewState.fullPreview=null; document.getElementById('fullPreviewStructured')?.classList.add('d-none'); }
        else {
            previewState.fullPreview = data.full_preview;
            buildFullPreviewArtifacts(previewState.fullPreview);
            pre.textContent = JSON.stringify(previewState.fullPreview, null, 2);
            renderFullPreviewStructured();
            // Emit detailed calculation logs into dock
            try {
                const fp = previewState.fullPreview || {};
                // Traffic breakdown
                try {
                    if(fp.traffic_summary){
                        const ts = fp.traffic_summary;
                        const flows = ts.total_flows || ts.flows || 'n/a';
                        window.logLine && window.logLine('INFO', `[preview.plan.traffic] flows=${flows}`);
                    }
                } catch(e){}
            } catch(e){ /* ignore logging issues */ }
            try { showFullPreviewModal(previewState.fullPreview); } catch(e){ console.warn('Modal render failed', e); }
            // Append to history
            try {
                const fp = previewState.fullPreview;
                previewState.fullPreviewHistory.push({
                    ts: Date.now(),
                    seed: fp.seed,
                    seed_generated: fp.seed_generated,
                    stats: {
                        routers: (fp.routers||[]).length,
                        hosts: (fp.hosts||[]).length,
                        switches: (fp.switches||[]).length,
                        r2r_edges: (fp.r2r_edges_preview||[]).length,
                        seg_rules: (fp.segmentation_preview && fp.segmentation_preview.rules ? fp.segmentation_preview.rules.length : 0)
                    },
                    preview: fp
                });
                saveFullPreviewHistory();
            } catch(e){}
        }
    } catch(e){ pre.textContent='Error: '+e; previewState.fullPreview=null; }
    btn.disabled = false; btn.textContent = btn.dataset.prevLabel || 'Full Preview';
}

function renderFullPreviewStructured(){
    const wrap = document.getElementById('fullPreviewStructured');
    if(!wrap) return;
    const full = previewState.fullPreview;
    if(!full){ wrap.classList.add('d-none'); return; }
    wrap.classList.remove('d-none');
    const tabsEl = document.getElementById('fullPreviewSectionTabs');
    const contentEl = document.getElementById('fullPreviewSectionContent');
    if(!tabsEl || !contentEl) return;
    const sections = [
        { id:'overview', label:'Overview' },
        { id:'routers', label:`Routers (${(full.routers||[]).length})` },
        { id:'hosts', label:`Hosts (${(full.hosts||[]).length})` },
        { id:'switches', label:`Switches (${(full.switches||[]).length})` },
        { id:'subnets', label:'Subnets' },
        { id:'r2r', label:`R2R Edges (${(full.r2r_edges_preview||[]).length})` },
        { id:'seg', label:`Seg Rules (${(full.segmentation_preview && full.segmentation_preview.rules ? full.segmentation_preview.rules.length : 0)})` },
        { id:'services_bd', label:'Services Plan' },
        { id:'vuln_bd', label:'Vuln Plan' },
        { id:'seg_bd', label:'Seg Plan' },
        { id:'router_bd', label:'Router Plan' },
        { id:'traffic_bd', label:'Traffic Plan' },
        { id:'history', label:'History' },
    ];
    // Build tabs
    tabsEl.innerHTML = '';
    sections.forEach((s, idx) => {
        const b = document.createElement('button');
        b.type='button'; b.className='btn btn-outline-primary' + (idx===0?' active':'');
        b.textContent = s.label;
        b.dataset.section = s.id;
        b.onclick = () => { tabsEl.querySelectorAll('button').forEach(x=>x.classList.remove('active')); b.classList.add('active'); renderSectionContent(s.id); };
        tabsEl.appendChild(b);
    });
    function esc(x){ return (''+x).replace(/[&<>]/g,c=>({'&':'&amp;','<':'&lt;','>':'&gt;'}[c])); }
    function renderSectionContent(id){
        if(id==='overview'){
            const stats = [
                ['Routers', (full.routers||[]).length],
                ['Hosts', (full.hosts||[]).length],
                ['Switches', (full.switches||[]).length],
                ['R2R Edges', (full.r2r_edges_preview||[]).length],
                ['Avg R2R Deg', full.r2r_stats_preview && full.r2r_stats_preview.avg],
                ['Seg Rules', full.segmentation_preview && full.segmentation_preview.rules ? full.segmentation_preview.rules.length : 0],
                ['P2P /24', (full.ptp_subnets||[]).length],
                ['Router-Sw /24', (full.router_switch_subnets||[]).length],
                ['LAN /24', (full.lan_subnets||[]).length],
                // Seed removed from UI summary
            ];
            contentEl.innerHTML = '<div class="row g-2">' + stats.map(s=>`<div class="col-auto"><span class="badge text-bg-secondary">${esc(s[0])}: ${esc(s[1]??'-')}</span></div>`).join('') + '</div>';
            return;
        }
        if(id==='routers'){
            contentEl.innerHTML = tableFromObjects(full.routers || [], ['node_id','name','ip4']); return;
        }
        if(id==='hosts'){
            contentEl.innerHTML = tableFromObjects(full.hosts || [], ['node_id','name','role','ip4']); return;
        }
        if(id==='switches'){
            const rows = full.switches_detail || [];
            contentEl.innerHTML = tableFromObjects(rows, ['switch_id','router_id','hosts','rsw_subnet','lan_subnet']); return;
        }
        if(id==='subnets'){
            const p2p = (full.ptp_subnets||[]).map(s=>`<li>${esc(s)}</li>`).join('');
            const rs = (full.router_switch_subnets||[]).map(s=>`<li>${esc(s)}</li>`).join('');
            const lan = (full.lan_subnets||[]).map(s=>`<li>${esc(s)}</li>`).join('');
            contentEl.innerHTML = `<div class="row small g-3"><div class="col"><h6 class="fw-bold">Host P2P (/24)</h6><ul class="mb-0">${p2p||'<li>(none)</li>'}</ul></div><div class="col"><h6 class="fw-bold">Router-Switch (/24)</h6><ul class="mb-0">${rs||'<li>(none)</li>'}</ul></div><div class="col"><h6 class="fw-bold">LAN (/24)</h6><ul class="mb-0">${lan||'<li>(none)</li>'}</ul></div></div>`; return;
        }
        if(id==='r2r'){
            const edges = full.r2r_edges_preview || [];
            const deg = full.r2r_degree_preview || {};
            const degList = Object.entries(deg).map(([k,v])=>`r${k}:${v}`).join(', ');
            const spark = Object.values(deg).join(' ');
            const edgesSample = edges.slice(0,200).map(e=>`(${e[0]}-${e[1]})`).join(' ');
            contentEl.innerHTML = `<div><div class="mb-2"><strong>Degree Stats:</strong> ${esc(JSON.stringify(full.r2r_stats_preview||{}))}</div><div class="mb-2"><strong>Degrees:</strong> ${esc(degList||'(none)')}</div><div class="mb-2"><strong>Edges (${edges.length}):</strong> ${esc(edgesSample||'(none)')} ${edges.length>200?'...':''}</div><div><strong>Spark:</strong> ${esc(spark)}</div></div>`; return;
        }
        if(id==='seg'){
            const artifacts = buildFullPreviewArtifacts(full);
            const segRows = (artifacts && artifacts.segmentation && artifacts.segmentation.rows) || [];
            contentEl.innerHTML = tableFromObjects(segRows, ['node_id','type','summary']);
            return;
        }
        if(id==='router_bd'){
            const rp = (full.router_plan)||{};
            contentEl.innerHTML = `<pre class="small mb-0">${esc(JSON.stringify(rp,null,2))}</pre>`; return;
        }
        if(id==='services_bd'){
            const sp = (full.services_plan)||{};
            contentEl.innerHTML = `<pre class="small mb-0">${esc(JSON.stringify(sp,null,2))}</pre>`; return;
        }
        if(id==='vuln_bd'){
            const vp = (full.vulnerabilities_plan)||{};
            contentEl.innerHTML = `<pre class="small mb-0">${esc(JSON.stringify(vp,null,2))}</pre>`; return;
        }
        if(id==='seg_bd'){
            const sb = (full.segmentation_preview)||{};
            contentEl.innerHTML = `<pre class="small mb-0">${esc(JSON.stringify(sb,null,2))}</pre>`; return;
        }
        if(id==='traffic_bd'){
            const tp = (full.traffic_summary)||{};
            contentEl.innerHTML = `<pre class="small mb-0">${esc(JSON.stringify(tp,null,2))}</pre>`; return;
        }
        if(id==='history'){
            renderPreviewHistory(contentEl, full);
            return;
        }
        contentEl.textContent='Unknown section';
    }
    function tableFromObjects(arr, cols){
        if(!arr.length) return '<div class="text-muted fst-italic">(none)</div>';
        const head = '<thead><tr>' + cols.map(c=>`<th>${esc(c)}</th>`).join('') + '</tr></thead>';
        const body = '<tbody>' + arr.map(o=>'<tr>'+cols.map(c=>`<td>${esc((o[c]!==undefined && o[c]!==null)? (Array.isArray(o[c])? o[c].join(','): o[c]): '')}</td>`).join('')+'</tr>').join('') + '</tbody>';
        return `<div class="table-responsive"><table class="table table-sm table-bordered mb-0">${head}${body}</table></div>`;
    }
    // Initial load
    renderSectionContent('overview');
    // Wire toggle button
    const toggleBtn = document.getElementById('toggleRawFullPreviewBtn');
    if(toggleBtn){
        toggleBtn.onclick = () => {
            const raw = document.getElementById('planPreviewJson');
            const struct = document.getElementById('fullPreviewStructured');
            if(raw.classList.contains('d-none')){ raw.classList.remove('d-none'); toggleBtn.textContent='Structured'; }
            else { raw.classList.add('d-none'); toggleBtn.textContent='Raw JSON'; }
        };
    }
    // Seed copy button removed
}

function renderPreviewHistory(contentEl, currentFull){
    loadFullPreviewHistory();
    if(!previewState.fullPreviewHistory.length){ contentEl.innerHTML = '<div class="text-muted fst-italic">No previous full previews</div>'; return; }
    function esc(x){ return (''+x).replace(/[&<>]/g,c=>({'&':'&amp;','<':'&lt;','>':'&gt;'}[c])); }
    const rows = previewState.fullPreviewHistory.slice().reverse().map((rec,idx) => {
        const dt = new Date(rec.ts).toLocaleTimeString();
        const diffBtn = `<button class="btn btn-sm btn-outline-primary" data-action="diff" data-seed="${esc(rec.seed)}">Diff</button>`;
        return `<tr><td>${idx+1}</td><td>${esc(rec.seed)}</td><td>${esc(rec.stats.routers)}/${esc(rec.stats.hosts)}/${esc(rec.stats.switches)}</td><td>${esc(rec.stats.r2r_edges)}</td><td>${esc(rec.stats.seg_rules)}</td><td>${dt}</td><td class="text-nowrap">${diffBtn}</td></tr>`;
    }).join('');
    contentEl.innerHTML = `<div class="table-responsive"><table class="table table-sm table-bordered mb-2"><thead><tr><th>#</th><th>Seed</th><th>R/H/S</th><th>R2R</th><th>Seg</th><th>Time</th><th></th></tr></thead><tbody>${rows}</tbody></table></div><div id="previewDiffOutput" class="small"></div>`;
    // Seed load buttons removed
    contentEl.querySelectorAll('button[data-action="diff"]').forEach(btn => {
        btn.addEventListener('click', () => { const seed = btn.getAttribute('data-seed'); const rec = previewState.fullPreviewHistory.find(r=> String(r.seed)===seed); if(!rec){ return; } const diffHtml = buildPreviewDiff(rec.preview, currentFull); document.getElementById('previewDiffOutput').innerHTML = diffHtml; });
    });
}

function buildPreviewDiff(a,b){
    const metrics = [
        ['Routers', (a.routers||[]).length, (b.routers||[]).length],
        ['Hosts', (a.hosts||[]).length, (b.hosts||[]).length],
        ['Switches', (a.switches||[]).length, (b.switches||[]).length],
        ['R2R Edges', (a.r2r_edges_preview||[]).length, (b.r2r_edges_preview||[]).length],
        ['Seg Rules', (a.segmentation_preview && a.segmentation_preview.rules ? a.segmentation_preview.rules.length : 0), (b.segmentation_preview && b.segmentation_preview.rules ? b.segmentation_preview.rules.length : 0)]
    ];
    function esc(x){ return (''+x).replace(/[&<>]/g,c=>({'&':'&amp;','<':'&lt;','>':'&gt;'}[c])); }
    const rows = metrics.map(m => { const delta = m[2]-m[1]; const cls = delta===0?'text-secondary':(delta>0?'text-success':'text-danger'); return `<tr><td>${esc(m[0])}</td><td>${esc(m[1])}</td><td>${esc(m[2])}</td><td class="${cls}">${delta>0?'+':''}${esc(delta)}</td></tr>`; }).join('');
    return `<div class="card border-info"><div class="card-header py-1 small">Diff vs current preview</div><div class="card-body p-2"><div class="table-responsive"><table class="table table-sm table-bordered mb-0"><thead><tr><th>Metric</th><th>Old</th><th>Current</th><th>Δ</th></tr></thead><tbody>${rows}</tbody></table></div></div></div>`;
}

// ---------- Full Preview Modal Rendering ----------
function showFullPreviewModal(full){
    if(!full) return;
    const modalEl = document.getElementById('fullPreviewModal');
    if(!modalEl) return;
    document.getElementById('fpModalSeed').textContent = `seed=${full.seed}`;
    // Counts
    const countsEl = document.getElementById('fpCounts');
    const stats = [
        ['Routers',(full.routers||[]).length],
        ['Hosts',(full.hosts||[]).length],
        ['Switches',(full.switches||[]).length],
        ['R2R Edges',(full.r2r_edges_preview||[]).length],
        ['Seg Rules', (full.segmentation_preview && full.segmentation_preview.rules ? full.segmentation_preview.rules.length:0)],
        ['P2P /24',(full.ptp_subnets||[]).length],
        ['R-Sw /24',(full.router_switch_subnets||[]).length],
        ['LAN /24',(full.lan_subnets||[]).length],
    ];
    countsEl.innerHTML = '<div class="row g-1">' + stats.map(s=>`<div class="col-auto"><span class="badge text-bg-secondary">${s[0]}: ${s[1]}</span></div>`).join('') + '</div>';
    // Policies & segmentation
    function setJson(id, obj){ const el=document.getElementById(id); if(el) el.textContent = JSON.stringify(obj||{}, null, 2); }
    setJson('fpR2RPolicy', full.r2r_policy_preview);
    setJson('fpR2SPolicy', full.r2s_policy_preview);
    // Render segmentation plan using shared artifacts so modal and structured views match
    (function(){
        const segEl = document.getElementById('fpSegmentation');
        if(!segEl) return;
        const typesEl = document.getElementById('fpSegmentationTypes');
        const runtimeWrap = document.getElementById('fpSegmentationRuntimeWrap');
        const runtimeEl = document.getElementById('fpSegmentationRuntime');
        const hashEl = document.getElementById('fpSegmentationHash');
        const artifacts = buildFullPreviewArtifacts(full) || {};
        const segArtifacts = artifacts.segmentation || null;
        const segJson = segArtifacts && segArtifacts.json;
        const hasRules = !!(segJson && typeof segJson === 'object' && segJson.rules_count > 0);
        if(hasRules){
            try {
                segEl.textContent = JSON.stringify(segJson, null, 2);
            } catch(e){
                segEl.textContent = '[error rendering segmentation plan JSON]';
            }
        } else {
            segEl.textContent = '(no segmentation plan rules)';
        }
        if(typesEl){
            typesEl.innerHTML = '';
            const typesSummary = hasRules ? (segJson.types_summary || {}) : {};
            const entries = Object.entries(typesSummary).filter(([, count]) => count !== undefined && count !== null);
            if(entries.length){
                typesEl.hidden = false;
                entries.forEach(([type, count]) => {
                    const badge = document.createElement('span');
                    badge.className = 'badge text-bg-light border me-1';
                    badge.textContent = `${type}: ${count}`;
                    typesEl.appendChild(badge);
                });
            } else {
                typesEl.hidden = true;
            }
        }
        const segPreview = (full && full.segmentation_preview) || {};
        const runtimeSummary = segPreview && segPreview.runtime_summary;
        if(runtimeWrap){
            if(runtimeSummary){
                runtimeWrap.hidden = false;
                if(runtimeEl){
                    try {
                        runtimeEl.textContent = JSON.stringify(runtimeSummary, null, 2);
                    } catch(e){
                        runtimeEl.textContent = '[error rendering runtime segmentation summary]';
                    }
                }
            } else {
                runtimeWrap.hidden = true;
                if(runtimeEl){ runtimeEl.textContent = ''; }
            }
        }
        if(hashEl){
            const hashVal = segPreview && segPreview.scripts_hash_sha256;
            if(hashVal){
                hashEl.hidden = false;
                hashEl.textContent = `Scripts Hash (SHA-256): ${hashVal}`;
            } else {
                hashEl.hidden = true;
                hashEl.textContent = '';
            }
        }
    })();
    // Breakdown plans
    try { setJson('fpRouterPlan', full.router_plan); } catch(e){}
    try { setJson('fpServicesPlan', full.services_plan); } catch(e){}
    try { setJson('fpVulnPlan', full.vulnerabilities_plan); } catch(e){}
    try { setJson('fpTrafficPlan', full.traffic_summary || full.traffic_plan || {}); } catch(e){}
    // Tables
    function tableHtml(arr, cols){ if(!arr||!arr.length) return '<div class="text-muted small">(none)</div>'; const head='<thead><tr>'+cols.map(c=>`<th>${c}</th>`).join('')+'</tr></thead>'; const body='<tbody>'+arr.map(o=>'<tr>'+cols.map(c=>`<td>${(o[c]!==undefined&&o[c]!==null)? (Array.isArray(o[c])? o[c].join(','): o[c]): ''}</td>`).join('')+'</tr>').join('')+'</tbody>'; return `<div class="table-responsive"><table class="table table-sm table-bordered mb-0">${head}${body}</table></div>`; }
    function summarizeRouterInterfaces(full){
        const routers = full.routers || [];
        if(!routers.length) return [];
        const r2rLinks = full.r2r_links_preview || [];
        const switches = full.switches_detail || [];
        const r2rMap = {};
        r2rLinks.forEach(link => {
            const routersList = link.routers || [];
            if(routersList.length < 2) return;
            const subnet = link.subnet || '';
            const [ra, rb] = routersList;
            const entryA = `r${rb.id ?? '?'}: ${(ra.ip || '-')}${subnet ? ` [${subnet}]` : ''}`;
            const entryB = `r${ra.id ?? '?'}: ${(rb.ip || '-')}${subnet ? ` [${subnet}]` : ''}`;
            if(ra && ra.id !== undefined){
                const listA = r2rMap[ra.id] || (r2rMap[ra.id] = []);
                listA.push(entryA);
            }
            if(rb && rb.id !== undefined){
                const listB = r2rMap[rb.id] || (r2rMap[rb.id] = []);
                listB.push(entryB);
            }
        });
        const switchMap = {};
        switches.forEach(sw => {
            if(sw.router_id === undefined) return;
            const label = `sw-${sw.switch_id ?? '?'}: ${(sw.router_ip || '-')}${sw.rsw_subnet ? ` [${sw.rsw_subnet}]` : ''}`;
            const list = switchMap[sw.router_id] || (switchMap[sw.router_id] = []);
            list.push(label);
        });
        return routers.map(r => {
            const r2rList = (r2rMap[r.node_id] || []).slice().sort();
            const swList = (switchMap[r.node_id] || []).slice().sort();
            return {
                'ID': r.node_id,
                'Name': r.name || `r${r.node_id}`,
                'Primary IP': r.ip4 || '-',
                'R2R Interfaces': r2rList.length ? r2rList.join('; ') : '-',
                'Switch Links': swList.length ? swList.join('; ') : '-',
            };
        });
    }
    const routersWrap = document.getElementById('fpRoutersWrap'); if(routersWrap) routersWrap.innerHTML = tableHtml(summarizeRouterInterfaces(full),['ID','Name','Primary IP','R2R Interfaces','Switch Links']);
    const hostsWrap = document.getElementById('fpHostsWrap'); if(hostsWrap) hostsWrap.innerHTML = tableHtml(full.hosts,['node_id','name','role','ip4']);
    const switchesWrap = document.getElementById('fpSwitchesWrap'); if(switchesWrap) switchesWrap.innerHTML = tableHtml(full.switches_detail,['switch_id','router_id','hosts','rsw_subnet','lan_subnet']);
    // Graph
    buildFullPreviewModalGraph(full);
    setupPreviewCollapsers();
    try { buildNodeSectionsTable(full); } catch(e){ console.warn('Node sections table failed', e); }
        // Removed history, role distribution, service distribution
    // Approval & drift removed
    document.getElementById('fpExportJsonBtn')?.addEventListener('click', ()=>{ try { const blob=new Blob([JSON.stringify(full,null,2)],{type:'application/json'}); const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download='full_preview_seed_'+(full.seed||'na')+'.json'; document.body.appendChild(a); a.click(); a.remove(); setTimeout(()=>URL.revokeObjectURL(a.href),4000);} catch(e){} });
    // Open standalone full preview page via POST (original GET caused 405 Method Not Allowed)
    document.getElementById('fpOpenStandaloneBtn')?.addEventListener('click', ()=>{
        const xmlPath = state.result_path || '';
        if(!xmlPath.endsWith('.xml')){ alert('Save XML first to open standalone preview.'); return; }
        const scen = state.scenarios && state.scenarios[activeIdx] ? state.scenarios[activeIdx].name : '';
        const form = document.createElement('form');
        form.method='POST';
        form.action='/plan/full_preview_page';
        form.target='_blank';
        const inXml = document.createElement('input'); inXml.type='hidden'; inXml.name='xml_path'; inXml.value=xmlPath; form.appendChild(inXml);
        if(scen){ const inSc = document.createElement('input'); inSc.type='hidden'; inSc.name='scenario'; inSc.value=scen; form.appendChild(inSc); }
        if(full && full.seed){ const inSeed=document.createElement('input'); inSeed.type='hidden'; inSeed.name='seed'; inSeed.value=full.seed; form.appendChild(inSeed); }
        document.body.appendChild(form);
        form.submit();
        setTimeout(()=>{ try { form.remove(); } catch(e){} }, 1000);
    });
    (new bootstrap.Modal(modalEl)).show();
}

// Removed history and distribution functions

// Drift function removed

function normalizeVulnerabilitiesByNode(source){
    const out = {};
    if(!source) return out;
    Object.entries(source).forEach(([key, value])=>{
        if(key === '__density_pool__') return;
        if(Array.isArray(value)){
            out[String(key)] = value;
            const numericKey = Number(key);
            if(Number.isFinite(numericKey)){
                out[numericKey] = value;
            }
        }
    });
    return out;
}

function buildFullPreviewModalGraph(full){
    const labelToggle = document.getElementById('fpGraphLabelsToggle');
    const labelStateKey = 'coretg_graph_labels_state';
    if(labelToggle && !labelToggle.dataset.initialized){
        try {
            const saved = sessionStorage.getItem(labelStateKey);
            if(saved){
                labelToggle.checked = saved === 'on';
                labelToggle.dataset.graphLabelsState = saved;
            }
        } catch(e){}
        labelToggle.dataset.initialized = '1';
    }
    const shouldShowLabels = !!(labelToggle && labelToggle.checked);
    if(labelToggle){
        labelToggle.dataset.graphLabelsState = shouldShowLabels ? 'on' : 'off';
    }
    if(!window.d3){ const g=document.getElementById('fpGraphLoading'); if(g) g.textContent='d3 not loaded'; return; }
    const container = d3.select('#fpGraph');
    container.selectAll('*').remove();
    const w = container.node().clientWidth || 800; const h = container.node().clientHeight || 480;
    const svg = container.append('svg').attr('width', w).attr('height', h).style('cursor','grab');
    const zoomLayer = svg.append('g').attr('class','zoom-layer');
    let currentTransform = d3.zoomIdentity;
    const zoom = d3.zoom().scaleExtent([0.2,4]).on('zoom', (ev)=>{
        currentTransform = ev.transform; zoomLayer.attr('transform', currentTransform);
    });
    svg.call(zoom).on('dblclick.zoom', null);
        const vulnerabilitiesByNode = normalizeVulnerabilitiesByNode(full.vulnerabilities_by_node);
    const nodes=[];
    const nodeById = new Map();
    const hitlPreview = deriveHitlPreviewArtifacts(full);
        const baseCluster = full.base_bridge_preview && full.base_bridge_preview.attached ? (full.base_bridge_preview.target_cluster || null) : null;
        const baseClusterNodeMap = new Map();
        const baseBridgeInfo = full.base_bridge_preview && full.base_bridge_preview.attached ? full.base_bridge_preview : null;
        const legend = svg.append('g').attr('class','legend').attr('transform','translate(8,8)');
        let legendOffset = 0;
        const legendTypesSeen = new Set();
        let legendSpacingAdded = false;

        const ensureLegendEntry = (canonicalType) => {
            if(!canonicalType || legendTypesSeen.has(canonicalType)) return;
            legendTypesSeen.add(canonicalType);
            const style = nodeStyleForType(canonicalType);
            const radius = Math.max(4, Math.min((style.radius ?? 6), 12));
            const entry = legend.append('g').attr('transform', `translate(0,${legendOffset})`);
            if (style.shape === 'square') {
                const side = radius * 2;
                entry.append('rect')
                    .attr('x', 0)
                    .attr('y', 0)
                    .attr('width', side)
                    .attr('height', side)
                    .attr('fill', style.color)
                    .attr('stroke', '#333')
                    .attr('stroke-width', 1);
            } else {
                entry.append('circle')
                    .attr('r', radius)
                    .attr('cx', radius)
                    .attr('cy', radius)
                    .attr('fill', style.color)
                    .attr('stroke', '#333')
                    .attr('stroke-width', 1);
            }
            entry.append('text')
                .text(style.label)
                .attr('x', radius * 2 + 6)
                .attr('y', radius + 4)
                .attr('font-size', '11px');
            legendOffset += Math.max(radius * 2 + 6, 20);
        };

        const registerLegendForNodes = (list) => {
            if(!Array.isArray(list)) return;
            list.forEach(node => {
                if(!node) return;
                const canonical = canonicalNodeType(node.type ?? node.kind ?? node.role);
                if(node.type !== canonical) node.type = canonical;
                ensureLegendEntry(canonical);
            });
        };

        const addLegendSpacing = () => {
            if(!legendSpacingAdded && legendTypesSeen.size > 0){
                legendOffset += 6;
                legendSpacingAdded = true;
            }
        };
        function resolveBaseNodeType(meta){
            if(!meta || typeof meta !== 'object') return 'host';
            const raw = meta.type ?? meta.model ?? meta.kind ?? meta.role ?? '';
            return canonicalNodeType(raw);
        }
        const addNode = (node)=>{
            if(node==null || node.id===undefined || node.id===null) return;
            const key = String(node.id);
            const canonicalType = canonicalNodeType(node.type ?? node.kind ?? node.role);
            const normalized = { ...node, type: canonicalType };
            if(nodeById.has(key)){
                Object.assign(nodeById.get(key), normalized);
                return;
            }
            nodeById.set(key, normalized);
            nodes.push(normalized);
        };
        const bridgeRouterIdNum = baseBridgeInfo ? Number(baseBridgeInfo.bridge_router_id) : null;
        (full.routers||[]).forEach(r=>{
            if(r==null || r.node_id===undefined || r.node_id===null) return;
            const routerIdNum = Number(r.node_id);
            const isBridgeRouter = Number.isFinite(bridgeRouterIdNum) && routerIdNum === bridgeRouterIdNum;
            addNode({id:r.node_id, label:r.name, type:'router', ip4: r.ip4 || '', isBaseBridge: isBridgeRouter});
        });
        (full.hosts||[]).forEach(hn=>{
            if(hn==null) return;
            const hostId = hn.node_id;
            if(hostId===undefined || hostId===null) return;
            const keyStr = String(hostId);
            const assignment = Array.isArray(hn.vulnerabilities) ? hn.vulnerabilities : vulnerabilitiesByNode[keyStr] || vulnerabilitiesByNode[hostId] || [];
            const vulnList = Array.isArray(assignment) ? assignment : [];
            const hasVuln = vulnList.length > 0;
            addNode({id:hostId, label:hn.name, type:'host', ip4: hn.ip4 || '', hasVuln: hasVuln, vulnerabilities: vulnList});
        });
        (full.switches_detail||[]).forEach(sw=>{
            if(sw==null) return;
            const switchId = sw.switch_id;
            if(switchId===undefined || switchId===null) return;
            addNode({id:switchId, label:'sw-'+switchId, type:'switch'});
        });
    const bridgePeerIdNum = baseBridgeInfo ? Number(baseBridgeInfo.internal_peer_router_id) : null;
        const baseBridgeKeys = new Set();
        if(Number.isFinite(bridgeRouterIdNum) && Number.isFinite(bridgePeerIdNum)){
            baseBridgeKeys.add(`${Math.min(bridgeRouterIdNum, bridgePeerIdNum)}-${Math.max(bridgeRouterIdNum, bridgePeerIdNum)}`);
        }

        const linkDescriptors=[];
        (full.r2r_edges_preview||[]).forEach(e=>{
            if(!Array.isArray(e) || e.length<2) return;
            const [a,b] = e;
            if(a===undefined || a===null || b===undefined || b===null) return;
            const key = `${Math.min(Number(a), Number(b))}-${Math.max(Number(a), Number(b))}`;
            const kind = baseBridgeKeys.has(key) ? 'base-bridge' : 'r2r';
            linkDescriptors.push({sourceId:a, targetId:b, kind});
        });
        (full.switches_detail||[]).forEach(sw=>{
            if(sw==null) return;
            const switchId = sw.switch_id;
            const routerId = sw.router_id;
            if(switchId===undefined || switchId===null || routerId===undefined || routerId===null) return;
            (sw.hosts||[]).forEach(hid=>{
                if(hid===undefined || hid===null) return;
                linkDescriptors.push({sourceId:switchId, targetId:hid, kind:'sw-host'});
            });
            linkDescriptors.push({sourceId:routerId, targetId:switchId, kind:'r-sw'});
        });
        const hr = full.host_router_map || {};
        Object.entries(hr).forEach(([hid,rid])=>{
            if(hid===undefined || hid===null) return;
            const hIdNum = Number.isFinite(Number(hid)) ? Number(hid) : parseInt(hid, 10);
            const hostId = Number.isFinite(hIdNum) ? hIdNum : hid;
            if(hostId===undefined || hostId===null) return;
            const hasSwitchLink = linkDescriptors.find(l=>l.kind==='sw-host' && String(l.targetId)===String(hostId));
            if(hasSwitchLink) return;
            const routerCandidate = (typeof rid === 'number' && Number.isFinite(rid)) ? rid : parseInt(rid,10);
            const routerId = Number.isFinite(routerCandidate) ? routerCandidate : rid;
            if(routerId===undefined || routerId===null) return;
            linkDescriptors.push({sourceId:routerId, targetId:hostId, kind:'r-host'});
        });

        const ensureNodeForLink = (id, role)=>{
            if(id===undefined || id===null || (typeof id==='number' && Number.isNaN(id))) return;
            const key = String(id);
            if(nodeById.has(key)) return;
            const type = role==='router'? 'router' : role==='switch'? 'switch' : 'host';
            const labelBase = role==='router'? `router-${key}` : role==='switch'? `sw-${key}` : `host-${key}`;
            const fallback = { id, label: labelBase, type };
            if(type==='host'){
                fallback.hasVuln = false;
                fallback.vulnerabilities = [];
            }
            addNode(fallback);
        };
        linkDescriptors.forEach(link=>{
            if(!link) return;
            if(link.kind==='r2r'){
                ensureNodeForLink(link.sourceId, 'router');
                ensureNodeForLink(link.targetId, 'router');
            } else if(link.kind==='r-sw'){
                ensureNodeForLink(link.sourceId, 'router');
                ensureNodeForLink(link.targetId, 'switch');
            } else if(link.kind==='sw-host'){
                ensureNodeForLink(link.sourceId, 'switch');
                ensureNodeForLink(link.targetId, 'host');
            } else if(link.kind==='r-host'){
                ensureNodeForLink(link.sourceId, 'router');
                ensureNodeForLink(link.targetId, 'host');
            }
        });

        if(hitlPreview && Array.isArray(hitlPreview.nodes)){
            hitlPreview.nodes.forEach(node => {
                if(!node) return;
                const sourceId = node.id ?? node.node_id ?? null;
                if(sourceId !== null){
                    const key = String(sourceId);
                    if(nodeById.has(key)){
                        const existing = nodeById.get(key);
                        const mergeFieldWhenMissing = (field) => {
                            if(Object.prototype.hasOwnProperty.call(node, field)){
                                const value = node[field];
                                if(value !== undefined && value !== null && (existing[field] === undefined || existing[field] === null)){
                                    existing[field] = value;
                                }
                            }
                        };
                        mergeFieldWhenMissing('type');
                        mergeFieldWhenMissing('label');
                        mergeFieldWhenMissing('name');
                        mergeFieldWhenMissing('ip4');
                        mergeFieldWhenMissing('linkNetwork');
                        mergeFieldWhenMissing('prefixLen');
                        mergeFieldWhenMissing('netmask');
                        mergeFieldWhenMissing('peerRouterIp4');
                        mergeFieldWhenMissing('existingRouterIp4');
                        mergeFieldWhenMissing('broadcastIp4');
                        mergeFieldWhenMissing('attachment');
                        mergeFieldWhenMissing('assignment');
                        mergeFieldWhenMissing('hitlAttachment');
                        mergeFieldWhenMissing('hitlAssignment');
                        mergeFieldWhenMissing('hitlUplinkRouterId');
                        mergeFieldWhenMissing('uplinkRouterId');
                        if(node.hitlInterface && !existing.hitlInterface){
                            existing.hitlInterface = node.hitlInterface;
                        }
                        if(node.hitlLinkMeta && !existing.hitlLinkMeta){
                            existing.hitlLinkMeta = node.hitlLinkMeta;
                        }
                        if(Array.isArray(node.hitlSwitchInterfaces) && node.hitlSwitchInterfaces.length){
                            if(!Array.isArray(existing.hitlSwitchInterfaces)){
                                existing.hitlSwitchInterfaces = node.hitlSwitchInterfaces.slice();
                            } else {
                                const seenKeys = new Set(existing.hitlSwitchInterfaces.map(entry => {
                                    if(!entry) return '';
                                    return entry.switch_id !== undefined && entry.switch_id !== null
                                        ? String(entry.switch_id)
                                        : JSON.stringify(entry);
                                }));
                                node.hitlSwitchInterfaces.forEach(entry => {
                                    if(!entry) return;
                                    const keyEntry = entry.switch_id !== undefined && entry.switch_id !== null
                                        ? String(entry.switch_id)
                                        : JSON.stringify(entry);
                                    if(!seenKeys.has(keyEntry)){
                                        existing.hitlSwitchInterfaces.push(entry);
                                        seenKeys.add(keyEntry);
                                    }
                                });
                            }
                        }
                        if(node.isHitlRouter){
                            existing.isHitlRouter = true;
                        }
                        if(node.isHitl){
                            existing.isHitl = true;
                        }
                        if(node.hitlAttachment && !existing.hitlAttachment){
                            existing.hitlAttachment = node.hitlAttachment;
                        }
                        if(node.hitlAssignment && !existing.hitlAssignment){
                            existing.hitlAssignment = node.hitlAssignment;
                        }
                        if(node.hitlUplinkRouterId && !existing.hitlUplinkRouterId){
                            existing.hitlUplinkRouterId = node.hitlUplinkRouterId;
                        }
                        existing._hasHitlOverlay = true;
                        return;
                    }
                }
                const canonical = canonicalNodeType(node.type ?? node.kind ?? node.role);
                const clone = { ...node, type: canonical };
                const key = sourceId !== null ? String(sourceId) : (clone.id !== undefined && clone.id !== null ? String(clone.id) : null);
                if(key !== null){
                    nodeById.set(key, clone);
                }
                nodes.push(clone);
            });
        }

        const filteredLinks = linkDescriptors.filter(link=>{
            if(!link) return false;
            return nodeById.has(String(link.sourceId)) && nodeById.has(String(link.targetId));
        });

        if(hitlPreview && Array.isArray(hitlPreview.links)){
            hitlPreview.links.forEach(link=>{
                if(!link) return;
                if(!nodeById.has(String(link.sourceId)) || !nodeById.has(String(link.targetId))) return;
                filteredLinks.push({
                    sourceId: link.sourceId,
                    targetId: link.targetId,
                    kind: link.kind || 'hitl',
                    attachment: link.attachment || null,
                    assignment: link.assignment || null,
                });
            });
        }

        if(baseCluster && Array.isArray(baseCluster.nodes)){
            baseCluster.nodes.forEach((baseNodeMeta, idx)=>{
                if(!baseNodeMeta) return;
                const originalId = baseNodeMeta.id !== undefined && baseNodeMeta.id !== null ? String(baseNodeMeta.id) : `base-${idx}`;
                if(baseClusterNodeMap.has(originalId)) return;
                const nodeId = `base-cluster-${originalId}`;
                baseClusterNodeMap.set(originalId, nodeId);
                const clusterLabel = baseNodeMeta.name || `Base ${originalId}`;
                const clusterNode = {
                    id: nodeId,
                    name: clusterLabel,
                    label: clusterLabel,
                    type: resolveBaseNodeType(baseNodeMeta),
                    isBaseCluster: true,
                    isBase: true,
                    baseOriginal: baseNodeMeta,
                };
                if(baseNodeMeta.position && Number.isFinite(Number(baseNodeMeta.position.x)) && Number.isFinite(Number(baseNodeMeta.position.y))){
                    clusterNode._layout = { x: Number(baseNodeMeta.position.x), y: Number(baseNodeMeta.position.y) };
                }
                addNode(clusterNode);
            });
        }
        let baseAnchorId = null;
        const baseTargetMeta = full.base_bridge_preview && full.base_bridge_preview.attached ? (full.base_bridge_preview.target || null) : null;
        if(baseClusterNodeMap.size > 0){
            const targetKey = baseTargetMeta && baseTargetMeta.id !== undefined && baseTargetMeta.id !== null ? String(baseTargetMeta.id) : null;
            if(targetKey && baseClusterNodeMap.has(targetKey)){
                baseAnchorId = baseClusterNodeMap.get(targetKey);
            } else {
                baseAnchorId = baseClusterNodeMap.values().next().value;
            }
        } else if(baseTargetMeta){
            baseAnchorId = `base-target-${baseTargetMeta.id || 'base'}`;
            if(!nodeById.has(baseAnchorId)){
                const anchorLabel = baseTargetMeta.name || 'Base Scenario';
                const anchorNode = {
                    id: baseAnchorId,
                    name: anchorLabel,
                    label: anchorLabel,
                    type: resolveBaseNodeType(baseTargetMeta),
                    isBaseExternal: true,
                    isBase: true,
                    baseTarget: baseTargetMeta,
                };
                if(baseTargetMeta.position && Number.isFinite(Number(baseTargetMeta.position.x)) && Number.isFinite(Number(baseTargetMeta.position.y))){
                    anchorNode._layout = { x: Number(baseTargetMeta.position.x), y: Number(baseTargetMeta.position.y) };
                }
                addNode(anchorNode);
            }
        }
        if(baseCluster && Array.isArray(baseCluster.edges)){
            baseCluster.edges.forEach(edge=>{
                if(!Array.isArray(edge) || edge.length < 2) return;
                const aRaw = edge[0];
                const bRaw = edge[1];
                const keyA = aRaw !== undefined && aRaw !== null ? String(aRaw) : null;
                const keyB = bRaw !== undefined && bRaw !== null ? String(bRaw) : null;
                if(!keyA || !keyB) return;
                const mappedA = baseClusterNodeMap.get(keyA);
                const mappedB = baseClusterNodeMap.get(keyB);
                if(!mappedA || !mappedB) return;
                filteredLinks.push({ sourceId: mappedA, targetId: mappedB, kind: 'base-cluster' });
            });
        }
        const bridgeRouterId = baseBridgeInfo ? baseBridgeInfo.bridge_router_id : null;
        if(baseAnchorId && bridgeRouterId !== null){
            filteredLinks.push({ sourceId: bridgeRouterId, targetId: baseAnchorId, kind: 'base-external' });
        }

        if(nodes.length === 0){
            svg.remove();
            container.append('div').attr('class','text-muted small p-2').text('No nodes to display');
            document.getElementById('fpGraphLoading')?.remove();
            return;
        }

        registerLegendForNodes(nodes);
        addLegendSpacing();

        const layoutPositions = full.layout_positions;
        const layoutMaps = (layoutPositions && !layoutPositions.error && typeof layoutPositions === 'object')
            ? {
                    routers: layoutPositions.routers || {},
                    switches: layoutPositions.switches || {},
                    hosts: layoutPositions.hosts || {},
                }
            : null;
        function layoutCoordForNode(node){
            if(!layoutMaps) return null;
            let table = null;
            if(node.type==='router') table = layoutMaps.routers;
            else if(node.type==='switch') table = layoutMaps.switches;
            else if(node.isBase){
                if(node._layout) return node._layout;
                return null;
            }
            else table = layoutMaps.hosts;
            if(!table) return null;
            const key = String(node.id);
            const raw = table[key] || table[node.id];
            if(!raw) return null;
            const x = Number(raw.x);
            const y = Number(raw.y);
            if(Number.isFinite(x) && Number.isFinite(y)) return {x, y};
            return null;
        }
        const layoutCoords = [];
        if(layoutMaps){
            nodes.forEach(n=>{
                let pos = layoutCoordForNode(n);
                if(!pos && n.isBase && n._layout){
                    pos = n._layout;
                }
                if(pos){
                    n._layout = pos;
                    layoutCoords.push(pos);
                }
            });
        }
        const margin = 40;
        const innerWidth = Math.max(w - margin*2, 200);
        const innerHeight = Math.max(h - margin*2, 200);
        let usingLayout = layoutCoords.length > 0;
        const originalPositions = new Map();
    function applyRowJitter(list){
            const buckets = new Map();
            list.forEach(node=>{
                if(!Number.isFinite(node.y)) return;
        if(node.isBase) return;
                const base = node._layout ? node._layout.y : node.y;
                if(!Number.isFinite(base)) return;
                const key = Math.round(base * 1000);
                const bucket = buckets.get(key);
                if(bucket){
                    bucket.push(node);
                } else {
                    buckets.set(key, [node]);
                }
            });
            buckets.forEach(group=>{
                if(group.length <= 1) return;
                group.sort((a,b)=> String(a.id).localeCompare(String(b.id)));
                const mid = (group.length - 1) / 2;
                const spacing = 8;
                group.forEach((node, idx)=>{
                    node.y += (idx - mid) * spacing;
                });
            });
        }
        let scale = 1;
        let offsetX = margin;
        let offsetY = margin;
        if(usingLayout && layoutCoords.length){
            let minX = layoutCoords[0].x, maxX = layoutCoords[0].x;
            let minY = layoutCoords[0].y, maxY = layoutCoords[0].y;
            layoutCoords.forEach(c=>{ if(c.x<minX) minX=c.x; if(c.x>maxX) maxX=c.x; if(c.y<minY) minY=c.y; if(c.y>maxY) maxY=c.y; });
            const spanX = Math.max(1, maxX - minX);
            const spanY = Math.max(1, maxY - minY);
            scale = Math.min(innerWidth/spanX, innerHeight/spanY);
            if(!Number.isFinite(scale) || scale <= 0){
                scale = 1;
                usingLayout = false;
            } else {
                offsetX = margin + (innerWidth - spanX * scale) / 2 - minX * scale;
                offsetY = margin + (innerHeight - spanY * scale) / 2 - minY * scale;
            }
        }

        if(usingLayout){
            nodes.forEach(n=>{
                if(n._layout){
                    n.x = offsetX + n._layout.x * scale;
                    n.y = offsetY + n._layout.y * scale;
                } else {
                    n.x = w/2 + Math.random()*40 - 20;
                    n.y = h/2 + Math.random()*40 - 20;
                }
            });
            applyRowJitter(nodes);
            nodes.forEach(n=>{
                n.layoutX = n.x;
                n.layoutY = n.y;
                if(Number.isFinite(n.x) && Number.isFinite(n.y)){
                    originalPositions.set(n.id, { x: n.x, y: n.y });
                }
            });
        } else {
            nodes.forEach(n=>{
                n.x = w/2 + Math.random()*80 - 40;
                n.y = h/2 + Math.random()*80 - 40;
                n.layoutX = undefined;
                n.layoutY = undefined;
            });
        }

        const simLinks = filteredLinks.map(l=>({...l, source:l.sourceId, target:l.targetId}));

        // Build per-node interface/IP hints for hover tooltips.
        function buildIfaceHints(preview){
            const map = new Map();
            const add = (id, line) => {
                if(id === undefined || id === null || line == null) return;
                const key = String(id);
                const txt = String(line).trim();
                if(!txt) return;
                if(!map.has(key)) map.set(key, []);
                const arr = map.get(key);
                if(arr.length >= 20) return;
                if(!arr.includes(txt)) arr.push(txt);
            };

            // Router-router links with explicit IPs (preferred)
            try {
                (preview.r2r_links_preview || []).forEach(link => {
                    const routers = link && link.routers ? link.routers : null;
                    if(!Array.isArray(routers) || routers.length !== 2) return;
                    const a = routers[0];
                    const b = routers[1];
                    const aId = a && a.id !== undefined ? a.id : null;
                    const bId = b && b.id !== undefined ? b.id : null;
                    if(aId === null || bId === null) return;
                    if(a.ip) add(aId, `to r${bId}: ${a.ip}`);
                    if(b.ip) add(bId, `to r${aId}: ${b.ip}`);
                });
            } catch(e){}

            // Router<->switch and host<->switch interface IPs
            try {
                (preview.switches_detail || []).forEach(sw => {
                    if(!sw) return;
                    const sid = sw.switch_id;
                    const rid = sw.router_id;
                    if(sw.router_ip) add(rid, `to sw${sid}: ${sw.router_ip}`);
                    const hostIps = (sw.host_if_ips && typeof sw.host_if_ips === 'object') ? sw.host_if_ips : {};
                    (sw.hosts || []).forEach(hid => {
                        const ip = hostIps[String(hid)] || hostIps[hid];
                        if(ip) add(hid, `to sw${sid}: ${ip}`);
                    });
                });
            } catch(e){}

            return map;
        }

        const ifaceHints = buildIfaceHints(full);

        function nodeTitle(d){
            const label = d.label || d.name || String(d.id);
            const lines = [`${label} (${d.type || 'node'})`];
            const ip4 = (d.ip4 || '').trim();
            if(ip4) lines.push(`IP: ${ip4}`);
            const extras = ifaceHints.get(String(d.id)) || [];
            // HITL overlays: include any explicit peer/existing router IP hints
            if(d.peerRouterIp4) extras.unshift(`peer: ${d.peerRouterIp4}`);
            if(d.existingRouterIp4) extras.unshift(`uplink: ${d.existingRouterIp4}`);
            if(extras.length){
                lines.push('Interfaces:');
                extras.slice(0, 12).forEach(x => lines.push(`- ${x}`));
            } else {
                lines.push('Interfaces: -');
            }
            return lines.join('\n');
        }

        const isHitlLink = (kind) => typeof kind === 'string' && kind.startsWith('hitl');
        const link = zoomLayer.selectAll('line').data(simLinks).enter().append('line')
            .attr('stroke', l=> {
                if(l.kind === 'base-bridge' || l.kind === 'base-external' || l.kind === 'base-cluster') return '#6f42c1';
                if(l.kind==='r2r') return '#0d6efd';
                if(isHitlLink(l.kind)) return '#20c997';
                return (l.kind==='r-sw'? '#198754':'#999');
            })
            .attr('stroke-width', l=> {
                if(l.kind === 'base-cluster') return 3;
                if(l.kind === 'base-bridge' || l.kind === 'base-external') return 4;
                if(isHitlLink(l.kind)) return 2.4;
                return l.kind==='r2r'? 2:1.2;
            })
            .attr('stroke-linecap', l=> (l.kind === 'base-bridge' || l.kind === 'base-external' || l.kind === 'base-cluster') ? 'round' : null)
            .attr('stroke-dasharray', l=> {
                if(l.kind==='r-host') return '3,3';
                if(isHitlLink(l.kind)) return '5,4';
                return null;
            })
            .attr('opacity', .9);
    const node = zoomLayer.selectAll('g').data(nodes).enter().append('g');
        // Native SVG tooltip on hover
        node.insert('title', ':first-child').text(d => nodeTitle(d));
        const vulnerabilityColor = '#28a745';
        const hasVulnerableHosts = nodes.some(n => n.type === 'host' && n.hasVuln);
        const normalNode = node.filter(d => !(d.type === 'host' && d.hasVuln));
        normalNode.each(function(d){
            const nodeGroup = d3.select(this);
            const style = nodeStyleForType(d.type);
            if (style.shape === 'square') {
                const side = (Number.isFinite(style.radius) ? style.radius : 6) * 2;
                nodeGroup.append('rect')
                    .attr('x', -side / 2)
                    .attr('y', -side / 2)
                    .attr('width', side)
                    .attr('height', side)
                    .attr('rx', 2)
                    .attr('ry', 2)
                    .attr('fill', style.color)
                    .attr('stroke', (d.isBase || d.isBaseBridge) ? '#6f42c1' : '#333')
                    .attr('stroke-width', d.isBaseBridge ? 3 : d.isBase ? 2 : 1.1);
            } else {
                const radius = Number.isFinite(style.radius) ? style.radius : 6;
                nodeGroup.append('circle')
                    .attr('r', radius)
                    .attr('fill', style.color)
                    .attr('stroke', (d.isBase || d.isBaseBridge) ? '#6f42c1' : '#333')
                    .attr('stroke-width', d.isBaseBridge ? 3 : d.isBase ? 2 : 1.1);
            }
        });
        const vulnNode = node.filter(d => d.type === 'host' && d.hasVuln);
        const vulnSymbol = d3.symbol().type(d3.symbolStar).size(170);
        vulnNode.append('path')
            .attr('d', vulnSymbol)
            .attr('fill', vulnerabilityColor)
            .attr('stroke', '#333')
            .attr('stroke-width', 1.1);
        const labelGroups = node.append('g').attr('class', 'node-label-wrapper');

        const computeLabelWidth = (d) => {
            const text = d.label || d.name || String(d.id);
            return Math.max(24, (String(text).length * 6 + 6));
        };

        labelGroups.append('rect')
            .attr('class', 'node-label-bg')
            .attr('x', d => -computeLabelWidth(d) / 2)
            .attr('y', 10)
            .attr('width', d => computeLabelWidth(d))
            .attr('height', 16)
            .attr('rx', 3)
            .attr('ry', 3)
            .attr('fill', '#fff')
            .attr('stroke', '#bbb')
            .attr('stroke-width', 0.8)
            .attr('opacity', 0.88);

        labelGroups.append('text')
            .attr('class', 'node-label-text')
            .attr('text-anchor', 'middle')
            .attr('x', 0)
            .attr('y', 21)
            .attr('font-size', '10px')
            .attr('fill', '#212529')
            .text(d => d.label || d.name || String(d.id));

        const simulation = d3.forceSimulation(nodes)
            .force('link', d3.forceLink(simLinks).id(d=>d.id).distance(l=> {
                if(l.kind === 'base-cluster') return 60;
                if(l.kind === 'base-bridge' || l.kind === 'base-external') return 95;
                return l.kind==='r2r'? 80 : (l.kind==='r-sw'? 60 : 40);
            }).strength(l => l.kind === 'base-cluster' ? 0.9 : (l.kind === 'base-bridge' || l.kind === 'base-external' ? 0.7 : 0.6)))
            .force('charge', d3.forceManyBody().strength(d => d.isBase ? -160 : -220))
            .force('center', d3.forceCenter(w/2,h/2))
            .force('layoutX', d3.forceX(d => Number.isFinite(d.layoutX) ? d.layoutX : w/2).strength(usingLayout ? 0.2 : 0.04))
            .force('layoutY', d3.forceY(d => Number.isFinite(d.layoutY) ? d.layoutY : h/2).strength(usingLayout ? 0.2 : 0.04));

        simulation.alpha(1).alphaTarget(0.03).restart();

        link.data(simLinks, d=>`${d.source}-${d.target}`);

        simulation.on('tick', ()=>{
            link.attr('x1', d=>d.source.x).attr('y1', d=>d.source.y).attr('x2', d=>d.target.x).attr('y2', d=>d.target.y);
            node.attr('transform', d=>`translate(${d.x},${d.y})`);
        });

        node.call(d3.drag().on('start', dragstarted).on('drag', dragged).on('end', dragended));

        let sim = simulation;

        let resetStaticPositions = null;
        if(usingLayout){
            resetStaticPositions = () => {
                nodes.forEach(n => {
                    const orig = originalPositions.get(n.id);
                    if(orig){
                        n.layoutX = orig.x;
                        n.layoutY = orig.y;
                        n.x = orig.x;
                        n.y = orig.y;
                        n.vx = 0;
                        n.vy = 0;
                        n.fx = null;
                        n.fy = null;
                    }
                });
                simulation.alpha(0.55).restart();
            };
        }
    // Legend
    const hasBaseBridge = baseBridgeInfo && baseBridgeInfo.attached;
    if(hasBaseBridge){
        const g=legend.append('g').attr('transform',`translate(0,${legendOffset})`);
        g.append('line').attr('x1',0).attr('y1',8).attr('x2',24).attr('y2',8).attr('stroke','#6f42c1').attr('stroke-width',4).attr('stroke-linecap','round');
        g.append('text').text('Bridge to Base Scenario').attr('x',28).attr('y',12).attr('font-size','11px');
        legendOffset += 20;
    }
    if(hasVulnerableHosts){
        const g=legend.append('g').attr('transform',`translate(0,${legendOffset})`);
        const vulnLegendSymbol = d3.symbol().type(d3.symbolStar).size(80);
        g.append('path')
            .attr('d', vulnLegendSymbol)
            .attr('transform','translate(8,8)')
            .attr('fill', vulnerabilityColor)
            .attr('stroke','#333')
            .attr('stroke-width',1);
        g.append('text').text('Host (vulnerable)').attr('x', 20).attr('y', 12).attr('font-size','11px');
        legendOffset += 20;
    }
    // Node labels rendered conditionally (toggle in UI)
    // Build section lookups
    const servicesByNode = full.services_preview || {}; // node_id -> [services]
    const vulnByNode = vulnerabilitiesByNode; // node_id -> [vulns]
    const segRules = (full.segmentation_preview && full.segmentation_preview.rules) || [];
    const segCnt = {}; segRules.forEach(r=>{ segCnt[r.node_id] = (segCnt[r.node_id]||0)+1; });
    const traffic = full.traffic_summary || {};
    const tSend = {}; const tRecv = {};
    try { (traffic.flows || traffic || []).forEach(f=>{ const s=f.src_id??f.src; const d=f.dst_id??f.dst; if(s!==undefined) tSend[s]=(tSend[s]||0)+1; if(d!==undefined) tRecv[d]=(tRecv[d]||0)+1; }); } catch(e){}
    // Hover tooltips use native SVG <title> (see nodeTitle)
    function dragstarted(event,d){
        try { event.sourceEvent?.stopPropagation?.(); } catch(e){}
        if(sim && !event.active) sim.alphaTarget(.35).restart();
        d.fx=d.x; d.fy=d.y;
    }
    function dragged(event,d){ d.fx=event.x; d.fy=event.y; }
    function dragended(event,d){
        if(sim && !event.active) sim.alphaTarget(0.03);
        d.fx=d.x; d.fy=d.y;
        d.layoutX = d.x;
        d.layoutY = d.y;
    }
    document.getElementById('fpGraphLoading')?.remove();
    const resetBtn = document.getElementById('fpGraphResetBtn');
    if(resetBtn){
        resetBtn.addEventListener('click', ()=>{
            if(sim){
                sim.alpha(1).restart();
                nodes.forEach(n=>{ n.fx=null; n.fy=null; });
            }
            if(resetStaticPositions){
                resetStaticPositions();
            }
            svg.transition().duration(250).call(zoom.transform, d3.zoomIdentity);
        });
    }
    // Removed zoom hint tooltip
    svg.on('mousedown', ()=> svg.style('cursor','grabbing'));
    window.addEventListener('mouseup', ()=> svg.style('cursor','grab'));
    document.getElementById('fpGraphPngBtn')?.addEventListener('click', ()=>{ try { const serializer=new XMLSerializer(); const svgStr=serializer.serializeToString(svg.node()); const canvas=document.createElement('canvas'); canvas.width=w*2; canvas.height=h*2; const ctx=canvas.getContext('2d'); const img=new Image(); img.onload=function(){ ctx.fillStyle='#fff'; ctx.fillRect(0,0,canvas.width,canvas.height); ctx.drawImage(img,0,0,canvas.width,canvas.height); canvas.toBlob(b=>{ const a=document.createElement('a'); a.href=URL.createObjectURL(b); a.download='full_preview_graph_'+(full.seed||'na')+'.png'; document.body.appendChild(a); a.click(); a.remove(); setTimeout(()=>URL.revokeObjectURL(a.href),4000); }); }; img.src='data:image/svg+xml;base64,'+btoa(unescape(encodeURIComponent(svgStr))); } catch(e){ console.error('PNG export failed', e); } });

    container.node().dispatchEvent(new CustomEvent('coretg-graph-ready', {
        bubbles: true,
        detail: {
            target: '#fpGraph',
            showLabels: shouldShowLabels,
            svg: container.select('svg').node()
        }
    }));

    if(labelToggle && !labelToggle.dataset.bound){
        labelToggle.dataset.bound = '1';
        labelToggle.addEventListener('change', ()=>{
            const wrap = document.getElementById('fpGraph');
            const show = !!labelToggle.checked;
            labelToggle.dataset.graphLabelsState = show ? 'on' : 'off';
            try { sessionStorage.setItem(labelStateKey, show ? 'on' : 'off'); } catch(e){}
            if(wrap){
                wrap.dataset.showLabels = show ? 'on' : 'off';
                d3.select(wrap).selectAll('.node-label-wrapper').style('display', show ? null : 'none');
            }
            labelToggle.dispatchEvent(new CustomEvent('coretg-graph-label-toggle', {
                bubbles: true,
                detail: { target: '#fpGraph', show }
            }));
        });
    }

    if(labelToggle && labelToggle.dataset.bound && container.node()){
        container.node().dataset.showLabels = shouldShowLabels ? 'on' : 'off';
        container.selectAll('.node-label-wrapper').style('display', shouldShowLabels ? null : 'none');
        try { sessionStorage.setItem(labelStateKey, shouldShowLabels ? 'on' : 'off'); } catch(e){}
    }
}

function buildNodeSectionsTable(full){
    const wrap = document.getElementById('fpNodeSectionsWrap'); if(!wrap) return;
    const servicesByNode = full.services_preview || {};
    const vulnByNode = normalizeVulnerabilitiesByNode(full.vulnerabilities_by_node);
    const segRules = (full.segmentation_preview && full.segmentation_preview.rules) || [];
    const segCnt = {}; segRules.forEach(r=>{ segCnt[r.node_id]=(segCnt[r.node_id]||0)+1; });
    const traffic = full.traffic_summary || {};
    const tSend = {}; const tRecv = {};
    try { (traffic.flows || traffic || []).forEach(f=>{ const s=f.src_id??f.src; const d=f.dst_id??f.dst; if(s!==undefined) tSend[s]=(tSend[s]||0)+1; if(d!==undefined) tRecv[d]=(tRecv[d]||0)+1; }); } catch(e){}
    const all = [];
    const seenIds = new Set();
    const pushNode = (entry) => {
        if(!entry || entry.id === undefined || entry.id === null) return;
        const key = String(entry.id);
        if(seenIds.has(key)) return;
        seenIds.add(key);
        all.push(entry);
    };
    (full.routers||[]).forEach(r=> pushNode({id:r.node_id, name:r.name, type:'router'}));
    (full.hosts||[]).forEach(h=> pushNode({id:h.node_id, name:h.name, type:h.role||'host'}));
    (full.switches_detail||[]).forEach(sw=> pushNode({id:sw.switch_id, name:'sw-'+sw.switch_id, type:'switch'}));
    const hitlPreview = deriveHitlPreviewArtifacts(full);
    if(hitlPreview && Array.isArray(hitlPreview.nodes)){
        hitlPreview.nodes.forEach(node=>{
            if(!node) return;
            const canonical = canonicalNodeType(node.type || (node.isHitl ? 'rj45' : node.isHitlNetwork ? 'network' : 'host'));
            pushNode({
                id: node.id,
                name: node.label || node.name || String(node.id),
                type: canonical,
                hitlAttachment: node.attachment || (node.hitlInterface && node.hitlInterface.attachment) || null,
                hitlAssignment: node.assignment || null,
                hitlPeer: node.peerNodeId || null,
            });
        });
    }
    if(!all.length){ wrap.innerHTML='<div class="text-muted small">No nodes</div>'; return; }
    const rows = all.map(n=>{
        const svc=(servicesByNode[n.id]||[]).join(',');
        const vul=(vulnByNode[n.id]||[]).join(',');
        const sc=segCnt[n.id]||0; const ts=tSend[n.id]||0; const tr=tRecv[n.id]||0;
        let attachmentDisplay = '-';
        if(n.hitlAttachment){
            const baseLabel = prettyHitlAttachment(n.hitlAttachment);
            let assignmentLabel = '';
            if(n.hitlAssignment){
                if(HITL_ATTACHMENT_ALLOWED.has(n.hitlAssignment)){
                    assignmentLabel = prettyHitlAttachment(n.hitlAssignment);
                } else if(n.hitlAssignment === 'existing_host'){
                    assignmentLabel = 'Existing Host';
                } else if(n.hitlAssignment === 'network'){
                    assignmentLabel = 'Isolated Network';
                } else {
                    assignmentLabel = n.hitlAssignment.replace(/_/g, ' ');
                }
            }
            attachmentDisplay = assignmentLabel && assignmentLabel !== baseLabel
                ? `${baseLabel} → ${assignmentLabel}`
                : baseLabel;
        }
        return `<tr><td>${n.id}</td><td>${n.name ?? '-'}</td><td>${n.type || '-'}</td><td>${attachmentDisplay}</td><td>${svc}</td><td>${vul}</td><td>${sc}</td><td>${ts}</td><td>${tr}</td></tr>`;
    }).join('');
    wrap.innerHTML = `<div class='table-responsive'><table class='table table-sm table-bordered mb-0'><thead><tr><th>ID</th><th>Name</th><th>Type</th><th>HITL Attachment</th><th>Services</th><th>Vulns</th><th>Seg Rules</th><th>Traffic S</th><th>Traffic R</th></tr></thead><tbody>${rows}</tbody></table></div>`;
}

// Execute button in Full Preview modal
document.addEventListener('DOMContentLoaded', ()=>{
    const execBtn = document.getElementById('fpExecuteBtn');
    if(execBtn && !execBtn.dataset.boundExecute){
        execBtn.dataset.boundExecute = '1';
        let executing = false;
        const originalLabel = execBtn.textContent;
        const modalEl = document.getElementById('fullPreviewModal');
        let modalHidden = false;
        let allowPreviewRestore = true;
        if(modalEl && !modalEl.dataset.executeVisibilityBound){
            modalEl.addEventListener('shown.bs.modal', () => { modalHidden = false; });
            modalEl.addEventListener('hidden.bs.modal', () => { modalHidden = true; });
            modalEl.dataset.executeVisibilityBound = '1';
        }
        const resolveModalInstance = () => {
            if(!modalEl || !window.bootstrap) return null;
            try {
                return bootstrap.Modal.getInstance(modalEl) || new bootstrap.Modal(modalEl);
            } catch(e){
                console.error('Failed to resolve full preview modal instance', e);
                return null;
            }
        };
        execBtn.addEventListener('click', async ()=>{
            if(executing) return;
            if(!state.result_path || !state.result_path.endsWith('.xml')){
                alert('Save XML before executing.');
                return;
            }
            const execInfo = detectLocalEmulation();
            const confirmMsg = 'Execute this scenario now? This will start a CORE session.';
            const { idx: scenarioIdx } = getActiveScenarioContext();
            const modalInstance = resolveModalInstance();
            allowPreviewRestore = true;
            const hideModalForConfirm = async () => {
                try { modalInstance?.hide(); } catch(e){}
                if(modalEl){
                    modalEl.classList.remove('show');
                    modalEl.setAttribute('aria-hidden','true');
                    modalEl.style.display = 'none';
                }
                const openModals = document.querySelectorAll('.modal.show');
                if(openModals.length === 0){
                    document.querySelectorAll('.modal-backdrop').forEach(b => { try { b.remove(); } catch(e){} });
                    document.body.classList.remove('modal-open');
                    document.body.style.removeProperty('paddingRight');
                    document.body.style.removeProperty('overflow');
                }
                modalHidden = true;
                await new Promise(resolve => requestAnimationFrame(() => resolve()));
            };
            const restoreModalIfHidden = () => {
                if(!modalHidden || !allowPreviewRestore) return;
                modalHidden = false;
                try {
                    if(modalInstance){
                        modalInstance.show();
                    } else if(modalEl){
                        modalEl.style.display = 'block';
                        modalEl.classList.add('show');
                        document.body.classList.add('modal-open');
                    }
                } catch(e){}
            };
            await hideModalForConfirm();
            allowPreviewRestore = false;
            const confirmResult = await promptExecuteConfirmation({
                message: confirmMsg,
                scenarioIndex: scenarioIdx,
                alertMessage: '',
                alertTone: 'info',
                keepOpenOnConfirm: true,
            });
            const updateRemoteRepo = !!confirmResult?.updateRemote;
            if(!confirmResult?.confirmed){
                return;
            }
            const forceHideModal = () => {
                try { modalInstance?.hide(); } catch(e){}
                if(modalEl){
                    modalEl.classList.remove('show');
                    modalEl.setAttribute('aria-hidden','true');
                    modalEl.style.display = 'none';
                }
                const openModals = document.querySelectorAll('.modal.show');
                if(openModals.length === 0){
                    document.querySelectorAll('.modal-backdrop').forEach(b => { try { b.remove(); } catch(e){} });
                    document.body.classList.remove('modal-open');
                    document.body.style.removeProperty('paddingRight');
                    document.body.style.removeProperty('overflow');
                }
                modalHidden = true;
            };
            const restoreModal = () => {
                if(!allowPreviewRestore) return;
                try {
                    if(modalInstance){
                        modalInstance.show();
                    } else if(modalEl){
                        modalEl.style.display = 'block';
                        modalEl.classList.add('show');
                        document.body.classList.add('modal-open');
                    }
                } catch(e){}
                modalHidden = false;
            };
            const waitForPaint = async () => {
                await new Promise(resolve => requestAnimationFrame(() => resolve()));
            };
            executing = true;
            execBtn.disabled = true;
            execBtn.classList.add('disabled');
            if(originalLabel){ execBtn.textContent = 'Executing…'; }
            let launchFailed = false;
            try {
                forceHideModal();
                await waitForPaint();
                showExecuteProgressPanel(
                    execInfo.shouldFake ? 'Local emulation run' : 'Preparing CORE run…',
                    execInfo.shouldFake
                        ? 'CORE connection unavailable; running locally.'
                        : (IS_BUILDER_VIEW ? 'Remote CORE backend managed by admin.' : `CORE ${execInfo.host}:${execInfo.port}`)
                );
                // Ensure dock visible
                try { const showBtn=document.getElementById('dockShowBtn'); if(showBtn && !showBtn.classList.contains('d-none')) showBtn.click(); } catch(e){}
                appendLog('--- Execute (Full Preview) start: '+state.result_path+' ---','info');
                const result = await runSyncWithModal({
                    showProgressModal: false,
                    skipConfirm: true,
                    scenarioIndex: scenarioIdx,
                    updateRemoteRepo,
                    confirmResult,
                    advanced: confirmResult?.advanced,
                    onRunId: (runId) => {
                        bindExecuteProgressToRun(runId);
                        appendLog('Run ID: '+runId,'info');
                    },
                    onTick: (data) => {
                        if(data && !data.done){
                            setExecuteProgressStatus('Running CLI…', 'Streaming logs…');
                        }
                    },
                    onComplete: (data) => {
                        if(data?.returncode === 0){
                            completeExecuteProgressPanel(true, 'Scenario started', 'Redirecting to reports…');
                            try {
                                setTimeout(()=>{
                                    if(executeConfirmModalEl && window.bootstrap){
                                        bootstrap.Modal.getOrCreateInstance(executeConfirmModalEl).hide();
                                    }
                                }, 200);
                            } catch(e){}
                            scheduleScenarioRedirect("{{ url_for('reports_page') }}", { delay: 600 });
                        } else {
                            completeExecuteProgressPanel(false, 'Finished with errors', 'Check logs for details.');
                            restoreModal();
                        }
                    },
                    onError: (err) => {
                        launchFailed = true;
                        const detail = (err && err.message) ? err.message : 'Unable to launch CLI';
                        completeExecuteProgressPanel(false, 'Failed to start', detail);
                        restoreModal();
                    },
                });
                if(result === false){
                    if(!launchFailed){
                        completeExecuteProgressPanel(false, 'Failed to start', 'Request aborted');
                        restoreModal();
                    }
                    return;
                }
            } catch(e){
                appendLog('Execution exception: '+e,'error');
                completeExecuteProgressPanel(false, 'Failed to start', 'Unexpected error');
                restoreModal();
            }
            finally {
                execBtn.disabled = false;
                execBtn.classList.remove('disabled');
                if(originalLabel){ execBtn.textContent = originalLabel; }
                executing = false;
            }
        });
    }
});

// Seed clear button
document.addEventListener('DOMContentLoaded', () => {
  const scb = document.getElementById('seedClearBtn');
    // seed clear button removed
});

// ------------- Auto-Save Support for Planning -------------
async function autoSaveXml(){
    return new Promise((resolve, reject) => {
        try {
            const scenariosJsonInput = document.getElementById('scenarios_json');
            if(!scenariosJsonInput){ reject('Editor form missing'); return; }
            try { scenariosJsonInput.value = JSON.stringify({ scenarios: state.scenarios, active_index: activeIdx }); } catch(e){ reject('Serialize failed'); return; }
            const latestCoreConfig = getCoreConfig(true);
            const coreJsonInput = document.getElementById('core_json');
            if (coreJsonInput) {
                coreJsonInput.value = JSON.stringify(latestCoreConfig);
            }
            const scenarioQueryHint = resolveScenarioQueryHint();
            const projectKeyHint = currentProjectKey || DEFAULT_PROJECT_KEY;
            const priorPassword = state?.core?.ssh_password || '';
            const applyCoreUpdate = (corePayload) => {
                if (!corePayload) return;
                state.core = normalizeCoreState(corePayload, true);
                if (priorPassword && !state.core.ssh_password) {
                    state.core.ssh_password = priorPassword;
                }
                storeCorePasswordInSession();
            };
            const applyResultPath = (resultPath) => {
                if (!resultPath) return;
                const previousProjectKey = currentProjectKey;
                const previousSnapshot = { ...(projectStateMap[previousProjectKey] || legacyEditorState || {}) };
                state.result_path = resultPath;
                try { updateDownloadButtonState(); } catch (err) {}
                try {
                    const projectKeyProbe = {
                        project_key_hint: resultPath,
                        result_path: resultPath,
                        scenarios: state.scenarios || [],
                        base_upload: state.base_upload || null,
                        scenario_query: resolveScenarioQueryHint() || null,
                    };
                    const derivedKey = deriveProjectKey(projectKeyProbe, previousProjectKey || DEFAULT_PROJECT_KEY);
                    currentProjectKey = derivedKey || previousProjectKey || DEFAULT_PROJECT_KEY;
                } catch (keyErr) {
                    console.warn('Failed to derive project key from result_path', keyErr);
                    if (!currentProjectKey) {
                        currentProjectKey = previousProjectKey || DEFAULT_PROJECT_KEY;
                    }
                }
                try {
                    const persisted = { ...previousSnapshot };
                    persisted.result_path = state.result_path;
                    persisted.project_key_hint = state.result_path;
                    projectStateMap[currentProjectKey] = persisted;
                    legacyEditorState = persisted;
                    writeJsonToLocalStorage(LEGACY_EDITOR_STATE_STORAGE_KEY, persisted);
                    writeJsonToLocalStorage(PROJECT_STATE_STORAGE_KEY, projectStateMap);
                } catch(err) {}
                // Persist again so the new result_path becomes the active project key
                persistEditorState();
            };
            const finalizeSuccess = () => {
                previewState.xmlSaved = true;
                try { updatePlanButtons(); } catch(err) {}
                resolve();
            };
            const legacySave = () => {
                const formData = new FormData();
                formData.append('scenarios_json', scenariosJsonInput.value);
                if (coreJsonInput) {
                    formData.append('core_json', coreJsonInput.value);
                }
                formData.append('project_key_hint', projectKeyHint);
                formData.append('scenario_query', scenarioQueryHint || '');
                return fetch('/save_xml', { method:'POST', body: formData, credentials: 'same-origin' })
                    .then(r=>r.text())
                    .then(html => {
                        try {
                            const parser = new DOMParser();
                            const doc = parser.parseFromString(html, 'text/html');
                            const payloadScript = doc.querySelector('#payload-data');
                            if(payloadScript){
                                const newPayload = JSON.parse(payloadScript.textContent || 'null');
                                if(newPayload){
                                    if (newPayload.core) {
                                        applyCoreUpdate(newPayload.core);
                                    }
                                    if(newPayload.result_path){
                                        applyResultPath(newPayload.result_path);
                                        finalizeSuccess();
                                        return;
                                    }
                                }
                            }
                            reject(new Error('Could not detect saved XML path in response'));
                        } catch(e){ reject(e); }
                    })
                    .catch(err => reject(err));
            };
            const apiSave = () => {
                return fetch('/save_xml_api', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    credentials: 'same-origin',
                    body: JSON.stringify({
                        scenarios: state.scenarios,
                        active_index: activeIdx,
                        core: latestCoreConfig,
                        project_key_hint: projectKeyHint,
                        scenario_query: scenarioQueryHint,
                    }),
                }).then(async resp => {
                    let data = null;
                    try { data = await resp.json(); } catch(_) {}
                    if (!resp.ok || !data || data.ok === false) {
                        const errMsg = (data && (data.error || data.message)) || `HTTP ${resp.status}`;
                        throw new Error(errMsg);
                    }
                    if (data.core) {
                        applyCoreUpdate(data.core);
                    }
                    if (data.result_path) {
                        applyResultPath(data.result_path);
                    }
                    finalizeSuccess();
                });
            };
            apiSave().catch(err => {
                console.warn('save_xml_api failed, falling back to legacy save_xml', err);
                legacySave();
            });
        } catch(e){ reject(e); }
    });
}

document.addEventListener('DOMContentLoaded', () => {
    const bindModalSaveButton = (buttonId, options = {}) => {
        const btn = document.getElementById(buttonId);
        if (!btn || btn.dataset.modalSaveBound === '1') return;
        const busyHtml = '<span class="spinner-border spinner-border-sm me-2" role="status" aria-hidden="true"></span>Saving…';
        const doFallbackSubmit = () => {
            const editorForm = document.getElementById('editorForm');
            if (!editorForm) return Promise.reject(new Error('Editor form not found'));
            return new Promise((resolve) => {
                try {
                    if (typeof editorForm.requestSubmit === 'function') {
                        editorForm.requestSubmit();
                    } else {
                        editorForm.submit();
                    }
                    resolve();
                } catch (err) {
                    console.warn('Fallback submit failed', err);
                    resolve();
                }
            });
        };
        const runSave = async () => {
            if (typeof autoSaveXml === 'function') {
                await autoSaveXml();
            } else {
                await doFallbackSubmit();
            }
        };
        const closeParentModal = () => {
            try {
                const modalEl = btn.closest('.modal');
                if (modalEl && window.bootstrap) {
                    const instance = window.bootstrap.Modal.getOrCreateInstance(modalEl);
                    instance.hide();
                } else if (modalEl) {
                    modalEl.classList.remove('show');
                    modalEl.setAttribute('aria-hidden', 'true');
                    modalEl.style.display = 'none';
                }
            } catch (err) {
                console.warn('Failed to close modal after save', err);
            }
        };
        btn.addEventListener('click', async () => {
            if (btn.disabled) return;
            const originalHtml = btn.innerHTML;
            btn.disabled = true;
            btn.innerHTML = busyHtml;
            try {
                await runSave();
                if (typeof showToast === 'function') {
                    showToast('Scenario saved.', { autohide: true, delay: 2200 });
                }
                closeParentModal();
            } catch (err) {
                const message = err && err.message ? err.message : (typeof err === 'string' ? err : 'Save failed');
                console.warn(`Modal save failed: ${message}`);
                if (typeof showToast === 'function') {
                    showToast(`Scenario save failed: ${message}`, { autohide: false });
                } else {
                    alert(`Scenario save failed: ${message}`);
                }
            } finally {
                btn.disabled = false;
                btn.innerHTML = originalHtml;
            }
        });
        btn.dataset.modalSaveBound = '1';
    };
    bindModalSaveButton('coreVmModalSaveBtn');
    bindModalSaveButton('externalIfxModalSaveBtn');
});

state.core = restoreCorePasswordFromSession(state.core);
if (USE_LOCAL_EDITOR_STATE && persistedState && persistedState.core) {
    const persistedCore = normalizeCoreState(persistedState.core, false);
    state.core = {
        ...state.core,
        ...persistedCore,
    };
    state.core = restoreCorePasswordFromSession(state.core);
}
if (!state.core) {
    state.core = restoreCorePasswordFromSession({});
}
if (USE_LOCAL_EDITOR_STATE && persistedState) {
    if (persistedState.core_ok !== undefined) state.core_ok = persistedState.core_ok;
    if (persistedState.core_tested_host !== undefined) state.core_tested_host = persistedState.core_tested_host;
    if (persistedState.core_tested_port !== undefined) state.core_tested_port = persistedState.core_tested_port;
}
let activeIdx = Math.min(Math.max(0, persistedActiveIdx), (state.scenarios.length||1)-1);

function persistEditorState(){
    try {
        const baseUploadMeta = normalizeBaseUpload(state.base_upload) || (state.scenarios?.[0]?.base?.filepath || state.scenarios?.[0]?.base?.display_name ? {
            path: state.scenarios?.[0]?.base?.filepath || '',
            display_name: state.scenarios?.[0]?.base?.display_name || (state.scenarios?.[0]?.base?.filepath ? state.scenarios[0].base.filepath.split(/[/\\]/).pop() || '' : '')
        } : null);
        const coreForPersist = sanitizeCoreForPersist(state.core);
        const scenariosForSnapshot = cloneScenariosForSnapshot(state.scenarios || []);
        const snapshot = {
            scenarios: scenariosForSnapshot,
            result_path: state.result_path || null,
            core: coreForPersist || null,
            core_ok: !!state.core_ok,
            core_tested_host: state.core_tested_host || null,
            core_tested_port: state.core_tested_port || null,
            base_upload: baseUploadMeta,
            host_interfaces: Array.isArray(state.host_interfaces) ? state.host_interfaces : [],
            host_interfaces_source: state.host_interfaces_source || null,
            host_interfaces_metadata: state.host_interfaces_metadata || null,
            host_interfaces_fetched_at: state.host_interfaces_fetched_at || null,
        };
        snapshot.active_index = Number.isInteger(activeIdx) ? activeIdx : 0;
        const scenarioSignature = deriveScenarioSignature({ scenarios: scenariosForSnapshot });
        const trimmedScenarioToken = (scenarioQueryToken || '').trim();
        const nextScenarioQuery = trimmedScenarioToken || scenarioSignature || '';
        snapshot.scenario_query = nextScenarioQuery || null;
        if (!trimmedScenarioToken && nextScenarioQuery) {
            scenarioQueryToken = nextScenarioQuery;
        }
        const stableProjectHint = (() => {
            if (currentProjectKey && currentProjectKey !== DEFAULT_PROJECT_KEY) return currentProjectKey;
            if (snapshot.project_key_hint) return snapshot.project_key_hint;
            if (nextScenarioQuery) return nextScenarioQuery;
            if (snapshot.result_path) return snapshot.result_path;
            if (snapshot.base_upload && snapshot.base_upload.path) return snapshot.base_upload.path;
            return null;
        })();
        snapshot.project_key_hint = stableProjectHint;
        scrubSnapshotTransientErrors(snapshot);
        writeJsonToLocalStorage(LEGACY_EDITOR_STATE_STORAGE_KEY, snapshot);
        const nextProjectKey = deriveProjectKey(snapshot, currentProjectKey || DEFAULT_PROJECT_KEY);
        currentProjectKey = nextProjectKey || DEFAULT_PROJECT_KEY;
        projectStateMap[currentProjectKey] = snapshot;
        writeJsonToLocalStorage(PROJECT_STATE_STORAGE_KEY, projectStateMap);
        activeIdxMap[currentProjectKey] = activeIdx || 0;
        writeJsonToLocalStorage(PROJECT_ACTIVE_IDX_STORAGE_KEY, activeIdxMap);
        try { localStorage.setItem(LAST_PROJECT_KEY_STORAGE_KEY, currentProjectKey); } catch (err) {}
        localStorage.setItem('coretg_active_idx', String(activeIdx||0));
        storeCorePasswordInSession();
        scheduleServerSnapshotPersist(snapshot);
    } catch(e){}
}
// Persist initial merged state so it survives cross-page navigation immediately
persistEditorState();

const dropdownsBySection = {
    'Node Information': ['Server','Workstation','PC','Random'],
    // Added 'Random' entry so user can explicitly request a random routing protocol.
    'Routing': ['RIP','RIPNG','BGP','OSPFv2','OSPFv3','Random'],
    'Services': ['SSH','HTTP','DHCPClient','Random'],
    'Traffic': ['Random','TCP','UDP','CUSTOM'],
    'Events': ['Script Path'],
    'Vulnerabilities': ['Category','Specific','Random'],
    'Segmentation': ['Random','Firewall','NAT','CUSTOM']
};

const proxInventoryFetchInFlight = new Set();
// Feature flag: disable automatic CORE VM interface refresh; require explicit user action
const HOST_INTERFACES_AUTO_REFRESH_ENABLED = false;
// Feature flag: disable automatic Proxmox VM inventory refresh; rely on user action
const PROXMOX_INVENTORY_AUTO_REFRESH_ENABLED = false;
const HOST_INTERFACES_REFRESH_COOLDOWN_MS = 10_000;
const HOST_INTERFACES_REQUEST_TIMEOUT_MS = 15_000;
const HOST_INTERFACES_MAX_AUTO_RETRIES = 5;
const hostInterfacesRetryTimers = new Map();
const hostInterfacesRetryCounters = new Map();
const HITL_MODAL_AUTO_REFRESH_STALE_MS = 30_000;

function isNetworkFetchError(err) {
    if (!err || typeof err !== 'object') return false;
    if (err.name === 'TypeError' && typeof err.message === 'string' && /fetch/i.test(err.message)) return true;
    if (err.message && typeof err.message === 'string' && err.message.includes('Failed to fetch')) return true;
    return false;
}

function isHitlAuthenticationReady(hitlState) {
    if (!hitlState || typeof hitlState !== 'object') return false;
    const proxState = hitlState.proxmox && typeof hitlState.proxmox === 'object' ? hitlState.proxmox : {};
    const coreState = hitlState.core && typeof hitlState.core === 'object' ? hitlState.core : {};
    const proxValidated = !!(proxState.validated && proxState.secret_id);
    const coreSecretId = typeof coreState.core_secret_id === 'string' ? coreState.core_secret_id.trim() : '';
    const vmKey = (coreState.vm_key || '').toString();
    return proxValidated && !!coreSecretId && !!vmKey;
}

function setHitlStatus(sidx, message, tone = 'info') {
    const statusEl = document.querySelector(`[data-hitl-status="${sidx}"]`);
    if (!statusEl) return;
    statusEl.textContent = message;
    const toneClasses = ['text-danger', 'text-warning', 'text-success', 'text-muted'];
    toneClasses.forEach(cls => statusEl.classList.remove(cls));
    switch (tone) {
        case 'error':
            statusEl.classList.add('text-danger');
            break;
        case 'warning':
            statusEl.classList.add('text-warning');
            break;
        case 'success':
            statusEl.classList.add('text-success');
            break;
        case 'neutral':
            statusEl.classList.add('text-muted');
            break;
        default:
            statusEl.classList.add('text-muted');
            break;
    }
}

async function refreshHostInterfacesForScenario(sidx, options = {}) {
    const {
        reason = 'manual',
        silent = false,
        setStatus = null,
        timeoutMs = null,
    } = options;
    const scenario = Number.isInteger(sidx) ? state.scenarios?.[sidx] : null;
    const retryKey = String(sidx);
    if (hostInterfacesRetryTimers.has(retryKey)) {
        clearTimeout(hostInterfacesRetryTimers.get(retryKey));
        hostInterfacesRetryTimers.delete(retryKey);
    }
    const statusFn = typeof setStatus === 'function'
        ? setStatus
        : (message, tone) => setHitlStatus(sidx, message, tone);
    if (!scenario) {
        statusFn('Scenario unavailable for refresh.', 'error');
        return { ok: false, reason: 'no-scenario' };
    }
    const hitlState = ensureHitlStateForScenario(scenario);
    const proxState = hitlState.proxmox && typeof hitlState.proxmox === 'object' ? hitlState.proxmox : {};
    const proxValidated = !!(proxState.validated && proxState.secret_id);
    if (!proxValidated) {
        statusFn('Validate Proxmox credentials in Step 1 before refreshing interfaces.', 'error');
        if (!silent) {
            try { showToast('Validate Proxmox credentials to unlock HITL steps.', { autohide: true, delay: 2800 }); } catch (e) {}
        }
        return { ok: false, reason: 'no-proxmox' };
    }
    const coreState = hitlState.core || (hitlState.core = {});
    const coreSecretId = typeof coreState.core_secret_id === 'string' ? coreState.core_secret_id.trim() : '';
    if (!coreSecretId) {
        statusFn('Store CORE credentials to enumerate interfaces.', 'error');
        if (!silent) {
            try { showToast('Configure CORE credentials to refresh interfaces.', { autohide: true, delay: 2500 }); } catch (e) {}
        }
        return { ok: false, reason: 'no-secret' };
    }
    const nowIso = new Date().toISOString();
    coreState.last_interfaces_attempt = nowIso;
    if (coreState.interfaces_refresh_inflight) {
        statusFn('Interface refresh already in progress.', 'warning');
        return { ok: false, reason: 'busy' };
    }
    const vmKey = (coreState.vm_key || '').toString();
    const coreVmMeta = {
        vm_key: vmKey,
        vm_name: coreState.vm_name || '',
        vm_node: '',
        vmid: '',
    };
    if (vmKey) {
        const [nodePart, vmidPart] = vmKey.split('::');
        coreVmMeta.vm_node = (nodePart || '').trim();
        coreVmMeta.vmid = vmidPart && vmidPart.trim() ? vmidPart.trim() : '';
    }
    const proxInventory = hitlState.proxmox && hitlState.proxmox.inventory && Array.isArray(hitlState.proxmox.inventory.vms)
        ? hitlState.proxmox.inventory.vms
        : [];
    const targetVm = proxInventory.find(vm => `${vm.node ?? ''}::${vm.vmid ?? ''}` === vmKey);
    if (targetVm) {
        coreVmMeta.vm_name = targetVm.name ? String(targetVm.name) : coreVmMeta.vm_name;
        if (!coreVmMeta.vm_node && targetVm.node) coreVmMeta.vm_node = String(targetVm.node);
        if (!coreVmMeta.vmid && targetVm.vmid !== undefined && targetVm.vmid !== null) coreVmMeta.vmid = String(targetVm.vmid);
        if (Array.isArray(targetVm.interfaces)) {
            coreVmMeta.interfaces = targetVm.interfaces;
        }
    }
    coreState.interfaces_refresh_inflight = true;
    coreState.last_interfaces_error = null;
    persistEditorState();
    try { window.requestAnimationFrame(() => renderMain()); } catch (err) {}
    statusFn(reason === 'auto' ? 'Enumerating host interfaces…' : 'Refreshing interface list…', 'neutral');
    const controller = (typeof AbortController === 'function') ? new AbortController() : null;
    const requestTimeoutMs = Number.isFinite(timeoutMs) && timeoutMs > 0 ? timeoutMs : HOST_INTERFACES_REQUEST_TIMEOUT_MS;
    let timeoutId = null;
    let timedOut = false;
    try {
        const payload = {
            core_secret_id: coreSecretId,
            include_down: true,
            core_vm: coreVmMeta,
            scenario_index: sidx,
            scenario_name: scenario?.name || '',
        };
        const fetchOptions = {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Accept': 'application/json',
            },
            credentials: 'same-origin',
            body: JSON.stringify(payload),
        };
        if (controller) {
            fetchOptions.signal = controller.signal;
        }
        const fetchPromise = fetch('/api/host_interfaces', fetchOptions);
        const shouldTimeout = requestTimeoutMs > 0;
        let resp;
        if (shouldTimeout) {
            const timeoutPromise = new Promise((_, reject) => {
                timeoutId = window.setTimeout(() => {
                    timedOut = true;
                    if (controller) {
                        try { controller.abort(); } catch (err) { /* ignore */ }
                    }
                    reject(new Error('RequestTimedOut'));
                }, requestTimeoutMs);
            });
            resp = await Promise.race([fetchPromise, timeoutPromise]);
        } else {
            resp = await fetchPromise;
        }
        if (timeoutId !== null) {
            try { window.clearTimeout(timeoutId); } catch (err) { /* ignore */ }
            timeoutId = null;
        }
        if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
        const contentType = resp.headers.get('content-type') || '';
        let data;
        if (contentType.toLowerCase().includes('application/json')) {
            data = await resp.json();
        } else {
            const text = await resp.text();
            const snippet = text ? text.trim().slice(0, 240) : 'Empty response body';
            throw new Error(`Non-JSON response from host interface endpoint: ${snippet}`);
        }
        if (!data || data.success === false) {
            const errMsg = data && data.error ? data.error : 'Interface enumeration failed';
            throw new Error(errMsg);
        }
        const interfaces = Array.isArray(data.interfaces) ? data.interfaces : [];
        state.host_interfaces = interfaces;
        state.host_interfaces_source = data.source || 'core_vm';
        state.host_interfaces_metadata = data.metadata || null;
        const fetchedAt = data.fetched_at || new Date().toISOString();
        state.host_interfaces_fetched_at = fetchedAt;
        coreState.last_interfaces_refresh = fetchedAt;
        coreState.last_interfaces_error = null;
        persistEditorState();
        hostInterfacesRetryCounters.delete(retryKey);
        const hidden = document.getElementById('scenarios_json');
        if (hidden) hidden.value = JSON.stringify({ scenarios: state.scenarios, active_index: activeIdx });
        renderMain();
        statusFn('Interfaces refreshed from CORE VM', 'success');
        if (!silent) {
            try { showToast('CORE interfaces refreshed', { autohide: true, delay: 2200 }); } catch (e) {}
        }
        return { ok: true, data };
    } catch (err) {
        const requestTimedOut = timedOut || (err && (err.name === 'AbortError' || err.code === 20 || err.message === 'RequestTimedOut'));
        const networkFailure = requestTimedOut || isNetworkFetchError(err);
        const timeoutSeconds = Math.max(1, Math.round((requestTimeoutMs || HOST_INTERFACES_REQUEST_TIMEOUT_MS) / 1000));
        const message = requestTimedOut
            ? `Interface refresh timed out after ${timeoutSeconds} seconds. Verify CORE connectivity and try again.`
            : (networkFailure
                ? 'Unable to reach the server while refreshing interfaces. Will retry shortly.'
                : (err?.message ? String(err.message) : 'Refresh failed. Check server logs.'));
        if (networkFailure) {
            logWarn(`Host interface refresh temporarily unavailable: ${err}`);
        } else {
            logError(`Failed to refresh host interfaces: ${err}`);
        }
        coreState.last_interfaces_error = message;
        statusFn(message, 'error');
        persistEditorState();
        try { renderMain(); } catch (e) {}
        const autoEligible = (reason === 'auto' || reason === 'retry');
        if (networkFailure && autoEligible) {
            const attempts = (hostInterfacesRetryCounters.get(retryKey) || 0) + 1;
            hostInterfacesRetryCounters.set(retryKey, attempts);
            if (attempts <= HOST_INTERFACES_MAX_AUTO_RETRIES) {
                const backoffMs = Math.min(60_000, 2_000 * Math.pow(2, attempts - 1));
                const timerId = window.setTimeout(() => {
                    hostInterfacesRetryTimers.delete(retryKey);
                    refreshHostInterfacesForScenario(sidx, {
                        reason: 'retry',
                        silent: true,
                        setStatus: (msg, tone) => setHitlStatus(sidx, msg, tone),
                    }).catch(err2 => console.warn('Auto retry refresh host interfaces failed', err2));
                }, backoffMs);
                hostInterfacesRetryTimers.set(retryKey, timerId);
            } else {
                logWarn(`Max auto retries reached for host interface refresh on scenario ${retryKey}`);
            }
        }
        return { ok: false, reason: 'error', error: err };
    } finally {
        if (timeoutId !== null) {
            try { window.clearTimeout(timeoutId); } catch (err) { /* ignore */ }
        }
        coreState.interfaces_refresh_inflight = false;
        persistEditorState();
        try { window.requestAnimationFrame(() => renderMain()); } catch (err) {}
    }
}

function maybeAutoRefreshHitlInterfacesOnModalOpen(sidx) {
    const scenario = Number.isInteger(sidx) ? state.scenarios?.[sidx] : null;
    if (!scenario) return;
    const hitlState = ensureHitlStateForScenario(scenario);
    if (!isHitlAuthenticationReady(hitlState)) return;
    const coreState = hitlState.core || {};
    if (coreState.interfaces_refresh_inflight) return;
    const hostInterfaces = Array.isArray(state.host_interfaces) ? state.host_interfaces : [];
    const lastRefreshMs = Date.parse(coreState.last_interfaces_refresh || '');
    const hasError = !!coreState.last_interfaces_error;
    const shouldRefresh = (() => {
        if (!hostInterfaces.length) return true;
        if (hasError) return true;
        if (Number.isNaN(lastRefreshMs)) return true;
        return (Date.now() - lastRefreshMs) > HITL_MODAL_AUTO_REFRESH_STALE_MS;
    })();
    if (!shouldRefresh) return;
    refreshHostInterfacesForScenario(sidx, {
        reason: 'modal-open',
        silent: true,
        setStatus: (message, tone) => setHitlStatus(sidx, message, tone),
    }).catch(err => console.warn('HITL modal auto-refresh failed', err));
}

function scheduleAutoRefreshHostInterfaces(sidx) {
    if (!HOST_INTERFACES_AUTO_REFRESH_ENABLED) return;
    const scenario = Number.isInteger(sidx) ? state.scenarios?.[sidx] : null;
    if (!scenario) return;
    const hitlState = ensureHitlStateForScenario(scenario);
    if (!hitlState.enabled) return;
    if (!isHitlAuthenticationReady(hitlState)) return;
    const coreState = hitlState.core || (hitlState.core = {});
    const hostInterfaces = Array.isArray(state.host_interfaces) ? state.host_interfaces : [];
    if (hostInterfaces.length) return;
    if (coreState.interfaces_refresh_inflight) return;
    const coreSecretId = typeof coreState.core_secret_id === 'string' ? coreState.core_secret_id.trim() : '';
    if (!coreSecretId) return;
    if (!(coreState.vm_key || '').toString()) return;
    const lastAttemptMs = Date.parse(coreState.last_interfaces_attempt || '');
    if (!Number.isNaN(lastAttemptMs) && (Date.now() - lastAttemptMs) < HOST_INTERFACES_REFRESH_COOLDOWN_MS) {
        return;
    }
    window.setTimeout(() => {
        refreshHostInterfacesForScenario(sidx, {
            reason: 'auto',
            silent: true,
            setStatus: (message, tone) => setHitlStatus(sidx, message, tone),
        }).catch(err => console.warn('Auto refresh host interfaces failed', err));
    }, 150);
}

function describeTimestampRelative(isoString) {
    if (!isoString || typeof isoString !== 'string') return null;
    const epoch = Date.parse(isoString);
    if (Number.isNaN(epoch)) return null;
    try {
        const deltaMs = Date.now() - epoch;
        if (Math.abs(deltaMs) < 90_000) return 'just now';
        return new Date(epoch).toLocaleString();
    } catch (err) {
        return null;
    }
}

function updateHitlStatusForScenario(sidx) {
    const scenario = Number.isInteger(sidx) ? state.scenarios?.[sidx] : null;
    if (!scenario) return;
    const hitlState = ensureHitlStateForScenario(scenario);
    if (!hitlState.enabled) {
        if (isHitlAuthenticationReady(hitlState)) {
            setHitlStatus(sidx, 'Enable Hardware in the Loop to manage interface mappings.', 'neutral');
        } else {
            setHitlStatus(sidx, 'Validate Steps 1 and 2 before enabling Hardware in the Loop.', 'warning');
        }
        return;
    }
    if (!isHitlAuthenticationReady(hitlState)) {
        setHitlStatus(sidx, 'Validate Proxmox credentials and store CORE credentials to manage HITL interfaces.', 'warning');
        return;
    }
    const coreState = hitlState.core || {};
    const hostInterfaces = Array.isArray(state.host_interfaces) ? state.host_interfaces : [];
    const hasInterfaces = hostInterfaces.length > 0;
    const refreshBusy = coreState.interfaces_refresh_inflight === true;
    const lastAttemptStr = coreState.last_interfaces_attempt;
    const lastRefreshStr = coreState.last_interfaces_refresh;
    const lastError = coreState.last_interfaces_error;
    if (refreshBusy) {
        setHitlStatus(sidx, 'Enumerating host interfaces…', 'neutral');
        return;
    }
    if (lastError) {
        const attemptLabel = describeTimestampRelative(lastAttemptStr);
        const message = attemptLabel ? `${lastError} • Last attempt ${attemptLabel}` : lastError;
        setHitlStatus(sidx, message, 'error');
        return;
    }
    if (hasInterfaces) {
        const refreshLabel = describeTimestampRelative(lastRefreshStr) || 'recently';
        setHitlStatus(sidx, `Interfaces loaded from CORE VM ${refreshLabel}.`, 'success');
        return;
    }
    const attemptLabel = describeTimestampRelative(lastAttemptStr);
    if (attemptLabel) {
        setHitlStatus(sidx, `No interfaces detected yet • Last attempt ${attemptLabel}`, 'warning');
    } else {
        setHitlStatus(sidx, 'Select Refresh to enumerate interfaces from the CORE VM.', 'neutral');
    }
}

function updateParticipantProxmoxNavLink() {
    const wrapper = document.getElementById('navParticipantLinkWrap');
    const link = document.getElementById('navParticipantLink');
    if (!wrapper || !link) return;
    const scenario = state.scenarios?.[activeIdx];
    if (!scenario) {
        wrapper.classList.add('d-none');
        link.href = '#';
        link.setAttribute('aria-disabled', 'true');
        return;
    }
    const hitlState = ensureHitlStateForScenario(scenario);
    const href = normalizeParticipantProxmoxHref(hitlState.participant_proxmox_url || '');
    if (!href) {
        wrapper.classList.add('d-none');
        link.setAttribute('aria-disabled', 'true');
        link.setAttribute('title', 'Participant UI unavailable');
        link.dataset.participantUiHref = '';
        window.CORETG_PARTICIPANT_UI_HREF = '';
        return;
    }
    wrapper.classList.remove('d-none');
    link.setAttribute('aria-disabled', 'false');
    link.setAttribute('title', `Participant UI (${href})`);
    link.dataset.participantUiHref = href;
    window.CORETG_PARTICIPANT_UI_HREF = href;
}

function updateDownloadButtonState() {
    const dlBtn = document.getElementById('downloadXmlBtn');
    if (!dlBtn) return;
    const rp = state.result_path || '';
    if (rp && rp.endsWith('.xml')) {
        dlBtn.removeAttribute('disabled');
        dlBtn.classList.remove('pe-none');
        dlBtn.setAttribute('title', '');
    } else {
        dlBtn.setAttribute('disabled', 'disabled');
        dlBtn.classList.add('pe-none');
        dlBtn.setAttribute('title', 'Save XML first');
    }
}

function render() {
    updateActiveScenarioQueryParam();
    renderSidebar();
    renderMain();
    updateParticipantProxmoxNavLink();
    // Ensure H/S bounds visibility reflects initial r2s_mode values
    updateHsBoundsVisibility();
    // Ensure routing policy preview replaces the default "(pending)" label.
    setTimeout(validateRoutingEdges, 0);
    // Enable/disable Download XML button based on saved xml path
    updateDownloadButtonState();
    // Sync Base Scenario UI with persisted metadata (independent of active scenario)
    const scen0 = state.scenarios?.[0] || {};
    const scen0Base = (typeof scen0.base === 'object' && scen0.base) ? scen0.base : {};
    const metaBase = (state.base_upload && typeof state.base_upload === 'object') ? state.base_upload : (initialPayload?.base_upload && typeof initialPayload.base_upload === 'object' ? initialPayload.base_upload : {});
    const basePath = metaBase.path || scen0Base.filepath || '';
    const baseDisplayName = metaBase.display_name || scen0Base.display_name || (basePath ? basePath.split(/[/\\]/).pop() : '');
    const baseValid = typeof metaBase.valid === 'boolean' ? metaBase.valid : true;

    const baseIn = document.getElementById('baseFileInput');
    if (baseIn) {
        const current = baseIn.value || '';
        const target = baseDisplayName || '';
        if (current !== target) baseIn.value = target;
    }
    const baseBadge = document.getElementById('baseValidityBadge');
    if (baseBadge) {
        if (basePath) {
            baseBadge.textContent = baseValid ? 'VALID' : 'INVALID';
            baseBadge.classList.remove('d-none', 'text-bg-success', 'text-bg-danger');
            baseBadge.classList.add(baseValid ? 'text-bg-success' : 'text-bg-danger');
        } else {
            baseBadge.classList.add('d-none');
            baseBadge.classList.remove('text-bg-success', 'text-bg-danger');
        }
    }
    const baseDetailsLink = document.getElementById('baseDetailsLink');
    if (baseDetailsLink) {
        if (basePath) {
            const baseUrl = baseDetailsLink.dataset.baseUrl || baseDetailsLink.getAttribute('href') || '';
            if (baseUrl) {
                baseDetailsLink.href = `${baseUrl}${encodeURIComponent(basePath)}`;
            }
            baseDetailsLink.classList.remove('d-none');
        } else {
            baseDetailsLink.classList.add('d-none');
        }
    }
    const baseRemoveForm = document.getElementById('baseRemoveForm');
    if (baseRemoveForm) {
        if (basePath) baseRemoveForm.classList.remove('d-none');
        else baseRemoveForm.classList.add('d-none');
    }
}

function toggleEditorBusy(isBusy) {
    const root = document.getElementById('editorRoot');
    if (root) {
        root.classList.toggle('opacity-50', !!isBusy);
        if (isBusy) {
            root.setAttribute('aria-busy', 'true');
        } else {
            root.removeAttribute('aria-busy');
        }
    }
    document.querySelectorAll('#editorRoot button, #editorRoot input, #editorRoot select, #editorRoot textarea').forEach(el => {
        if (el.closest('#proxmoxAssignModal')) return;
        if (el.closest('#coreConnectionModal')) return;
        if (isBusy) {
            el.setAttribute('data-busy-disabled', el.disabled ? '1' : '0');
            el.disabled = true;
        } else if (el.hasAttribute('data-busy-disabled')) {
            const wasDisabled = el.getAttribute('data-busy-disabled') === '1';
            el.disabled = wasDisabled;
            el.removeAttribute('data-busy-disabled');
        }
    });
}

function toggleExternalIfxModalBusy(isBusy) {
    const modal = document.getElementById('externalIfxModal');
    if (!modal) return;
    const busy = !!isBusy;
    const notice = document.getElementById('externalIfxBusyNotice');
    if (busy) {
        modal.setAttribute('aria-busy', 'true');
        if (notice) {
            notice.textContent = 'Refreshing Proxmox interfaces…';
            notice.classList.remove('d-none');
        }
    } else {
        modal.removeAttribute('aria-busy');
        if (notice) {
            notice.classList.add('d-none');
            notice.textContent = '';
        }
    }
    modal.querySelectorAll('button, input, select, textarea').forEach(el => {
        if (el.matches('[data-bs-dismiss="modal"]')) return;
        if (busy) {
            if (!el.hasAttribute('data-ifx-busy-disabled')) {
                el.setAttribute('data-ifx-busy-disabled', el.disabled ? '1' : '0');
            }
            el.disabled = true;
        } else if (el.hasAttribute('data-ifx-busy-disabled')) {
            const wasDisabled = el.getAttribute('data-ifx-busy-disabled') === '1';
            el.disabled = wasDisabled;
            el.removeAttribute('data-ifx-busy-disabled');
        }
    });
}

let externalIfxStatusTimer = null;

function clearExternalIfxStatus() {
    const notice = document.getElementById('externalIfxBusyNotice');
    if (!notice) return;
    notice.classList.add('d-none');
    notice.classList.remove('alert-info', 'alert-success', 'alert-warning', 'alert-danger');
    notice.textContent = '';
    notice.removeAttribute('aria-busy');
    if (externalIfxStatusTimer) {
        clearTimeout(externalIfxStatusTimer);
        externalIfxStatusTimer = null;
    }
}

function updateExternalIfxStatus(message, variant = 'info', { busy = false, autoHideMs = 0 } = {}) {
    const notice = document.getElementById('externalIfxBusyNotice');
    if (!notice) return;
    const variants = ['info', 'success', 'warning', 'danger'];
    if (externalIfxStatusTimer) {
        clearTimeout(externalIfxStatusTimer);
        externalIfxStatusTimer = null;
    }
    notice.classList.remove('alert-info', 'alert-success', 'alert-warning', 'alert-danger');
    if (!message) {
        clearExternalIfxStatus();
        return;
    }
    if (!variants.includes(variant)) variant = 'info';
    notice.classList.remove('d-none');
    notice.classList.add(`alert-${variant}`);
    notice.textContent = message;
    notice.setAttribute('role', 'status');
    notice.setAttribute('aria-live', variant === 'danger' ? 'assertive' : 'polite');
    notice.setAttribute('aria-busy', busy ? 'true' : 'false');
    if (autoHideMs > 0) {
        externalIfxStatusTimer = window.setTimeout(() => {
            clearExternalIfxStatus();
        }, autoHideMs);
    }
}

function setExternalIfxApplyBusy(isBusy, label = 'Applying…') {
    const btn = document.getElementById('externalIfxApplyBtn');
    if (!btn) return;
    if (!btn.dataset.defaultHtml) {
        btn.dataset.defaultHtml = btn.innerHTML || btn.textContent || 'Apply';
    }
    if (isBusy) {
        btn.disabled = true;
        btn.innerHTML = `<span class="spinner-border spinner-border-sm me-2" role="status" aria-hidden="true"></span>${label}`;
    } else {
        btn.disabled = false;
        const fallback = btn.dataset.defaultHtml || 'Apply';
        btn.innerHTML = fallback;
    }
}

async function handleExternalIfxApply() {
    const bridgeName = computeInternalBridgeName();
    logInfo(`External IFX apply initiated for bridge ${bridgeName}`);
    const message = `This will create a new internal bridge named "${bridgeName}" and use it to connect the CORE VM with the selected VM.\n\nDo you want to continue?`;
    if (!window.confirm(message)) {
        logInfo('External IFX apply cancelled by user');
        return;
    }
    setExternalIfxApplyBusy(true);
    updateExternalIfxStatus(`Applying bridge "${bridgeName}"…`, 'info', { busy: true });
    try {
        const { idx, scenario, name: scenarioName } = getActiveScenarioContext();
        if (idx === null || !scenario) {
            const failureMessage = 'Unable to determine the active scenario. Please select a scenario and try again.';
            logWarn('External IFX apply failed: active scenario not found');
            updateExternalIfxStatus(failureMessage, 'danger');
            try { showToast('Unable to determine active scenario for Apply.', { autohide: true, delay: 2500 }); } catch (e) {}
            return;
        }

        logInfo(`External IFX apply context resolved for scenario ${idx} (${scenarioName || 'unnamed'})`);

        const hitlState = ensureHitlStateForScenario(scenario);
        const coreState = hitlState.core || (hitlState.core = {});
        const proxState = hitlState.proxmox || {};
        const pickFirst = (...candidates) => {
            for (let idxCandidate = 0; idxCandidate < candidates.length; idxCandidate += 1) {
                const candidate = candidates[idxCandidate];
                if (candidate === null || candidate === undefined) continue;
                const text = String(candidate).trim();
                if (text) return text;
            }
            return '';
        };
        const hostInterfaces = Array.isArray(state.host_interfaces) ? state.host_interfaces : [];
        const hostInfoLookup = new Map(
            hostInterfaces
                .filter(item => item && typeof item === 'object' && item.name)
                .map(item => [item.name, item])
        );
        const proxInventoryList = proxState && proxState.inventory && Array.isArray(proxState.inventory.vms)
            ? proxState.inventory.vms
            : [];
        const findVmRecord = (nodeVal, vmidVal) => {
            if (!nodeVal || !vmidVal) return null;
            const nodeKey = String(nodeVal).trim();
            const vmidKey = String(vmidVal).trim();
            if (!nodeKey || !vmidKey) return null;
            for (let vmIdx = 0; vmIdx < proxInventoryList.length; vmIdx += 1) {
                const vmEntry = proxInventoryList[vmIdx];
                if (!vmEntry || typeof vmEntry !== 'object') continue;
                const vmNode = vmEntry.node !== undefined && vmEntry.node !== null ? String(vmEntry.node).trim() : '';
                const vmId = vmEntry.vmid !== undefined && vmEntry.vmid !== null ? String(vmEntry.vmid).trim() : '';
                if (vmNode && vmId && vmNode === nodeKey && vmId === vmidKey) {
                    return vmEntry;
                }
            }
            return null;
        };

        const buildHitlApplyPayload = (rawHitl) => {
            const clean = { enabled: !!rawHitl.enabled, interfaces: [], core: {}, proxmox: {} };
            const missingCore = [];
            const ifaceList = Array.isArray(rawHitl.interfaces) ? rawHitl.interfaces : [];
            for (let i = 0; i < ifaceList.length; i += 1) {
                const entry = ifaceList[i];
                if (!entry || typeof entry !== 'object') {
                    continue;
                }
                const sanitized = {
                    name: entry.name || '',
                    attachment: entry.attachment || '',
                };
                const hostInfo = hostInfoLookup.get(sanitized.name) || null;
                let proxTargetClean = null;
                const proxTarget = entry.proxmox_target;
                if (proxTarget && typeof proxTarget === 'object') {
                    proxTargetClean = {
                        node: pickFirst(proxTarget.node, proxTarget.vm_node, proxTarget.raw && proxTarget.raw.node),
                        vmid: pickFirst(proxTarget.vmid, proxTarget.vm_id, proxTarget.raw && proxTarget.raw.vmid, proxTarget.raw && proxTarget.raw.vm_id),
                        interface_id: pickFirst(
                            proxTarget.interface_id,
                            proxTarget.id,
                            proxTarget.adapter,
                            proxTarget.raw && proxTarget.raw.interface_id,
                            proxTarget.raw && proxTarget.raw.id,
                            proxTarget.raw && proxTarget.raw.adapter
                        ),
                    };
                    if (proxTarget.vm_name || proxTarget.label) {
                        proxTargetClean.vm_name = proxTarget.vm_name ?? proxTarget.label ?? '';
                    }
                    if (proxTarget.macaddr) proxTargetClean.macaddr = proxTarget.macaddr;
                    if (proxTarget.bridge) proxTargetClean.bridge = proxTarget.bridge;
                    if (proxTarget.model) proxTargetClean.model = proxTarget.model;
                }
                if (!proxTargetClean && hostInfo && hostInfo.proxmox && typeof hostInfo.proxmox === 'object') {
                    const hostProx = hostInfo.proxmox;
                    proxTargetClean = {
                        node: pickFirst(hostProx.vm_node, hostProx.node, hostProx.raw && hostProx.raw.node),
                        vmid: pickFirst(hostProx.vmid, hostProx.vm_id, hostProx.raw && hostProx.raw.vmid, hostProx.raw && hostProx.raw.vm_id),
                        interface_id: pickFirst(hostProx.id, hostProx.interface_id, hostProx.adapter, hostProx.raw && hostProx.raw.interface_id, hostProx.raw && hostProx.raw.id, hostProx.raw && hostProx.raw.adapter),
                    };
                    const vmName = pickFirst(hostProx.vm_name, hostProx.raw && hostProx.raw.vm_name, hostProx.raw && hostProx.raw.name);
                    if (vmName) proxTargetClean.vm_name = vmName;
                    if (hostProx.macaddr) proxTargetClean.macaddr = String(hostProx.macaddr).trim();
                    if (hostProx.bridge) proxTargetClean.bridge = String(hostProx.bridge).trim();
                    if (hostProx.model) proxTargetClean.model = String(hostProx.model).trim();
                }
                if (proxTargetClean) {
                    if (!proxTargetClean.interface_id && hostInfo && hostInfo.mac) {
                        const macKey = String(hostInfo.mac).trim().toLowerCase();
                        const nodeVal = proxTargetClean.node || (hostInfo.proxmox && pickFirst(hostInfo.proxmox.vm_node, hostInfo.proxmox.node));
                        const vmidVal = proxTargetClean.vmid || (hostInfo.proxmox && pickFirst(hostInfo.proxmox.vmid, hostInfo.proxmox.vm_id));
                        const vmRecord = findVmRecord(nodeVal, vmidVal);
                        if (vmRecord && Array.isArray(vmRecord.interfaces)) {
                            for (let ifaceIdx = 0; ifaceIdx < vmRecord.interfaces.length; ifaceIdx += 1) {
                                const vmIface = vmRecord.interfaces[ifaceIdx];
                                if (!vmIface || typeof vmIface !== 'object') continue;
                                const ifaceMac = vmIface.macaddr ? String(vmIface.macaddr).trim().toLowerCase() : '';
                                if (ifaceMac && ifaceMac === macKey) {
                                    proxTargetClean.interface_id = pickFirst(vmIface.id, vmIface.interface_id, vmIface.name);
                                    if (!proxTargetClean.bridge && vmIface.bridge) proxTargetClean.bridge = String(vmIface.bridge).trim();
                                    if (!proxTargetClean.model && vmIface.model) proxTargetClean.model = String(vmIface.model).trim();
                                    break;
                                }
                            }
                        }
                    }
                    if (!proxTargetClean.interface_id && proxTargetClean.macaddr) {
                        const macKey = String(proxTargetClean.macaddr).trim().toLowerCase();
                        const vmRecord = findVmRecord(proxTargetClean.node, proxTargetClean.vmid);
                        if (vmRecord && Array.isArray(vmRecord.interfaces)) {
                            for (let ifaceIdx = 0; ifaceIdx < vmRecord.interfaces.length; ifaceIdx += 1) {
                                const vmIface = vmRecord.interfaces[ifaceIdx];
                                if (!vmIface || typeof vmIface !== 'object') continue;
                                const ifaceMac = vmIface.macaddr ? String(vmIface.macaddr).trim().toLowerCase() : '';
                                if (ifaceMac && ifaceMac === macKey) {
                                    proxTargetClean.interface_id = pickFirst(vmIface.id, vmIface.interface_id, vmIface.name);
                                    if (!proxTargetClean.bridge && vmIface.bridge) proxTargetClean.bridge = String(vmIface.bridge).trim();
                                    if (!proxTargetClean.model && vmIface.model) proxTargetClean.model = String(vmIface.model).trim();
                                    break;
                                }
                            }
                        }
                    }
                    sanitized.proxmox_target = proxTargetClean;
                }
                const external = entry.external_vm;
                if (external && typeof external === 'object') {
                    const ext = {
                        vm_key: external.vm_key ?? '',
                        vmid: external.vmid ?? '',
                        interface_id: external.interface_id ?? '',
                    };
                    if (external.vm_node) ext.vm_node = external.vm_node;
                    if (external.vm_name) ext.vm_name = external.vm_name;
                    sanitized.external_vm = ext;
                    const hasCoreSelection = proxTargetClean && proxTargetClean.interface_id;
                    const hasExternalSelection = (ext.vm_key && String(ext.vm_key).trim()) ||
                        (ext.vmid && String(ext.vmid).trim()) ||
                        (ext.vm_name && String(ext.vm_name).trim());
                    if (hasExternalSelection && !hasCoreSelection) {
                        missingCore.push(sanitized.name || `Interface ${i + 1}`);
                    }
                }
                clean.interfaces.push(sanitized);
            }
            const coreRaw = rawHitl.core;
            if (coreRaw && typeof coreRaw === 'object') {
                clean.core = {
                    vm_key: coreRaw.vm_key ?? '',
                    vm_name: coreRaw.vm_name ?? '',
                    vm_node: coreRaw.vm_node ?? '',
                    internal_bridge: coreRaw.internal_bridge ?? '',
                    internal_bridge_owner: coreRaw.internal_bridge_owner ?? '',
                };
            }
            const proxRaw = rawHitl.proxmox;
            if (proxRaw && typeof proxRaw === 'object') {
                clean.proxmox = {
                    secret_id: proxRaw.secret_id ?? proxRaw.secretId ?? null,
                };
            }
            return { clean, missingCore };
        };

        const { clean: sanitizedHitl, missingCore } = buildHitlApplyPayload(hitlState);
        const ifaceCount = Array.isArray(sanitizedHitl.interfaces) ? sanitizedHitl.interfaces.length : 0;
        const extSelections = sanitizedHitl.interfaces.filter(iface => iface?.external_vm && (iface.external_vm.vm_key || iface.external_vm.vmid || iface.external_vm.vm_name)).length;
        const proxSelections = sanitizedHitl.interfaces.filter(iface => iface?.proxmox_target && iface.proxmox_target.interface_id).length;
        logInfo(`External IFX apply payload prepared (interfaces=${ifaceCount}, externalMapped=${extSelections}, coreAdapters=${proxSelections})`);
        if (missingCore.length) {
            const detailMessage = missingCore.length === 1
                ? `${missingCore[0]} needs a Proxmox adapter (for example, net0) selected in Step 3 before applying the bridge.`
                : `Select a Proxmox adapter (for example, net0) in Step 3 for: ${missingCore.join(', ')}.`;
            logWarn(`External IFX apply blocked: no Proxmox adapter chosen for ${missingCore.join(', ')}`);
            updateExternalIfxStatus(detailMessage, 'warning', { busy: false });
            try { showToast(detailMessage, { autohide: false }); } catch (e) {}
            return;
        }
        const requestPayload = {
            bridge_name: bridgeName,
            scenario_index: idx,
            scenario_name: scenarioName,
            bridge_owner: window.CORETG_USERNAME || '',
            hitl: sanitizedHitl,
        };
        enrichPayloadWithScenarioContext(requestPayload, { includeCore: false });

        logInfo(`External IFX apply dispatching to /api/hitl/apply_bridge for scenario ${idx}`);

        const resp = await fetch('/api/hitl/apply_bridge', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            credentials: 'same-origin',
            body: JSON.stringify(requestPayload),
        });

        let data = null;
        try { data = await resp.json(); } catch (err) { data = null; }

        logInfo(`External IFX apply response received HTTP ${resp.status}`);

        if (!resp.ok || !data || data.success === false) {
            const errMessage = (data && (data.error || data.message)) ? (data.error || data.message) : `Bridge apply failed (HTTP ${resp.status})`;
            logError(`External IFX apply failed: ${errMessage}`);
            updateExternalIfxStatus(errMessage, 'danger');
            try { showToast(errMessage, { autohide: false }); } catch (e) {}
            return;
        }

        const appliedBridgeName = data.bridge_name || bridgeName;
        coreState.internal_bridge = appliedBridgeName;
        const responseOwner = (data.bridge_owner || requestPayload.bridge_owner || '').toString();
        coreState.internal_bridge_owner = responseOwner;
        window.requestAnimationFrame(() => {
            try { updateProxmoxSummary(idx); } catch (rafErr) { console.warn('Failed to update Proxmox summary', rafErr); }
        });
        window.setTimeout(() => {
            try { persistEditorState(); } catch (persistErr) { console.warn('Failed to persist editor state', persistErr); }
            try {
                const hidden = document.getElementById('scenarios_json');
                if (hidden) hidden.value = JSON.stringify({ scenarios: state.scenarios, active_index: activeIdx });
            } catch (hiddenErr) { console.warn('Failed refreshing hidden scenarios_json', hiddenErr); }
        }, 0);

        const successMessage = data.message || `Bridge "${appliedBridgeName}" applied successfully.`;
        logInfo(`External IFX apply confirmed for scenario ${idx} with bridge ${appliedBridgeName}`);
        updateExternalIfxStatus(successMessage, 'success', { busy: false, autoHideMs: 3000 });
        try { showToast(`${successMessage} Scenario saved.`, { autohide: true, delay: 2500 }); } catch (e) {}
        if (Array.isArray(data.warnings) && data.warnings.length) {
            const warningText = data.warnings.join('\n');
            logWarn(`External IFX apply warnings: ${warningText}`);
            updateExternalIfxStatus(`${successMessage}\n${warningText}`, 'warning');
            try { showToast(warningText, { autohide: false }); } catch (e) {}
        }
        window.setTimeout(() => {
            const fallbackSubmit = () => {
                const editorForm = document.getElementById('editorForm');
                try {
                    if (editorForm && typeof editorForm.requestSubmit === 'function') {
                        editorForm.requestSubmit();
                    } else if (editorForm) {
                        editorForm.submit();
                    }
                } catch (submitErr) {
                    console.warn('Failed to auto-save scenario after External IFX apply (fallback submit)', submitErr);
                }
            };
            if (typeof autoSaveXml !== 'function') {
                fallbackSubmit();
                return;
            }
            (async () => {
                try {
                    await autoSaveXml();
                    logInfo('Scenario auto-saved after External IFX apply');
                } catch (saveErr) {
                    const warningMessage = 'Bridge applied but auto-save failed. Save XML manually.';
                    logWarn(`${warningMessage}: ${saveErr}`);
                    updateExternalIfxStatus(warningMessage, 'warning');
                    try { showToast(warningMessage, { autohide: false }); } catch (toastErr) { console.warn('Toast failed', toastErr); }
                    fallbackSubmit();
                }
            })();
        }, 300);
    } catch (err) {
        try {
            const detail = err && err.stack ? err.stack : (err && err.toString ? err.toString() : 'unknown error');
            logError(`External IFX apply threw unexpected error: ${detail}`);
        } catch (_) {}
        const errMessage = err instanceof Error ? err.message : 'Failed to apply external IFX configuration.';
        logError(`External IFX apply failed: ${errMessage}`);
        updateExternalIfxStatus(errMessage, 'danger');
        try { showToast(errMessage, { autohide: false }); } catch (e) {}
    } finally {
        setExternalIfxApplyBusy(false);
    }
}

function handleCoreFieldUpdate(inputEl, { rerender } = { rerender: false }) {
    if (!inputEl) return;
    if (IS_BUILDER_VIEW) return;
    const sidx = parseInt(inputEl.getAttribute('data-scen-idx'));
    if (Number.isNaN(sidx) || !state.scenarios?.[sidx]) return;
    const field = inputEl.getAttribute('data-hitl-core-field');
    if (!field) return;
    const hitlState = ensureHitlStateForScenario(state.scenarios[sidx]);
    const coreState = hitlState.core || (hitlState.core = {});
    let dirty = false;
    if (inputEl.type === 'checkbox') {
        const value = !!inputEl.checked;
        if (coreState[field] !== value) {
            coreState[field] = value;
            dirty = true;
        }
    } else if (field === 'grpc_port' || field === 'ssh_port') {
        const fallback = field === 'grpc_port' ? 50051 : 22;
        const parsed = parseInt(inputEl.value, 10);
        const sanitized = Number.isFinite(parsed) && parsed > 0 ? parsed : fallback;
        if (coreState[field] !== sanitized) {
            coreState[field] = sanitized;
            dirty = true;
        }
    } else if (field === 'ssh_host' || field === 'venv_bin' || field === 'ssh_username' || field === 'ssh_password') {
        const value = (inputEl.value || '').trim();
        if ((coreState[field] || '') !== value) {
            coreState[field] = value;
            dirty = true;
            if (field === 'venv_bin') {
                coreState.venv_test_status = null;
                coreState.venv_test_message = null;
                coreState.venv_test_at = null;
                coreState.venv_test_python = null;
                const modalIdxRaw = coreConnectionModal?.getAttribute('data-scen-idx');
                const modalIdx = modalIdxRaw !== null ? parseInt(modalIdxRaw, 10) : NaN;
                if (!Number.isNaN(modalIdx) && modalIdx === sidx) {
                    setCoreVenvStatusDisplay(null, null);
                }
            } else if (field in {'ssh_host':1,'ssh_username':1,'ssh_password':1}) {
                coreState.venv_test_status = null;
                coreState.venv_test_message = null;
                coreState.venv_test_at = null;
                coreState.venv_test_python = null;
            }
        }
    } else {
        const value = inputEl.value || '';
        if ((coreState[field] || '') !== value) {
            coreState[field] = value;
            dirty = true;
        }
    }
    if (dirty) {
        coreState.last_tested_status = null;
        coreState.last_tested_message = null;
        coreState.last_tested_at = null;
        coreState.last_tested_host = null;
        coreState.last_tested_port = null;
        persistEditorState();
        const hidden = document.getElementById('scenarios_json');
        if (hidden) hidden.value = JSON.stringify({ scenarios: state.scenarios, active_index: activeIdx });
    }
    updateProxmoxSummary(sidx);
    if (dirty && rerender) {
        renderMain();
    }
}

async function validateCoreConnection(sidx, options = {}) {
    const {
        triggerButton = null,
        workingLabel = 'Testing…',
        statusEl: providedStatusEl,
        hintOnStart = null,
        hintOnSuccess = null,
        hintOnFailure = null,
        successToastMessage = null,
        closeModalOnSuccess = false,
        suppressToasts = false,
        rememberCredentials = true,
        autoStartDaemon = false,
    } = options;
    if (Number.isNaN(sidx) || !state.scenarios?.[sidx]) {
        return { ok: false, message: 'Scenario unavailable' };
    }
    if (IS_BUILDER_VIEW) {
        if (!options.suppressToasts && typeof showToast === 'function') {
            try { showToast('Builder view is read-only. CORE credentials are managed by an admin.', { autohide: true, delay: 3200 }); } catch (_) {}
        }
        return { ok: false, message: 'Builder view is read-only' };
    }
    const scenario = state.scenarios[sidx];
    const hitlState = ensureHitlStateForScenario(scenario);
    const coreState = hitlState.core || (hitlState.core = {});
    const vmKey = (coreState.vm_key || '').toString().trim();
    const vmNode = (coreState.vm_node || '').toString().trim();
    const body = {
        core: {
            host: coreState.grpc_host || '',
            port: coreState.grpc_port || 50051,
            ssh_host: coreState.ssh_host || coreState.grpc_host || '',
            ssh_port: coreState.ssh_port || 22,
            ssh_username: coreState.ssh_username || '',
            ssh_password: coreState.ssh_password || '',
                venv_bin: coreState.venv_bin || '',
            ssh_enabled: true,
            core_secret_id: coreState.core_secret_id || null,
            vm_key: vmKey,
            vm_node: vmNode,
            auto_start_daemon: autoStartDaemon,
        },
    };
    enrichPayloadWithScenarioContext(body, { scenarioIndex: sidx, scenarioOverride: scenario });
    const statusEl = providedStatusEl ?? document.querySelector(`[data-hitl-core-status="${sidx}"]`);
    const button = triggerButton;
    const originalLabel = button?.textContent;
    if (!vmKey) {
        const message = 'Select a CORE VM before testing the connection.';
        if (statusEl) {
            statusEl.textContent = message;
            statusEl.classList.remove('text-success', 'text-warning', 'text-danger', 'text-muted');
            statusEl.classList.add('text-danger');
        }
        if (!suppressToasts) {
            try { showToast(message, { autohide: true, delay: 2600 }); } catch (e) {}
        }
        return { ok: false, message };
    }
    if (button) {
        button.disabled = true;
        button.textContent = workingLabel;
    }
    if (statusEl) {
        statusEl.textContent = workingLabel === 'Testing…' ? 'Testing CORE connection…' : 'Validating CORE connection…';
        statusEl.classList.remove('text-success', 'text-warning', 'text-danger');
        statusEl.classList.add('text-muted');
    }
    if (hintOnStart && typeof setCoreConnectionHint === 'function') {
        setCoreConnectionHint(hintOnStart, 'info');
    }
    const restoreButton = () => {
        if (button) {
            button.disabled = false;
            if (originalLabel !== undefined) {
                button.textContent = originalLabel;
            }
        }
    };
    try {
        const resp = await fetch('/test_core', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            credentials: 'same-origin',
            body: JSON.stringify(body),
        });
        let data = null;
        try { data = await resp.json(); } catch (err) { data = null; }
        const nowIso = new Date().toISOString();
        if (data && data.ok) {
            const summary = (data.core_summary && typeof data.core_summary === 'object') ? data.core_summary : null;
            coreState.last_tested_status = 'success';
            coreState.last_tested_message = data.message
                || (data.forward_host && data.forward_port
                    ? `Tunnel ${data.forward_host}:${data.forward_port}`
                    : 'Connection successful');
            coreState.last_tested_at = nowIso;
            coreState.last_tested_host = data.host || coreState.grpc_host || '';
            coreState.last_tested_port = data.port || coreState.grpc_port || null;
            const incomingSecretId = data.core_secret_id || (summary && summary.identifier) || null;
            if (rememberCredentials) {
                coreState.core_secret_id = incomingSecretId;
                coreState.validated = !!incomingSecretId;
                coreState.last_validated_at = (summary && summary.stored_at) || nowIso;
                coreState.stored_summary = summary;
            } else {
                coreState.core_secret_id = coreState.core_secret_id || null;
                if (!coreState.core_secret_id) {
                    coreState.validated = false;
                    coreState.last_validated_at = null;
                    coreState.stored_summary = null;
                }
            }
            syncGlobalCoreConnection(coreState, coreState.last_tested_host, coreState.last_tested_port);
            coreState.ssh_password = '';
            persistEditorState();
            const hidden = document.getElementById('scenarios_json');
            if (hidden) hidden.value = JSON.stringify({ scenarios: state.scenarios, active_index: activeIdx });
            const pwdInput = document.querySelector(`[data-hitl-core-field="ssh_password"][data-scen-idx="${sidx}"]`);
            if (pwdInput) {
                pwdInput.value = '';
                pwdInput.setAttribute('placeholder', 'Stored securely');
            }
            updateProxmoxSummary(sidx);
            renderMain();
            if (typeof setCoreConnectionHint === 'function') {
                if (hintOnSuccess) {
                    setCoreConnectionHint(hintOnSuccess, rememberCredentials ? 'success' : 'warning');
                } else if (hintOnStart) {
                    setCoreConnectionHint(rememberCredentials ? 'Validation successful.' : 'Validated without storing credentials. Re-enter password next time.', rememberCredentials ? 'success' : 'warning');
                }
            }
            if (!suppressToasts) {
                try {
                    const toastMessage = successToastMessage || data.message || (rememberCredentials ? 'CORE connection verified' : 'CORE verified (not stored)');
                    showToast(toastMessage, { autohide: true, delay: 2500 });
                } catch (e) {}
            }
            if (closeModalOnSuccess && coreConnectionModal && window.bootstrap) {
                try { bootstrap.Modal.getInstance(coreConnectionModal)?.hide(); } catch (e) {}
            }
            return { ok: true, data };
        }
        const message = (data && data.error) ? data.error : `HTTP ${resp.status}`;
        coreState.last_tested_status = 'failure';
        coreState.last_tested_message = message;
        coreState.last_tested_at = nowIso;
        coreState.last_tested_host = coreState.grpc_host || '';
        coreState.last_tested_port = coreState.grpc_port || null;
        markGlobalCoreDisconnected();
        persistEditorState();
        const hidden = document.getElementById('scenarios_json');
        if (hidden) hidden.value = JSON.stringify({ scenarios: state.scenarios, active_index: activeIdx });
        updateProxmoxSummary(sidx);
        renderMain();
        const pwdInput = document.querySelector(`[data-hitl-core-field="ssh_password"][data-scen-idx="${sidx}"]`);
        if (pwdInput) pwdInput.removeAttribute('placeholder');
        if (typeof setCoreConnectionHint === 'function') {
            if (hintOnFailure) {
                setCoreConnectionHint(`${hintOnFailure}: ${message}`, 'danger');
            } else if (hintOnStart) {
                setCoreConnectionHint(message, 'danger');
            }
        }
        if (!suppressToasts) {
            try { showToast(`CORE test failed: ${message}`, { autohide: false }); } catch (e) {}
        }
        return { ok: false, message };
    } catch (err) {
        const message = err instanceof Error ? err.message : 'Connection test failed';
        coreState.last_tested_status = 'failure';
        coreState.last_tested_message = message;
        coreState.last_tested_at = new Date().toISOString();
        coreState.last_tested_host = coreState.grpc_host || '';
        coreState.last_tested_port = coreState.grpc_port || null;
        markGlobalCoreDisconnected();
        persistEditorState();
        const hidden = document.getElementById('scenarios_json');
        if (hidden) hidden.value = JSON.stringify({ scenarios: state.scenarios, active_index: activeIdx });
        updateProxmoxSummary(sidx);
        renderMain();
        const pwdInput = document.querySelector(`[data-hitl-core-field="ssh_password"][data-scen-idx="${sidx}"]`);
        if (pwdInput) pwdInput.removeAttribute('placeholder');
        if (typeof setCoreConnectionHint === 'function') {
            if (hintOnFailure) {
                setCoreConnectionHint(`${hintOnFailure}: ${message}`, 'danger');
            } else if (hintOnStart) {
                setCoreConnectionHint(message, 'danger');
            }
        }
        if (!suppressToasts) {
            try { showToast(`CORE test failed: ${message}`, { autohide: false }); } catch (e) {}
        }
        return { ok: false, message };
    } finally {
        restoreButton();
    }
}

async function hydrateCoreModalWithSecret(secretId, sidx, { scenarioName = '' } = {}) {
    if (!secretId || !coreConnectionModal) return;
    try {
        const creds = await fetchStoredCoreCredentials(secretId);
        if (!creds) return;
        if (!coreConnectionModal || coreConnectionModal.getAttribute('data-scen-idx') !== String(sidx)) {
            return;
        }
        const assignIfEmpty = (inputEl, value) => {
            if (!inputEl || inputEl.disabled) return;
            const strValue = value ?? '';
            if (!inputEl.value && strValue !== undefined && strValue !== null) {
                inputEl.value = strValue;
            }
        };
        assignIfEmpty(coreModalInputs.grpc_host, creds.grpc_host || creds.host || '');
        assignIfEmpty(coreModalInputs.grpc_port, creds.grpc_port || creds.port || 50051);
        assignIfEmpty(coreModalInputs.ssh_host, creds.ssh_host || creds.host || '');
        assignIfEmpty(coreModalInputs.ssh_port, creds.ssh_port || 22);
        assignIfEmpty(coreModalInputs.ssh_username, creds.ssh_username || '');
        assignIfEmpty(coreModalInputs.venv_bin, creds.venv_bin || CORE_DEFAULT_VENV_BIN);
        if (coreModalInputs.ssh_password && !coreModalInputs.ssh_password.disabled) {
            coreModalInputs.ssh_password.value = creds.ssh_password || '';
            if (creds.ssh_password) {
                coreModalInputs.ssh_password.removeAttribute('placeholder');
            }
        }
        if (typeof setCoreConnectionHint === 'function') {
            const label = scenarioName
                ? `Loaded stored CORE credentials for ${scenarioName}.`
                : 'Loaded stored CORE credentials from the vault.';
            setCoreConnectionHint(label, creds.ssh_password ? 'success' : 'info');
        }
    } catch (err) {
        console.warn('Failed to load stored CORE credentials', err);
        if (typeof setCoreConnectionHint === 'function' && coreConnectionModal && coreConnectionModal.getAttribute('data-scen-idx') === String(sidx)) {
            setCoreConnectionHint('Stored CORE credentials unavailable. Re-enter password to continue.', 'warning');
        }
    }
}

const CORE_MODAL_INPUT_IDS = {
    grpc_host: 'coreGrpcHost',
    grpc_port: 'coreGrpcPort',
    ssh_host: 'coreSshHost',
    ssh_port: 'coreSshPort',
    ssh_username: 'coreSshUsername',
    ssh_password: 'coreSshPassword',
    venv_bin: 'coreVenvBin',
};

function resolveCoreModalReferences() {
    if (!coreConnectionModal) {
        coreConnectionModal = document.getElementById('coreConnectionModal');
    }
    if (!coreConnectionForm) {
        coreConnectionForm = document.getElementById('coreConnectionForm');
    }
    if (!coreConnectionHint) {
        coreConnectionHint = document.getElementById('coreConnectionHint');
    }
    Object.entries(CORE_MODAL_INPUT_IDS).forEach(([field, id]) => {
        if (!coreModalInputs[field]) {
            const inputEl = document.getElementById(id);
            if (inputEl) {
                coreModalInputs[field] = inputEl;
                if (!inputEl.dataset.coreModalInputBound) {
                    inputEl.addEventListener('input', () => handleCoreModalInputChange(field));
                    if (inputEl.type === 'checkbox') {
                        inputEl.addEventListener('change', () => handleCoreModalInputChange(field));
                    }
                    inputEl.dataset.coreModalInputBound = '1';
                }
            }
        }
    });
}

async function handleCoreConnectionSave(event) {
    event?.preventDefault?.();
    resolveCoreModalReferences();
    if (IS_BUILDER_VIEW) {
        if (typeof setCoreConnectionHint === 'function') {
            setCoreConnectionHint('Builder view is read-only. Ask an admin to update CORE credentials.', 'info');
        }
        return;
    }
    if (!coreConnectionModal || !state?.scenarios?.length) {
        return;
    }
    const triggerButton = (event && event.currentTarget && event.currentTarget instanceof HTMLElement)
        ? event.currentTarget
        : (coreConnectionSaveBtn || document.getElementById('coreConnectionSaveBtn'));
    const targetIdxRaw = coreConnectionModal.getAttribute('data-scen-idx') || String(activeIdx);
    const sidx = parseInt(targetIdxRaw, 10);
    if (Number.isNaN(sidx) || !state.scenarios?.[sidx]) {
        return;
    }
    const scenario = state.scenarios[sidx];
    const hitlState = ensureHitlStateForScenario(scenario);
    const coreState = hitlState.core || (hitlState.core = {});
    const rememberToggle = document.getElementById('coreRememberCreds');
    const rememberCreds = rememberToggle ? !!rememberToggle.checked : shouldRememberCore(hitlState);
    coreState.remember_credentials = rememberCreds;
    const autoStartToggle = document.getElementById('coreAutoStartDaemon');
    const autoStartDaemon = autoStartToggle ? !!autoStartToggle.checked : !!(coreState.auto_start_daemon);
    coreState.auto_start_daemon = autoStartDaemon;
    const proxState = hitlState.proxmox || {};
    const prerequisitesMet = !!(proxState.validated && proxState.secret_id && coreState.vm_key);
    if (!prerequisitesMet) {
        if (typeof setCoreConnectionHint === 'function') {
            setCoreConnectionHint('Select and validate a CORE VM before saving connection details.', 'warning');
        }
        return;
    }
    if (coreConnectionForm && !coreConnectionForm.checkValidity()) {
        coreConnectionForm.classList.add('was-validated');
        const invalidControls = Array.from(coreConnectionForm.querySelectorAll(':invalid'));
        const invalidLabels = invalidControls.map((input) => {
            if (!(input instanceof HTMLElement)) return null;
            const id = input.id || input.getAttribute('name') || '';
            let labelText = '';
            if (id) {
                const escapedId = (window.CSS && typeof window.CSS.escape === 'function') ? window.CSS.escape(id) : id;
                const lbl = coreConnectionForm.querySelector(`label[for="${escapedId}"]`);
                if (lbl) {
                    labelText = lbl.textContent?.trim() || '';
                }
            }
            if (!labelText) {
                labelText = input.getAttribute('placeholder') || input.dataset.hitlCoreField || 'Field';
            }
            return labelText.trim();
        }).filter(Boolean);
        if (typeof setCoreConnectionHint === 'function') {
            const msg = invalidLabels.length
                ? `Fix the highlighted fields: ${invalidLabels.join(', ')}.`
                : 'Please fill out the required fields.';
            setCoreConnectionHint(msg, 'warning');
        }
        const firstInvalid = invalidControls[0];
        try {
            firstInvalid?.focus({ preventScroll: false });
            if (typeof firstInvalid?.select === 'function' && firstInvalid.type !== 'number') {
                firstInvalid.select();
            }
            firstInvalid?.scrollIntoView({ block: 'center', behavior: 'smooth' });
        } catch (err) {}
        coreConnectionForm?.reportValidity();
        return;
    }
    const snapshotBefore = JSON.stringify(coreState);
    Object.entries(coreModalInputs).forEach(([field, input]) => {
        if (!input || input.disabled) return;
        input.setAttribute('data-scen-idx', String(sidx));
        if (field === 'ssh_password' && input.value) {
            input.removeAttribute('placeholder');
        }
        handleCoreFieldUpdate(input, { rerender: false });
    });
    const snapshotAfter = JSON.stringify(coreState);
    const changed = snapshotBefore !== snapshotAfter;
    const modalRefresher = typeof window.refreshCoreConnectionModal === 'function'
        ? window.refreshCoreConnectionModal
        : null;
    if (changed) {
        updateProxmoxSummary(sidx);
        renderMain();
    } else if (modalRefresher) {
        modalRefresher(sidx);
    }
    const statusEl = document.querySelector(`[data-hitl-core-status="${sidx}"]`);
    await validateCoreConnection(sidx, {
        triggerButton,
        workingLabel: 'Validating…',
        statusEl,
        hintOnStart: 'Validating CORE connection…',
        hintOnSuccess: 'Connection saved and validated.',
        hintOnFailure: 'Validation failed',
        successToastMessage: rememberCreds ? 'CORE connection saved & validated' : 'CORE connection verified (not stored)',
        closeModalOnSuccess: true,
        rememberCredentials: rememberCreds,
        autoStartDaemon: autoStartDaemon,
    });
}

function wireCoreConnectionSaveButton() {
    if (!coreConnectionSaveBtn) {
        coreConnectionSaveBtn = document.getElementById('coreConnectionSaveBtn');
    }
    if (!coreConnectionSaveBtn) return;
    if (!coreConnectionSaveBtn.dataset.coreSaveBound) {
        coreConnectionSaveBtn.addEventListener('click', handleCoreConnectionSave);
        coreConnectionSaveBtn.dataset.coreSaveBound = '1';
    }
}

function resolveCoreVenvTestElements() {
    if (!coreTestVenvBtn) {
        coreTestVenvBtn = document.getElementById('coreTestVenvBtn');
    }
    if (!coreVenvTestStatus) {
        coreVenvTestStatus = document.getElementById('coreVenvTestStatus');
    }
}

function setCoreVenvStatusDisplay(status, message) {
    resolveCoreVenvTestElements();
    if (!coreVenvTestStatus) {
        return;
    }
    let text = message;
    if (!text) {
        if (status === 'success') {
            text = 'Virtualenv verified.';
        } else if (status === 'failure') {
            text = 'Virtualenv test failed.';
        } else {
            text = 'Not tested.';
        }
    }
    coreVenvTestStatus.textContent = text;
    coreVenvTestStatus.classList.remove('text-success', 'text-danger', 'text-muted');
    if (status === 'success') {
        coreVenvTestStatus.classList.add('text-success');
    } else if (status === 'failure') {
        coreVenvTestStatus.classList.add('text-danger');
    } else {
        coreVenvTestStatus.classList.add('text-muted');
    }
}

function handleCoreModalInputChange(fieldName) {
    if (['venv_bin', 'ssh_host', 'ssh_username', 'ssh_password'].includes(fieldName)) {
        setCoreVenvStatusDisplay(null, null);
    }
    updateCoreVenvTestButtonState();
}

function updateCoreVenvTestButtonState() {
    resolveCoreModalReferences();
    resolveCoreVenvTestElements();
    if (!coreTestVenvBtn) {
        return;
    }
    if (IS_BUILDER_VIEW) {
        coreTestVenvBtn.disabled = true;
        coreTestVenvBtn.title = 'Builder view is read-only';
        return;
    }
    const venvInput = coreModalInputs.venv_bin;
    const hostInput = coreModalInputs.ssh_host;
    const usernameInput = coreModalInputs.ssh_username;
    const passwordInput = coreModalInputs.ssh_password;
    const grpcHostInput = coreModalInputs.grpc_host;
    const inputsDisabled = !!(venvInput && venvInput.disabled);
    const venvPath = (venvInput && venvInput.value ? venvInput.value.trim() : '');
    const sshHost = (hostInput && hostInput.value ? hostInput.value.trim() : '')
        || (grpcHostInput && grpcHostInput.value ? grpcHostInput.value.trim() : '');
    const sshUsername = (usernameInput && usernameInput.value ? usernameInput.value.trim() : '');
    const sshPassword = passwordInput ? passwordInput.value || '' : '';
    const enable = !inputsDisabled && !!(venvPath && sshHost && sshUsername && sshPassword);
    coreTestVenvBtn.disabled = !enable;
}

async function handleCoreVenvTest(event) {
    event?.preventDefault?.();
    resolveCoreModalReferences();
    resolveCoreVenvTestElements();
    if (!coreConnectionModal || !coreModalInputs.venv_bin) {
        return;
    }
    if (IS_BUILDER_VIEW) {
        setCoreVenvStatusDisplay(null, 'Builder view cannot run remote tests.');
        return;
    }
    const triggerButton = (event && event.currentTarget instanceof HTMLElement)
        ? event.currentTarget
        : coreTestVenvBtn;
    if (!triggerButton) {
        return;
    }
    const targetIdxRaw = coreConnectionModal.getAttribute('data-scen-idx') || String(activeIdx);
    const sidx = parseInt(targetIdxRaw, 10);
    if (Number.isNaN(sidx) || !state.scenarios?.[sidx]) {
        return;
    }
    const scenario = state.scenarios[sidx];
    const hitlState = ensureHitlStateForScenario(scenario);
    const coreState = hitlState.core || (hitlState.core = {});
    const venvPath = (coreModalInputs.venv_bin.value || '').trim();
    if (!venvPath) {
        setCoreVenvStatusDisplay('failure', 'Enter a venv bin path to test.');
        return;
    }
    const sshHost = (coreModalInputs.ssh_host?.value || coreState.ssh_host || coreState.grpc_host || '').trim()
        || (coreModalInputs.grpc_host?.value || '').trim();
    if (!sshHost) {
        setCoreVenvStatusDisplay('failure', 'Enter the SSH host before testing the virtualenv.');
        return;
    }
    const sshPortRaw = parseInt(coreModalInputs.ssh_port?.value || '', 10);
    const sshPort = Number.isFinite(sshPortRaw) && sshPortRaw > 0
        ? sshPortRaw
        : (Number(coreState.ssh_port) || 22);
    const sshUsername = (coreModalInputs.ssh_username?.value || '').trim();
    if (!sshUsername) {
        setCoreVenvStatusDisplay('failure', 'Enter the SSH username before testing the virtualenv.');
        return;
    }
    const sshPassword = coreModalInputs.ssh_password?.value || '';
    if (!sshPassword) {
        setCoreVenvStatusDisplay('failure', 'Enter the SSH password before testing the virtualenv.');
        return;
    }
    const originalLabel = triggerButton.textContent;
    triggerButton.disabled = true;
    triggerButton.textContent = 'Testing…';
    setCoreVenvStatusDisplay(null, 'Testing virtualenv…');
    const payload = {
        venv_bin: venvPath,
        ssh_host: sshHost,
        ssh_port: sshPort,
        ssh_username: sshUsername,
        ssh_password: sshPassword,
    };
    const persistVenvResult = (status, message, extra = {}) => {
        coreState.venv_test_status = status;
        coreState.venv_test_message = message;
        coreState.venv_test_at = new Date().toISOString();
        coreState.venv_test_python = extra.python || null;
        persistEditorState();
    };
    try {
        const resp = await fetch('/test_core_venv', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            credentials: 'same-origin',
            body: JSON.stringify(payload),
        });
        let data = null;
        try { data = await resp.json(); } catch (err) { data = null; }
        if (resp.ok && data?.ok) {
            const msg = data.message || 'Virtualenv verified.';
            setCoreVenvStatusDisplay('success', msg);
            persistVenvResult('success', msg, { python: data.python_executable || null });
            if (typeof showToast === 'function') {
                try { showToast('CORE venv verified', { autohide: true, delay: 2200 }); } catch (_) {}
            }
        } else {
            const message = (data && data.error) ? data.error : `HTTP ${resp.status}`;
            setCoreVenvStatusDisplay('failure', message);
            persistVenvResult('failure', message, { python: null });
            if (typeof showToast === 'function') {
                try { showToast(`CORE venv test failed: ${message}`, { autohide: false }); } catch (_) {}
            }
        }
    } catch (err) {
        const message = err instanceof Error ? err.message : 'Virtualenv test failed.';
        setCoreVenvStatusDisplay('failure', message);
        persistVenvResult('failure', message, { python: null });
        if (typeof showToast === 'function') {
            try { showToast(message, { autohide: false }); } catch (_) {}
        }
    } finally {
        triggerButton.disabled = false;
        if (originalLabel !== undefined) {
            triggerButton.textContent = originalLabel;
        }
    }
}

function wireCoreVenvTestButton() {
    resolveCoreVenvTestElements();
    if (!coreTestVenvBtn) {
        return;
    }
    if (!coreTestVenvBtn.dataset.coreVenvBound) {
        coreTestVenvBtn.addEventListener('click', handleCoreVenvTest);
        coreTestVenvBtn.dataset.coreVenvBound = '1';
    }
    updateCoreVenvTestButtonState();
}

// --- Scenario multi-select support ---
let selectedScenarioIds = new Set();
try {
    const savedSel = JSON.parse(localStorage.getItem('coretg_selected_scenarios')||'[]');
    if (Array.isArray(savedSel)) savedSel.forEach(id => selectedScenarioIds.add(id));
} catch(e){}

function persistScenarioSelection() {
    try { localStorage.setItem('coretg_selected_scenarios', JSON.stringify(Array.from(selectedScenarioIds))); } catch(e){}
}

function ensureScenarioIds() {
    let changed = false;
    state.scenarios.forEach(s => {
        if (!s._sid) { s._sid = 'scen_' + Date.now().toString(36) + '_' + Math.random().toString(36).slice(2,8); changed = true; }
    });
    if (changed) persistEditorState();
}

function toggleScenarioSelection(id, checked) {
    if (checked) selectedScenarioIds.add(id); else selectedScenarioIds.delete(id);
    persistScenarioSelection();
    updateBulkButtonsState();
}

function selectAllScenarios() {
    ensureScenarioIds();
    const allIds = state.scenarios.map(s => s._sid);
    const allSelected = allIds.every(id => selectedScenarioIds.has(id));
    if (allSelected) { selectedScenarioIds.clear(); }
    else { allIds.forEach(id => selectedScenarioIds.add(id)); }
    persistScenarioSelection();
    renderSidebar();
}

function deleteSelectedScenarios() {
    if (!selectedScenarioIds.size) return;
    const count = selectedScenarioIds.size;
    if (!confirm(`Delete ${count} selected scenario${count>1?'s':''}? This cannot be undone.`)) return;
    const beforeLen = state.scenarios.length;
    state.scenarios = state.scenarios.filter(s => !selectedScenarioIds.has(s._sid));
    selectedScenarioIds.clear();
    if (!state.scenarios.length) {
        // Always keep at least one blank scenario to avoid empty editor state hassles
        state.scenarios.push(defaultScenario());
        activeIdx = 0;
    } else {
        if (activeIdx >= state.scenarios.length) activeIdx = state.scenarios.length - 1;
    }
    logInfo(`Deleted ${beforeLen - state.scenarios.length} scenarios`);
    persistEditorState();
    persistScenarioSelection();
    try { previewState.dirty = true; updatePlanButtons(); } catch(e){}
    render();
}

function updateBulkButtonsState() {
    const delBtn = document.getElementById('deleteSelectedScenariosBtn');
    if (!delBtn) return;
    if (selectedScenarioIds.size) { delBtn.removeAttribute('disabled'); delBtn.title = 'Delete selected'; }
    else { delBtn.setAttribute('disabled','disabled'); delBtn.title = 'No scenarios selected'; }
}

function renderSidebar() {
    ensureScenarioIds();
    const list = document.getElementById('scenarioList');
    list.innerHTML = '';
    const escapeHtml = (value) => (value ?? '').toString()
        .replace(/&/g,'&amp;')
        .replace(/</g,'&lt;')
        .replace(/>/g,'&gt;')
        .replace(/"/g,'&quot;')
        .replace(/'/g,'&#39;');
    state.scenarios.forEach((scen, idx) => {
        const sid = scen._sid;
        const a = document.createElement('a');
        a.href = '#';
        a.className = 'list-group-item list-group-item-action py-1' + (idx === activeIdx ? ' active bg-primary text-white' : '');
        // Build inner HTML with checkbox
        const isChecked = selectedScenarioIds.has(sid);
        const name = scen.name || `Scenario ${idx+1}`;
        const safeName = escapeHtml(name);
        const checkboxHtml = IS_BUILDER_VIEW ? '' : `<input type="checkbox" class="form-check-input me-2 scenario-select" data-sid="${sid}" ${isChecked? 'checked':''} onclick="event.stopPropagation(); toggleScenarioSelection('${sid}', this.checked);" />`;
        a.innerHTML = `<div class="d-flex align-items-center">
            ${checkboxHtml}
            <span class="flex-grow-1 text-truncate" title="${safeName}">${safeName}</span>
        </div>`;
        a.onclick = (e) => { e.preventDefault(); activeIdx = idx; persistEditorState(); render(); };
        list.appendChild(a);
    });
    const appendScenarioBtn = document.getElementById('appendScenarioBtn');
    const importBtn = document.getElementById('importBtn');
    const exportBtn = document.getElementById('exportBtn');
    const selectAllBtn = document.getElementById('selectAllScenariosBtn');
    const deleteSelectedBtn = document.getElementById('deleteSelectedScenariosBtn');
    const hiddenLoadInput = document.getElementById('hiddenLoadInput');
    const hiddenLoadForm = document.getElementById('hiddenLoadForm');
    if (appendScenarioBtn && !IS_BUILDER_VIEW) {
        appendScenarioBtn.onclick = (e) => {
            e.preventDefault();
            logInfo('New scenario created');
            state.scenarios.push(defaultScenario());
            activeIdx = state.scenarios.length - 1;
            persistEditorState();
            try { previewState.dirty = true; updatePlanButtons(); } catch(e){}
            render();
        };
    }
    if (importBtn) importBtn.onclick = (e) => { e.preventDefault(); logInfo('Import scenarios clicked'); hiddenLoadInput.click(); };
    if (hiddenLoadInput) hiddenLoadInput.onchange = () => { if (hiddenLoadInput.files && hiddenLoadInput.files.length > 0) { saveScrollBeforeNav(); hiddenLoadForm.submit(); } };
    if (exportBtn) exportBtn.onclick = (e) => {
        e.preventDefault();
        logInfo('Export clicked');
        const rp = state.result_path || '';
        if (!rp.endsWith('.xml')) {
            logWarn('Export blocked: no saved XML');
            alert('Please Save XML first (middle panel) to export the current scenarios.');
            return;
        }
        window.location.href = window.location.origin + '/download_report?path=' + encodeURIComponent(rp);
    };
    if (selectAllBtn && !IS_BUILDER_VIEW) {
        selectAllBtn.onclick = (e) => { e.preventDefault(); selectAllScenarios(); };
    }
    if (deleteSelectedBtn && !IS_BUILDER_VIEW) {
        deleteSelectedBtn.onclick = (e) => { e.preventDefault(); deleteSelectedScenarios(); };
    }
    const selectCoreVmBtn = document.getElementById('selectCoreVmBtn');
    const configHitlBtn = document.getElementById('configHitlBtn');
    const coreVmSelectModalEl = document.getElementById('coreVmSelectModal');
    const configHitlModalEl = document.getElementById('externalIfxModal');
    const openCoreVmSelectModal = () => {
        if (IS_BUILDER_VIEW) {
            const msg = 'CORE VM changes require admin access.';
            if (typeof showToast === 'function') {
                try { showToast(msg, { autohide: true, delay: 3200 }); } catch (_) {}
            } else if (window.alert) {
                window.alert(msg);
            }
            return;
        }
        if (!coreVmSelectModalEl || !window.bootstrap) return;
        const modalInstance = bootstrap.Modal.getInstance(coreVmSelectModalEl)
            || new bootstrap.Modal(coreVmSelectModalEl, { backdrop: true, keyboard: true });
        modalInstance.show();
    };

    if (selectCoreVmBtn && !IS_BUILDER_VIEW && !selectCoreVmBtn.dataset.hitlModalBound) {
        selectCoreVmBtn.addEventListener('click', openCoreVmSelectModal);
        selectCoreVmBtn.dataset.hitlModalBound = '1';
    }

    window.openCoreVmSelectModal = openCoreVmSelectModal;

    if (!IS_BUILDER_VIEW) {
        (() => {
            try {
                const url = new URL(window.location.href);
                if (url.searchParams.get('core_modal') === '1') {
                    setTimeout(openCoreVmSelectModal, 250);
                    url.searchParams.delete('core_modal');
                    const newQuery = url.searchParams.toString();
                    const queryPart = newQuery ? `?${newQuery}` : '';
                    const newUrl = `${url.pathname}${queryPart}${url.hash}`;
                    window.history.replaceState({}, '', newUrl);
                }
            } catch (err) {
                console.warn('Failed to auto-open CORE VM modal', err);
            }
        })();
    }
    if (configHitlBtn && !configHitlBtn.dataset.hitlModalBound) {
        configHitlBtn.addEventListener('click', () => {
            if (configHitlBtn.disabled) {
                const hint = configHitlBtn.getAttribute('title') || 'Complete Steps 1 and 2 first.';
                if (typeof showToast === 'function') {
                    showToast(hint, { autohide: true, delay: 2500 });
                } else if (window.alert) {
                    window.alert(hint);
                }
                return;
            }
            if (!configHitlModalEl || !window.bootstrap) return;
            const modalInstance = bootstrap.Modal.getInstance(configHitlModalEl) || new bootstrap.Modal(configHitlModalEl, { backdrop: true, keyboard: true });
            maybeAutoRefreshHitlInterfacesOnModalOpen(activeIdx);
            modalInstance.show();
        });
        configHitlBtn.dataset.hitlModalBound = '1';
    }
    updateBulkButtonsState();
}

function renderMain() {
    const root = document.getElementById('editorRoot');
    root.innerHTML = '';
    if (!state.scenarios.length) { return; }
    const scen = state.scenarios[activeIdx] || state.scenarios[0];
    const escapeHtml = (value) => (value ?? '').toString()
        .replace(/&/g,'&amp;')
        .replace(/</g,'&lt;')
        .replace(/>/g,'&gt;')
        .replace(/"/g,'&quot;')
        .replace(/'/g,'&#39;');
    const safeScenarioName = escapeHtml(scen?.name || '');
    const defaultScenarioName = escapeHtml(`Scenario ${activeIdx + 1}`);
    const existingMetaCard = document.getElementById('scenarioMetaCard');
    if (existingMetaCard && existingMetaCard.parentNode) {
        existingMetaCard.parentNode.removeChild(existingMetaCard);
    }

    const metaCard = document.createElement('div');
    metaCard.id = 'scenarioMetaCard';
    metaCard.className = 'card mb-3';
    metaCard.innerHTML = `
        <div class="card-body">
            <label class="form-label mb-1 small text-muted" for="scenarioNameInput_${activeIdx}">Scenario name</label>
            <input type="text" class="form-control" id="scenarioNameInput_${activeIdx}" data-field="name" data-scen-idx="${activeIdx}" value="${safeScenarioName}" placeholder="${defaultScenarioName}">
        </div>`;
    const baseScenarioCard = document.getElementById('baseCoreScenarioCard');
    if (baseScenarioCard && baseScenarioCard.parentNode) {
        baseScenarioCard.parentNode.insertBefore(metaCard, baseScenarioCard);
    } else {
        root.appendChild(metaCard);
    }

    const removeExistingCard = (cardId) => {
        const existing = document.getElementById(cardId);
        if (existing && existing.parentNode) {
            existing.parentNode.removeChild(existing);
        }
    };
    removeExistingCard('scenarioHitlCoreCard');
    removeExistingCard('scenarioHitlConfigCard');

    const hostInterfaces = Array.isArray(state.host_interfaces) ? state.host_interfaces : [];
    const hitl = ensureHitlStateForScenario(scen);
    const proxmox = hitl.proxmox || { url: '', port: 8006, username: '', password: '' };
    const participantProxmoxUrlRaw = (hitl.participant_proxmox_url || '').toString();
    const participantProxmoxUrlHtml = escapeHtml(participantProxmoxUrlRaw);
    const participantProxmoxUrlHasValue = participantProxmoxUrlRaw.trim().length > 0;
    const proxValidated = !!(proxmox.validated && proxmox.secret_id);
    const hasProxmox = !!(proxmox.url && proxmox.username);
    const proxPort = proxmox.port ?? 8006;
    const proxSummaryText = hasProxmox
        ? (proxValidated
            ? `Proxmox validated for ${proxmox.username} @ ${proxmox.url}:${proxPort}`
            : `Proxmox pending validation for ${proxmox.username} @ ${proxmox.url}:${proxPort}`)
        : 'Proxmox resource not assigned.';
    const proxSummaryHtml = escapeHtml(proxSummaryText);
    const proxSummaryClass = proxValidated ? 'text-success' : (hasProxmox ? 'text-warning' : 'text-muted');
    const proxHasSecret = !!proxmox.secret_id;
    const proxHasAny = proxHasSecret || hasProxmox;
    const proxAssignLabel = proxHasSecret ? 'Update Proxmox Resource' : 'Assign Proxmox Resource';
    const proxInventoryInfo = (proxmox.inventory && typeof proxmox.inventory === 'object') ? proxmox.inventory : { fetched_at: null, vms: [] };
    const proxInventory = Array.isArray(proxInventoryInfo.vms) ? proxInventoryInfo.vms : [];
    const proxInventoryBusy = proxInventoryFetchInFlight.has(activeIdx);
    const proxInventoryError = proxmox.inventory_error ? proxmox.inventory_error.toString() : '';
    let proxInventoryStatus = '';
    if (!hasProxmox) {
        proxInventoryStatus = 'Assign credentials to load VM inventory.';
    } else if (!proxValidated) {
        proxInventoryStatus = 'Validate credentials to load VM inventory.';
    } else if (proxInventoryBusy) {
        proxInventoryStatus = 'Fetching Proxmox VM inventory…';
    } else if (proxInventory.length) {
        let fetchedReadable = '';
        if (proxInventoryInfo.fetched_at) {
            try {
                fetchedReadable = new Date(proxInventoryInfo.fetched_at).toLocaleString();
            } catch (err) {
                fetchedReadable = '';
            }
        }
        proxInventoryStatus = `Loaded ${proxInventory.length} VM${proxInventory.length === 1 ? '' : 's'}${fetchedReadable ? ` • Last fetched ${fetchedReadable}` : ''}`;
    } else if (proxInventoryError) {
        proxInventoryStatus = `Inventory error: ${proxInventoryError}`;
    } else {
        proxInventoryStatus = 'No VMs reported. Refresh to retry.';
    }
    const proxInventoryStatusHtml = escapeHtml(proxInventoryStatus);
    const proxRefreshDisabledAttr = (proxValidated && !proxInventoryBusy) ? '' : 'disabled';
    if (PROXMOX_INVENTORY_AUTO_REFRESH_ENABLED && proxValidated && !proxInventoryBusy && !proxInventory.length && !proxInventoryError) {
        fetchProxmoxInventory(activeIdx)
            .catch(err => console.warn('Proxmox inventory fetch failed', err));
    }
    const normalizeHost = (raw) => {
        if (!raw && raw !== 0) return '';
        let text = String(raw).trim().toLowerCase();
        if (text.startsWith('[') && text.endsWith(']')) text = text.slice(1, -1);
        if (text.startsWith('::ffff:') && /^::ffff:\d+\.\d+\.\d+\.\d+$/.test(text)) {
            text = text.replace('::ffff:', '');
        }
        return text;
    };
    const core = hitl.core || {};
    const coreVmKey = (core.vm_key || '').toString();
    const coreVmName = (core.vm_name || '').toString();
    const coreHost = (core.grpc_host || '').toString().trim();
    const corePort = Number.isFinite(Number(core.grpc_port)) && Number(core.grpc_port) > 0 ? Number(core.grpc_port) : 50051;
    const coreSshHostRaw = (core.ssh_host || '').toString().trim();
    const coreSshHost = coreSshHostRaw || coreHost;
    const coreSshPort = Number.isFinite(Number(core.ssh_port)) && Number(core.ssh_port) > 0 ? Number(core.ssh_port) : 22;
    const coreUser = (core.ssh_username || '').toString().trim();
    const coreSecretId = typeof core.core_secret_id === 'string' ? core.core_secret_id.trim() : '';
    const coreHasSecret = !!coreSecretId;
    const corePasswordRaw = (core.ssh_password || '').toString();
    const corePassword = corePasswordRaw;
    const corePasswordAvailable = !!corePasswordRaw || coreHasSecret;
    const vmKeyParts = coreVmKey ? coreVmKey.split('::') : [];
    const vmKeyNodePart = (vmKeyParts[0] || '').trim();
    const vmKeyIdPart = (vmKeyParts[1] || '').trim();
    const cachedVmInterfaceCount = Number.isFinite(Number(core.cached_vm_interface_count)) ? Number(core.cached_vm_interface_count) : null;
    const liveSelectedCoreVm = proxInventory.find(vm => `${vm.node ?? ''}::${vm.vmid ?? ''}` === coreVmKey) || null;
    const fallbackCoreVm = (!liveSelectedCoreVm && coreVmKey) ? {
        name: coreVmName || '',
        node: core.vm_node || vmKeyNodePart || '',
        status: core.cached_vm_status || '',
        vmid: vmKeyIdPart || '',
        interface_count_hint: cachedVmInterfaceCount,
    } : null;
    const resolvedCoreVm = liveSelectedCoreVm
        ? { ...liveSelectedCoreVm, cached: false }
        : (fallbackCoreVm ? { ...fallbackCoreVm, cached: true } : null);
    const resolvedVmInterfaceCount = (() => {
        if (resolvedCoreVm && Array.isArray(resolvedCoreVm.interfaces)) {
            return resolvedCoreVm.interfaces.length;
        }
        if (resolvedCoreVm && Number.isFinite(resolvedCoreVm.interface_count_hint)) {
            return Number(resolvedCoreVm.interface_count_hint);
        }
        if (cachedVmInterfaceCount !== null) {
            return cachedVmInterfaceCount;
        }
        return null;
    })();
    const interfaceCountKnown = resolvedVmInterfaceCount !== null;
    const coreVmHasInterfaces = !coreVmKey || !interfaceCountKnown || resolvedVmInterfaceCount >= 1;
    const coreVmSupportsHitl = !coreVmKey || !interfaceCountKnown || resolvedVmInterfaceCount >= 2;
    const coreVmNode = resolvedCoreVm && resolvedCoreVm.node !== undefined && resolvedCoreVm.node !== null
        ? String(resolvedCoreVm.node).trim()
        : (core.vm_node ? String(core.vm_node).trim() : vmKeyNodePart);
    const coreVmNameDisplay = IS_BUILDER_VIEW ? '' : coreVmName;
    const coreVmNodeDisplay = IS_BUILDER_VIEW ? '' : coreVmNode;
    const coreInputsComplete = !!(coreVmKey && coreHost && corePort && coreSshHost && coreSshPort && coreUser && corePasswordAvailable);
    const coreTestSuccess = core.last_tested_status === 'success';
    const coreTestMatches = coreTestSuccess
        && !!core.last_tested_host
        && normalizeHost(core.last_tested_host) === normalizeHost(coreHost)
        && Number(core.last_tested_port) === Number(corePort);
    const coreConnectionReady = proxValidated && coreInputsComplete && coreVmHasInterfaces && coreTestMatches;
    const coreReady = coreConnectionReady && coreVmSupportsHitl;
    const coreHitlBlocked = coreConnectionReady && !coreVmSupportsHitl;
    const coreTestable = proxValidated && coreInputsComplete && coreVmHasInterfaces;
    const hitlAuthReady = proxValidated && coreHasSecret && !!coreVmKey;
    const coreVmInterfaceWarning = (() => {
        if (!coreVmKey || !interfaceCountKnown) return '';
        if (!coreVmHasInterfaces) {
            const count = resolvedVmInterfaceCount || 0;
            return `<div class="alert alert-danger small mt-2 mb-0">Selected VM exposes ${count} network interface${count === 1 ? '' : 's'}. Add at least one interface to enable CORE connectivity.</div>`;
        }
        return '';
    })();
    const hostLookup = new Map(hostInterfaces.filter(it => it && typeof it === 'object').map(it => [it.name, it]));
    const getBridgeName = (iface) => {
        const direct = iface.bridge || iface.proxmox_bridge;
        if (direct) return String(direct).trim();
        const prox = iface.proxmox && typeof iface.proxmox === 'object' ? iface.proxmox : null;
        if (prox) {
            if (prox.bridge) return String(prox.bridge).trim();
            if (prox.raw && typeof prox.raw === 'object' && prox.raw.bridge) return String(prox.raw.bridge).trim();
        }
        return '';
    };
    const isVmbr0Bridge = (iface) => getBridgeName(iface).toLowerCase() === 'vmbr0';
    const describeIface = (iface) => {
        if (!iface || typeof iface !== 'object') return '';
        const parts = [];
        if (Array.isArray(iface.ipv4) && iface.ipv4.length) {
            parts.push(iface.ipv4.filter(Boolean).join(', '));
        }
        if ((!parts.length) && Array.isArray(iface.ipv6) && iface.ipv6.length) {
            parts.push(iface.ipv6.filter(Boolean)[0]);
        }
        if (iface.mac) parts.push(`MAC ${iface.mac}`);
        if (iface.mtu) parts.push(`MTU ${iface.mtu}`);
        if (iface.speed) parts.push(`${iface.speed} Mbps`);
        const bridgeName = getBridgeName(iface);
        if (bridgeName) parts.push(`Bridge ${bridgeName}`);
        if (iface.proxmox && typeof iface.proxmox === 'object') {
            const prox = iface.proxmox;
            const proxBits = [];
            const vmName = prox.vm_name || prox.raw?.vm_name || prox.raw?.name;
            const vmNode = prox.vm_node || prox.raw?.node;
            const ifaceId = prox.id || prox.raw?.id || prox.raw?.interface_id;
            if (vmName) proxBits.push(`${vmName}`);
            if (vmNode) proxBits.push(`node ${vmNode}`);
            if (ifaceId) proxBits.push(`iface ${ifaceId}`);
            if (prox.macaddr && prox.macaddr !== iface.mac) proxBits.push(prox.macaddr);
            if (prox.bridge) proxBits.push(`bridge ${prox.bridge}`);
            if (prox.model) proxBits.push(prox.model);
            if (proxBits.length) {
                parts.push(`Proxmox ${proxBits.join(' • ')}`);
            } else {
                parts.push('Proxmox mapping detected');
            }
        }
        return parts.join(' • ');
    };
    const normalizeVmInterfaceId = (vmIface) => {
        if (!vmIface || typeof vmIface !== 'object') return '';
        const rawId = vmIface.id ?? vmIface.interface_id ?? vmIface.name ?? '';
        return rawId ? String(rawId).trim() : '';
    };
    const isPhysicalVmInterface = (vmIface) => {
        if (!vmIface || typeof vmIface !== 'object') return false;
        const id = normalizeVmInterfaceId(vmIface);
        if (!id) return false;
        const bridge = (vmIface.bridge ?? '').toString().trim();
        if (!bridge) return false;
        if (bridge.toLowerCase() === 'vmbr0') return false;
        return true;
    };
    const getPhysicalVmInterfaces = (vm) => {
        if (!vm || typeof vm !== 'object') return [];
        const interfaces = Array.isArray(vm.interfaces) ? vm.interfaces : [];
        return interfaces.filter(isPhysicalVmInterface);
    };
    const describeVmInterface = (vmIface) => {
        if (!vmIface || typeof vmIface !== 'object') return '';
        const parts = [];
        const bridge = (vmIface.bridge ?? '').toString().trim();
        const macaddr = (vmIface.macaddr ?? '').toString().trim();
        const model = (vmIface.model ?? '').toString().trim();
        if (bridge) parts.push(`bridge ${bridge}`);
        if (macaddr) parts.push(macaddr);
        if (model) parts.push(model);
        return parts.join(' • ');
    };
    if (typeof window !== 'undefined') {
        window.getPhysicalVmInterfaces = getPhysicalVmInterfaces;
        window.describeVmInterface = describeVmInterface;
        window.normalizeVmInterfaceId = normalizeVmInterfaceId;
    }
    const summarizePhysicalVmInterfaces = (vm) => {
        const physical = getPhysicalVmInterfaces(vm);
        if (!physical.length) return '';
        const entries = physical.map(vmIface => {
            const ifaceId = normalizeVmInterfaceId(vmIface) || '(unknown)';
            const desc = describeVmInterface(vmIface);
            return desc ? `${ifaceId} (${desc})` : ifaceId;
        });
        return entries.join(', ');
    };
    const hitlInterfaces = Array.isArray(hitl.interfaces) ? hitl.interfaces : [];
    const hasHitlInterfaces = hitlInterfaces.length > 0;
    const selectedNames = new Set(hitlInterfaces.map(entry => (entry && entry.name ? entry.name : '')).filter(Boolean));
    const availableInterfaces = hostInterfaces.filter(iface => iface && !selectedNames.has(iface.name));
    const selectableInterfaces = availableInterfaces.filter(iface => iface && !isVmbr0Bridge(iface));
    const availableOptionsHtml = availableInterfaces.length
        ? availableInterfaces.map(iface => {
            const summary = describeIface(iface);
            const label = summary ? `${iface.name} — ${summary}` : iface.name;
            const disabled = isVmbr0Bridge(iface);
            const disabledAttr = disabled ? 'disabled data-hitl-bridge="vmbr0"' : '';
            const suffix = disabled ? ' (vmbr0 bridge)' : '';
            const title = disabled ? 'Interfaces on vmbr0 are reserved for the management bridge and cannot be selected for HITL.' : '';
            return `<option value="${escapeHtml(iface.name)}" ${disabledAttr} title="${escapeHtml(title)}">${escapeHtml(label + suffix)}</option>`;
        }).join('')
        : '<option disabled value="">All discovered interfaces selected</option>';
    const hitlToggleWasEnabled = !!hitl.enabled;
    const step3Enabled = hitlToggleWasEnabled && hitlAuthReady;
    const step3Disabled = !step3Enabled;
    const step3ToggleDisabledAttr = hitlAuthReady ? '' : 'disabled';
    const step3ToggleTooltipAttr = hitlAuthReady ? '' : 'data-bs-toggle="tooltip" data-bs-title="Validate Steps 1 and 2 before enabling Hardware in the Loop."';
    const step3ToggleCheckedAttr = hitlToggleWasEnabled ? 'checked' : '';
    const attachmentControlsDisabledAttr = (coreReady && step3Enabled) ? '' : 'disabled';
    const interfaceNoticeText = (() => {
        if (!hitlAuthReady) {
            if (!proxValidated) return 'Validate Proxmox credentials (Step 1) to unlock HITL interface mappings.';
            if (!coreHasSecret) return 'Store CORE credentials (Step 2) to unlock HITL interface mappings.';
            if (!coreVmKey) return 'Select a CORE VM in Step 2 to unlock HITL interface mappings.';
            return 'Authenticate Steps 1 and 2 to manage HITL interface mappings.';
        }
        if (!hitlToggleWasEnabled) return 'Enable Hardware in the Loop to manage HITL interface mappings.';
        if (!coreVmKey) return 'Complete steps 1 and 2 to manage HITL interface mappings.';
        if (!coreVmHasInterfaces) {
            return 'Selected CORE VM must expose at least one interface before mapping HITL interfaces.';
        }
        if (!coreVmSupportsHitl) {
            return 'Selected CORE VM exposes only one interface. HITL cannot be used until a second interface is added.';
        }
        return 'Complete steps 1 and 2 to manage HITL interface mappings.';
    })();
    const interfaceNoticeClass = (() => {
        if (!hitlAuthReady) return 'alert-warning';
        if (!hitlToggleWasEnabled) return 'alert-info';
        if (!coreVmKey) return 'alert-info';
        if (!coreVmHasInterfaces) return 'alert-danger';
        if (!coreVmSupportsHitl) return 'alert-warning';
        return 'alert-info';
    })();
    const externalVmCandidates = proxInventory.filter(vm => {
        const vmKey = `${vm.node ?? ''}::${vm.vmid ?? ''}`;
        if (vmKey === coreVmKey) return false;
        if (!coreVmNode) return false;
        const vmNode = vm && vm.node !== undefined && vm.node !== null ? String(vm.node).trim() : '';
        return vmNode && vmNode === coreVmNode;
    });
    const step4BaseEnabled = step3Enabled && proxValidated && !!coreVmKey && hitlAuthReady;
    const step4HasCandidates = externalVmCandidates.length > 0;
    const step4Enabled = step4BaseEnabled && step4HasCandidates;
    const step4PrereqItems = [
        {
            ok: hitlAuthReady,
            label: hitlAuthReady ? 'Steps 1 and 2 authenticated' : 'Validate Proxmox (Step 1) and CORE credentials (Step 2)',
        },
        {
            ok: step3Enabled,
            label: step3Enabled ? 'Hardware in the Loop toggle is enabled' : 'Enable the Hardware in the Loop toggle in Step 3',
        },
        {
            ok: hasHitlInterfaces,
            label: hasHitlInterfaces ? 'At least one HITL interface selected in Step 3' : 'Add a HITL interface in Step 3',
        },
        {
            ok: proxValidated,
            label: proxValidated ? 'Proxmox credentials are validated' : 'Validate the Proxmox credentials (Step 1)',
        },
        {
            ok: !!coreVmKey,
            label: coreVmKey ? 'CORE VM selected in Step 2' : 'Select a CORE VM in Step 2',
        },
        {
            ok: !proxInventoryBusy,
            label: proxInventoryBusy ? 'Wait for the Proxmox inventory fetch to finish' : 'Proxmox inventory fetch complete',
        },
        {
            ok: !proxInventoryError,
            label: proxInventoryError ? `Resolve Proxmox inventory error: ${proxInventoryError}` : 'Proxmox inventory is available',
        },
    ];
    const step4BlockingItems = step4PrereqItems.filter(item => !item.ok);
    const step4PrereqList = step4BlockingItems.map(item => {
        const icon = '❌';
        const toneClass = 'text-danger';
        return `<li class="${toneClass}">${icon} ${escapeHtml(item.label)}</li>`;
    }).join('');
    const step4PrereqHtml = step4BlockingItems.length
        ? `<div class="alert alert-info small mt-2 mb-0"><div class="fw-semibold">Step 4 prerequisites</div><ul class="mb-0 ps-3" style="list-style: none;">${step4PrereqList}</ul></div>`
        : '';
    const availableSize = Math.min(8, Math.max(4, hostInterfaces.length || 4));
    const gateShouldHide = step3Enabled && coreReady && hitlAuthReady;
    const interfacesGateNotice = `<div class="alert ${interfaceNoticeClass} small mb-3 ${gateShouldHide ? 'd-none' : ''}" data-hitl-interface-gate="${activeIdx}">${interfaceNoticeText}</div>`;
    const allowStep3RefreshUi = !!hitlAuthReady;
    const interfacesRefreshBusyRaw = core.interfaces_refresh_inflight === true;
    const interfacesRefreshBusy = allowStep3RefreshUi ? interfacesRefreshBusyRaw : false;
    const lastInterfacesError = core.last_interfaces_error || '';
    const lastInterfacesAttempt = core.last_interfaces_attempt || '';
    const lastInterfacesRefresh = core.last_interfaces_refresh || '';
    const availableSelectDisabledAttr = (coreReady && step3Enabled) ? '' : 'disabled';
    const addInterfacesDisabledAttr = (coreReady && step3Enabled && availableInterfaces.length && !interfacesRefreshBusy) ? '' : 'disabled';
    const refreshInterfacesDisabledAttr = (step3Enabled && !interfacesRefreshBusy) ? '' : 'disabled';
    const removeInterfaceDisabledAttr = step3Enabled ? '' : 'disabled';
    const refreshButtonLabel = interfacesRefreshBusy
        ? '<span class="spinner-border spinner-border-sm me-2" role="status" aria-hidden="true"></span>Refreshing…'
        : 'Refresh list';
    const retryButtonLabel = interfacesRefreshBusy
        ? '<span class="spinner-border spinner-border-sm me-2" role="status" aria-hidden="true"></span>Refreshing…'
        : 'Refresh CORE VM Interfaces';
    const refreshStatusText = (() => {
        if (interfacesRefreshBusy) return 'Enumerating interfaces…';
        if (lastInterfacesRefresh) {
            const rel = describeTimestampRelative(lastInterfacesRefresh);
            const relSafe = rel ? escapeHtml(rel) : null;
            const exact = (() => {
                try { return escapeHtml(new Date(lastInterfacesRefresh).toLocaleString()); }
                catch (err) { return null; }
            })();
            const parts = [];
            if (relSafe) parts.push(`Last refreshed ${relSafe}`);
            if (!relSafe && exact) parts.push(`Last refreshed ${exact}`);
            if (relSafe && exact && relSafe !== exact) parts.push(`(${exact})`);
            if (!parts.length && exact) parts.push(`Last refreshed ${exact}`);
            if (!parts.length) parts.push('Interfaces cached from previous run.');
            const source = state.host_interfaces_source ? `Source: ${escapeHtml(String(state.host_interfaces_source))}` : '';
            if (source) parts.push(source);
            return parts.join(' • ');
        }
        if (lastInterfacesAttempt) {
            const rel = describeTimestampRelative(lastInterfacesAttempt);
            if (rel) return `Last attempt ${escapeHtml(rel)}`;
        }
        return '';
    })();
    const refreshStatusHtml = refreshStatusText ? `<div class="small text-muted mt-1" data-hitl-refresh-status="${activeIdx}">${refreshStatusText}</div>` : '';
    const interfacesEmptyMessage = (() => {
        if (!hitlAuthReady) {
            if (!proxValidated) return '<div class="alert alert-info mb-0">Validate Proxmox credentials in Step 1 to unlock HITL interfaces.</div>';
            if (!coreHasSecret) return '<div class="alert alert-info mb-0">Store CORE credentials in Step 2 to unlock HITL interfaces.</div>';
            if (!coreVmKey) return '<div class="alert alert-info mb-0">Select a CORE VM in Step 2 to unlock HITL interfaces.</div>';
        }
        if (interfacesRefreshBusy) {
            return '<div class="alert alert-info mb-0">Enumerating interfaces from CORE…</div>';
        }
        if (lastInterfacesError) {
            const rel = describeTimestampRelative(lastInterfacesAttempt);
            const detail = rel ? ` <span class="text-muted">(Last attempt ${escapeHtml(rel)})</span>` : '';
            return `<div class="alert alert-danger mb-0">${escapeHtml(lastInterfacesError)}${detail}</div>`;
        }
        if (lastInterfacesAttempt) {
            const rel = describeTimestampRelative(lastInterfacesAttempt);
            const label = rel ? ` ${escapeHtml(rel)}` : ' previously';
            return `<div class="alert alert-warning mb-0">No interfaces were reported during the last refresh${label}. Verify the CORE VM has multiple adapters and try again.</div>`;
        }
        return '<div class="alert alert-info mb-0">Refresh to load interfaces from the CORE VM.</div>';
    })();
    const externalVmRowsHtml = (() => {
        if (!hasHitlInterfaces || !step3Enabled || (Array.isArray(hostInterfaces) && hostInterfaces.length === 0)) {
            return '<div class="text-muted small">Complete Step 3 (enable HITL and add at least one interface) to configure external connectivity.</div>';
        }
        if (!externalVmCandidates.length) {
            if (!coreVmNode) {
                return '<div class="alert alert-warning small mb-0">Unable to determine the CORE VM\'s Proxmox node. Refresh the inventory so external VMs on the same node can be suggested.</div>';
            }
            const nodeHint = ` on node ${escapeHtml(coreVmNode)}`;
            return `<div class="alert alert-warning small mb-0">No eligible Proxmox VMs${nodeHint} detected that share the CORE VM's node. Refresh the inventory after provisioning additional VMs on the same node.</div>`;
        }
        return hitlInterfaces.map((iface, ifaceIdx) => {
            if (!iface || typeof iface !== 'object') return '';
            const safeName = escapeHtml(iface.name || `Interface ${ifaceIdx + 1}`);
            const selectedExternal = (iface.external_vm && typeof iface.external_vm === 'object') ? iface.external_vm : null;
            const selectedKey = selectedExternal?.vm_key ? String(selectedExternal.vm_key) : '';
            const vmOptionMarkup = externalVmCandidates
                .filter(vm => `${vm.node ?? ''}::${vm.vmid ?? ''}` !== coreVmKey)
                .map(vm => {
                    const vmKey = `${vm.node ?? ''}::${vm.vmid ?? ''}`;
                    const ifaceCount = getPhysicalVmInterfaces(vm).length;
                    const vmName = vm.name ? String(vm.name) : `VM ${vm.vmid}`;
                    const labelParts = [`${vmName} (${ifaceCount} interface${ifaceCount === 1 ? '' : 's'})`];
                    if (vm.node) labelParts.push(`node ${vm.node}`);
                    if (vm.status) labelParts.push(`status ${vm.status}`);
                    return {
                        key: vmKey,
                        label: labelParts.join(' — '),
                        ifaceCount,
                        selected: vmKey === selectedKey,
                    };
                })
                .sort((a, b) => {
                    if (b.ifaceCount !== a.ifaceCount) return b.ifaceCount - a.ifaceCount;
                    const nameA = a.label.toLowerCase();
                    const nameB = b.label.toLowerCase();
                    if (nameA < nameB) return -1;
                    if (nameA > nameB) return 1;
                    return 0;
                })
                .map(option => `<option value="${escapeHtml(option.key)}" ${option.selected ? 'selected' : ''}>${escapeHtml(option.label)}</option>`);
            const selectDisabledAttr = step4Enabled ? '' : 'disabled';
            const selectedVm = selectedKey ? proxInventory.find(vm => `${vm.node ?? ''}::${vm.vmid ?? ''}` === selectedKey) : null;
            const physicalInterfaces = selectedVm ? getPhysicalVmInterfaces(selectedVm) : [];
            const physicalInterfacesSummary = selectedVm ? summarizePhysicalVmInterfaces(selectedVm) : '';
            const selectedIfaceId = selectedExternal?.interface_id ? String(selectedExternal.interface_id).trim() : '';
            const interfaceOptionList = physicalInterfaces.map(vmIface => {
                const ifaceId = normalizeVmInterfaceId(vmIface);
                const desc = describeVmInterface(vmIface);
                const label = desc ? `${ifaceId} — ${desc}` : ifaceId;
                return `<option value="${escapeHtml(ifaceId)}" ${ifaceId === selectedIfaceId ? 'selected' : ''}>${escapeHtml(label)}</option>`;
            });
            if (selectedIfaceId && !physicalInterfaces.some(vmIface => normalizeVmInterfaceId(vmIface) === selectedIfaceId)) {
                interfaceOptionList.unshift(`<option value="${escapeHtml(selectedIfaceId)}" selected>${escapeHtml(`${selectedIfaceId} (not detected)`)}</option>`);
            }
            const interfaceOptionsMarkup = ['<option value="">Select interface…</option>', ...interfaceOptionList].join('');
            const interfaceSelectDisabledAttr = (step4BaseEnabled && !!selectedKey) ? '' : 'disabled';
            const refreshExternalInterfacesDisabledAttr = (step4BaseEnabled && !!selectedKey && !proxInventoryBusy) ? '' : 'disabled';
            const helperParts = [];
            if (selectedExternal?.vm_name) helperParts.push(String(selectedExternal.vm_name));
            if (selectedExternal?.vm_node) helperParts.push(`node ${selectedExternal.vm_node}`);
            if (selectedExternal?.vmid !== undefined && selectedExternal?.vmid !== null && selectedExternal.vmid !== '') {
                helperParts.push(`ID ${selectedExternal.vmid}`);
            }
            if (selectedExternal?.interface_id) helperParts.push(`iface ${selectedExternal.interface_id}`);
            const helperHtml = helperParts.length ? `<div class="form-text">Selected: ${escapeHtml(helperParts.join(' • '))}</div>` : '';
            const interfaceSummaryParts = [];
            if (selectedExternal?.interface_bridge) interfaceSummaryParts.push(`bridge ${selectedExternal.interface_bridge}`);
            if (selectedExternal?.interface_mac) interfaceSummaryParts.push(selectedExternal.interface_mac);
            if (selectedExternal?.interface_model) interfaceSummaryParts.push(selectedExternal.interface_model);
            const interfaceSummaryHtml = interfaceSummaryParts.length ? `<div class="form-text">${escapeHtml(interfaceSummaryParts.join(' • '))}</div>` : '';
            const availableInterfacesHint = physicalInterfacesSummary ? `<div class="form-text text-muted">Physical interfaces: ${escapeHtml(physicalInterfacesSummary)}</div>` : '';
            let interfaceFooterHtml = '';
            if (!selectedKey) {
                interfaceFooterHtml = '<div class="form-text text-muted">Select a VM to choose its interface.</div>';
            } else if (!physicalInterfaces.length) {
                interfaceFooterHtml = '<div class="alert alert-warning small mt-2 mb-0">No physical interfaces detected on this VM (bridged adapters only).</div>';
            } else if (!selectedIfaceId) {
                interfaceFooterHtml = '<div class="form-text text-muted">Select the interface that should connect through this HITL link.</div>';
            }
            return `
                <div class="border rounded p-2 mb-2">
                    <div class="fw-semibold mb-1">CORE VM IFX Mapping: ${safeName}</div>
                    <label class="form-label small mb-1" for="hitlExternalVm_${activeIdx}_${ifaceIdx}">Participant VM</label>
                    <select class="form-select form-select-sm" id="hitlExternalVm_${activeIdx}_${ifaceIdx}" data-hitl-external-vm-select data-scen-idx="${activeIdx}" data-iface-index="${ifaceIdx}" ${selectDisabledAttr}>
                        <option value="">Select VM…</option>
                        ${vmOptionMarkup.join('')}
                    </select>
                    ${helperHtml}
                    <label class="form-label small mb-1 mt-2" for="hitlExternalVmIface_${activeIdx}_${ifaceIdx}">VM Interface</label>
                    <select class="form-select form-select-sm" id="hitlExternalVmIface_${activeIdx}_${ifaceIdx}" data-hitl-external-vm-iface-select data-scen-idx="${activeIdx}" data-iface-index="${ifaceIdx}" ${interfaceSelectDisabledAttr}>
                        ${interfaceOptionsMarkup}
                    </select>
                    <div class="d-flex flex-wrap gap-2 mt-2">
                        <button type="button" class="btn btn-sm btn-outline-secondary" data-hitl-step4-refresh data-scen-idx="${activeIdx}" data-iface-index="${ifaceIdx}" ${refreshExternalInterfacesDisabledAttr}>Refresh interfaces</button>
                    </div>
                    ${availableInterfacesHint}
                    ${interfaceSummaryHtml}
                    ${interfaceFooterHtml}
                </div>`;
        }).join('');
    })();
    const step4Content = (() => {
        if (!hasHitlInterfaces) {
            return '<div class="alert alert-info small mb-0">Add at least one HITL interface in Step 3 to configure external connectivity.</div>' + step4PrereqHtml;
        }
        if (!hitl.enabled) {
            return '<div class="alert alert-info small mb-0">Enable Hardware in the Loop to configure external connectivity.</div>' + step4PrereqHtml;
        }
        if (!proxValidated) {
            return '<div class="alert alert-warning small mb-0">Validate Proxmox credentials to load eligible VMs.</div>' + step4PrereqHtml;
        }
        if (proxInventoryBusy) {
            return '<div class="small text-muted">Loading Proxmox VM inventory…</div>' + step4PrereqHtml;
        }
        if (proxInventoryError) {
            return `<div class="alert alert-danger small mb-0">${escapeHtml(proxInventoryError)}</div>` + step4PrereqHtml;
        }
        if (!coreVmKey) {
            return '<div class="alert alert-warning small mb-0">Select a CORE VM in Step 2 before configuring external connectivity.</div>' + step4PrereqHtml;
        }
        if (!step4HasCandidates) {
            return externalVmRowsHtml + step4PrereqHtml;
        }
        return externalVmRowsHtml + step4PrereqHtml;
    })();
    const selectedInterfacesHtml = (hitl.interfaces && hitl.interfaces.length)
        ? hitl.interfaces.map((iface, ifaceIdx) => {
            const safeName = escapeHtml(iface.name || 'interface');
            const hostInfo = hostLookup.get(iface.name);
            const proxMapping = hostInfo && typeof hostInfo.proxmox === 'object' ? hostInfo.proxmox : null;
            const summary = describeIface(hostInfo || iface);
            const missingBadge = hostInfo ? '' : '<span class="badge rounded-pill text-bg-warning">Not detected</span>';
            const vmbrBadge = isVmbr0Bridge(hostInfo || iface) ? '<span class="badge rounded-pill text-bg-warning">vmbr0</span>' : '';
            const proxBadge = (() => {
                if (!proxMapping) return '';
                const vmName = proxMapping.vm_name || proxMapping.raw?.vm_name || proxMapping.raw?.name || '';
                const ifaceId = proxMapping.id || proxMapping.raw?.id || proxMapping.raw?.interface_id || '';
                const node = proxMapping.vm_node || proxMapping.raw?.node || '';
                const labelParts = [];
                if (vmName) labelParts.push(vmName);
                if (ifaceId) labelParts.push(ifaceId);
                if (node) labelParts.push(`node ${node}`);
                if (!labelParts.length && proxMapping.macaddr) labelParts.push(proxMapping.macaddr);
                const badgeLabel = labelParts.length ? labelParts.join(' • ') : 'Proxmox match';
                return `<span class="badge rounded-pill text-bg-info">${escapeHtml(badgeLabel)}</span>`;
            })();
            const summaryHtml = summary ? escapeHtml(summary) : 'No address information available';
            const attachmentValue = normalizeHitlAttachment(iface.attachment);
            const attachmentLabel = escapeHtml(prettyHitlAttachment(attachmentValue));
            const optionsMarkup = HITL_ATTACHMENT_CHOICES
                .map(opt => `<option value="${opt.value}" ${opt.value === attachmentValue ? 'selected' : ''}>${escapeHtml(opt.label)}</option>`)
                .join('');
            return `<div class="border rounded p-2 mb-2 d-flex justify-content-between align-items-start gap-2 flex-wrap">
                        <div class="flex-grow-1">
                            <div class="fw-semibold d-flex align-items-center gap-2 flex-wrap">${safeName}${missingBadge}${vmbrBadge}${proxBadge}<span class="badge rounded-pill text-bg-secondary">${attachmentLabel}</span></div>
                            <div class="small text-muted">${summaryHtml}</div>
                            <div class="mt-2">
                                <label class="form-label small mb-1" for="hitlAttach_${activeIdx}_${ifaceIdx}">Attach to</label>
                                <select class="form-select form-select-sm" id="hitlAttach_${activeIdx}_${ifaceIdx}" data-hitl-attach data-scen-idx="${activeIdx}" data-iface-index="${ifaceIdx}" ${attachmentControlsDisabledAttr}>
                                    ${optionsMarkup}
                                </select>
                            </div>
                        </div>
                        <button type="button" class="btn btn-sm btn-outline-danger" data-hitl-remove data-scen-idx="${activeIdx}" data-iface="${safeName}" ${removeInterfaceDisabledAttr}>Remove</button>
                    </div>`;
        }).join('')
        : '<div class="text-muted small">No interfaces selected.</div>';
    const hitlInterfacesMarkup = hostInterfaces.length
        ? `
            ${interfacesGateNotice}
            <div class="row g-3">
                <div class="col-md-6">
                    <label class="form-label">Available interfaces</label>
                    <select class="form-select" multiple size="${availableSize}" data-hitl-available data-scen-idx="${activeIdx}" id="hitlAvailable_${activeIdx}" ${availableSelectDisabledAttr}>
                        ${availableOptionsHtml}
                    </select>
                    <div class="d-flex flex-wrap gap-2 mt-2">
                        <button type="button" class="btn btn-sm btn-outline-primary" data-hitl-add data-scen-idx="${activeIdx}" ${addInterfacesDisabledAttr}>Add selected</button>
                        <button type="button" class="btn btn-sm btn-outline-secondary" data-hitl-refresh data-scen-idx="${activeIdx}" ${refreshInterfacesDisabledAttr} ${interfacesRefreshBusy ? 'data-refresh-busy="1"' : ''}>${refreshButtonLabel}</button>
                    </div>
                    <div class="form-text">Use ⌘/Ctrl to multi-select before adding.</div>
                    ${refreshStatusHtml}
                    ${!hasHitlInterfaces ? '<div class="alert alert-info small mt-3 mb-0">Add at least one interface to enable CORE VM IFX mapping.</div>' : ''}
                </div>
                ${hasHitlInterfaces ? `
                <div class="col-md-6">
                    <label class="form-label">Selected interfaces</label>
                    <div id="hitlSelected_${activeIdx}">
                        ${selectedInterfacesHtml}
                    </div>
                </div>` : ''}
            </div>
        </div>
    </div>`
        : `
            ${interfacesGateNotice}
            ${interfacesEmptyMessage}
            <div class="d-flex flex-wrap gap-2 mt-3">
                <button type="button" class="btn btn-sm btn-outline-secondary" data-hitl-refresh data-scen-idx="${activeIdx}" ${refreshInterfacesDisabledAttr} ${interfacesRefreshBusy ? 'data-refresh-busy="1"' : ''}>${retryButtonLabel}</button>
            </div>
            ${refreshStatusHtml}`;

    let coreVmOptionsMarkup = '';
    if (proxInventory.length) {
        const optionList = proxInventory.map(vm => {
            const vmKey = `${vm.node ?? ''}::${vm.vmid ?? ''}`;
            const vmDisplayName = vm.name ? String(vm.name) : `VM ${vm.vmid}`;
            const ifaceCount = Array.isArray(vm.interfaces) ? vm.interfaces.length : 0;
            const parts = [vmDisplayName];
            if (vm.node) parts.push(`node ${vm.node}`);
            if (vm.status) parts.push(`status ${vm.status}`);
            if (vm.vmid !== undefined && vm.vmid !== null) parts.push(`ID ${vm.vmid}`);
            if (ifaceCount) parts.push(`${ifaceCount} interface${ifaceCount === 1 ? '' : 's'}`);
            return `<option value="${escapeHtml(vmKey)}" ${vmKey === coreVmKey ? 'selected' : ''}>${escapeHtml(parts.join(' — '))}</option>`;
        });
        coreVmOptionsMarkup = ['<option value="">Select VM…</option>', ...optionList].join('');
    } else if (coreVmKey) {
        const fallbackLabelParts = [];
        if (coreVmName) fallbackLabelParts.push(coreVmName);
        if (coreVmNode) fallbackLabelParts.push(`node ${coreVmNode}`);
        fallbackLabelParts.push('cached selection');
        const fallbackLabel = fallbackLabelParts.filter(Boolean).join(' — ');
        coreVmOptionsMarkup = [
            '<option value="">Select VM…</option>',
            `<option value="${escapeHtml(coreVmKey)}" selected>${escapeHtml(fallbackLabel)}</option>`
        ].join('');
    } else {
        coreVmOptionsMarkup = '<option value="">No VMs available (refresh list)</option>';
    }

    const coreVmDetailsHtml = (() => {
        if (!coreVmKey) {
            return '';
        }
        if (!resolvedCoreVm) {
            return '<div class="alert alert-info small mb-0">Previously selected CORE VM preserved. Refresh the VM list to view details.</div>';
        }
        const name = escapeHtml(resolvedCoreVm.name ? String(resolvedCoreVm.name) : (resolvedCoreVm.vmid ? `VM ${resolvedCoreVm.vmid}` : 'Selected VM'));
        const node = escapeHtml(resolvedCoreVm.node ? String(resolvedCoreVm.node) : (coreVmNode || '—'));
        const status = resolvedCoreVm.status ? escapeHtml(String(resolvedCoreVm.status)) : (resolvedCoreVm.cached ? 'cached' : null);
        const vmid = resolvedCoreVm.vmid !== undefined && resolvedCoreVm.vmid !== null && resolvedCoreVm.vmid !== ''
            ? escapeHtml(String(resolvedCoreVm.vmid))
            : (vmKeyIdPart ? escapeHtml(vmKeyIdPart) : '—');
        const ifaceCountValue = interfaceCountKnown ? (resolvedVmInterfaceCount || 0) : null;
        const ifaceInfo = ifaceCountValue === null
            ? 'Interfaces unknown. Refresh VM list to confirm.'
            : `${ifaceCountValue} interface${ifaceCountValue === 1 ? '' : 's'}`;
        const ifaceLabel = escapeHtml(ifaceInfo);
        const cachedBadge = resolvedCoreVm.cached ? '<span class="badge text-bg-warning text-uppercase">Cached</span>' : (status ? `<span class="badge text-bg-secondary text-uppercase">${status}</span>` : '');
        return `
            <div class="border rounded p-3 bg-light small">
                <div class="d-flex justify-content-between align-items-center mb-2">
                    <span class="fw-semibold">${name}</span>
                    ${cachedBadge}
                </div>
                <dl class="row mb-0">
                    <dt class="col-5 text-muted">Node</dt><dd class="col-7">${node || '—'}</dd>
                    <dt class="col-5 text-muted">VM ID</dt><dd class="col-7">${vmid}</dd>
                    <dt class="col-5 text-muted">Interfaces</dt><dd class="col-7">${ifaceLabel}</dd>
                </dl>
            </div>`;
    })();

    const coreStoredSummary = (core.stored_summary && typeof core.stored_summary === 'object') ? core.stored_summary : null;
    const coreStoredAtRaw = core.last_validated_at || (coreStoredSummary && coreStoredSummary.stored_at) || '';
    const testedAtDisplay = core.last_tested_at ? (() => {
        try { return new Date(core.last_tested_at).toLocaleString(); } catch (err) { return null; }
    })() : null;
    const storedAtDisplay = coreStoredAtRaw ? (() => {
        try { return new Date(coreStoredAtRaw).toLocaleString(); } catch (err) { return null; }
    })() : null;
    let coreStatusText = '';
    let coreStatusClass = 'text-muted';
    if (!proxValidated) {
        coreStatusText = 'Validate Proxmox credentials to choose a CORE VM.';
    } else if (!coreVmKey) {
        coreStatusText = 'Select a CORE VM to configure connection details.';
    } else if (!coreVmHasInterfaces) {
        const count = interfaceCountKnown ? (resolvedVmInterfaceCount || 0) : 0;
        coreStatusText = `Selected CORE VM exposes ${count} network interface${count === 1 ? '' : 's'}. Add at least one interface to enable CORE connectivity.`;
        coreStatusClass = 'text-danger';
    } else if (!coreInputsComplete) {
        coreStatusText = 'Use Configure Connection to enter gRPC and SSH details, including credentials.';
        coreStatusClass = 'text-warning';
    } else if (!coreVmSupportsHitl) {
        if (coreHitlBlocked) {
            const vmNote = coreVmName ? ` • ${coreVmName}` : '';
            const storedNote = storedAtDisplay ? ` • Credentials stored ${storedAtDisplay}` : '';
            coreStatusText = `CORE connection verified${testedAtDisplay ? ` • Last tested ${testedAtDisplay}` : ''}${vmNote}${storedNote}. Add a second interface before enabling HITL mappings in Step 3.`;
        } else {
            coreStatusText = 'Selected CORE VM exposes only one interface. Add a second interface before enabling HITL mappings in Step 3.';
        }
        coreStatusClass = 'text-warning';
    } else if (coreReady) {
        const storedNote = storedAtDisplay ? ` • Credentials stored ${storedAtDisplay}` : '';
        const vmNote = coreVmName ? ` • ${coreVmName}` : '';
        coreStatusText = `CORE connection verified${testedAtDisplay ? ` • Last tested ${testedAtDisplay}` : ''}${vmNote}${storedNote}`;
        coreStatusClass = 'text-success';
    } else if (coreHasSecret && coreTestSuccess) {
        coreStatusText = 'Stored CORE credentials available. Re-test if connection details changed.';
        coreStatusClass = 'text-warning';
    } else if (core.last_tested_status === 'failure') {
        coreStatusText = core.last_tested_message ? `Last test failed: ${core.last_tested_message}` : 'CORE connection test failed.';
        coreStatusClass = 'text-danger';
    } else if (core.last_tested_status === 'success') {
        coreStatusText = 'CORE connection test succeeded for a different endpoint. Update details or re-test.';
        coreStatusClass = 'text-warning';
    } else {
        coreStatusText = 'Test the CORE connection to continue.';
        coreStatusClass = 'text-warning';
    }
    const coreStatusHtml = escapeHtml(coreStatusText);
    const coreInputsDisabled = !(proxValidated && coreVmKey);
    const testBtnDisabledAttr = coreTestable ? '' : 'disabled';
    const configureBtnDisabledAttr = (!coreVmKey || !proxValidated || proxInventoryBusy) ? 'disabled' : '';
        const coreConnectionSummaryHtml = (() => {
            if (IS_BUILDER_VIEW) {
                const summaryBody = coreVmKey
                    ? '<div class="text-muted small">Connection configured by an administrator.</div>'
                    : '<div class="text-muted small">No CORE VM assigned yet.</div>';
                return `
                    <div class="border rounded p-3 bg-light-subtle">
                        <h6 class="text-uppercase small mb-2">Connection</h6>
                        ${summaryBody}
                    </div>`;
            }
            const summarizeEndpoint = () => {
                if (!coreVmKey) return '';
                const grpcLabel = coreHost ? `${escapeHtml(coreHost)}:${corePort}` : '<span class="text-danger">Not set</span>';
                const sshHostLabel = coreSshHost ? escapeHtml(coreSshHost) : '<span class="text-danger">Not set</span>';
                const sshPortLabel = coreSshPort ? String(coreSshPort) : '<span class="text-danger">Not set</span>';
                const sshUserLabel = coreUser ? escapeHtml(coreUser) : '<span class="text-danger">Not set</span>';
                const pwdLabel = coreHasSecret
                    ? '<span class="text-success">Stored securely</span>'
                    : (corePasswordRaw ? '<span class="text-success">Provided</span>' : '<span class="text-danger">Not set</span>');
                return `
                    <dl class="row small mb-0">
                        <dt class="col-5 text-muted">gRPC Endpoint</dt><dd class="col-7">${grpcLabel}</dd>
                        <dt class="col-5 text-muted">SSH Host</dt><dd class="col-7">${sshHostLabel}</dd>
                        <dt class="col-5 text-muted">SSH Port</dt><dd class="col-7">${sshPortLabel}</dd>
                        <dt class="col-5 text-muted">SSH Username</dt><dd class="col-7">${sshUserLabel}</dd>
                        <dt class="col-5 text-muted">Password</dt><dd class="col-7">${pwdLabel}</dd>
                    </dl>`;
            };
            return `
                <div class="border rounded p-3 bg-light-subtle">
                    <h6 class="text-uppercase small mb-2">Connection</h6>
                    ${summarizeEndpoint()}
                </div>`;
        })();

    const step1SectionHtml = `
        <div class="mb-4" data-hitl-step="1">
            <h6 class="mb-2">Step 1 — Proxmox Resource</h6>
            <div class="d-flex flex-wrap align-items-center justify-content-between gap-2">
                <div class="${proxSummaryClass} small" data-proxmox-summary="${activeIdx}">${proxSummaryHtml}</div>
                <div class="d-flex flex-wrap align-items-center gap-2">
                    <span class="badge rounded-pill text-bg-info" data-proxmox-refresh-badge="${activeIdx}" style="${proxInventoryBusy ? '' : 'display:none;'}">Refreshing vm list</span>
                    <button type="button" class="btn btn-sm btn-outline-primary" data-proxmox-assign data-scen-idx="${activeIdx}">${proxAssignLabel}</button>
                    <button type="button" class="btn btn-sm btn-outline-secondary" data-proxmox-refresh data-scen-idx="${activeIdx}" ${proxRefreshDisabledAttr}>Refresh VM List</button>
                    <button type="button" class="btn btn-sm btn-outline-danger" data-proxmox-clear data-scen-idx="${activeIdx}" ${proxHasAny ? '' : 'disabled'}>Clear Proxmox Resource</button>
                </div>
            </div>
            <div class="small text-muted mt-2" data-proxmox-inventory-status="${activeIdx}">${proxInventoryStatusHtml}</div>
        </div>`;
    const step2SectionHtml = (() => {
        if (IS_BUILDER_VIEW) {
            const builderNotice = '<div class="alert alert-secondary small mb-3">CORE VM selection and credentials are managed by an admin. Contact them to request changes.</div>';
            const vmSummary = coreVmKey
                ? '<div class="alert alert-info small mb-0">CORE VM assigned by an administrator.</div>'
                : '<div class="alert alert-info small mb-0">No CORE VM assigned yet.</div>';
            return `
                <div class="mb-4" data-hitl-step="2">
                    <h6 class="mb-2">Step 2 — CORE VM &amp; Credentials</h6>
                    ${builderNotice}
                    <div class="row g-3 align-items-start">
                        <div class="col-md-6">
                            ${vmSummary}
                        </div>
                        <div class="col-md-6">
                            <div data-hitl-core-connection="${activeIdx}">${coreConnectionSummaryHtml}</div>
                        </div>
                    </div>
                    <div class="small mt-2 ${coreStatusClass}" data-hitl-core-status="${activeIdx}">${coreStatusHtml}</div>
                </div>`;
        }
        return `
        <div class="mb-4" data-hitl-step="2">
            <div class="d-flex justify-content-between align-items-center gap-2 mb-2">
                <h6 class="m-0">Step 2 — CORE VM &amp; Credentials</h6>
                <button type="button" class="btn btn-sm btn-outline-secondary" data-hitl-core-clear data-scen-idx="${activeIdx}" ${(coreVmKey || coreHost || coreUser || coreHasSecret) ? '' : 'disabled'}>Clear CORE Settings</button>
            </div>
            ${!proxValidated
                ? '<div class="alert alert-warning small mb-0">Validate Proxmox credentials to unlock CORE VM selection.</div>'
                : proxInventoryBusy
                    ? '<div class="small text-muted">Loading Proxmox VM inventory…</div>'
                    : proxInventoryError
                        ? `<div class="alert alert-danger small mb-3">${escapeHtml(proxInventoryError)}</div>`
                        : ''}
            ${proxValidated && !proxInventoryBusy && !proxInventoryError
                ? `
                    <div class="row g-3 align-items-start">
                        <div class="col-md-6">
                            <label class="form-label small" for="hitlCoreVm_${activeIdx}">CORE VM</label>
                            <select class="form-select form-select-sm mt-1" id="hitlCoreVm_${activeIdx}" data-hitl-core-vm-select data-scen-idx="${activeIdx}" ${proxInventory.length && !proxInventoryBusy ? '' : 'disabled'}>
                                ${coreVmOptionsMarkup}
                            </select>
                            <button type="button" class="btn btn-sm btn-outline-primary mt-2" data-hitl-core-configure data-scen-idx="${activeIdx}" ${configureBtnDisabledAttr}>Configure Connection</button>
                            ${coreVmInterfaceWarning}
                        </div>
                        <div class="col-md-6">
                            <div data-hitl-core-summary="${activeIdx}">${coreVmDetailsHtml}</div>
                        </div>
                    </div>
                    <div class="mt-3" data-hitl-core-connection="${activeIdx}">${coreConnectionSummaryHtml}</div>
                    <div class="d-flex flex-wrap gap-2 mt-3">
                        <button type="button" class="btn btn-sm btn-outline-primary" data-hitl-core-test data-scen-idx="${activeIdx}" ${testBtnDisabledAttr}>Test CORE Connection</button>
                    </div>
                    <div class="small mt-2 ${coreStatusClass}" data-hitl-core-status="${activeIdx}">${coreStatusHtml}</div>
                ` : ''}
        </div>`;
    })();
    const step3SectionHtml = `
        <div class="mb-4" data-hitl-step="3">
            <div class="d-flex justify-content-between align-items-center gap-2 mb-2">
                <h6 class="m-0">Step 3 — Hardware in the Loop</h6>
                <div class="form-check form-switch m-0" ${step3ToggleTooltipAttr}>
                    <input class="form-check-input" type="checkbox" id="hitlToggle_${activeIdx}" data-hitl-toggle data-scen-idx="${activeIdx}" ${step3ToggleCheckedAttr} ${step3ToggleDisabledAttr}>
                    <label class="form-check-label small" for="hitlToggle_${activeIdx}">Enable</label>
                </div>
            </div>
            ${(!hitlAuthReady && hitlToggleWasEnabled) ? '<div class="alert alert-warning py-2 px-3 small mb-3">HITL remains disabled until Steps 1 and 2 are authenticated again.</div>' : ''}
            <fieldset class="hitl-step-fieldset ${step3Disabled ? 'hitl-step-disabled' : ''}" ${step3Disabled ? 'disabled' : ''} data-hitl-step3-body>
                ${hitlInterfacesMarkup}
            </fieldset>
        </div>`;
    const step4SectionHtml = `
        <div class="mb-4" data-hitl-step="4">
            <h6 class="mb-2">Step 4 — CTF Participant VM</h6>
            <div class="form-text mb-2">Choose a VM that will connect a participant to the scenario.</div>
            <fieldset class="hitl-step-fieldset ${step3Disabled ? 'hitl-step-disabled' : ''}" ${step3Disabled ? 'disabled' : ''} data-hitl-step4-body>
                ${step4Content}
            </fieldset>
            ${(() => {
                const applyDisabledAttr = (step4BlockingItems.length === 0) ? '' : 'disabled';
                return `
                    <div class="d-flex justify-content-end mt-2">
                        <button type="button" class="btn btn-primary" data-hitl-apply data-scen-idx="${activeIdx}" ${applyDisabledAttr}>Apply</button>
                    </div>`;
            })()}
        </div>`;
    const participantUrlStatusClass = participantProxmoxUrlHasValue ? 'text-success' : 'text-muted';
    const participantUrlStatusText = participantProxmoxUrlHasValue
        ? PARTICIPANT_STATUS_SAVED_TEXT
        : PARTICIPANT_STATUS_EMPTY_TEXT;
    const part5SectionHtml = `
        <div data-hitl-part="5">
            <h6 class="mb-2">Part 5 — Participant UI</h6>
            <div class="form-text mb-3">Paste the Proxmox console or landing URL that participants should use. This adds the Participant UI navigation tab and links the HITL interface entry so facilitators and players open the same console.</div>
            <div class="mb-3">
                <label class="form-label small" for="participantProxmoxUrl_${activeIdx}">Participant UI URL</label>
                <input type="url" class="form-control form-control-sm" id="participantProxmoxUrl_${activeIdx}" placeholder="https://proxmox.example.local" autocomplete="url" data-hitl-participant-url data-scen-idx="${activeIdx}" value="${participantProxmoxUrlHtml}">
                <div class="form-text">Accepts HTTP or HTTPS targets, including console paths.</div>
                <div class="form-text">The Apply button pins this URL to the editor and navigation tab, while Clear removes the Participant shortcut.</div>
                <div class="small ${participantUrlStatusClass} mt-2" data-hitl-participant-status="${activeIdx}">${escapeHtml(participantUrlStatusText)}</div>
            </div>
            <div class="d-flex flex-wrap gap-2">
                <button type="button" class="btn btn-sm btn-outline-primary" data-hitl-participant-apply data-scen-idx="${activeIdx}">Apply Participant URL</button>
                <button type="button" class="btn btn-sm btn-outline-secondary" data-hitl-participant-clear data-scen-idx="${activeIdx}" ${participantProxmoxUrlHasValue ? '' : 'disabled'}>Clear Participant URL</button>
            </div>
        </div>`;
    const coreSectionsHtml = `${step1SectionHtml}${step2SectionHtml}`;
    const hitlSectionsHtml = `${step3SectionHtml}${step4SectionHtml}${part5SectionHtml}`;
    const coreCard = document.createElement('div');
    coreCard.id = 'scenarioHitlCoreCard';
    coreCard.className = 'card mb-3';
    coreCard.innerHTML = `<div class="card-body">${coreSectionsHtml}</div>`;
    const hitlCard = document.createElement('div');
    hitlCard.id = 'scenarioHitlConfigCard';
    hitlCard.className = 'card mb-3';
    hitlCard.innerHTML = `<div class="card-body">${hitlSectionsHtml}<div class="small text-muted mt-3" data-hitl-status="${activeIdx}"></div></div>`;
    const mountCardInto = (cardEl, containerId) => {
        const container = document.getElementById(containerId);
        if (container) {
            container.innerHTML = '';
            container.appendChild(cardEl);
        } else if (baseScenarioCard && baseScenarioCard.parentNode) {
            baseScenarioCard.parentNode.insertBefore(cardEl, baseScenarioCard);
        } else {
            root.appendChild(cardEl);
        }
    };
    mountCardInto(coreCard, 'coreVmSelectContainer');
    mountCardInto(hitlCard, 'externalIfxHitlContainer');

    if (typeof setupPreviewCollapsers === 'function') {
        setupPreviewCollapsers();
    }

    try { updateProxmoxSummary(activeIdx); } catch (err) { console.warn('Failed to refresh Proxmox summary', err); }

    toggleExternalIfxModalBusy(proxInventoryFetchInFlight.size > 0);

    updateHitlStatusForScenario(activeIdx);
    updateHitlEntryButtons({ hitlAuthReady, proxValidated, coreHasSecret, coreVmKey });
    // Prefer previously selected/available interfaces when Steps 1 and 2 are validated.
    // Only consider auto-refresh when explicitly enabled and no prior data exists.
    const shouldAutoRefreshHostIfx = HOST_INTERFACES_AUTO_REFRESH_ENABLED
        && !(hitlAuthReady && (hostInterfaces.length > 0 || hasHitlInterfaces));
    if (shouldAutoRefreshHostIfx) {
        scheduleAutoRefreshHostInterfaces(activeIdx);
    }

    const refreshCoreConnectionModal = (sidx) => {
        if (!coreConnectionModal) return;
        const scenario = state.scenarios?.[sidx];
        if (!scenario) return;
        const hitlState = ensureHitlStateForScenario(scenario);
        const proxState = hitlState.proxmox || {};
        const coreState = hitlState.core || (hitlState.core = {});
        const proxValidatedForScenario = !!(proxState.validated && proxState.secret_id);
        const hasVmSelection = !!coreState.vm_key;
        const builderLocked = !!IS_BUILDER_VIEW;
        const inputsDisabled = builderLocked || !(proxValidatedForScenario && hasVmSelection);
        const effectiveVenv = (coreState.venv_bin || '').trim() || CORE_DEFAULT_VENV_BIN;
        coreConnectionModal.setAttribute('data-scen-idx', String(sidx));
        if (coreConnectionForm) {
            coreConnectionForm.classList.remove('was-validated');
        }
        if (coreRememberInput) {
            coreRememberInput.checked = shouldRememberCore(hitlState);
            coreRememberInput.disabled = builderLocked || !proxValidatedForScenario;
        }
        if (coreAutoStartInput) {
            coreAutoStartInput.checked = !!(coreState.auto_start_daemon);
            coreAutoStartInput.disabled = builderLocked || inputsDisabled;
        }
        if (coreModalInputs.grpc_host) {
            coreModalInputs.grpc_host.value = coreState.grpc_host || '';
            coreModalInputs.grpc_host.disabled = inputsDisabled;
            coreModalInputs.grpc_host.setAttribute('data-scen-idx', String(sidx));
        }
        if (coreModalInputs.grpc_port) {
            const port = Number.isFinite(Number(coreState.grpc_port)) && Number(coreState.grpc_port) > 0 ? Number(coreState.grpc_port) : 50051;
            coreModalInputs.grpc_port.value = port;
            coreModalInputs.grpc_port.disabled = inputsDisabled;
            coreModalInputs.grpc_port.setAttribute('data-scen-idx', String(sidx));
        }
        if (coreModalInputs.venv_bin) {
            coreModalInputs.venv_bin.value = effectiveVenv;
            coreModalInputs.venv_bin.disabled = inputsDisabled;
            coreModalInputs.venv_bin.setAttribute('data-scen-idx', String(sidx));
        }
        if (coreModalInputs.ssh_host) {
            coreModalInputs.ssh_host.value = coreState.ssh_host || '';
            coreModalInputs.ssh_host.disabled = inputsDisabled;
            coreModalInputs.ssh_host.setAttribute('data-scen-idx', String(sidx));
        }
        if (coreModalInputs.ssh_port) {
            const sshPort = Number.isFinite(Number(coreState.ssh_port)) && Number(coreState.ssh_port) > 0 ? Number(coreState.ssh_port) : 22;
            coreModalInputs.ssh_port.value = sshPort;
            coreModalInputs.ssh_port.disabled = inputsDisabled;
            coreModalInputs.ssh_port.setAttribute('data-scen-idx', String(sidx));
        }
        if (coreModalInputs.ssh_username) {
            coreModalInputs.ssh_username.value = coreState.ssh_username || '';
            coreModalInputs.ssh_username.disabled = inputsDisabled;
            coreModalInputs.ssh_username.setAttribute('data-scen-idx', String(sidx));
        }
        if (coreModalInputs.ssh_password) {
            const pwdVal = coreState.ssh_password || '';
            coreModalInputs.ssh_password.value = pwdVal;
            if (coreState.core_secret_id && !pwdVal) {
                coreModalInputs.ssh_password.setAttribute('placeholder', 'Stored securely');
            } else {
                coreModalInputs.ssh_password.removeAttribute('placeholder');
            }
            coreModalInputs.ssh_password.disabled = inputsDisabled;
            coreModalInputs.ssh_password.setAttribute('data-scen-idx', String(sidx));
        }
        resolveCoreVenvTestElements();
        setCoreVenvStatusDisplay(coreState.venv_test_status || null, coreState.venv_test_message || null);
        updateCoreVenvTestButtonState();
        if (coreConnectionSaveBtn) {
            coreConnectionSaveBtn.disabled = inputsDisabled;
            coreConnectionSaveBtn.classList.toggle('d-none', builderLocked);
        }
        if (typeof setCoreConnectionHint === 'function') {
            if (builderLocked) {
                setCoreConnectionHint('Builder view is read-only. Contact an admin to change CORE credentials.', 'info');
            } else if (!hasVmSelection) {
                setCoreConnectionHint('Select a CORE VM to configure connection details.', 'warning');
            } else if (!proxValidatedForScenario) {
                setCoreConnectionHint('Validate Proxmox credentials before editing CORE connection details.', 'warning');
            } else if (coreState.core_secret_id) {
                setCoreConnectionHint('Update SSH credentials to update stored secrets. Leave password blank to keep the existing vault record.', 'success');
            } else {
                setCoreConnectionHint('Provide gRPC host/port and SSH credentials. Passwords are stored securely after a successful test.', 'info');
            }
        }
    };

    window.refreshCoreConnectionModal = refreshCoreConnectionModal;

    refreshCoreConnectionModal(activeIdx);

    if (!IS_BUILDER_VIEW) {
        document.querySelectorAll('[data-hitl-core-configure]').forEach(btn => {
            btn.onclick = () => {
                const sidx = parseInt(btn.getAttribute('data-scen-idx'));
                if (isNaN(sidx) || !state.scenarios?.[sidx]) return;
                if (!coreConnectionModal || !window.bootstrap) {
                    console.warn('CORE connection modal unavailable');
                    return;
                }
                refreshCoreConnectionModal(sidx);
                const modalInstance = bootstrap.Modal.getInstance(coreConnectionModal) || new bootstrap.Modal(coreConnectionModal, { backdrop: true, keyboard: true });
                modalInstance.show();
                setTimeout(() => {
                    try {
                        const primaryInput = coreModalInputs.grpc_host && !coreModalInputs.grpc_host.disabled
                            ? coreModalInputs.grpc_host
                            : coreModalInputs.ssh_username;
                        primaryInput?.focus();
                        primaryInput?.select?.();
                    } catch (err) {}
                }, 150);
            };
        });
    }

    wireCoreConnectionSaveButton();
    wireCoreVenvTestButton();

    (function installCoreNavGuard(){
        if (IS_BUILDER_VIEW) {
            return;
        }
        const NAV_GUARD_DATA_KEY = 'coreNavGuardInstalled';
        const navLink = document.getElementById('navCoreLink');
        if (!navLink || navLink.dataset[NAV_GUARD_DATA_KEY] === '1') {
            return;
        }
        navLink.dataset[NAV_GUARD_DATA_KEY] = '1';
        const ensureModalHook = () => {
            resolveCoreModalReferences();
            const modal = coreConnectionModal;
            if (modal && !modal.dataset.coreNavAwaitResetHook) {
                modal.addEventListener('hidden.bs.modal', () => {
                    window._coreNavAwaitingValidation = null;
                });
                modal.dataset.coreNavAwaitResetHook = '1';
            }
        };
        const hasCoreVmSelection = () => {
            try {
                const { scenario } = getActiveScenarioContext();
                if (!scenario) return false;
                const hitlState = ensureHitlStateForScenario(scenario);
                const coreState = hitlState.core || {};
                const vmKey = (coreState.vm_key || '').toString().trim();
                return vmKey.length > 0;
            } catch (err) {
                return false;
            }
        };

        const hasVerifiedCoreConnection = () => {
            try {
                const { scenario } = getActiveScenarioContext();
                if (!scenario) return false;
                const hitlState = ensureHitlStateForScenario(scenario);
                const coreState = hitlState.core || {};
                const status = (coreState.last_tested_status || '').toString().trim().toLowerCase();
                return status === 'success';
            } catch (err) {
                return false;
            }
        };

        const openCoreNavBlockedModal = () => {
            const modalEl = document.getElementById('coreNavBlockedModal');
            if (modalEl && window.bootstrap) {
                const modalInstance = bootstrap.Modal.getInstance(modalEl)
                    || new bootstrap.Modal(modalEl, { backdrop: true, keyboard: true });
                modalInstance.show();
            }
        };
        const ensureValidationHook = () => {
            if (window.__coreNavValidationHookInstalled) {
                return;
            }
            const original = window.validateCoreConnection;
            if (typeof original !== 'function') {
                return;
            }
            window.validateCoreConnection = async function wrappedValidateCoreConnection(...args) {
                const result = await original.apply(this, args);
                if (result && result.ok && window._coreNavAwaitingValidation) {
                    const target = window._coreNavAwaitingValidation;
                    window._coreNavAwaitingValidation = null;
                    window.location.href = target;
                }
                return result;
            };
            window.__coreNavValidationHookInstalled = true;
        };
        const openModalForActiveScenario = () => {
            const ctx = getActiveScenarioContext();
            let scenarioIdx = Number.isInteger(ctx.idx) ? ctx.idx : null;
            if (!Number.isInteger(scenarioIdx) && Number.isInteger(activeIdx)) {
                scenarioIdx = activeIdx;
            }
            ensureModalHook();
            if (typeof refreshCoreConnectionModal === 'function' && Number.isInteger(scenarioIdx)) {
                refreshCoreConnectionModal(scenarioIdx);
            }
            if (coreConnectionModal && window.bootstrap) {
                const modalInstance = bootstrap.Modal.getInstance(coreConnectionModal) || new bootstrap.Modal(coreConnectionModal, { backdrop: true, keyboard: true });
                modalInstance.show();
                setTimeout(() => {
                    try {
                        const primaryInput = coreModalInputs.grpc_host && !coreModalInputs.grpc_host.disabled
                            ? coreModalInputs.grpc_host
                            : coreModalInputs.ssh_username;
                        primaryInput?.focus();
                        primaryInput?.select?.();
                    } catch (_) {}
                }, 150);
            }
        };
        navLink.addEventListener('click', (event) => {
            if (!hasCoreVmSelection()) {
                event.preventDefault();
                openCoreNavBlockedModal();
                return;
            }

            if (hasVerifiedCoreConnection()) {
                return;
            }

            event.preventDefault();
            window._coreNavAwaitingValidation = navLink.href;
            ensureValidationHook();
            openModalForActiveScenario();
            if (typeof setCoreConnectionHint === 'function') {
                setCoreConnectionHint('Verify the CORE connection before opening the CORE page.', 'warning');
            }
        });
    })();

    // --- Host density normalization for Node Information ---
    try {
        const ni = scen.sections && scen.sections['Node Information'];
        if (ni) {
            ni.items = ni.items || [];
            // Ensure at least one weight row (Random) exists for fallback if all removed
            let randomRow = ni.items.find(it => !(it.v_metric==='Count') && (it.selected||'').toLowerCase()==='random');
            if (!randomRow) {
                // Add with temporary factor 0 (will be set if needed)
                ni.items.unshift({ selected:'Random', factor: 0.0 });
                randomRow = ni.items[0];
            }
            // Mark the first Random weight row as protected residual; unmark any other Random weight rows
            randomRow._protected_random = true;
            ni.items.forEach(it => {
                if (it !== randomRow && (it.v_metric !== 'Count') && ((it.selected||'').toLowerCase()==='random')) {
                    if (it._protected_random) delete it._protected_random;
                }
            });
            const weightRows = ni.items.filter(it => !(it.v_metric==='Count'));
            weightRows.forEach(it => { let f = parseFloat(it.factor); if (isNaN(f) || f < 0) f = 0; it.factor = f; });
            // Sum excluding Random for decision
            const nonRandom = weightRows.filter(it => (it.selected||'').toLowerCase()!=='random');
            let nonRandomSum = nonRandom.reduce((a,b)=> a + (parseFloat(b.factor)||0), 0);
            if (nonRandom.length === 0) {
                // Only Random exists; set to 1.0
                randomRow.factor = 1.0; nonRandomSum = 0;
            } else {
                if (nonRandomSum >= 1.0) {
                    randomRow.factor = 0.0; // others define full density
                } else {
                    randomRow.factor = 1.0 - nonRandomSum;
                }
            }
            // Final normalization (should already sum to 1.0)
            const finalSum = weightRows.reduce((a,b)=> a + (parseFloat(b.factor)||0), 0);
            if (Math.abs(finalSum - 1.0) > 1e-6 && finalSum > 0) {
                // scale all
                weightRows.forEach(it => { it.factor = (parseFloat(it.factor)||0)/finalSum; });
            }
        }
    } catch(e) { console.warn('Normalization error', e); }
    // Load persisted section collapse state (per scenario + section)
    let collapseState = {};
    try { collapseState = JSON.parse(localStorage.getItem('sectionCollapseState') || '{}'); } catch(e) { collapseState = {}; }
    // No auto-insertion of Count rows for Node Information; totals should only include user-added Count rows
    // Scenario header with Count for Density (base host pool) restored
    const niSec = scen.sections['Node Information'] || { items: [] };
    const niItems = niSec.items || [];
    const niWeightRows = niItems.filter(it => (it.v_metric || (it.selected==='Specific'?'Count':'Weight')) === 'Weight');
    const niCountRows = niItems.filter(it => (it.v_metric || (it.selected==='Specific'?'Count':'Weight')) === 'Count');
    // Base removed: host total now purely additive Count rows when no base; or proportional part is implied but base count is scenario-level (not editable here)
    let densityCountVal = 10;
    try {
        if (scen.density_count !== undefined && scen.density_count !== null && scen.density_count !== '') {
            const parsed = parseInt(scen.density_count, 10);
            if (!isNaN(parsed)) densityCountVal = parsed;
        }
    } catch(e) { densityCountVal = 10; }
    densityCountVal = Math.max(DENSITY_COUNT_MIN, Math.min(DENSITY_COUNT_MAX, densityCountVal));
    scen.density_count = densityCountVal;
    const densityBounds = resolveDensityBoundsForScenario(scen);
    densityCountVal = applyDensityBoundsToScenario(scen, densityBounds) ?? densityCountVal;
    const densityMinEnabled = densityBounds.minEnabled;
    const densityMaxEnabled = densityBounds.maxEnabled;
    const densityMinDisplayValue = densityMinEnabled && typeof densityBounds.minValue === 'number' ? densityBounds.minValue : '';
    const densityMaxDisplayValue = densityMaxEnabled && typeof densityBounds.maxValue === 'number' ? densityBounds.maxValue : '';
    const niBase = densityCountVal;
    const niAdd = niCountRows.reduce((a,it)=> a + (parseInt(it.v_count,10)||0), 0);
    const niTotal = niBase + niAdd;
    const niTitle = 'Hosts = Base (Count for Density) allocated by weight rows + additive Count rows';
    // Build allocation breakdown tooltip for weight rows
    let allocTip = niTitle;
    if (niWeightRows.length) {
        const wTotal = niWeightRows.reduce((a,it)=> a + (parseFloat(it.factor)||0), 0) || 0;
        if (wTotal > 0) {
            const parts = niWeightRows.map(it => {
                const f = parseFloat(it.factor)||0;
                const pct = wTotal ? ((f / wTotal) * 100).toFixed(1) : '0.0';
                const label = (it.selected || 'Row');
                return `${label}:${f}(${pct}%)`;
            });
            allocTip += ' | Weights: ' + parts.join(', ');
        }
    }
    const hostBadgeClass = (niWeightRows.length && niBase === 0 && niAdd > 0) ? 'text-bg-warning' : 'text-bg-primary';
    // Simplified host summary: remove ΣW badge, allocation popover, and auto-scale functionality
    const hostSummaryHtml = `<span class=\"badge rounded-pill ${hostBadgeClass} host-total-badge ms-2\" data-bs-toggle=\"tooltip\" title=\"${allocTip.replace(/"/g,'&quot;')}\">Hosts: ${niWeightRows.length ? (niBase + ' + ' + niAdd + ' = ' + niTotal) : (niAdd)}</span>`;
    const densityBaseTip = 'Base host pool used only for weight-based density calculations; Count rows are additive beyond this.';
    const densityBaseTipEsc = densityBaseTip.replace(/"/g,'&quot;');
    const boundsRestrictionTip = IS_BUILDER_VIEW
        ? 'Restrictions set by the admin.'
        : 'Set optional Min/Max bounds to guide builder runs.';
    const densityBoundChipFragments = [];
    if (!IS_BUILDER_VIEW || densityMinEnabled) {
        densityBoundChipFragments.push(buildBoundChip({
            label: 'Min',
            baseField: 'scenario_density_min',
            enabled: !!densityMinEnabled,
            value: densityMinDisplayValue,
            controlsDisabled: false,
            min: DENSITY_COUNT_MIN,
            max: DENSITY_COUNT_MAX,
            step: 1,
            width: 110,
            scenarioIdx: activeIdx,
            placeholder: 'Min',
            tooltip: boundsRestrictionTip,
            readOnly: IS_BUILDER_VIEW,
        }));
    }
    if (!IS_BUILDER_VIEW || densityMaxEnabled) {
        densityBoundChipFragments.push(buildBoundChip({
            label: 'Max',
            baseField: 'scenario_density_max',
            enabled: !!densityMaxEnabled,
            value: densityMaxDisplayValue,
            controlsDisabled: false,
            min: DENSITY_COUNT_MIN,
            max: DENSITY_COUNT_MAX,
            step: 1,
            width: 110,
            scenarioIdx: activeIdx,
            placeholder: 'Max',
            tooltip: boundsRestrictionTip,
            readOnly: IS_BUILDER_VIEW,
        }));
    }
    const densityBoundsRow = densityBoundChipFragments.length
        ? `<div class="d-flex flex-wrap align-items-center gap-2">${densityBoundChipFragments.join('')}</div>`
        : '';
    const densityBaseHtml = `
        <div class=\"d-flex flex-wrap align-items-center gap-3\">
            <div class=\"d-flex align-items-center gap-1\">
                <label class=\"form-label mb-0\">Count for Density</label>
                <button type=\"button\" class=\"btn btn-link btn-sm p-0 text-muted\" tabindex=\"0\" data-bs-toggle=\"tooltip\" data-bs-placement=\"top\" data-bs-title=\"${densityBaseTipEsc}\">
                    <i class=\"bi bi-info-circle\"></i>
                </button>
                <input type=\"number\" min=\"${DENSITY_COUNT_MIN}\" max=\"${DENSITY_COUNT_MAX}\" step=\"1\" class=\"form-control form-control-sm\" style=\"width:120px\" value=\"${densityCountVal}\" data-scen-idx=\"${activeIdx}\" data-field=\"scenario_density_count\" />
            </div>
            ${densityBoundsRow}
        </div>`;
    const headerRow = document.createElement('div');
    const rawSectionNames = Object.keys(scen.sections || {});
    const filteredSectionNames = rawSectionNames.filter(name => name !== 'Notes' && name !== 'Events' && name !== 'HITL');
    const secNames = [];
    if (filteredSectionNames.includes('Node Information')) {
        secNames.push('Node Information');
    }
    filteredSectionNames.forEach(name => {
        if (name !== 'Node Information') {
            secNames.push(name);
        }
    });
    // Base host pool for density-driven (weight) allocations comes from scenario.density_count
    const baseHostPool = (scen.density_count !== undefined && scen.density_count !== null && scen.density_count !== '' ? (parseInt(scen.density_count,10)||0) : 10);
    secNames.forEach(name => {
        const sec = scen.sections[name] || { items: [] };
    const hasNodes = (name === 'Node Information');
        const itemCount = (sec.items || []).length;
        // Determine if any weight rows exist in this section (used for Node Information behavior)
        const hasWeightRowsPre = hasNodes ? ((sec.items || []).some(it => ((it.v_metric || (it.selected==='Specific'? 'Count' : 'Weight')) === 'Weight'))) : false;
        // Always ensure density has a sensible default value
        if (!hasNodes) {
            if (sec.density === undefined || sec.density === null || isNaN(sec.density)) {
                sec.density = 0.5;
            }
        }
        const densVal = sec.density;
        const nodesVal = '';
        const extraNodeCount = hasNodes ? ((sec.items || []).reduce((acc, it) => {
            const metric = it.v_metric || (it.selected==='Specific'?'Count':'Weight');
            return acc + (metric === 'Count' ? (parseInt(it.v_count) || 0) : 0);
        }, 0)) : 0;
    const hasWeightRows = hasNodes ? hasWeightRowsPre : false;
    const totalNodeCount = hasNodes ? (extraNodeCount + (hasWeightRowsPre ? niBase : 0)) : 0;
    const totalNodesLabel = hasNodes ? (totalNodeCount === 1 ? 'Total Node' : 'Total Nodes') : '';
    // Define totalPlanned (was previously referenced but never declared, causing a ReferenceError that prevented section rendering)
    const totalPlanned = hasNodes ? totalNodeCount : 0;
        // Improved initial collapse behavior:
        // - Always expand Node Information (primary planning surface)
        // - Other sections start collapsed only if empty
        let collapsed;
        if (name === 'Node Information') collapsed = false; else collapsed = (itemCount === 0);
        // Override with persisted state if present
        const collapseKey = `${activeIdx}::${name}`;
        if (collapseState.hasOwnProperty(collapseKey)) {
            collapsed = !!collapseState[collapseKey];
        }
        const card = document.createElement('div');
        card.className = 'card mb-3';
        const collapseId = `collapse-${name.replace(/\s+/g,'-')}`;
        const iconHtml = itemCount > 0
            ? `<i class='bi bi-collection-fill text-success' data-bs-toggle="tooltip" data-bs-title="${itemCount} item(s)"></i>`
            : `<i class='bi bi-collection text-muted' data-bs-toggle="tooltip" data-bs-title="No items"></i>`;
        // Enhanced tooltip text clarifying how combined total is derived.
        const totalNodesTooltip = hasNodes ? 'Combined total = (sum of all Count-based row counts) + (Total Nodes if any Weight-based rows exist). Weight rows allocate Total Nodes by their weights; Count rows are absolute and do not affect weights.' : '';
        // Compute planned badges (hosts / routers / vulns) for this section
        let hostBadge = '';
        if (name === 'Node Information') {
            const basePart = hasWeightRows ? niBase : 0;
            const additivePart = extraNodeCount;
            const totalPlannedHosts = basePart + additivePart;
            if (hasWeightRows || additivePart > 0) {
                const display = hasWeightRows ? `${basePart} + ${additivePart} = ${totalPlannedHosts}` : `${additivePart}`;
                hostBadge = `<span class=\"badge rounded-pill text-bg-primary ms-2 host-total-badge\" data-bs-toggle=\"tooltip\" title=\"${allocTip.replace(/"/g,'&quot;')}\">Hosts: ${display}</span>`;
            }
        }
        const hostSummaryBlock = (name === 'Node Information' && (niBase > 0 || niAdd > 0 || hasWeightRows))
            ? `<div class="d-flex align-items-center gap-2">${hostSummaryHtml}</div>`
            : '';
        const nodeMetaHtml = (name === 'Node Information')
            ? `<div class="d-flex flex-wrap align-items-center justify-content-between gap-3 mb-3">
                    ${densityBaseHtml}
                    ${hostSummaryBlock}
                </div>`
            : '';
        let routingBadge = '';
        if (name === 'Routing') {
            const rItems = sec.items || [];
            const rRows = rItems.map(it => ({ metric: (it.v_metric || 'Weight'), it }));
            const rCountRows = rRows.filter(r => r.metric === 'Count');
            const rWeightRows = rRows.filter(r => r.metric === 'Weight');
            const densR = (typeof sec.density === 'number') ? sec.density : 0;
            const explicit = rCountRows.reduce((a,r)=> a + (parseInt(r.it.v_count,10)||0), 0);
            let derived = 0;
            if (rWeightRows.length && densR > 0) {
                const frac = Math.max(0, Math.min(1, densR));
                derived = Math.round(baseHostPool * frac);
            }
            const total = explicit + derived;
            if (total > 0) routingBadge = `<span class=\"badge rounded-pill text-bg-secondary ms-2\" title=\"Routers planned additively: Count rows + (Density * Base Hosts). Density constrained 0..1.\">Routers: ${total}</span>`;
        }
        let vulnBadge = '';
        if (name === 'Vulnerabilities') {
            const vItems = sec.items || [];
            const vRows = vItems.map(it => ({ metric: (it.v_metric || (it.selected==='Specific'?'Count':'Weight')), it }));
            const vCountRows = vRows.filter(r => r.metric === 'Count');
            const vWeightRows = vRows.filter(r => r.metric === 'Weight');
            const densV = (typeof sec.density === 'number') ? sec.density : 0;
            const explicit = vCountRows.reduce((a,r)=> a + (parseInt(r.it.v_count,10)||0), 0);
            let derived = 0;
            if (vWeightRows.length && densV > 0) derived = Math.round(baseHostPool * Math.min(1, densV));
            const total = explicit + derived;
            if (total > 0) vulnBadge = `<span class=\"badge rounded-pill text-bg-info ms-2\" title=\"Vulnerability assignments additive: Count rows + (Density * Base Hosts). Density clipped to 1.0 when fractional.\">Vulns: ${total}</span>`;
        }
    const badgeSpan = hostBadge + routingBadge + vulnBadge;
        card.innerHTML = `
            <div class="card-header d-flex align-items-center gap-2">
                ${iconHtml}
                <strong>${name}</strong>${badgeSpan}
                <div class="ms-auto d-flex gap-2">
                    <button class="btn btn-sm btn-outline-primary" data-action="add-item" data-scen-idx="${activeIdx}" data-sec="${name}">Add</button>
                    <button class="btn btn-sm btn-outline-secondary" type="button" data-action="toggle-collapse" data-target="#${collapseId}">${collapsed ? 'Expand' : 'Collapse'}</button>
                </div>
            </div>
            <div id="${collapseId}" class="card-body" style="display:${collapsed ? 'none':'block'};">
                ${nodeMetaHtml}
                                <div class="table-responsive">
                                                                                <table class="table table-sm align-middle">
                                                                                        <thead>
                                                                                            <tr>
                                                                                                <th style="width:280px"></th>
                                                                                                <th></th>
                                                                                                <th style="width:160px"></th>
                                                                                                <th style="width:80px"></th>
                                                                                            </tr>
                                                                                        </thead>
                                                                    <tbody>
                                                                                ${(() => {
                                                                                const items = sec.items || [];
                                                                                const rowsByMetric = items.map((it, iidx) => ({ it, iidx, metric: (it.v_metric || (name==='Vulnerabilities' && (it.selected||'Category')==='Specific' ? 'Count' : 'Weight')) }));
                                                                                const weights = rowsByMetric.filter(x => x.metric === 'Weight');
                                                                                const counts = rowsByMetric.filter(x => x.metric === 'Count');
                                                                                // If there are no remaining weight rows but a stale total_nodes exists, clear it (frontend-only cleanup)
                                                                                if (name === 'Node Information' && weights.length === 0) {
                                                                                    const secRef = state.scenarios[activeIdx].sections[name];
                                                                                    if (secRef && secRef.total_nodes) { secRef.total_nodes = 0; }
                                                                                }
                                                                                const parts = [];
                                                                                const showWeightHeader = (weights.length > 0);
                                        if (showWeightHeader) {
                                                                                    const densCtrl = (
                                                                                        name === 'Node Information'
                                                                                            ? `<div class=\"d-flex align-items-center justify-content-end gap-2 small text-muted\"><span>Density</span><input disabled class=\"form-control form-control-sm\" style=\"width:80px\" value=\"1.0\"></div>`
                                                                                                : (name === 'Routing'
                                                                                                                                                                                                ? `<div class=\"d-flex align-items-center justify-content-end gap-2\">`
                                                                                                                                                                                                        + `<span>Density</span>`
                                                                                                                                                                                                        + `<input type=\"number\" step=\"0.01\" min=\"0\" max=\"1\" class=\"form-control form-control-sm\" style=\"width:120px\" placeholder=\"e.g., 0.25\" value=\"${densVal}\" data-scen-idx=\"${activeIdx}\" data-sec=\"${name}\" data-field=\"density\">`
                                                                                                                                                                                                    + `</div>`
                                                                                                                                                                                                : (() => {
                                                                                                                                                                                                    const tooltip = (name === 'Services')
                                                                                                                                                                                                        ? 'Services: per-item Count overrides density; assigns exactly that many hosts the selected service.'
                                                                                                                                                                                                        : (name === 'Traffic')
                                                                                                                                                                                                            ? 'Traffic: per-item Count overrides density; creates exactly that many sender/receiver pairs.'
                                                                                                                                                                                                            : (name === 'Segmentation')
                                                                                                                                                                                                                ? 'Segmentation: per-item Count overrides density; plans exactly that many slots (NAT prioritized).'
                                                                                                                                                                                                                : '';
                                                                                                                                                                                                    let info = '';
                                                                                                                                                                                                    // Density tooltip removed
                                                                                                                                                                                                    return '<div class="d-flex align-items-center justify-content-end gap-2">'
                                                                                                                                                                                                        + '<span>Density</span>'
                                                                                                                                                                                                        + info
                                                                                                                                                                                                        + '<input type="number" step="0.01" min="0" max="1" class="form-control form-control-sm" style="width:100px" value="' + densVal + '" data-scen-idx="' + activeIdx + '" data-sec="' + name + '" data-field="density">'
                                                                                                                                                                                                    + '</div>';
                                                                                                                                                                                                })()
                                                                                                                                                                                            )
                                                                                                                                                                        );
                                                                                    parts.push(`<tr class=\"table-light\"><td colspan=\"2\"><strong>Weight-based</strong></td><td class=\"text-end\">${densCtrl}</td><td></td></tr>`);
                                                                                    if (weights.length) { parts.push(weights.map(x => renderItemRow(activeIdx, name, x.iidx, x.it)).join('')); }
                                                                                }
                                                                                if (counts.length) {
                                                                                    const countHdr = 'Count-based';
                                                                                    const secRef = state.scenarios[activeIdx].sections[name];
                                                                                    const countBounds = resolveSectionCountBounds(secRef, counts);
                                                                                    const boundChipFragments = [];
                                                                                    if (!IS_BUILDER_VIEW || countBounds.minEnabled) {
                                                                                        boundChipFragments.push(buildBoundChip({
                                                                                            label: 'Min',
                                                                                            baseField: 'node_count_min',
                                                                                            enabled: !!countBounds.minEnabled,
                                                                                            value: countBounds.minValue,
                                                                                            controlsDisabled: !!countBounds.controlsDisabled,
                                                                                            min: NODE_COUNT_MIN,
                                                                                            max: NODE_COUNT_MAX,
                                                                                            step: 1,
                                                                                            width: 90,
                                                                                            scenarioIdx: activeIdx,
                                                                                            sectionName: name,
                                                                                            placeholder: 'Min',
                                                                                            tooltip: boundsRestrictionTip,
                                                                                            readOnly: IS_BUILDER_VIEW,
                                                                                        }));
                                                                                    }
                                                                                    if (!IS_BUILDER_VIEW || countBounds.maxEnabled) {
                                                                                        boundChipFragments.push(buildBoundChip({
                                                                                            label: 'Max',
                                                                                            baseField: 'node_count_max',
                                                                                            enabled: !!countBounds.maxEnabled,
                                                                                            value: countBounds.maxValue,
                                                                                            controlsDisabled: !!countBounds.controlsDisabled,
                                                                                            min: NODE_COUNT_MIN,
                                                                                            max: NODE_COUNT_MAX,
                                                                                            step: 1,
                                                                                            width: 90,
                                                                                            scenarioIdx: activeIdx,
                                                                                            sectionName: name,
                                                                                            placeholder: 'Max',
                                                                                            tooltip: boundsRestrictionTip,
                                                                                            readOnly: IS_BUILDER_VIEW,
                                                                                        }));
                                                                                    }
                                                                                    const boundsControls = boundChipFragments.length
                                                                                        ? `<div class="d-flex flex-wrap align-items-center gap-2 node-total-bounds-controls">${boundChipFragments.join('')}</div>`
                                                                                        : '';
                                                                                    const countHeaderHtml = `
                                                                                        <div class="d-flex flex-wrap align-items-center gap-2">
                                                                                            <strong>${countHdr}</strong>
                                                                                            ${boundsControls}
                                                                                        </div>`;

                                                                                    parts.push(`<tr class=\"table-light\"><td colspan=\"4\">${countHeaderHtml}</td></tr>`);
                                                                                    parts.push(counts.map(x => renderItemRow(activeIdx, name, x.iidx, x.it)).join(''));
                                                                                }
                                                                                return parts.join('');
                                                                            })()}
                                                                    </tbody>
                    </table>
                </div>
                                        <div class="text-danger small mt-1 section-warning" data-scen-idx="${activeIdx}" data-sec="${name}" style="display:none">Weights must sum to 1.000</div>
                                        ${name==='Routing' ? `
                                        <div id="routingEdgesWarnings" class="alert alert-warning py-2 px-3 small mt-3 d-none"></div>
                                        <div class="d-flex flex-wrap align-items-center gap-3 mt-3 small" id="routingEdgesSummary" style="display:none;">
                                                <div><strong>Policy:</strong> <span data-role="edges-policy">(pending)</span></div>
                                        </div>
                                        ` : ''}
            </div>`;
        root.appendChild(card);
    });
    // Apply visibility rule for H/S bounds after DOM built
    updateHsBoundsVisibility();
        // activate tooltips for icons
        if(window.bootstrap){
            const tts = root.querySelectorAll('[data-bs-toggle="tooltip"]');
            tts.forEach(el => new bootstrap.Tooltip(el));
        }

    // Notes card (collapsible, collapsed by default)
    const notesCard = document.createElement('div');
    notesCard.className = 'card mb-3';
    const hasNotes = (scen.notes||'').trim().length>0;
    const collapseId = `notesCollapse_${activeIdx}`;
    notesCard.innerHTML = `
        <div class="card-header d-flex justify-content-between align-items-center">
            <button class="btn btn-sm btn-link text-decoration-none p-0 d-flex align-items-center gap-2" type="button" data-bs-toggle="collapse" data-bs-target="#${collapseId}" aria-expanded="false" aria-controls="${collapseId}">
                <span class="me-1">Notes</span>
                <span id="notesIndicator_${activeIdx}" class="d-inline-flex align-items-center" data-bs-toggle="tooltip" data-bs-title="${hasNotes? 'Notes present':'No notes'}">
                    ${hasNotes ? `<i class='bi bi-journal-text text-success'></i>` : `<i class='bi bi-journal text-muted'></i>`}
                </span>
            </button>
            <small class="text-muted">optional</small>
        </div>
        <div id="${collapseId}" class="collapse">
            <div class="card-body p-2">
                <textarea class="form-control" rows="3" data-scen-idx="${activeIdx}" data-field="notes" placeholder="Add scenario notes (markdown supported)">${scen.notes || ''}</textarea>
            </div>
        </div>`;
    root.appendChild(notesCard);

    wireHandlers();
    // Populate dynamic vuln selects after DOM paint
    populateVulnSelects();
    // Hook up Specific picker buttons
    document.querySelectorAll('[data-action="pick-specific"]').forEach(btn => {
        const handler = () => {
            const sidx = parseInt(btn.getAttribute('data-scen-idx'));
            const sec = btn.getAttribute('data-sec');
            const iidx = parseInt(btn.getAttribute('data-item-idx'));
            openVulnPicker(sidx, sec, iidx);
        };
        // Attach the click handler (fix: previously not wired)
        btn.addEventListener('click', handler);
    });
}

function clampDensityCountValue(raw) {
    const parsed = parseInt(raw, 10);
    if (Number.isNaN(parsed)) return null;
    return Math.max(DENSITY_COUNT_MIN, Math.min(DENSITY_COUNT_MAX, parsed));
}

function resolveDensityBoundsForScenario(scen) {
    const result = {
        minEnabled: false,
        maxEnabled: false,
        minValue: null,
        maxValue: null,
    };
    if (!scen) {
        return result;
    }
    if (scen.density_count_min_enabled) {
        let minValue = clampDensityCountValue(scen.density_count_min);
        if (minValue === null) {
            minValue = clampDensityCountValue(scen.density_count);
        }
        if (minValue === null) {
            minValue = DENSITY_COUNT_MIN;
        }
        scen.density_count_min = minValue;
        result.minEnabled = true;
        result.minValue = minValue;
    }
    if (scen.density_count_max_enabled) {
        let maxValue = clampDensityCountValue(scen.density_count_max);
        if (maxValue === null) {
            maxValue = clampDensityCountValue(scen.density_count);
        }
        if (maxValue === null) {
            maxValue = DENSITY_COUNT_MAX;
        }
        scen.density_count_max = maxValue;
        result.maxEnabled = true;
        result.maxValue = maxValue;
    }
    if (result.minEnabled && result.maxEnabled && (result.minValue ?? 0) > (result.maxValue ?? 0)) {
        result.maxValue = result.minValue;
        scen.density_count_max = result.maxValue;
    }
    return result;
}

function applyDensityBoundsToScenario(scen, bounds) {
    if (!scen) return null;
    let countValue = clampDensityCountValue(scen.density_count);
    if (countValue === null) {
        countValue = DENSITY_COUNT_MIN;
    }
    if (bounds?.minEnabled && typeof bounds.minValue === 'number' && countValue < bounds.minValue) {
        countValue = bounds.minValue;
    }
    if (bounds?.maxEnabled && typeof bounds.maxValue === 'number' && countValue > bounds.maxValue) {
        countValue = bounds.maxValue;
    }
    scen.density_count = countValue;
    return countValue;
}

function enforceDensityBounds(idx) {
    if (Number.isNaN(idx) || !state.scenarios?.[idx]) return null;
    const scen = state.scenarios[idx];
    const bounds = resolveDensityBoundsForScenario(scen);
    return applyDensityBoundsToScenario(scen, bounds);
}

function refreshScenarioStateAfterCountEdit() {
    renderMain();
    const hidden = document.getElementById('scenarios_json');
    if (hidden) {
        hidden.value = JSON.stringify({ scenarios: state.scenarios, active_index: activeIdx });
    }
    persistEditorState();
    try { previewState.dirty = true; updatePlanButtons(); } catch (e) {}
}

function clampNodeCountValue(raw) {
    const parsed = parseInt(raw, 10);
    if (Number.isNaN(parsed)) return null;
    return Math.max(NODE_COUNT_MIN, Math.min(NODE_COUNT_MAX, parsed));
}

function buildBoundChip(options = {}) {
    const {
        label = '',
        baseField = '',
        enabled = false,
        value = null,
        controlsDisabled = false,
        min = null,
        max = null,
        step = 1,
        width = 90,
        scenarioIdx = null,
        sectionName = null,
        placeholder = '',
        tooltip = '',
        tooltipPlacement = 'top',
        readOnly = false,
    } = options;
    if (!baseField) return '';
    const enableField = `${baseField}_enabled`;
    const dataAttrs = [];
    if (Number.isInteger(scenarioIdx)) {
        dataAttrs.push(`data-scen-idx="${scenarioIdx}"`);
    }
    if (sectionName) {
        dataAttrs.push(`data-sec="${sectionName}"`);
    }
    const scopeAttrs = dataAttrs.length ? ` ${dataAttrs.join(' ')}` : '';
    const checkedAttr = enabled ? 'checked' : '';
    const isReadOnly = !!readOnly;
    const checkboxDisabled = (controlsDisabled || isReadOnly) ? 'disabled' : '';
    const inputDisabled = controlsDisabled ? 'disabled' : (!enabled ? 'disabled' : '');
    const readonlyAttr = (isReadOnly && !controlsDisabled && enabled) ? 'readonly' : '';
    const tabindexAttr = isReadOnly ? 'tabindex="-1"' : '';
    const numericValue = (typeof value === 'number' && !Number.isNaN(value)) ? value : '';
    const displayValue = (controlsDisabled || !enabled) ? '' : numericValue;
    const placeholderText = placeholder || label || '';
    const minAttr = (typeof min === 'number') ? `min="${min}"` : '';
    const maxAttr = (typeof max === 'number') ? `max="${max}"` : '';
    const stepAttr = (typeof step === 'number') ? `step="${step}"` : '';
    const tooltipAttr = tooltip ? ` data-bs-toggle="tooltip" data-bs-placement="${tooltipPlacement}" data-bs-title="${tooltip.replace(/"/g,'&quot;')}"` : '';
    return `
        <div class="node-bound-chip border border-secondary-subtle rounded-pill px-2 py-1 bg-body-tertiary d-flex align-items-center gap-2${controlsDisabled ? ' opacity-50' : ''}"${tooltipAttr}>
            <div class="form-check form-check-inline mb-0">
                <input class="form-check-input" type="checkbox" data-field="${enableField}"${scopeAttrs} ${checkedAttr} ${checkboxDisabled} />
                <label class="form-check-label small mb-0">${label}</label>
            </div>
            <input type="number" ${minAttr} ${maxAttr} ${stepAttr} class="form-control form-control-sm bg-transparent border-0 shadow-none" style="width:${width}px" value="${displayValue}" data-field="${baseField}"${scopeAttrs} ${inputDisabled} ${readonlyAttr} ${tabindexAttr} placeholder="${placeholderText}">
        </div>`;
}

function collectSectionCountRows(section) {
    if (!section || !Array.isArray(section.items)) return [];
    const rows = [];
    section.items.forEach((item, index) => {
        const metric = item && (item.v_metric || ((item.selected === 'Specific') ? 'Count' : 'Weight'));
        if (metric === 'Count') {
            rows.push({ item, index });
        }
    });
    return rows;
}

function prepareSectionCountRowRefs(section, seedRows) {
    if (Array.isArray(seedRows) && seedRows.length) {
        return seedRows
            .map(entry => {
                const item = entry.item || entry.it || entry;
                const idx = (typeof entry.index === 'number') ? entry.index : entry.iidx;
                if (!item || Number.isNaN(idx)) return null;
                const metric = item.v_metric || ((item.selected === 'Specific') ? 'Count' : 'Weight');
                if (metric !== 'Count') return null;
                return { item, index: idx };
            })
            .filter(Boolean);
    }
    return collectSectionCountRows(section);
}

function sumSectionCountRowValues(rowRefs) {
    if (!Array.isArray(rowRefs)) return 0;
    return rowRefs.reduce((acc, entry) => {
        const val = clampNodeCountValue(entry.item?.v_count);
        return acc + (val === null ? NODE_COUNT_MIN : val);
    }, 0);
}

function resolveSectionCountBounds(section, seedRows) {
    const rowRefs = prepareSectionCountRowRefs(section, seedRows);
    const rowCount = rowRefs.length;
    const minFeasible = rowCount * NODE_COUNT_MIN;
    const result = {
        minEnabled: false,
        maxEnabled: false,
        minValue: null,
        maxValue: null,
        rowCount,
        controlsDisabled: rowCount === 0,
    };
    if (!section || !rowCount) {
        return result;
    }
    const currentTotal = sumSectionCountRowValues(rowRefs);
    if (section.node_count_min_enabled) {
        let minValue = clampNodeCountValue(section.node_count_min);
        if (minValue === null) minValue = clampNodeCountValue(currentTotal);
        if (minValue === null) minValue = minFeasible || NODE_COUNT_MIN;
        if (minValue < minFeasible) minValue = minFeasible;
        section.node_count_min = minValue;
        result.minEnabled = true;
        result.minValue = minValue;
    }
    if (section.node_count_max_enabled) {
        let maxValue = clampNodeCountValue(section.node_count_max);
        if (maxValue === null) maxValue = clampNodeCountValue(currentTotal);
        if (maxValue === null) maxValue = Math.max(minFeasible, currentTotal || NODE_COUNT_MIN);
        if (result.minEnabled && maxValue < (result.minValue ?? minFeasible)) {
            maxValue = result.minValue;
        }
        if (maxValue < minFeasible) {
            maxValue = minFeasible;
        }
        section.node_count_max = maxValue;
        result.maxEnabled = true;
        result.maxValue = maxValue;
    }
    return result;
}

function orderSectionCountRows(rowRefs, preferredIdx) {
    if (!Array.isArray(rowRefs)) return [];
    const ordered = [];
    const preferred = (typeof preferredIdx === 'number') ? rowRefs.find(entry => entry.index === preferredIdx) : null;
    if (preferred) ordered.push(preferred);
    rowRefs.forEach(entry => {
        if (!ordered.includes(entry)) {
            ordered.push(entry);
        }
    });
    return ordered;
}

function increaseSectionCountRows(rowRefs, delta, preferredIdx) {
    if (!Array.isArray(rowRefs) || !rowRefs.length || delta <= 0) return false;
    const targetList = orderSectionCountRows(rowRefs, preferredIdx);
    const target = targetList[0];
    if (!target) return false;
    let current = clampNodeCountValue(target.item.v_count);
    if (current === null) current = NODE_COUNT_MIN;
    target.item.v_count = current + delta;
    return true;
}

function decreaseSectionCountRows(section, rowRefs, delta, preferredIdx) {
    if (!Array.isArray(rowRefs) || !rowRefs.length || delta <= 0) return false;
    let remaining = delta;
    let changed = false;
    const ordered = orderSectionCountRows(rowRefs, preferredIdx);
    ordered.forEach(entry => {
        if (remaining <= 0) return;
        let current = clampNodeCountValue(entry.item.v_count);
        if (current === null) current = NODE_COUNT_MIN;
        const reducible = Math.max(0, current - NODE_COUNT_MIN);
        if (reducible <= 0) return;
        const take = Math.min(reducible, remaining);
        entry.item.v_count = current - take;
        remaining -= take;
        changed = true;
    });
    if (remaining > 0 && section && section.node_count_max_enabled) {
        section.node_count_max = sumSectionCountRowValues(rowRefs);
    }
    return changed;
}

function enforceSectionCountBoundsForScenario(sidx, secName, preferredIdx = null) {
    if (Number.isNaN(sidx) || !state.scenarios?.[sidx] || !secName) return false;
    const scenario = state.scenarios[sidx];
    const section = scenario.sections?.[secName];
    if (!section) return false;
    const rowRefs = collectSectionCountRows(section);
    if (!rowRefs.length) return false;
    const bounds = resolveSectionCountBounds(section, rowRefs);
    let total = sumSectionCountRowValues(rowRefs);
    let changed = false;
    if (bounds.minEnabled && typeof bounds.minValue === 'number' && total < bounds.minValue) {
        const needed = bounds.minValue - total;
        if (needed > 0) {
            changed = increaseSectionCountRows(rowRefs, needed, preferredIdx) || changed;
            total = sumSectionCountRowValues(rowRefs);
        }
    }
    if (bounds.maxEnabled && typeof bounds.maxValue === 'number' && total > bounds.maxValue) {
        const excess = total - bounds.maxValue;
        if (excess > 0) {
            changed = decreaseSectionCountRows(section, rowRefs, excess, preferredIdx) || changed;
        }
    }
    return changed;
}

function updateHsBoundsVisibility(){
    try {
        document.querySelectorAll('[data-field="r2s_mode"]').forEach(selEl => {
            const modeVal = selEl.value;
            const wrapper = selEl.closest('.routing-edge-groups')?.querySelector('.hs-bounds-wrapper');
            if (wrapper) {
                if (modeVal === 'NonUniform') {
                    wrapper.classList.add('hs-show');
                } else {
                    wrapper.classList.remove('hs-show');
                }
            }
        });
    } catch(e) { /* ignore */ }
}

// renderSections was deprecated and removed; rendering is handled in renderMain()
function renderItemRow(sidx, secName, iidx, it) {
    // Build Selected options and current weight
    const weight = ((parseFloat(it.factor) || 0).toFixed(3));
    let opts = '';
    if (secName === 'Vulnerabilities') {
        const cur = it.selected || 'Category';
        const options = ['Category', 'Specific', 'Random'];
        opts = options.map(o => `<option ${o===cur?'selected':''}>${o}</option>`).join('');
    } else {
        const cur = it.selected || 'Random';
        // Per-section allowed options (excluding 'auto')
        let options = ['Random'];
        switch (secName) {
            case 'Node Information':
                options = ['Server', 'Workstation', 'PC', 'Random'];
                break;
            case 'Routing':
                options = ['RIP', 'RIPNG', 'BGP', 'OSPFv2', 'OSPFv3', 'Random'];
                break;
            case 'Services':
                options = ['SSH', 'HTTP', 'DHCPClient', 'Random'];
                break;
            case 'Traffic':
                options = ['Random', 'TCP', 'UDP', 'CUSTOM'];
                break;
            case 'Events':
                options = ['Script Path'];
                break;
            case 'Segmentation':
                options = ['Random', 'Firewall', 'NAT', 'CUSTOM'];
                break;
            default:
                options = ['Random'];
        }
        opts = options.map(o => `<option ${o===cur?'selected':''}>${o}</option>`).join('');
    }

    const extras = (() => {
        if (secName === 'Events') {
            return `<input class="form-control form-control-sm" placeholder="script path" value="${it.script_path || ''}" data-scen-idx="${sidx}" data-sec="${secName}" data-item-idx="${iidx}" data-field="script_path">`;
        }
        if (secName === 'Routing') {
            // Edges mode (Random/Min/Max/Exact). Random now acts like previous Auto (no extra links augmentation).
            const mode = it.r2r_mode || (it.r2r_edges !== undefined ? 'Exact' : 'Random');
            const val = (it.r2r_edges !== undefined && it.r2r_edges !== null) ? it.r2r_edges : '';
            const options = [
                {v:'Random', l:'Random'},
                {v:'Min', l:'Min'},
                {v:'Uniform', l:'Uniform'},
                {v:'Exact', l:'Exact'},
                {v:'NonUniform', l:'NonUniform'}
            ];
            const selHtml = `<select class="form-select form-select-sm routing-mode-select" style="width:105px" data-field="r2r_mode" data-scen-idx="${sidx}" data-sec="${secName}" data-item-idx="${iidx}">${options.map(o => `<option value="${o.v}" ${o.v===mode?'selected':''}>${o.l}</option>`).join('')}</select>`;
            // R-to-S (router to switch) connectivity policy (same option set)
            const r2sMode = it.r2s_mode || 'Random';
            const r2sVal = (it.r2s_edges !== undefined && it.r2s_edges !== null) ? it.r2s_edges : '';
            const r2sSel = `<select class="form-select form-select-sm routing-mode-select" style="width:105px" data-field="r2s_mode" data-scen-idx="${sidx}" data-sec="${secName}" data-item-idx="${iidx}">${options.map(o => `<option value="${o.v}" ${o.v===r2sMode?'selected':''}>${o.l}</option>`).join('')}</select>`;
            const r2sHostsMin = (it.r2s_hosts_min !== undefined && it.r2s_hosts_min !== null) ? it.r2s_hosts_min : 1;
            const r2sHostsMax = (it.r2s_hosts_max !== undefined && it.r2s_hosts_max !== null) ? it.r2s_hosts_max : 4;
            const showHsBounds = (r2sMode === 'NonUniform');
            return `
                <div class="d-flex flex-column gap-1 routing-edge-groups">
                    <div class="d-flex flex-wrap gap-2 align-items-center">
                        <label class="form-label mb-0 me-1" style="min-width:110px" title="Router-to-Router edge policy. Random = spanning tree; Min = chain; Uniform = balanced degrees; Exact = chain+augment to target; NonUniform = heterogeneous.">R-to-R Edges</label>
                        <div class="d-flex gap-3 align-items-end">
                            <div>${selHtml}</div>
                            <div class="edges-exact-input" style="display:${mode==='Exact'?'block':'none'};">
                                <input type="number" min="1" class="form-control form-control-sm edges-degree-input" style="width:110px" value="${val}" data-field="r2r_edges" data-scen-idx="${sidx}" data-sec="${secName}" data-item-idx="${iidx}" placeholder="Exact (e.g. 3)" aria-label="Exact router degree target" title="Target degree each router should attempt to reach (cannot reduce existing higher degrees).">
                            </div>
                        </div>
                    </div>
                    <div class="d-flex flex-wrap gap-2 align-items-center">
                        <label class="form-label mb-0 me-1" style="min-width:110px" title="Router-to-Switch attachment policy; controls how many distinct switches each router connects to.">R-to-S Edges</label>
                        <div class="d-flex gap-3 align-items-end flex-wrap align-items-center">
                            <div>${r2sSel}</div>
                            <div class="r2s-exact-input" style="display:${r2sMode==='Exact'?'block':'none'};">
                                <input type="number" min="1" class="form-control form-control-sm r2s-degree-input" style="width:110px" value="${r2sVal}" data-field="r2s_edges" data-scen-idx="${sidx}" data-sec="${secName}" data-item-idx="${iidx}" placeholder="Exact (e.g. 2)" aria-label="Exact router-to-switch target" title="Target number of switches per router (Exact mode).">
                            </div>
                            <div class="gap-2 align-items-end small hs-bounds-wrapper">
                                <div>
                                    <label class="form-label mb-0" style="font-size:0.7rem" title="Minimum hosts per created switch for this router row (preview & build).">H/S Min</label>
                                    <input type="number" min="1" max="32" class="form-control form-control-sm hs-min-input" style="width:70px" value="${r2sHostsMin}" data-field="r2s_hosts_min" data-scen-idx="${sidx}" data-sec="${secName}" data-item-idx="${iidx}" placeholder="min">
                                </div>
                                <div>
                                    <label class="form-label mb-0" style="font-size:0.7rem" title="Maximum hosts per created switch for this router row (preview & build).">H/S Max</label>
                                    <input type="number" min="1" max="64" class="form-control form-control-sm hs-max-input" style="width:70px" value="${r2sHostsMax}" data-field="r2s_hosts_max" data-scen-idx="${sidx}" data-sec="${secName}" data-item-idx="${iidx}" placeholder="max">
                                </div>
                            </div>
                        </div>
                    </div>
                </div>`;
        }
        if (secName === 'Traffic') {
            return `
                <div class="d-flex flex-wrap gap-2">
                    <div>
                        <label class="form-label mb-0">Payload</label>
                        <select class="form-select form-select-sm" data-field="content_type" data-scen-idx="${sidx}" data-sec="${secName}" data-item-idx="${iidx}">
                            ${['Random','text','photo','audio','video','gibberish'].map(ct => `<option value="${ct}" ${((it.content_type||'Random')===ct)?'selected':''}>${ct}</option>`).join('')}
                        </select>
                    </div>
                    <div class="traffic-config" style="display:${((it.content_type||'Random')==='Random')?'none':'block'};">
                        <label class="form-label mb-0">Pattern</label>
                        <select class="form-select form-select-sm" data-field="pattern" data-scen-idx="${sidx}" data-sec="${secName}" data-item-idx="${iidx}">
                            ${['continuous','periodic','burst','poisson','ramp'].map(p => `<option ${((it.pattern||'')===p)?'selected':''}>${p}</option>`).join('')}
                        </select>
                    </div>
                    <div class="traffic-config" style="display:${((it.content_type||'Random')==='Random')?'none':'block'};">
                        <label class="form-label mb-0">Rate (kbps)</label>
                        <input type="number" step="0.1" class="form-control form-control-sm" value="${it.rate_kbps ?? 64.0}" data-field="rate_kbps" data-scen-idx="${sidx}" data-sec="${secName}" data-item-idx="${iidx}">
                    </div>
                    <div class="traffic-config" style="display:${((it.content_type||'Random')==='Random')?'none':'block'};">
                        <label class="form-label mb-0">Period (s)</label>
                        <input type="number" step="0.1" class="form-control form-control-sm" value="${it.period_s ?? 1.0}" data-field="period_s" data-scen-idx="${sidx}" data-sec="${secName}" data-item-idx="${iidx}">
                    </div>
                    <div class="traffic-config" style="display:${((it.content_type||'Random')==='Random')?'none':'block'};">
                        <label class="form-label mb-0">Jitter (%)</label>
                        <input type="number" step="0.1" class="form-control form-control-sm" value="${it.jitter_pct ?? 10.0}" data-field="jitter_pct" data-scen-idx="${sidx}" data-sec="${secName}" data-item-idx="${iidx}">
                    </div>
                </div>`;
        }
        if (secName === 'Vulnerabilities') {
            const mode = it.selected || 'Type/Vector';
            if (mode === 'Specific') {
                const nm = it.v_name || '';
                // Try to obtain full description (prefer stored v_desc, else look up in catalog)
                let fullDesc = it.v_desc || '';
                if (!fullDesc && nm && window.VULN_CATALOG && Array.isArray(window.VULN_CATALOG.items)) {
                    const match = window.VULN_CATALOG.items.find(x => x.Name === nm && (!it.v_path || x.Path === it.v_path));
                    if (match && match.Description) { fullDesc = match.Description; }
                }
                const abbr = (s, n=80) => (s && s.length > n ? (s.slice(0, n-1) + '…') : (s||''));
                const esc = (s) => (s||'')
                    .replace(/&/g,'&amp;')
                    .replace(/</g,'&lt;')
                    .replace(/>/g,'&gt;')
                    .replace(/"/g,'&quot;')
                    .replace(/'/g,'&#39;');
                const descShort = abbr(fullDesc);
                const centerText = nm ? `${nm}${descShort ? ' — ' + descShort : ''}` : '<span class="text-muted">No selection</span>';
                return `<span class="small" ${fullDesc ? `data-bs-toggle="tooltip" data-bs-title="${esc(fullDesc)}"` : ''}>${centerText}</span>`;
            }
            return '';
        }
        return '';
    })();
    // Build first cell content, optionally augmenting Selected with Vulnerabilities controls
    const firstCell = (() => {
        const isProtectedRandom = (secName === 'Node Information') && ((it.selected||'').toLowerCase()==='random') && it._protected_random;
        const disabledAttr = isProtectedRandom ? 'disabled title="Residual Random row is auto-managed"' : '';
        const selectedCtl = `<select class="form-select form-select-sm" ${disabledAttr} data-field="selected" data-scen-idx="${sidx}" data-sec="${secName}" data-item-idx="${iidx}">${opts}</select>`;
        if (secName !== 'Vulnerabilities') return selectedCtl;
    const mode = it.selected || 'Category';
    if (mode === 'Category') {
            return `
            <div class="d-flex flex-wrap gap-2 align-items-end">
                <div style="min-width:160px">${selectedCtl}</div>
                <div>
                    <label class="form-label mb-0">Type</label>
                    <select class="form-select form-select-sm vuln-type" data-field="v_type" data-scen-idx="${sidx}" data-sec="${secName}" data-item-idx="${iidx}"></select>
                </div>
                <div>
                    <label class="form-label mb-0">Vector</label>
                    <select class="form-select form-select-sm vuln-vector" data-field="v_vector" data-scen-idx="${sidx}" data-sec="${secName}" data-item-idx="${iidx}"></select>
                </div>
            </div>`;
        } else if (mode === 'Specific') {
            const nm = it.v_name || '';
            // Try to obtain full description (prefer stored v_desc, else look up in catalog)
            let fullDesc = it.v_desc || '';
            if (!fullDesc && nm && window.VULN_CATALOG && Array.isArray(window.VULN_CATALOG.items)) {
                const match = window.VULN_CATALOG.items.find(x => x.Name === nm && (!it.v_path || x.Path === it.v_path));
                if (match && match.Description) { fullDesc = match.Description; }
            }
            const abbr = (s, n=80) => (s && s.length > n ? (s.slice(0, n-1) + '…') : (s||''));
            const esc = (s) => (s||'')
                .replace(/&/g,'&amp;')
                .replace(/</g,'&lt;')
                .replace(/>/g,'&gt;')
                .replace(/"/g,'&quot;')
                .replace(/'/g,'&#39;');
            const descShort = abbr(fullDesc);
            return `
            <div class="d-flex flex-wrap gap-2 align-items-center">
                <div style="min-width:160px">${selectedCtl}</div>
                <button type="button" class="btn btn-sm btn-outline-primary" data-action="pick-specific" data-scen-idx="${sidx}" data-sec="${secName}" data-item-idx="${iidx}">Choose...</button>
            </div>`;
        }
        return selectedCtl;
    })();
    // Right-most: Weight or Count cell
    const weightCell = (() => {
        if (secName === 'Vulnerabilities') {
            const mode = it.selected || 'Type/Vector';
            const metric = it.v_metric || (mode === 'Specific' ? 'Count' : 'Weight');
            const metricSel = `<select class="form-select form-select-sm" style="min-width: 140px" data-field="v_metric" data-scen-idx="${sidx}" data-sec="${secName}" data-item-idx="${iidx}"><option ${metric==='Weight'?'selected':''}>Weight</option><option ${metric==='Count'?'selected':''}>Count</option></select>`;
            if (metric === 'Count') {
                const count = (parseInt(it.v_count, 10) || 5);
                return `<div class="d-flex gap-2">${metricSel}<input type="number" min="1" step="1" class="form-control form-control-sm" style="min-width: 120px" value="${count}" data-field="v_count" data-scen-idx="${sidx}" data-sec="${secName}" data-item-idx="${iidx}"></div>`;
            }
            return `<div class="d-flex gap-2">${metricSel}<input type="number" step="0.01" min="0" max="1" class="form-control form-control-sm weight-input" style="min-width: 120px" value="${weight}" data-field="factor" data-scen-idx="${sidx}" data-sec="${secName}" data-item-idx="${iidx}"></div>`;
        }
        // For all other sections, provide a Count/Weight selector as well
        const metric = it.v_metric || 'Weight';
        const metricSel = `<select class="form-select form-select-sm" style="min-width: 140px" data-field="v_metric" data-scen-idx="${sidx}" data-sec="${secName}" data-item-idx="${iidx}"><option ${metric==='Weight'?'selected':''}>Weight</option><option ${metric==='Count'?'selected':''}>Count</option></select>`;
        if (metric === 'Count') {
            const count = (parseInt(it.v_count, 10) || NODE_COUNT_MIN);
            return `<div class="d-flex gap-2">${metricSel}<input type="number" min="${NODE_COUNT_MIN}" max="${NODE_COUNT_MAX}" step="1" class="form-control form-control-sm" style="min-width: 120px" value="${count}" data-field="v_count" data-scen-idx="${sidx}" data-sec="${secName}" data-item-idx="${iidx}"></div>`;
        }
    const isProtectedRandom = (secName === 'Node Information') && ((it.selected||'').toLowerCase()==='random') && it._protected_random;
    const metricDisabled = isProtectedRandom ? 'disabled title="Residual Random row metric locked"' : '';
    const metricSelProtected = `<select class="form-select form-select-sm" ${metricDisabled} style="min-width: 140px" data-field="v_metric" data-scen-idx="${sidx}" data-sec="${secName}" data-item-idx="${iidx}"><option ${metric==='Weight'?'selected':''}>Weight</option><option ${metric==='Count'?'selected':''}>Count</option></select>`;
    const ro = isProtectedRandom ? 'readonly class="form-control form-control-sm weight-input bg-light" title="Auto-adjusted to keep sum=1.0"' : 'class="form-control form-control-sm weight-input"';
    return `<div class="d-flex gap-2">${metricSelProtected}<input type="number" step="0.01" min="0" max="1" ${ro} style="min-width: 120px" value="${weight}" data-field="factor" data-scen-idx="${sidx}" data-sec="${secName}" data-item-idx="${iidx}"></div>`;
    })();
    const removeBtnHtml = ((secName === 'Node Information') && ((it.selected||'').toLowerCase()==='random') && it._protected_random)
        ? '<span class="text-muted small" title="Residual Random row">&mdash;</span>'
        : `<button type="button" class="btn btn-sm btn-outline-danger" data-action="remove-item" data-scen-idx="${sidx}" data-sec="${secName}" data-item-idx="${iidx}">Remove</button>`;
    return `
        <tr>
            <td>${firstCell}</td>
            <td>${extras}</td>
            <td>${weightCell}</td>
            <td>${removeBtnHtml}</td>
        </tr>`;
}
// Render Vulnerabilities rows grouped with two row-headers
function renderVulnRows(sidx, secName, items) {
    const withIdx = items.map((it, iidx) => ({ it, iidx }));
    const typeOrRandom = withIdx.filter(x => (x.it.selected || 'Category') !== 'Specific');
    const specifics = withIdx.filter(x => (x.it.selected || 'Category') === 'Specific');
    const parts = [];
    if (typeOrRandom.length) {
        parts.push(`<tr class="table-light"><td colspan="4"><strong>Category or Random</strong></td></tr>`);
        parts.push(typeOrRandom.map(x => renderItemRow(sidx, secName, x.iidx, x.it)).join(''));
    }
    if (specifics.length) {
        parts.push(`<tr class="table-light"><td colspan="4"><strong>Specific</strong></td></tr>`);
        parts.push(specifics.map(x => renderItemRow(sidx, secName, x.iidx, x.it)).join(''));
    }
    return parts.join('');
}

function wireHandlers() {
    // Count for Density input handler
    document.querySelectorAll('input[data-field="scenario_density_count"]').forEach(inp => {
        inp.addEventListener('change', () => {
            const idx = parseInt(inp.getAttribute('data-scen-idx'));
            if (Number.isNaN(idx) || !state.scenarios?.[idx]) return;
            let val = clampDensityCountValue(inp.value);
            if (val === null) {
                val = DENSITY_COUNT_MIN;
            }
            state.scenarios[idx].density_count = val; // store at scenario level; do NOT mutate node rows
            enforceDensityBounds(idx);
            refreshScenarioStateAfterCountEdit();
        });
        // Prevent Enter key from triggering unintended form behavior (like adding a row)
        inp.addEventListener('keydown', (ev) => {
            if (ev.key === 'Enter') { ev.preventDefault(); inp.blur(); }
        });
    });
    document.querySelectorAll('input[data-field="scenario_density_min_enabled"]').forEach(inp => {
        inp.addEventListener('change', () => {
            const idx = parseInt(inp.getAttribute('data-scen-idx'));
            if (Number.isNaN(idx) || !state.scenarios?.[idx]) return;
            const scen = state.scenarios[idx];
            const enabled = !!inp.checked;
            scen.density_count_min_enabled = enabled;
            if (enabled && clampDensityCountValue(scen.density_count_min) === null) {
                const fallback = clampDensityCountValue(scen.density_count);
                scen.density_count_min = fallback === null ? DENSITY_COUNT_MIN : fallback;
            }
            enforceDensityBounds(idx);
            refreshScenarioStateAfterCountEdit();
        });
    });
    document.querySelectorAll('input[data-field="scenario_density_max_enabled"]').forEach(inp => {
        inp.addEventListener('change', () => {
            const idx = parseInt(inp.getAttribute('data-scen-idx'));
            if (Number.isNaN(idx) || !state.scenarios?.[idx]) return;
            const scen = state.scenarios[idx];
            const enabled = !!inp.checked;
            scen.density_count_max_enabled = enabled;
            if (enabled && clampDensityCountValue(scen.density_count_max) === null) {
                const fallback = clampDensityCountValue(scen.density_count);
                scen.density_count_max = fallback === null ? DENSITY_COUNT_MAX : fallback;
            }
            enforceDensityBounds(idx);
            refreshScenarioStateAfterCountEdit();
        });
    });
    const handleDensityBoundInput = (selector, fieldName, enabledField) => {
        document.querySelectorAll(selector).forEach(inp => {
            inp.addEventListener('change', () => {
                const idx = parseInt(inp.getAttribute('data-scen-idx'));
                if (Number.isNaN(idx) || !state.scenarios?.[idx]) return;
                const scen = state.scenarios[idx];
                let val = clampDensityCountValue(inp.value);
                if (val === null) {
                    inp.value = '';
                    delete scen[fieldName];
                    scen[enabledField] = false;
                } else {
                    scen[fieldName] = val;
                    scen[enabledField] = true;
                }
                enforceDensityBounds(idx);
                refreshScenarioStateAfterCountEdit();
            });
            inp.addEventListener('keydown', (ev) => {
                if (ev.key === 'Enter') { ev.preventDefault(); inp.blur(); }
            });
        });
    };
    handleDensityBoundInput('input[data-field="scenario_density_min"]', 'density_count_min', 'density_count_min_enabled');
    handleDensityBoundInput('input[data-field="scenario_density_max"]', 'density_count_max', 'density_count_max_enabled');
    document.querySelectorAll('[data-field]').forEach(el => {
        const sidx = parseInt(el.getAttribute('data-scen-idx'));
        const sec = el.getAttribute('data-sec');
        const field = el.getAttribute('data-field');
        const iidx = el.getAttribute('data-item-idx');
        const rowIdx = (iidx !== null && iidx !== undefined) ? parseInt(iidx, 10) : null;
        const handler = (ev) => {
            if (field === 'scenario_base_hosts') { return; }
            if (sec) {
                if (rowIdx !== null && !Number.isNaN(rowIdx)) {
                    const item = state.scenarios[sidx].sections[sec].items[rowIdx];
                    if (['factor','rate_kbps','period_s','jitter_pct','total_nodes','density','r2r_edges','r2s_edges','r2s_hosts_min','r2s_hosts_max'].includes(field)) {
                        item ? (item[field] = parseFloat(el.value)) : state.scenarios[sidx].sections[sec][field] = parseFloat(el.value);
                        if ((field === 'edges' || field === 'r2s_edges') && (isNaN(item[field]) || el.value === '')) {
                            // Allow blank to mean "unset" so generator can apply defaults
                            delete item[field];
                        }
                        if ((field === 'r2s_hosts_min' || field === 'r2s_hosts_max')) {
                            const mn = parseInt(item.r2s_hosts_min || 1, 10);
                            const mx = parseInt(item.r2s_hosts_max || 4, 10);
                            if (!isNaN(mn) && !isNaN(mx) && mn > mx) {
                                item.r2s_hosts_max = mn;
                            }
                            persistEditorState();
                        }
                        if (field === 'factor') {
                            adjustWeightsProportionally(sidx, sec, rowIdx);
                            updateWeightWarning(sidx, sec);
                            updateWeightInputsDisplay(sidx, sec);
                        }
                        if (field === 'edges' || field === 'r2s_edges') {
                            setTimeout(validateRoutingEdges, 20);
                        }
                    } else if (['pattern','content_type','selected','script_path','v_type','v_vector','v_name','v_path','v_count','v_metric','r2r_mode','r2s_mode'].includes(field)) {
                        const prev = item[field];
                        if (field === 'v_count') {
                            let n = clampNodeCountValue(el.value);
                            if (n === null) {
                                n = NODE_COUNT_MIN;
                            }
                            item[field] = n;
                            if (sec) {
                                enforceSectionCountBoundsForScenario(sidx, sec, rowIdx);
                            }
                        } else {
                            item[field] = el.value;
                        }
                        if(field === 'r2r_mode') {
                            item.r2r_mode = el.value;
                            if(el.value !== 'Exact') { delete item.edges; }
                            renderMain();
                            updateHsBoundsVisibility();
                            setTimeout(validateRoutingEdges, 50);
                        }
                        if(field === 'r2s_mode') {
                            item.r2s_mode = el.value;
                            if(el.value !== 'Exact') { delete item.r2s_edges; }
                            renderMain();
                            updateHsBoundsVisibility();
                            setTimeout(validateRoutingEdges, 50);
                        }
                        if (field === 'edges') {
                            setTimeout(validateRoutingEdges, 20);
                        } else if (field === 'content_type') {
                            // Re-render to reflect show/hide of traffic-config inputs when Random is selected
                            renderMain();
                        } else if (field === 'selected') {
                            if (item.selected === 'Specific') {
                                if (!item.v_count) item.v_count = 5;
                                if (!item.v_metric) item.v_metric = 'Count';
                            } else {
                                if (!item.v_metric) item.v_metric = 'Weight';
                            }
                            if (sec) {
                                enforceSectionCountBoundsForScenario(sidx, sec, rowIdx);
                            }
                            // Re-render to show/hide appropriate controls and recalc weight warnings
                            renderMain();
                        } else if (field === 'v_metric') {
                            // On metric toggle, normalize weights for current section and re-render
                            if (item.v_metric === 'Count' && (item.v_count === undefined || item.v_count === null || isNaN(parseInt(item.v_count, 10)))) {
                                item.v_count = 5;
                            }
                            redistributeEven(sidx, sec);
                            if (sec === 'Node Information') {
                                const secRef = state.scenarios[sidx].sections[sec];
                                const hasWeight = (secRef.items || []).some(it => (it.v_metric || 'Weight') === 'Weight');
                                if (!hasWeight && secRef.total_nodes) { secRef.total_nodes = 0; }
                                enforceSectionCountBoundsForScenario(sidx, sec, rowIdx);
                            }
                            updateWeightWarning(sidx, sec);
                            renderMain();
                        } else if (field === 'v_count') {
                            // Count change affects Total Nodes label
                            renderMain();
                        }
                    } else {
                        state.scenarios[sidx].sections[sec][field] = el.value;
                    }
                } else {
                    const sectionRef = state.scenarios[sidx].sections[sec];
                    if (!sectionRef) return;
                    if (field === 'density' || field === 'total_nodes') {
                        let v = parseFloat(el.value);
                        if (field === 'density') {
                            if (isNaN(v)) v = 0.0;
                            v = Math.max(0, Math.min(1, v)); // Clamp globally 0..1
                        }
                        sectionRef[field] = v;
                        // keep hidden for submit and update any warnings
                        if (field === 'density') { updateWeightWarning(sidx, sec); }
                        // Ensure Total Nodes label refreshes on total_nodes edits
                        if (field === 'total_nodes') { renderMain(); }
                    } else if (field === 'node_count_min_enabled' || field === 'node_count_max_enabled') {
                        if (ev?.type === 'input') return;
                        const enabled = !!el.checked;
                        const targetField = field === 'node_count_min_enabled' ? 'node_count_min' : 'node_count_max';
                        sectionRef[field] = enabled;
                        if (enabled) {
                            let fallback = clampNodeCountValue(sectionRef[targetField]);
                            if (fallback === null) {
                                const rows = collectSectionCountRows(sectionRef);
                                const total = sumSectionCountRowValues(rows);
                                fallback = total > 0 ? total : (rows.length * NODE_COUNT_MIN);
                            }
                            if (fallback === null || fallback === undefined) {
                                fallback = NODE_COUNT_MIN;
                            }
                            sectionRef[targetField] = fallback;
                        }
                        enforceSectionCountBoundsForScenario(sidx, sec);
                        refreshScenarioStateAfterCountEdit();
                        return;
                    } else if (field === 'node_count_min' || field === 'node_count_max') {
                        if (ev?.type === 'input') return;
                        let val = clampNodeCountValue(el.value);
                        const enabledField = `${field}_enabled`;
                        if (val === null) {
                            el.value = '';
                            delete sectionRef[field];
                            sectionRef[enabledField] = false;
                        } else {
                            sectionRef[field] = val;
                            sectionRef[enabledField] = true;
                        }
                        enforceSectionCountBoundsForScenario(sidx, sec);
                        refreshScenarioStateAfterCountEdit();
                        return;
                    } else {
                        sectionRef[field] = el.value;
                    }
                }
            } else {
                if (field === 'name') {
                    const raw = el.value ?? '';
                    if (ev?.type === 'change') {
                        const trimmed = raw.trim();
                        const finalName = trimmed || `Scenario ${sidx + 1}`;
                        state.scenarios[sidx].name = finalName;
                        if (el.value !== finalName) {
                            el.value = finalName;
                        }
                        try { logInfo(`Scenario renamed to ${finalName}`); } catch(_) {}
                    } else {
                        state.scenarios[sidx].name = raw;
                    }
                }
                if (field === 'base-file') state.scenarios[sidx].base.filepath = el.value;
                if (field === 'notes') state.scenarios[sidx].notes = el.value;
                if(field === 'notes'){
                    try {
                        const ind = document.getElementById('notesIndicator_'+sidx);
                        if(ind){
                            const has = (el.value||'').trim().length>0;
                            ind.innerHTML = has ? `<i class='bi bi-journal-text text-success'></i>` : `<i class='bi bi-journal text-muted'></i>`;
                            ind.setAttribute('data-bs-title', has ? 'Notes present' : 'No notes');
                            if(window.bootstrap){ try { new bootstrap.Tooltip(ind); } catch(e){} }
                        }
                    } catch(e){}
                }
            }
            if (field === 'name') {
                renderSidebar();
            }
            // keep hidden for submit
            document.getElementById('scenarios_json').value = JSON.stringify({ scenarios: state.scenarios, active_index: activeIdx });
            // persist edits across navigation
            persistEditorState();
            logDebug(`Field change: scen=${sidx} sec=${sec||''} field=${field}`);
            try { previewState.dirty = true; updatePlanButtons(); } catch(e){}
        };
        el.addEventListener('input', handler);
        el.addEventListener('change', handler);
    });
    document.querySelectorAll('[data-action="remove-item"]').forEach(btn => {
        btn.onclick = () => {
            const sidx = parseInt(btn.getAttribute('data-scen-idx'));
            const sec = btn.getAttribute('data-sec');
            const iidx = parseInt(btn.getAttribute('data-item-idx'));
            state.scenarios[sidx].sections[sec].items.splice(iidx,1);
                        logInfo(`Removed item ${iidx} from ${sec}`);
              redistributeEven(sidx, sec);
              // Auto-clear total_nodes if Node Information loses its last weight-based row
              if (sec === 'Node Information') {
                  const secRef = state.scenarios[sidx].sections[sec];
                  const hasWeight = (secRef.items || []).some(it => (it.v_metric || 'Weight') === 'Weight');
                  if (!hasWeight && secRef.total_nodes) { secRef.total_nodes = 0; }
                  enforceSectionCountBoundsForScenario(sidx, sec);
              }
              // Re-render to refresh totals and labels
                            renderMain();
                            persistEditorState();
                            try { previewState.dirty = true; updatePlanButtons(); } catch(e){}
        };
    });
    document.querySelectorAll('[data-action="add-item"]').forEach(btn => {
        btn.onclick = () => {
            const sidx = parseInt(btn.getAttribute('data-scen-idx'));
            const sec = btn.getAttribute('data-sec');
            // Default selection logic: for Routing we prefer the first concrete protocol (not Random) so
            // routers don't silently become 'Random' unless user explicitly chooses it. Other sections
            // still start at 'Random' (or specialized default) as before.
            let defaultSelected = 'Random';
            if (sec === 'Routing') {
                try {
                    const opts = dropdownsBySection['Routing'] || [];
                    // pick the first option that isn't 'Random'
                    const concrete = opts.find(o => o !== 'Random');
                    if (concrete) defaultSelected = concrete;
                } catch(e){}
            }
            const item = { selected: defaultSelected, factor: 1.0 };
            if (sec === 'Events') item.script_path = '';
            if (sec === 'Traffic') { item.pattern = 'continuous'; item.rate_kbps = 64.0; item.period_s = 1.0; item.jitter_pct = 10.0; item.content_type = 'Random'; }
            if (sec === 'Vulnerabilities') { item.selected = 'Category'; item.v_type = 'Random'; item.v_vector = 'Random'; }
            // Default new rows: Node Information -> Count; others -> Weight.
            if (sec === 'Node Information') { item.v_metric = 'Count'; item.v_count = 5; }
            else { item.v_metric = 'Weight'; }
            state.scenarios[sidx].sections[sec].items.push(item);
                        logInfo(`Added item to ${sec}`);
              redistributeEven(sidx, sec);
            if (sec === 'Node Information') {
                const newIdx = state.scenarios[sidx].sections[sec].items.length - 1;
                enforceSectionCountBoundsForScenario(sidx, sec, newIdx);
            }
                            renderMain();
                            persistEditorState();
                            try { previewState.dirty = true; updatePlanButtons(); } catch(e){}
        };
    });
    document.querySelectorAll('[data-action="toggle-collapse"]').forEach(btn => {
        btn.onclick = () => {
            const targetSel = btn.getAttribute('data-target');
            const target = document.querySelector(targetSel);
            if (!target) return;
            const visible = target.style.display !== 'none';
            target.style.display = visible ? 'none' : 'block';
            btn.textContent = visible ? 'Expand' : 'Collapse';
            const secName = targetSel.replace('#collapse-','').replace(/-/g,' ');
            const collapseKey = `${activeIdx}::${secName}`;
            collapseState[collapseKey] = visible; // store collapsed state (true means now collapsed)
            try { localStorage.setItem('sectionCollapseState', JSON.stringify(collapseState)); } catch(e) {}
            logDebug(`Section toggle ${targetSel} -> ${visible ? 'collapsed':'expanded'}`);
        };
    });
    document.querySelectorAll('[data-hitl-toggle]').forEach(toggle => {
        toggle.addEventListener('change', () => {
            const sidx = parseInt(toggle.getAttribute('data-scen-idx'));
            if (isNaN(sidx) || !state.scenarios[sidx]) return;
            const hitlState = ensureHitlStateForScenario(state.scenarios[sidx]);
            hitlState.enabled = !!toggle.checked;
            logInfo(`HITL ${hitlState.enabled ? 'enabled' : 'disabled'} for scenario ${state.scenarios[sidx].name || sidx + 1}`);
            persistEditorState();
            const hidden = document.getElementById('scenarios_json');
            if (hidden) hidden.value = JSON.stringify({ scenarios: state.scenarios, active_index: activeIdx });
            renderMain();
        });
    });
    document.querySelectorAll('[data-hitl-add]').forEach(btn => {
        btn.addEventListener('click', () => {
            const sidx = parseInt(btn.getAttribute('data-scen-idx'));
            if (isNaN(sidx) || !state.scenarios[sidx]) return;
            const select = document.getElementById(`hitlAvailable_${sidx}`);
            if (!select) return;
            const chosen = Array.from(select.selectedOptions || []);
            if (!chosen.length) {
                try { showToast('Select one or more interfaces to add', { autohide: true, delay: 2000 }); } catch(e) {}
                return;
            }
            const hitlState = ensureHitlStateForScenario(state.scenarios[sidx]);
            const catalog = Array.isArray(state.host_interfaces) ? state.host_interfaces : [];
            const isVmbr0 = (entry) => {
                if (!entry) return false;
                const bridge = (entry.bridge || (entry.proxmox && entry.proxmox.bridge) || (entry.proxmox && entry.proxmox.raw && entry.proxmox.raw.bridge) || '').toString().trim().toLowerCase();
                return bridge === 'vmbr0';
            };
            let added = 0;
            let blocked = 0;
            chosen.forEach(opt => {
                const name = (opt.value || opt.textContent || '').trim();
                if (!name) return;
                if (hitlState.interfaces.some(entry => entry.name === name)) return;
                const hostInfo = catalog.find(entry => entry && entry.name === name);
                if (hostInfo && isVmbr0(hostInfo)) {
                    blocked += 1;
                    return;
                }
                const newEntry = { name, attachment: 'existing_router' };
                if (hostInfo) {
                    if (Array.isArray(hostInfo.ipv4)) newEntry.ipv4 = hostInfo.ipv4;
                    if (Array.isArray(hostInfo.ipv6)) newEntry.ipv6 = hostInfo.ipv6;
                    if (hostInfo.mac) newEntry.mac = hostInfo.mac;
                }
                hitlState.interfaces.push(newEntry);
                added += 1;
            });
            if (!added) {
                if (blocked) {
                    try { showToast('Interfaces on vmbr0 cannot be mapped for HITL.', { autohide: true, delay: 2500 }); } catch(e) {}
                } else {
                    try { showToast('Interfaces already selected', { autohide: true, delay: 2000 }); } catch(e) {}
                }
                return;
            }
            hitlState.enabled = true;
            logInfo(`Added ${added} HITL interface${added > 1 ? 's' : ''}`);
            if (blocked) {
                try { showToast('Skipped vmbr0 interfaces; they remain visible but unavailable.', { autohide: true, delay: 2500 }); } catch(e) {}
            }
            persistEditorState();
            const hidden = document.getElementById('scenarios_json');
            if (hidden) hidden.value = JSON.stringify({ scenarios: state.scenarios, active_index: activeIdx });
            renderMain();
        });
    });
    document.querySelectorAll('[data-hitl-attach]').forEach(select => {
        select.addEventListener('change', () => {
            const sidx = parseInt(select.getAttribute('data-scen-idx'));
            const ifaceIdx = parseInt(select.getAttribute('data-iface-index'));
            if (isNaN(sidx) || isNaN(ifaceIdx) || !state.scenarios[sidx]) return;
            const hitlState = ensureHitlStateForScenario(state.scenarios[sidx]);
            if (!Array.isArray(hitlState.interfaces) || !hitlState.interfaces[ifaceIdx]) return;
            const newValue = normalizeHitlAttachment(select.value);
            hitlState.interfaces[ifaceIdx].attachment = newValue;
            logInfo(`Updated HITL attachment for ${hitlState.interfaces[ifaceIdx].name || 'interface'} → ${newValue}`);
            persistEditorState();
            const hidden = document.getElementById('scenarios_json');
            if (hidden) hidden.value = JSON.stringify({ scenarios: state.scenarios, active_index: activeIdx });
            renderMain();
        });
    });
    document.querySelectorAll('[data-hitl-external-vm-select]').forEach(select => {
        select.addEventListener('change', () => {
            const sidx = parseInt(select.getAttribute('data-scen-idx'));
            const ifaceIdx = parseInt(select.getAttribute('data-iface-index'));
            if (isNaN(sidx) || isNaN(ifaceIdx) || !state.scenarios?.[sidx]) return;
            const scenario = state.scenarios[sidx];
            const hitlState = ensureHitlStateForScenario(scenario);
            if (!Array.isArray(hitlState.interfaces) || !hitlState.interfaces[ifaceIdx]) return;
            const ifaceEntry = hitlState.interfaces[ifaceIdx];
            const rawValue = (select.value || '').trim();
            const coreState = hitlState.core || {};
            const coreVmKeyCurrent = (coreState.vm_key || '').toString();
            const proxState = hitlState.proxmox || {};
            const inventory = proxState.inventory && Array.isArray(proxState.inventory.vms) ? proxState.inventory.vms : [];
            if (!rawValue) {
                delete ifaceEntry.external_vm;
                persistEditorState();
                const hidden = document.getElementById('scenarios_json');
                if (hidden) hidden.value = JSON.stringify({ scenarios: state.scenarios, active_index: activeIdx });
                renderMain();
                return;
            }
            if (rawValue === coreVmKeyCurrent) {
                logWarn('Ignoring selection of CORE VM for external connectivity');
                select.value = '';
                delete ifaceEntry.external_vm;
                try { showToast('Select a VM other than the CORE VM.', { autohide: true, delay: 2500 }); } catch (e) {}
                return;
            }
            const selectedVm = inventory.find(vm => `${vm.node ?? ''}::${vm.vmid ?? ''}` === rawValue);
            const [nodePart, vmidPartRaw] = rawValue.split('::');
            const vmidPart = vmidPartRaw && vmidPartRaw.trim() ? vmidPartRaw.trim() : '';
            const normalizedVmNode = selectedVm && selectedVm.node !== undefined && selectedVm.node !== null
                ? String(selectedVm.node).trim()
                : (nodePart || '').trim();
            const physicalInterfaces = selectedVm ? getPhysicalVmInterfaces(selectedVm) : [];
            const baseExternalVm = selectedVm
                ? {
                    vm_key: rawValue,
                    vm_node: normalizedVmNode,
                    vmid: selectedVm.vmid ?? vmidPart,
                    vm_name: selectedVm.name ?? '',
                    status: selectedVm.status ?? '',
                }
                : {
                    vm_key: rawValue,
                    vm_node: normalizedVmNode,
                    vmid: vmidPart,
                    vm_name: '',
                    status: '',
                };
            if (physicalInterfaces.length === 1) {
                const onlyIface = physicalInterfaces[0];
                const ifaceId = normalizeVmInterfaceId(onlyIface);
                if (ifaceId) {
                    baseExternalVm.interface_id = ifaceId;
                    baseExternalVm.interface_bridge = (onlyIface.bridge ?? '').toString().trim();
                    baseExternalVm.interface_mac = (onlyIface.macaddr ?? '').toString().trim();
                    baseExternalVm.interface_model = (onlyIface.model ?? '').toString().trim();
                }
            }
            ifaceEntry.external_vm = baseExternalVm;
            persistEditorState();
            const hidden = document.getElementById('scenarios_json');
            if (hidden) hidden.value = JSON.stringify({ scenarios: state.scenarios, active_index: activeIdx });
            renderMain();
            const labelParts = [];
            if (ifaceEntry.external_vm?.vm_name) labelParts.push(ifaceEntry.external_vm.vm_name);
            if (ifaceEntry.external_vm?.vm_node) labelParts.push(`node ${ifaceEntry.external_vm.vm_node}`);
            if (ifaceEntry.external_vm?.vmid !== undefined && ifaceEntry.external_vm?.vmid !== null && ifaceEntry.external_vm.vmid !== '') {
                labelParts.push(`ID ${ifaceEntry.external_vm.vmid}`);
            }
            if (ifaceEntry.external_vm?.interface_id) {
                labelParts.push(`iface ${ifaceEntry.external_vm.interface_id}`);
                if (ifaceEntry.external_vm.interface_bridge) labelParts.push(`bridge ${ifaceEntry.external_vm.interface_bridge}`);
            }
            try { showToast(`Linked ${ifaceEntry.name || 'interface'} to ${labelParts.join(' • ') || 'selected VM'}`, { autohide: true, delay: 2200 }); } catch (e) {}
        });
    });
    document.querySelectorAll('[data-hitl-external-vm-iface-select]').forEach(select => {
        select.addEventListener('change', () => {
            const sidx = parseInt(select.getAttribute('data-scen-idx'));
            const ifaceIdx = parseInt(select.getAttribute('data-iface-index'));
            if (isNaN(sidx) || isNaN(ifaceIdx) || !state.scenarios?.[sidx]) return;
            const scenario = state.scenarios[sidx];
            const hitlState = ensureHitlStateForScenario(scenario);
            if (!Array.isArray(hitlState.interfaces) || !hitlState.interfaces[ifaceIdx]) return;
            const ifaceEntry = hitlState.interfaces[ifaceIdx];
            if (!ifaceEntry.external_vm || typeof ifaceEntry.external_vm !== 'object') return;
            const rawValue = (select.value || '').trim();
            const proxState = hitlState.proxmox || {};
            const inventory = proxState.inventory && Array.isArray(proxState.inventory.vms) ? proxState.inventory.vms : [];
            const externalVmKey = ifaceEntry.external_vm.vm_key || '';
            const selectedVm = inventory.find(vm => `${vm.node ?? ''}::${vm.vmid ?? ''}` === externalVmKey);
            const physicalInterfaces = selectedVm ? getPhysicalVmInterfaces(selectedVm) : [];
            if (!rawValue) {
                delete ifaceEntry.external_vm.interface_id;
                delete ifaceEntry.external_vm.interface_bridge;
                delete ifaceEntry.external_vm.interface_mac;
                delete ifaceEntry.external_vm.interface_model;
                persistEditorState();
                const hidden = document.getElementById('scenarios_json');
                if (hidden) hidden.value = JSON.stringify({ scenarios: state.scenarios, active_index: activeIdx });
                renderMain();
                try { showToast(`Cleared external interface for ${ifaceEntry.name || 'interface'}.`, { autohide: true, delay: 2000 }); } catch (e) {}
                return;
            }
            const matchedIface = physicalInterfaces.find(vmIface => normalizeVmInterfaceId(vmIface) === rawValue) || null;
            ifaceEntry.external_vm.interface_id = rawValue;
            ifaceEntry.external_vm.interface_bridge = matchedIface && matchedIface.bridge ? String(matchedIface.bridge).trim() : '';
            ifaceEntry.external_vm.interface_mac = matchedIface && matchedIface.macaddr ? String(matchedIface.macaddr).trim() : '';
            ifaceEntry.external_vm.interface_model = matchedIface && matchedIface.model ? String(matchedIface.model).trim() : '';
            persistEditorState();
            const hidden = document.getElementById('scenarios_json');
            if (hidden) hidden.value = JSON.stringify({ scenarios: state.scenarios, active_index: activeIdx });
            renderMain();
            const labelParts = [];
            if (ifaceEntry.external_vm?.vm_name) labelParts.push(ifaceEntry.external_vm.vm_name);
            if (ifaceEntry.external_vm?.vm_node) labelParts.push(`node ${ifaceEntry.external_vm.vm_node}`);
            labelParts.push(`iface ${rawValue}`);
            if (ifaceEntry.external_vm.interface_bridge) labelParts.push(`bridge ${ifaceEntry.external_vm.interface_bridge}`);
            try { showToast(`Mapped ${ifaceEntry.name || 'interface'} to ${labelParts.join(' • ')}`, { autohide: true, delay: 2200 }); } catch (e) {}
        });
    });
    document.querySelectorAll('[data-hitl-step4-refresh]').forEach(btn => {
        btn.addEventListener('click', async () => {
            if (btn.disabled) return;
            const sidx = parseInt(btn.getAttribute('data-scen-idx'));
            if (isNaN(sidx) || !state.scenarios?.[sidx]) return;
            btn.disabled = true;
            const originalLabel = btn.innerHTML;
            btn.innerHTML = 'Refreshing…';
            try { showToast('Refreshing Proxmox interfaces…', { autohide: true, delay: 1800 }); } catch (e) {}
            try {
                await fetchProxmoxInventory(sidx, { force: true });
            } finally {
                // renderMain will rebuild the button; restore label in case this element persists before re-render
                btn.innerHTML = originalLabel;
            }
        });
    });
    const setParticipantUrlStatus = (sidx, rawValue) => {
        const indicator = document.querySelector(`[data-hitl-participant-status="${sidx}"]`);
        if (!indicator) return;
        const normalized = normalizeParticipantProxmoxHref(rawValue || '');
        if (normalized) {
            indicator.textContent = `${PARTICIPANT_STATUS_SAVED_TEXT} (${normalized})`;
            indicator.classList.remove('text-muted');
            indicator.classList.add('text-success');
        } else {
            indicator.textContent = PARTICIPANT_STATUS_EMPTY_TEXT;
            indicator.classList.remove('text-success');
            indicator.classList.add('text-muted');
        }
    };
    const persistParticipantProxmoxUrl = (sidx, rawValue) => {
        if (Number.isNaN(sidx) || !state.scenarios?.[sidx]) return false;
        const scenario = state.scenarios[sidx];
        const hitlState = ensureHitlStateForScenario(scenario);
        const nextValue = (rawValue || '').trim();
        const previousValue = (hitlState.participant_proxmox_url || '').toString().trim();
        hitlState.participant_proxmox_url = nextValue;
        persistEditorState();
        const hidden = document.getElementById('scenarios_json');
        if (hidden) hidden.value = JSON.stringify({ scenarios: state.scenarios, active_index: activeIdx });
        updateParticipantProxmoxNavLink();
        setParticipantUrlStatus(sidx, nextValue);
        return previousValue !== nextValue;
    };
    const syncParticipantProxmoxControls = (sidx) => {
        const input = document.getElementById(`participantProxmoxUrl_${sidx}`);
        const hasValue = !!(input && input.value && input.value.trim());
        const clearBtn = document.querySelector(`[data-hitl-participant-clear][data-scen-idx="${sidx}"]`);
        if (clearBtn) clearBtn.disabled = !hasValue;
        setParticipantUrlStatus(sidx, input ? input.value : '');
    };
    document.querySelectorAll('[data-hitl-participant-url]').forEach(input => {
        const applyValue = () => {
            const sidx = parseInt(input.getAttribute('data-scen-idx'));
            if (isNaN(sidx) || !state.scenarios?.[sidx]) return;
            persistParticipantProxmoxUrl(sidx, input.value);
            syncParticipantProxmoxControls(sidx);
        };
        input.addEventListener('input', applyValue);
        input.addEventListener('change', applyValue);
        const sidx = parseInt(input.getAttribute('data-scen-idx'));
        if (!Number.isNaN(sidx)) {
            syncParticipantProxmoxControls(sidx);
        }
    });
    document.querySelectorAll('[data-hitl-participant-apply]').forEach(btn => {
        btn.addEventListener('click', () => {
            if (btn.disabled) return;
            const sidx = parseInt(btn.getAttribute('data-scen-idx'));
            if (Number.isNaN(sidx)) return;
            const input = document.getElementById(`participantProxmoxUrl_${sidx}`);
            const value = input ? input.value : '';
            const changed = persistParticipantProxmoxUrl(sidx, value);
            syncParticipantProxmoxControls(sidx);
            const toastMsg = changed ? 'Participant UI link saved.' : 'Participant UI link already up to date.';
            try { showToast(toastMsg, { autohide: true, delay: 2000 }); } catch (e) {}
        });
    });
    document.querySelectorAll('[data-hitl-participant-clear]').forEach(btn => {
        btn.addEventListener('click', () => {
            if (btn.disabled) return;
            const sidx = parseInt(btn.getAttribute('data-scen-idx'));
            if (Number.isNaN(sidx)) return;
            const input = document.getElementById(`participantProxmoxUrl_${sidx}`);
            if (input) input.value = '';
            persistParticipantProxmoxUrl(sidx, '');
            syncParticipantProxmoxControls(sidx);
            try { showToast('Participant UI link cleared.', { autohide: true, delay: 1800 }); } catch (e) {}
        });
    });
    document.querySelectorAll('[data-hitl-remove]').forEach(btn => {
        btn.addEventListener('click', () => {
            const sidx = parseInt(btn.getAttribute('data-scen-idx'));
            const ifaceName = btn.getAttribute('data-iface');
            if (isNaN(sidx) || !state.scenarios[sidx] || !ifaceName) return;
            const hitlState = ensureHitlStateForScenario(state.scenarios[sidx]);
            const idx = hitlState.interfaces.findIndex(entry => entry.name === ifaceName);
            if (idx === -1) return;
            hitlState.interfaces.splice(idx, 1);
            logInfo(`Removed HITL interface ${ifaceName}`);
            persistEditorState();
            const hidden = document.getElementById('scenarios_json');
            if (hidden) hidden.value = JSON.stringify({ scenarios: state.scenarios, active_index: activeIdx });
            renderMain();
        });
    });
    document.querySelectorAll('[data-proxmox-refresh]').forEach(btn => {
        btn.addEventListener('click', async () => {
            if (btn.disabled) return;
            const sidx = parseInt(btn.getAttribute('data-scen-idx'));
            if (Number.isNaN(sidx)) return;
            const originalHtml = btn.innerHTML;
            btn.disabled = true;
            btn.innerHTML = '<span class="spinner-border spinner-border-sm me-1" role="status" aria-hidden="true"></span>Refreshing VMs';
            try {
                await fetchProxmoxInventory(sidx, { force: true });
            } finally {
                if (document.body.contains(btn)) {
                    btn.disabled = false;
                    btn.innerHTML = originalHtml;
                }
            }
        });
    });
    document.querySelectorAll('[data-hitl-apply]').forEach(btn => {
        btn.addEventListener('click', async () => {
            if (btn.disabled) return;
            const sidx = parseInt(btn.getAttribute('data-scen-idx'));
            if (Number.isNaN(sidx)) return;
            // Open the External IFX modal to display progress/status if available
            try {
                const modalEl = document.getElementById('externalIfxModal');
                if (modalEl && window.bootstrap && window.bootstrap.Modal) {
                    const modalInstance = window.bootstrap.Modal.getOrCreateInstance(modalEl);
                    modalInstance.show();
                }
            } catch (e) { /* no-op */ }
            // Delegate to existing apply handler
            try {
                await handleExternalIfxApply();
            } catch (err) {
                console.warn('HITL apply failed', err);
            }
        });
    });
    if (!IS_BUILDER_VIEW) {
        document.querySelectorAll('[data-hitl-core-vm-select]').forEach(select => {
            select.addEventListener('change', () => {
                const sidx = parseInt(select.getAttribute('data-scen-idx'));
                if (isNaN(sidx) || !state.scenarios?.[sidx]) return;
                const hitlState = ensureHitlStateForScenario(state.scenarios[sidx]);
                const coreState = hitlState.core || (hitlState.core = {});
                const rawValue = select.value || '';
                const resetCoreSelection = () => {
                    coreState.vm_key = '';
                    coreState.vm_name = '';
                    coreState.vm_node = '';
                    coreState.last_tested_status = null;
                    coreState.last_tested_message = null;
                    coreState.last_tested_at = null;
                    coreState.last_tested_host = null;
                    coreState.last_tested_port = null;
                    coreState.core_secret_id = null;
                    coreState.validated = false;
                    coreState.last_validated_at = null;
                    coreState.stored_summary = null;
                    coreState.internal_bridge = '';
                    coreState.internal_bridge_owner = '';
                    coreState.cached_vm_interface_count = null;
                    coreState.cached_vm_status = null;
                };
                if (!rawValue) {
                    resetCoreSelection();
                    persistEditorState();
                    const pwdInput = document.querySelector(`[data-hitl-core-field="ssh_password"][data-scen-idx="${sidx}"]`);
                    if (pwdInput) pwdInput.removeAttribute('placeholder');
                    const hidden = document.getElementById('scenarios_json');
                    if (hidden) hidden.value = JSON.stringify({ scenarios: state.scenarios, active_index: activeIdx });
                    renderMain();
                    return;
                }
                const proxState = hitlState.proxmox || {};
                const inventory = proxState.inventory && Array.isArray(proxState.inventory.vms) ? proxState.inventory.vms : [];
                const selectedVm = inventory.find(vm => `${vm.node ?? ''}::${vm.vmid ?? ''}` === rawValue) || null;
                const [nodePart, vmidPartRaw] = rawValue.split('::');
                resetCoreSelection();
                coreState.vm_key = rawValue;
                coreState.vm_name = selectedVm && selectedVm.name ? String(selectedVm.name) : '';
                coreState.vm_node = selectedVm && selectedVm.node !== undefined && selectedVm.node !== null
                    ? String(selectedVm.node)
                    : (nodePart || '').trim();
                if (!coreState.vm_name && coreState.vm_node && vmidPartRaw && vmidPartRaw.trim()) {
                    coreState.vm_name = `${coreState.vm_node}::${vmidPartRaw.trim()}`;
                }
                coreState.cached_vm_interface_count = Array.isArray(selectedVm?.interfaces) ? selectedVm.interfaces.length : null;
                coreState.cached_vm_status = selectedVm && selectedVm.status ? String(selectedVm.status) : null;
                persistEditorState();
                const pwdInput = document.querySelector(`[data-hitl-core-field="ssh_password"][data-scen-idx="${sidx}"]`);
                if (pwdInput) pwdInput.removeAttribute('placeholder');
                const hidden = document.getElementById('scenarios_json');
                if (hidden) hidden.value = JSON.stringify({ scenarios: state.scenarios, active_index: activeIdx });
                renderMain();
            });
        });
    }
    if (!IS_BUILDER_VIEW) {
        document.querySelectorAll('[data-hitl-core-field]').forEach(input => {
            if (input.closest('#coreConnectionModal')) return;
            input.addEventListener('input', () => handleCoreFieldUpdate(input, { rerender: false }));
            input.addEventListener('change', () => handleCoreFieldUpdate(input, { rerender: true }));
        });
        document.querySelectorAll('[data-hitl-core-test]').forEach(btn => {
            btn.addEventListener('click', async () => {
                if (btn.disabled) return;
                const sidx = parseInt(btn.getAttribute('data-scen-idx'));
                await validateCoreConnection(sidx, {
                    triggerButton: btn,
                    workingLabel: 'Testing…',
                });
            });
        });
        document.querySelectorAll('[data-hitl-core-clear]').forEach(btn => {
            btn.addEventListener('click', () => {
                const sidx = parseInt(btn.getAttribute('data-scen-idx'));
                if (isNaN(sidx) || !state.scenarios?.[sidx]) return;
                const hitlState = ensureHitlStateForScenario(state.scenarios[sidx]);
                const existingSecretId = hitlState.core && typeof hitlState.core.core_secret_id === 'string' ? hitlState.core.core_secret_id : null;
                if (existingSecretId) {
                    try {
                        const payload = {
                            core_secret_id: existingSecretId,
                            scenario_index: sidx,
                            scenario_name: state.scenarios?.[sidx]?.name || '',
                        };
                        fetch('/api/core/credentials/clear', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            credentials: 'same-origin',
                            body: JSON.stringify(payload),
                        }).catch(err => logError(`Failed to clear stored CORE credentials: ${err}`));
                    } catch (err) {
                        logError(`Exception during CORE credential clear: ${err}`);
                    }
                }
                hitlState.core = {
                    vm_key: '',
                    vm_name: '',
                    vm_node: '',
                    grpc_host: '',
                    grpc_port: 50051,
                    ssh_host: '',
                    ssh_port: 22,
                    ssh_username: '',
                    ssh_password: '',
                    core_secret_id: null,
                    validated: false,
                    last_validated_at: null,
                    stored_summary: null,
                    last_tested_at: null,
                    last_tested_status: null,
                    last_tested_message: null,
                    last_tested_host: null,
                    last_tested_port: null,
                    internal_bridge: '',
                    internal_bridge_owner: '',
                    last_interfaces_refresh: null,
                    last_interfaces_attempt: null,
                    interfaces_refresh_inflight: false,
                    last_interfaces_error: null,
                };
                persistEditorState();
                const hidden = document.getElementById('scenarios_json');
                if (hidden) hidden.value = JSON.stringify({ scenarios: state.scenarios, active_index: activeIdx });
                const pwdInput = document.querySelector(`[data-hitl-core-field="ssh_password"][data-scen-idx="${sidx}"]`);
                if (pwdInput) pwdInput.removeAttribute('placeholder');
                renderMain();
            });
        });
    }
    document.querySelectorAll('[data-hitl-refresh]').forEach(btn => {
        btn.addEventListener('click', async () => {
            const sidx = parseInt(btn.getAttribute('data-scen-idx'));
            if (Number.isNaN(sidx)) return;
            const originalHtml = btn.innerHTML;
            btn.disabled = true;
            btn.setAttribute('data-refresh-busy', '1');
            btn.innerHTML = '<span class="spinner-border spinner-border-sm me-2" role="status" aria-hidden="true"></span>Refreshing…';
            try {
                await refreshHostInterfacesForScenario(sidx, { reason: 'manual' });
            } finally {
                if (document.body.contains(btn)) {
                    btn.disabled = false;
                    btn.innerHTML = originalHtml;
                    btn.removeAttribute('data-refresh-busy');
                }
            }
        });
    });
    const proxAssignModal = document.getElementById('proxmoxAssignModal');
    const proxAssignHint = document.getElementById('proxmoxAssignHint');
    const proxAssignError = document.getElementById('proxmoxAssignError');
    const proxAssignForm = document.getElementById('proxmoxAssignForm');
    const proxUrlInput = document.getElementById('proxmoxUrl');
    const proxPortInput = document.getElementById('proxmoxPort');
    const proxUserInput = document.getElementById('proxmoxUsername');
    const proxPassInput = document.getElementById('proxmoxPassword');
    const proxRememberInput = document.getElementById('proxmoxRememberCreds');
    const proxVerifyInput = document.getElementById('proxmoxVerifySsl');
    const setProxAssignHint = (message, tone = 'info') => {
        if (!proxAssignHint) return;
        proxAssignHint.textContent = message || '';
        proxAssignHint.style.display = message ? '' : 'none';
        proxAssignHint.classList.remove('alert-info', 'alert-success', 'alert-danger');
        const klass = tone === 'success' ? 'alert-success' : tone === 'danger' ? 'alert-danger' : 'alert-info';
        proxAssignHint.classList.add(klass);
    };
    window.setProxAssignHint = setProxAssignHint;
    if (proxRememberInput && !proxRememberInput.dataset.prefBound) {
        proxRememberInput.addEventListener('change', () => {
            if (!proxAssignModal) return;
            const sidx = parseInt(proxAssignModal.getAttribute('data-scen-idx') || '', 10);
            if (isNaN(sidx) || !state.scenarios?.[sidx]) return;
            const hitlState = ensureHitlStateForScenario(state.scenarios[sidx]);
            hitlState.proxmox.remember_credentials = !!proxRememberInput.checked;
            persistEditorState();
        });
        proxRememberInput.dataset.prefBound = '1';
    }
    coreConnectionModal = document.getElementById('coreConnectionModal');
    coreConnectionForm = document.getElementById('coreConnectionForm');
    coreConnectionHint = document.getElementById('coreConnectionHint');
    coreConnectionSaveBtn = document.getElementById('coreConnectionSaveBtn');
    coreModalInputs.grpc_host = document.getElementById('coreGrpcHost');
    coreModalInputs.grpc_port = document.getElementById('coreGrpcPort');
    coreModalInputs.ssh_host = document.getElementById('coreSshHost');
    coreModalInputs.ssh_port = document.getElementById('coreSshPort');
    coreModalInputs.ssh_username = document.getElementById('coreSshUsername');
    coreModalInputs.ssh_password = document.getElementById('coreSshPassword');
    coreRememberInput = document.getElementById('coreRememberCreds');
    coreAutoStartInput = document.getElementById('coreAutoStartDaemon');
    setCoreConnectionHint = (message, tone = 'info') => {
        if (!coreConnectionHint) return;
        coreConnectionHint.textContent = message || '';
        coreConnectionHint.style.display = message ? '' : 'none';
        coreConnectionHint.classList.toggle('d-none', !message);
        coreConnectionHint.classList.remove('alert-info', 'alert-success', 'alert-warning', 'alert-danger');
        const klass = tone === 'success'
            ? 'alert-success'
            : tone === 'warning'
                ? 'alert-warning'
                : tone === 'danger'
                    ? 'alert-danger'
                    : 'alert-info';
        coreConnectionHint.classList.add(klass);
    };
    window.setCoreConnectionHint = setCoreConnectionHint;
    wireCoreConnectionSaveButton();
    if (coreRememberInput && !coreRememberInput.dataset.prefBound) {
        coreRememberInput.addEventListener('change', () => {
            if (IS_BUILDER_VIEW) return;
            if (!coreConnectionModal) return;
            const sidx = parseInt(coreConnectionModal.getAttribute('data-scen-idx') || '', 10);
            if (isNaN(sidx) || !state.scenarios?.[sidx]) return;
            const hitlState = ensureHitlStateForScenario(state.scenarios[sidx]);
            hitlState.core.remember_credentials = !!coreRememberInput.checked;
            persistEditorState();
        });
        coreRememberInput.dataset.prefBound = '1';
    }
    if (coreAutoStartInput && !coreAutoStartInput.dataset.prefBound) {
        coreAutoStartInput.addEventListener('change', () => {
            if (IS_BUILDER_VIEW) return;
            if (!coreConnectionModal) return;
            const sidx = parseInt(coreConnectionModal.getAttribute('data-scen-idx') || '', 10);
            if (isNaN(sidx) || !state.scenarios?.[sidx]) return;
            const hitlState = ensureHitlStateForScenario(state.scenarios[sidx]);
            hitlState.core.auto_start_daemon = !!coreAutoStartInput.checked;
            persistEditorState();
        });
        coreAutoStartInput.dataset.prefBound = '1';
    }
    document.querySelectorAll('[data-proxmox-assign]').forEach(btn => {
        btn.addEventListener('click', async () => {
            const sidx = parseInt(btn.getAttribute('data-scen-idx'));
            if (isNaN(sidx) || !state.scenarios?.[sidx]) return;
            if (!proxAssignModal || !window.bootstrap) {
                console.warn('Proxmox modal not available');
                return;
            }
            const scenario = state.scenarios[sidx];
            const hitlState = ensureHitlStateForScenario(scenario);
            const prox = hitlState.proxmox || { url: '', port: 8006, username: '' };
            const rememberCreds = shouldRememberProxmox(hitlState);
            proxAssignModal.setAttribute('data-scen-idx', String(sidx));
            const scenName = (scenario?.name || '').trim() || `Scenario ${sidx + 1}`;
            if (proxAssignError) {
                proxAssignError.textContent = '';
                proxAssignError.classList.add('d-none');
            }
            if (proxAssignForm) {
                proxAssignForm.classList.remove('was-validated');
            }
            if (proxVerifyInput) {
                if (typeof prox.verify_ssl === 'boolean') {
                    proxVerifyInput.checked = prox.verify_ssl;
                } else if (prox.url) {
                    proxVerifyInput.checked = /^https:/i.test(prox.url);
                } else {
                    proxVerifyInput.checked = true;
                }
            }
            const savedDefaults = getSavedProxmoxDefaults();
            const prefillUrl = prox.url || savedDefaults.url || '';
            const prefillPort = prox.port ?? savedDefaults.port ?? 8006;
            const prefillUsername = prox.username || savedDefaults.username || '';
            const prefillVerify = typeof prox.verify_ssl === 'boolean'
                ? prox.verify_ssl
                : (typeof savedDefaults.verify_ssl === 'boolean'
                    ? savedDefaults.verify_ssl
                    : (prefillUrl ? /^https:/i.test(prefillUrl) : true));
            if (proxUrlInput) proxUrlInput.value = prefillUrl;
            if (proxPortInput) proxPortInput.value = prefillPort;
            if (proxUserInput) proxUserInput.value = prefillUsername;
            if (proxPassInput) proxPassInput.value = '';
            if (proxVerifyInput) proxVerifyInput.checked = prefillVerify;
            if (proxRememberInput) {
                proxRememberInput.checked = rememberCreds;
            }
            let validatedStamp = 'a previous run';
            if (prox.last_validated_at) {
                try {
                    const dtTemp = new Date(prox.last_validated_at);
                    if (!Number.isNaN(dtTemp.getTime())) {
                        validatedStamp = dtTemp.toLocaleString();
                    }
                } catch (err) {
                    validatedStamp = 'a previous run';
                }
            }
            const msg = prox.validated && prox.secret_id
                ? `Validated on ${validatedStamp}. Re-enter password to re-validate.`
                : 'Enter credentials to validate and store securely.';
            const baseHintText = `Configure Proxmox resources for ${scenName}. ${msg}`;
            const baseHintTone = prox.validated && prox.secret_id ? 'success' : 'info';
            setProxAssignHint(baseHintText, baseHintTone);
            const modalObj = bootstrap.Modal.getInstance(proxAssignModal) || new bootstrap.Modal(proxAssignModal, { backdrop: true, keyboard: true });
            modalObj.show();
            setTimeout(() => {
                try {
                    proxUrlInput?.focus();
                    proxUrlInput?.select?.();
                } catch(e){}
            }, 150);
            const secretId = typeof prox.secret_id === 'string' ? prox.secret_id.trim() : '';
            if (secretId && rememberCreds) {
                setProxAssignHint(`Restoring saved Proxmox credentials for ${scenName}…`, 'info');
                try {
                    const storedCreds = await fetchStoredProxmoxCredentials(secretId);
                    if (storedCreds) {
                        if (proxUrlInput && typeof storedCreds.url === 'string') {
                            proxUrlInput.value = storedCreds.url;
                        }
                        if (proxPortInput && storedCreds.port !== undefined && storedCreds.port !== null) {
                            proxPortInput.value = storedCreds.port;
                        }
                        if (proxUserInput && typeof storedCreds.username === 'string') {
                            proxUserInput.value = storedCreds.username;
                        }
                        if (proxPassInput) {
                            proxPassInput.value = storedCreds.password || '';
                            proxPassInput.removeAttribute('placeholder');
                        }
                        if (proxVerifyInput && typeof storedCreds.verify_ssl === 'boolean') {
                            proxVerifyInput.checked = storedCreds.verify_ssl;
                        }
                        setProxAssignHint(`${baseHintText} Saved credentials loaded.`, 'success');
                    } else {
                        setProxAssignHint(`${baseHintText} Stored credentials unavailable; please re-enter`, 'warning');
                    }
                } catch (err) {
                    console.error('Failed to load stored Proxmox credentials', err);
                    setProxAssignHint(`${baseHintText} Failed to load stored credentials; please re-enter.`, 'warning');
                    if (proxPassInput) {
                        proxPassInput.value = '';
                        proxPassInput.placeholder = 'Enter password';
                    }
                }
            }
        });
    });
    document.querySelectorAll('[data-proxmox-clear]').forEach(btn => {
        btn.addEventListener('click', async () => {
            const sidx = parseInt(btn.getAttribute('data-scen-idx'));
            if (isNaN(sidx) || !state.scenarios?.[sidx]) return;
            const scenario = state.scenarios[sidx];
            const hitlState = ensureHitlStateForScenario(scenario);
            const prox = hitlState.proxmox || {};
            const hasAny = !!(prox.secret_id || prox.url || prox.username);
            if (!hasAny) {
                try { showToast('No Proxmox credentials to clear', { autohide: true, delay: 2000 }); } catch(e) {}
                return;
            }
            const confirmClear = window.confirm('Clear saved Proxmox credentials for this scenario?');
            if (!confirmClear) return;
            const originalLabel = btn.textContent;
            btn.disabled = true;
            btn.dataset.busy = 'true';
            btn.textContent = 'Clearing…';
            try {
                const resp = await fetch('/api/proxmox/clear', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    credentials: 'same-origin',
                    body: JSON.stringify({
                        scenario_index: sidx,
                        scenario_name: scenario?.name || '',
                        secret_id: prox.secret_id || null,
                    }),
                });
                let data = null;
                try { data = await resp.json(); } catch(err) { data = null; }
                if (!resp.ok || (data && data.success === false)) {
                    const message = (data && (data.error || data.message)) || `Failed to clear credentials (HTTP ${resp.status})`;
                    throw new Error(message);
                }
                hitlState.proxmox = {
                    url: '',
                    port: 8006,
                    username: '',
                    verify_ssl: true,
                    secret_id: null,
                    validated: false,
                    last_validated_at: null,
                    last_message: 'Proxmox credentials cleared.',
                };
                if (Array.isArray(hitlState.interfaces)) {
                    hitlState.interfaces = hitlState.interfaces.map(entry => {
                        if (!entry || typeof entry !== 'object') return entry;
                        if ('proxmox_target' in entry) {
                            delete entry.proxmox_target;
                        }
                        const attachment = entry.attachment ? normalizeHitlAttachment(entry.attachment) : '';
                        if (attachment === 'proxmox_vm') {
                            entry.attachment = DEFAULT_HITL_ATTACHMENT;
                        }
                        return entry;
                    });
                }
                persistEditorState();
                const hidden = document.getElementById('scenarios_json');
                if (hidden) hidden.value = JSON.stringify({ scenarios: state.scenarios, active_index: activeIdx });
                updateProxmoxSummary(sidx);
                renderMain();
                try { showToast('Proxmox credentials cleared', { autohide: true, delay: 2500 }); } catch(e) {}
                logInfo('Cleared Proxmox credentials for scenario');
            } catch (err) {
                const message = err instanceof Error ? err.message : 'Failed to clear Proxmox credentials';
                logError(message);
                try { showToast(message, { autohide: false }); } catch(e) {}
            } finally {
                btn.disabled = false;
                btn.textContent = originalLabel || 'Clear Proxmox Resource';
                delete btn.dataset.busy;
            }
        });
    });
    // Export preview handler
    const previewBtn = document.querySelector('[data-action="preview-plan"]');
    if (previewBtn) {
        previewBtn.onclick = () => {
            const scen = state.scenarios[activeIdx];
            if (!scen) return;
            const ni = scen.sections['Node Information'] || { items: [], total_nodes:0 };
            const weightRows = (ni.items||[]).filter(it => (it.v_metric || (it.selected==='Specific'? 'Count':'Weight'))==='Weight');
            const countRows = (ni.items||[]).filter(it => (it.v_metric || (it.selected==='Specific'? 'Count':'Weight'))==='Count');
            const base = weightRows.length ? (parseInt(scen.density_count || 0) || 0) : 0;
            const addHosts = countRows.reduce((a,it)=> a + (parseInt(it.v_count,10)||0),0);
            const totalHosts = base + addHosts;
            let allocTable = [];
            if (base>0 && weightRows.length) {
                const sumW = weightRows.reduce((a,it)=> a + (parseFloat(it.factor)||0),0) || 1;
                const temp = weightRows.map(it => {
                    const f = parseFloat(it.factor)||0; const share = sumW? f/sumW:0; const raw = base*share; const alloc = Math.floor(raw);
                    return { it, share, raw, alloc, frac: raw - alloc };
                });
                let assigned = temp.reduce((a,r)=> a + r.alloc,0);
                let remain = base - assigned;
                temp.sort((a,b)=> b.frac - a.frac);
                for (let i=0;i<temp.length && remain>0;i++) { temp[i].alloc += 1; remain--; }
                allocTable = temp.sort((a,b)=> (ni.items.indexOf(a.it) - ni.items.indexOf(b.it))).map(r => ({ label: r.it.selected || 'Row', weight: (parseFloat(r.it.factor)||0), percent: (r.share*100), alloc: r.alloc }));
            }
            const routing = scen.sections['Routing'] || { items: [], density: 0 };
            const rWeight = (routing.items||[]).filter(it => (it.v_metric||'Weight')==='Weight');
            const rCount = (routing.items||[]).filter(it => (it.v_metric||'Weight')==='Count');
            const rExplicit = rCount.reduce((a,it)=> a + (parseInt(it.v_count,10)||0),0);
            let rDerived = 0; if (rWeight.length) { const d = parseFloat(routing.density)||0; rDerived = (d>=1)? d : Math.round((totalHosts - addHosts) * d); }
            const totalRouters = rExplicit + rDerived;
            const vulns = scen.sections['Vulnerabilities'] || { items: [], density: 0 };
            const vWeight = (vulns.items||[]).filter(it => (it.v_metric || (it.selected==='Specific'?'Count':'Weight'))==='Weight');
            const vCount = (vulns.items||[]).filter(it => (it.v_metric || (it.selected==='Specific'?'Count':'Weight'))==='Count');
            const vExplicit = vCount.reduce((a,it)=> a + (parseInt(it.v_count,10)||0),0);
            let vDerived = 0; if (vWeight.length) { const d = Math.min(1, Math.max(0, parseFloat(vulns.density)||0)); vDerived = Math.round((totalHosts - addHosts) * d); }
            const totalVulns = vExplicit + vDerived;
            const rowsHtml = allocTable.length ? allocTable.map(r => `<tr><td>${r.label}</td><td>${r.weight.toFixed(3)}</td><td>${r.percent.toFixed(1)}%</td><td>${r.alloc}</td></tr>`).join('') : '<tr><td colspan="4" class="text-muted">No weight allocation</td></tr>';
            const modalHtml = `
<div class=\"modal fade\" id=\"previewModal\" tabindex=\"-1\" aria-hidden=\"true\">\n  <div class=\"modal-dialog modal-lg modal-dialog-scrollable\">\n    <div class=\"modal-content\">\n      <div class=\"modal-header\">\n        <h5 class=\"modal-title\">Plan Preview: ${scen.name}</h5>\n        <button type=\"button\" class=\"btn-close\" data-bs-dismiss=\"modal\" aria-label=\"Close\"></button>\n      </div>\n      <div class=\"modal-body\">\n        <div class=\"progress mb-3 d-none\" id=\"previewExecuteProgress\">\n          <div class=\"progress-bar progress-bar-striped progress-bar-animated\" id=\"previewExecuteProgressBar\" style=\"width:100%\">Running…</div>\n        </div>\n        <div class=\"row mb-3\">\n          <div class=\"col-md-4\"><div class=\"card card-body p-2\"><small class=\"text-muted\">Hosts Total</small><div class=\"fs-5\">${totalHosts}</div><div class=\"small text-muted\">Base ${base} + Add ${addHosts}</div></div></div>\n          <div class=\"col-md-4\"><div class=\"card card-body p-2\"><small class=\"text-muted\">Routers</small><div class=\"fs-5\">${totalRouters}</div><div class=\"small text-muted\">Explicit ${rExplicit} + Derived ${rDerived}</div></div></div>\n          <div class=\"col-md-4\"><div class=\"card card-body p-2\"><small class=\"text-muted\">Vulns</small><div class=\"fs-5\">${totalVulns}</div><div class=\"small text-muted\">Explicit ${vExplicit} + Derived ${vDerived}</div></div></div>\n        </div>\n        <h6>Host Weight Allocation</h6>\n        <div class=\"table-responsive\">\n          <table class=\"table table-sm\">\n            <thead><tr><th>Row</th><th>Weight</th><th>%</th><th>Alloc</th></tr></thead>\n            <tbody>${rowsHtml}</tbody>\n          </table>\n        </div>\n      </div>\n      <div class=\"modal-footer\">\n        <button type=\"button\" class=\"btn btn-sm btn-warning\" id=\"previewModalExecuteBtn\">Execute</button>\n        <button type=\"button\" class=\"btn btn-sm btn-outline-secondary\" data-bs-dismiss=\"modal\">Close</button>\n      </div>\n    </div>\n  </div>\n</div>`;
            let container = document.getElementById('previewModalContainer');
            if (!container) { container = document.createElement('div'); container.id = 'previewModalContainer'; document.body.appendChild(container); }
            container.innerHTML = modalHtml;
            const modalEl = container.querySelector('#previewModal');
            let modalInstance = null;
            if (window.bootstrap) {
                try {
                    modalInstance = new bootstrap.Modal(modalEl);
                } catch(e) {
                    alert('Bootstrap modal failed; see console');
                    console.error(e);
                }
            } else {
                alert('Bootstrap not loaded.');
            }
            setupPreviewModalExecute(modalEl, modalInstance);
            try { modalInstance?.show(); } catch(e) {}
        };
    }
    // Initialize popovers & tooltips (Bootstrap 5)
    if (window.bootstrap) {
        document.querySelectorAll('[data-bs-toggle="popover"]').forEach(el => { try { new bootstrap.Popover(el); } catch(e) {} });
        document.querySelectorAll('[data-bs-toggle="tooltip"]').forEach(el => { try { new bootstrap.Tooltip(el); } catch(e) {} });
    }
    // Flash animation on Base input change
    document.querySelectorAll('.base-input').forEach(inp => {
        inp.addEventListener('change', () => {
            const badge = document.querySelector('.host-total-badge');
            if (!badge) return;
            badge.classList.add('pulse-change');
            setTimeout(()=> badge.classList.remove('pulse-change'), 900);
        });
    });
    document.querySelectorAll('[data-action="remove-scenario"]').forEach(btn => {
        btn.onclick = async (ev) => {
            if (ev && typeof ev.preventDefault === 'function') ev.preventDefault();
            if (ev && typeof ev.stopPropagation === 'function') ev.stopPropagation();
            const sidx = parseInt(btn.getAttribute('data-scen-idx'));
            const scen = state.scenarios[sidx];
            if (!scen) { return; }
            let runCount = 0;
            try {
                const resp = await fetch('/reports_data');
                if (resp.ok) {
                    const data = await resp.json();
                    runCount = (data.history || []).filter(r => (r.scenario_names || []).includes(scen.name)).length;
                }
            } catch (e) {}
            const lines = [];
            lines.push(`Delete scenario "${scen.name}"?`);
            if (runCount > 0) {
                lines.push("");
                lines.push(`WARNING: ${runCount} run history entr${runCount===1?'y':'ies'} and their artifact files (XML, report, pre-session XML) will be permanently deleted.`);
            }
            lines.push("");
            lines.push("This action cannot be undone.");
            lines.push("");
            lines.push("Proceed?");
            const msg = lines.join('\n');
            if (!window.confirm(msg)) { return; }

            // Remove scenario
            state.scenarios.splice(sidx, 1);
            // Leave list empty if last scenario removed
            activeIdx = state.scenarios.length === 0 ? 0 : Math.min(sidx, state.scenarios.length - 1);
            // Persist immediately before re-render so state survives any navigation
            const hidden = document.getElementById('scenarios_json');
            if (hidden) hidden.value = JSON.stringify({ scenarios: state.scenarios });
            persistEditorState();
            logInfo(`Deleted scenario: ${scen.name}`);
            // Re-render UI
            render();
            try { showToast(`Scenario "${scen.name}" deleted`); } catch(e){}

            // Purge matching run history and artifacts in background
            if (runCount > 0) {
                try {
                    await fetch('/purge_history_for_scenario', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ name: scen.name })
                    });
                } catch (e) {}
            }
        };
    });
    // keep hidden JSON synced
    const aiHidden = document.getElementById('active_index'); if(aiHidden) aiHidden.value = String(activeIdx);
    document.getElementById('scenarios_json').value = JSON.stringify({ scenarios: state.scenarios, active_index: activeIdx });
    persistEditorState();
        // Initialize warnings per section
        const scen = state.scenarios[activeIdx];
        if (scen) {
            ['Node Information','Routing','Services','Traffic','Events','Vulnerabilities','Segmentation'].forEach(sec => updateWeightWarning(activeIdx, sec));
        }
}
// Routing edges validation utilities
function validateRoutingEdges(){
    const scen = state.scenarios[activeIdx]; if(!scen) return;
    const routing = (scen.sections && scen.sections['Routing'] && scen.sections['Routing'].items) || [];
    const warn = [];
    routing.forEach((r,i)=>{ const m = r.r2r_mode; if(m==='Exact' && !(r.edges>=1)) warn.push(`Row ${i+1}: Exact mode requires a degree ≥ 1`); });
    routing.forEach((r,i)=>{ if(r.r2s_mode==='Exact' && !(r.r2s_edges>=1)) warn.push(`Row ${i+1}: R-to-S Exact requires a value ≥ 1`); });
    // Highlight inputs
    document.querySelectorAll('.edges-degree-input').forEach(inp => {
        const v = parseInt(inp.value,10); const tr = inp.closest('tr');
    const sel = tr ? tr.querySelector('[data-field="r2r_mode"]') : null;
        const mode = sel ? sel.value : '';
        if(mode==='Exact' && !(v>=1)) inp.classList.add('is-invalid'); else inp.classList.remove('is-invalid');
    });
    document.querySelectorAll('.r2s-degree-input').forEach(inp => {
        const v = parseInt(inp.value,10); const tr = inp.closest('tr');
        const sel = tr ? tr.querySelector('[data-field="r2s_mode"]') : null;
        const mode = sel ? sel.value : '';
        if(mode==='Exact' && !(v>=1)) inp.classList.add('is-invalid'); else inp.classList.remove('is-invalid');
    });
    // If a separate warning container existed we could populate it here later.
    computeRoutingEdgePolicyPreview();
}
setTimeout(validateRoutingEdges, 500);

// Derive a lightweight preview (pre-generation) of intended policy and an estimated degree band
function computeRoutingEdgePolicyPreview(){
    const scen = state.scenarios[activeIdx]; if(!scen) return;
    const routing = (scen.sections && scen.sections['Routing'] && scen.sections['Routing'].items) || [];
    const summaryEl = document.getElementById('routingEdgesSummary');
    if(!summaryEl) return;
    if(!routing.length){ summaryEl.style.display='none'; return; }
    // Make sure the preview is visible once we have routing rows.
    summaryEl.style.display = 'flex';
    // Determine target policy: Exact avg > Max > Min > Random (mirrors backend)
    const exactVals = routing.filter(r=> r.r2r_mode==='Exact' && r.edges>=1).map(r=>r.edges);
    let mode='Random'; let target=0;
    if(exactVals.length){
        target = Math.round(exactVals.reduce((a,b)=>a+b,0)/exactVals.length);
        if(target<1) target=1; mode='Exact';
    } else {
    const modes = routing.map(r=> r.r2r_mode).filter(Boolean);
    if(modes.includes('Uniform')) mode='Uniform';
        else if(modes.includes('Min')) mode='Min';
        else if(modes.includes('NonUniform')) mode='NonUniform';
        else mode='Random';
    }
    // Determine predominant R-to-S mode (simple precedence similar to R-to-R)
    let r2sMode = 'Random';
    const r2sExactVals = routing.filter(r=>r.r2s_mode==='Exact' && r.r2s_edges>=1).map(r=>r.r2s_edges);
    if(r2sExactVals.length){
        r2sMode = 'Exact';
    } else {
        const r2sModes = routing.map(r=>r.r2s_mode).filter(Boolean);
    if(r2sModes.includes('Uniform')) r2sMode='Uniform';
        else if(r2sModes.includes('Min')) r2sMode='Min';
        else if(r2sModes.includes('NonUniform')) r2sMode='NonUniform';
        else r2sMode='Random';
    }
    const policySpan = summaryEl.querySelector('[data-role="edges-policy"]');
    if(policySpan){ policySpan.textContent = `R-R: ${mode}${mode==='Exact'?`(≈${target})`:''} | R-S: ${r2sMode}`; }
    // Estimate degree distribution preview (pure heuristic):
    let minD=0, avgD=0, maxD=0;
    if(mode==='Exact'){ minD=target; avgD=target+1; maxD=target+2; }
    else if(mode==='Uniform'){ minD=4; avgD=4; maxD=5; }
    else if(mode==='NonUniform'){ minD=1; avgD=3; maxD=8; }
    else if(mode==='Min'){ minD=2; avgD=3; maxD=4; }
    else { minD=1; avgD=2; maxD=4; }
    // Removed Min/Avg/Max and sparkline visualization per request
    // Resource warning for Uniform (previously Max) mode – still warn if near-dense
	const warnEl = document.getElementById('routingEdgesWarnings');
	if(warnEl){
	    warnEl.classList.add('d-none');
	    warnEl.innerHTML='';
        if(mode==='Uniform'){
	        // Approximate router count: we don't know exact until build; use routing item count as lower bound
	        let approxRouters = routing.length || 0;
	        // If scenario embeds an explicit router count in future, prefer it; attempt common field names
	        if(typeof scen.router_count === 'number' && scen.router_count > approxRouters) approxRouters = scen.router_count;
	        if(typeof scen.routers_total === 'number' && scen.routers_total > approxRouters) approxRouters = scen.routers_total;
	        // Compute full mesh edges estimate
	        const estEdges = approxRouters > 1 ? (approxRouters * (approxRouters - 1) / 2) : 0;
	        // Thresholds: warn if routers >= 25 OR estimated edges >= 300
	        if(approxRouters >= 25 || estEdges >= 300){
	            const edgesFmt = estEdges.toLocaleString();
                warnEl.innerHTML = `<strong>Uniform Mode:</strong> balanced high degree connectivity can grow ~O(n²). With ~${approxRouters} routers this implies about ${edgesFmt} potential links. This may increase session startup time and resource usage.`;
	            warnEl.classList.remove('d-none');
	        } else {
	            // Light advisory (still show something so users understand cost) for smaller counts
	            if(approxRouters >= 10){
                    warnEl.innerHTML = `<strong>Heads up:</strong> Uniform mode aims for evenly high degrees (approaches dense graph). Routers: ~${approxRouters}.`;
	                warnEl.classList.remove('d-none');
	            }
	        }
	    }
	}
    summaryEl.style.display='flex';
}

function prepareRunCli() {
    // prefer the last saved XML path or result_path if it's XML
    const rp = state.result_path || '';
    if (!rp.endsWith('.xml')) {
        alert('Please save XML first.');
        logWarn('Run CLI blocked: no saved XML');
        return false;
    }
    // confirmation dialog warning user a CORE scenario will be created and started
    const confirmMsg = 'This action will generate a new CORE scenario and attempt to start it using the provided daemon connection.\n\nProceed?';
    if (!window.confirm(confirmMsg)) {
        logInfo('Run CLI cancelled by user at confirmation');
        return false;
    }
    document.getElementById('xml_path').value = rp;
    logInfo('Running CLI sync');
    // Preserve scroll so after the round trip we land where we were
    try { saveScrollBeforeNav(); } catch(e){}
    return true;
}

let coreConnectionModal = null;
let coreConnectionForm = null;
let coreConnectionHint = null;
let coreConnectionSaveBtn = null;
let coreRememberInput = null;
let coreAutoStartInput = null;
let coreTestVenvBtn = null;
let coreVenvTestStatus = null;
const coreModalInputs = {
    grpc_host: null,
    grpc_port: null,
    ssh_host: null,
    ssh_port: null,
    ssh_username: null,
    ssh_password: null,
    venv_bin: null,
};
let executeConfirmModalEl = null;
let executeConfirmMessageEl = null;
let executeConfirmAlertEl = null;
let executeConfirmRunBtn = null;
let executeConfirmCancelBtn = null;
let executeConfirmUpdateRemoteToggle = null;
let executeConfirmUpdateRemoteHelpEl = null;
let executeCoreStatusEl = null;
let executeCoreTestBtn = null;
let executeRemoteTestRow = null;
let executeCoreNotConfiguredRow = null;
let executeSelectCoreVmBtn = null;
let executeConfirmPushUpdateToggle = null;
let executePushUpdateWrap = null;
let executeConfirmPushUpdateHelpEl = null;
let executeAdvancedWrap = null;
let executeAdvFixDockerDaemon = null;
let executeAdvRunCoreCleanup = null;
let executeAdvCheckCoreVersion = null;
let executeAdvRestartCoreDaemon = null;
let executeAdvAutoKillSessions = null;
const EXECUTE_CONFIRM_PREFS_STORAGE_KEY = 'coretg_execute_confirm_prefs';

function loadExecuteConfirmPrefs() {
    if (typeof window === 'undefined' || !window.localStorage) {
        return {};
    }
    try {
        const raw = localStorage.getItem(EXECUTE_CONFIRM_PREFS_STORAGE_KEY);
        if (!raw) {
            return {};
        }
        const parsed = JSON.parse(raw);
        return parsed && typeof parsed === 'object' ? parsed : {};
    } catch (err) {
        return {};
    }
}

let executeConfirmPrefs = loadExecuteConfirmPrefs();

function persistExecuteConfirmPrefs() {
    if (typeof window === 'undefined' || !window.localStorage) {
        return;
    }
    try {
        localStorage.setItem(EXECUTE_CONFIRM_PREFS_STORAGE_KEY, JSON.stringify(executeConfirmPrefs || {}));
    } catch (err) { /* ignore */ }
}

function getExecuteConfirmUpdateRemotePref() {
    return !!(executeConfirmPrefs && executeConfirmPrefs.updateRemoteRepo);
}

function setExecuteConfirmUpdateRemotePref(value) {
    if (!executeConfirmPrefs || typeof executeConfirmPrefs !== 'object') {
        executeConfirmPrefs = {};
    }
    executeConfirmPrefs.updateRemoteRepo = !!value;
    persistExecuteConfirmPrefs();
}

function getExecuteRemoteModePref() {
    if (executeConfirmPrefs && typeof executeConfirmPrefs.remoteExecution === 'boolean') {
        return executeConfirmPrefs.remoteExecution;
    }
    if (executeConfirmPrefs && typeof executeConfirmPrefs.remoteExecution === 'undefined' && typeof executeConfirmPrefs.updateRemoteRepo === 'boolean') {
        // Legacy preference stored only the repo push flag; reuse it for initial remote-mode opt-in.
        return !!executeConfirmPrefs.updateRemoteRepo;
    }
    return false;
}

function setExecuteRemoteModePref(value) {
    if (!executeConfirmPrefs || typeof executeConfirmPrefs !== 'object') {
        executeConfirmPrefs = {};
    }
    executeConfirmPrefs.remoteExecution = !!value;
    persistExecuteConfirmPrefs();
}

function isRemoteExecutionSelected() {
    if (executeConfirmUpdateRemoteToggle) {
        return !!executeConfirmUpdateRemoteToggle.checked;
    }
    return getExecuteRemoteModePref();
}

function getExecuteConfirmSelections() {
    const remoteExecution = isRemoteExecutionSelected();
    const pushAllowed = !IS_BUILDER_VIEW;
    const pushEnabled = pushAllowed && (
        executeConfirmPushUpdateToggle
            ? !!executeConfirmPushUpdateToggle.checked
            : getExecuteConfirmUpdateRemotePref()
    );
    const advanced = {
        fixDockerDaemon: remoteExecution && !!(executeAdvFixDockerDaemon && executeAdvFixDockerDaemon.checked),
        runCoreCleanup: remoteExecution && !!(executeAdvRunCoreCleanup && executeAdvRunCoreCleanup.checked),
        checkCoreVersion: remoteExecution && !!(executeAdvCheckCoreVersion && executeAdvCheckCoreVersion.checked),
        restartCoreDaemon: remoteExecution && !!(executeAdvRestartCoreDaemon && executeAdvRestartCoreDaemon.checked),
        autoKillSessions: remoteExecution && !!(executeAdvAutoKillSessions && executeAdvAutoKillSessions.checked),
    };
    return {
        remoteExecution,
        pushPreference: pushAllowed ? pushEnabled : false,
        updateRemote: remoteExecution && pushAllowed && pushEnabled,
        advanced,
    };
}

const executeConfirmState = {
    pending: false,
    resolve: null,
    scenarioIndex: null,
    keepOpenOnConfirm: false,
};
let executeProgressWrap = null;
let executeProgressStatusEl = null;
let executeProgressMetaEl = null;
let executeProgressBarEl = null;
let executeProgressLogEl = null;
let executeProgressSpinnerEl = null;
let executeProgressPopoutBtn = null;
let executePhaseHeaderEl = null;
const executeProgressState = {
    active: false,
    logLines: [],
    maxLines: 300,
    runId: null,
    heartbeatTimer: null,
    heartbeatIndex: 0,
};
let setCoreConnectionHint = null;

// If the browser throws during execution flow, surface it in the Execute progress panel
// so users aren't left with only heartbeat messages.
if (!window.__coretg_exec_error_hooked) {
    window.__coretg_exec_error_hooked = true;
    window.addEventListener('error', (ev) => {
        try {
            if (!executeProgressState || !executeProgressState.active) return;
            const msg = ev?.message || 'Unknown error';
            appendExecuteProgressLog(`[ui] JS error: ${msg}`);
        } catch (e) {}
    });
    window.addEventListener('unhandledrejection', (ev) => {
        try {
            if (!executeProgressState || !executeProgressState.active) return;
            const reason = ev?.reason;
            const msg = (reason && (reason.message || String(reason))) || 'Unhandled promise rejection';
            appendExecuteProgressLog(`[ui] JS unhandled rejection: ${msg}`);
        } catch (e) {}
    });
}

function ensureExecuteConfirmElements() {
    if (!executeConfirmModalEl) {
        executeConfirmModalEl = document.getElementById('executeConfirmModal');
    }
    if (!executeConfirmMessageEl) {
        executeConfirmMessageEl = document.getElementById('executeConfirmMessage');
    }
    if (!executeConfirmAlertEl) {
        executeConfirmAlertEl = document.getElementById('executeConfirmAlert');
    }
    if (!executeConfirmRunBtn) {
        executeConfirmRunBtn = document.getElementById('executeConfirmRunBtn');
    }
    if (!executeConfirmCancelBtn) {
        executeConfirmCancelBtn = document.getElementById('executeConfirmCancelBtn');
    }
    if (!executePhaseHeaderEl) {
        executePhaseHeaderEl = document.getElementById('executePhaseHeader');
    }
    if (!executeConfirmUpdateRemoteToggle) {
        executeConfirmUpdateRemoteToggle = document.getElementById('executeConfirmUpdateRemoteToggle');
    }
    if (!executeConfirmUpdateRemoteHelpEl) {
        executeConfirmUpdateRemoteHelpEl = document.getElementById('executeConfirmUpdateRemoteHelp');
    }
    if (!executeCoreStatusEl) {
        executeCoreStatusEl = document.getElementById('executeCoreStatus');
    }
    if (!executeCoreTestBtn) {
        executeCoreTestBtn = document.getElementById('executeCoreTestBtn');
    }
    if (!executeRemoteTestRow) {
        executeRemoteTestRow = document.getElementById('executeCoreTestRow');
    }
    if (!executeCoreNotConfiguredRow) {
        executeCoreNotConfiguredRow = document.getElementById('executeCoreNotConfiguredRow');
    }
    if (!executeSelectCoreVmBtn) {
        executeSelectCoreVmBtn = document.getElementById('executeSelectCoreVmBtn');
    }
    if (!executePushUpdateWrap) {
        executePushUpdateWrap = document.getElementById('executePushUpdateToggleWrap');
    }
    if (!executeConfirmPushUpdateToggle) {
        executeConfirmPushUpdateToggle = document.getElementById('executeConfirmPushUpdateToggle');
    }
    if (!executeConfirmPushUpdateHelpEl) {
        executeConfirmPushUpdateHelpEl = document.getElementById('executeConfirmPushUpdateHelp');
    }
    if (!executeAdvancedWrap) {
        executeAdvancedWrap = document.getElementById('executeAdvancedWrap');
    }
    if (!executeAdvFixDockerDaemon) {
        executeAdvFixDockerDaemon = document.getElementById('executeAdvFixDockerDaemon');
    }
    if (!executeAdvRunCoreCleanup) {
        executeAdvRunCoreCleanup = document.getElementById('executeAdvRunCoreCleanup');
    }
    if (!executeAdvCheckCoreVersion) {
        executeAdvCheckCoreVersion = document.getElementById('executeAdvCheckCoreVersion');
    }
    if (!executeAdvRestartCoreDaemon) {
        executeAdvRestartCoreDaemon = document.getElementById('executeAdvRestartCoreDaemon');
    }
    if (!executeAdvAutoKillSessions) {
        executeAdvAutoKillSessions = document.getElementById('executeAdvAutoKillSessions');
    }
    if (executeConfirmRunBtn && !executeConfirmRunBtn.dataset.execBound) {
        executeConfirmRunBtn.addEventListener('click', async () => {
            if (executeConfirmRunBtn.disabled) {
                return;
            }
            const ready = await ensureBuilderCoreReadyForExecute();
            if (!ready) {
                return;
            }
            const stayOpen = !!executeConfirmState.keepOpenOnConfirm;
            settleExecuteConfirm({ confirmed: true });
            if (!stayOpen) {
                try {
                    if (executeConfirmModalEl && window.bootstrap) {
                        bootstrap.Modal.getOrCreateInstance(executeConfirmModalEl).hide();
                    }
                } catch (err) { /* ignore */ }
            }
        });
        executeConfirmRunBtn.dataset.execBound = '1';
    }
    if (executeConfirmCancelBtn && !executeConfirmCancelBtn.dataset.execBound) {
        executeConfirmCancelBtn.addEventListener('click', () => {
            settleExecuteConfirm({ confirmed: false });
        });
        executeConfirmCancelBtn.dataset.execBound = '1';
    }
    if (executeConfirmUpdateRemoteToggle && !executeConfirmUpdateRemoteToggle.dataset.execBound) {
        executeConfirmUpdateRemoteToggle.checked = getExecuteRemoteModePref();
        executeConfirmUpdateRemoteToggle.addEventListener('change', () => {
            setExecuteRemoteModePref(executeConfirmUpdateRemoteToggle.checked);
            refreshExecuteRemoteToggleState();
        });
        executeConfirmUpdateRemoteToggle.dataset.execBound = '1';
    }
    if (executeConfirmPushUpdateToggle && !executeConfirmPushUpdateToggle.dataset.execBound) {
        executeConfirmPushUpdateToggle.checked = getExecuteConfirmUpdateRemotePref();
        executeConfirmPushUpdateToggle.addEventListener('change', () => {
            setExecuteConfirmUpdateRemotePref(executeConfirmPushUpdateToggle.checked);
            refreshExecuteRemoteToggleState();
        });
        executeConfirmPushUpdateToggle.dataset.execBound = '1';
    }
    if (executeCoreTestBtn && !executeCoreTestBtn.dataset.execBound) {
        executeCoreTestBtn.addEventListener('click', () => {
            handleExecuteCoreTestClick();
        });
        executeCoreTestBtn.dataset.execBound = '1';
    }
    if (executeSelectCoreVmBtn && !executeSelectCoreVmBtn.dataset.execBound) {
        executeSelectCoreVmBtn.addEventListener('click', () => {
            try {
                if (executeConfirmModalEl && window.bootstrap) {
                    bootstrap.Modal.getOrCreateInstance(executeConfirmModalEl).hide();
                }
                if (typeof window.openCoreVmSelectModal === 'function') {
                    window.openCoreVmSelectModal();
                }
            } catch (err) { /* ignore */ }
        });
        executeSelectCoreVmBtn.dataset.execBound = '1';
    }
    if (executeConfirmModalEl && !executeConfirmModalEl.dataset.execHiddenBound) {
        executeConfirmModalEl.addEventListener('hidden.bs.modal', () => {
            settleExecuteConfirm({ confirmed: false });
            resetExecuteProgressUI();
        });
        executeConfirmModalEl.dataset.execHiddenBound = '1';
    }
    if (executeConfirmModalEl && !executeConfirmModalEl.dataset.execShowBound) {
        executeConfirmModalEl.addEventListener('show.bs.modal', () => {
            resetExecuteProgressUI();
            refreshExecuteRemoteToggleState();
        });
        executeConfirmModalEl.dataset.execShowBound = '1';
    }
}

function isExecuteCoreVmConfigured() {
    if (IS_BUILDER_VIEW) return true;
    try {
        const scenarioIdx = Number.isInteger(executeConfirmState?.scenarioIndex)
            ? executeConfirmState.scenarioIndex
            : getActiveScenarioContext().idx;
        if (!Number.isInteger(scenarioIdx)) return false;
        const scen = state?.scenarios?.[scenarioIdx];
        if (!scen) return false;
        const hitl = typeof ensureHitlStateForScenario === 'function' ? ensureHitlStateForScenario(scen) : (scen.hitl || {});
        const core = (hitl && typeof hitl === 'object' && hitl.core && typeof hitl.core === 'object') ? hitl.core : (scen.hitl?.core || {});
        const vmKey = (core?.vm_key ?? '').toString().trim();
        return !!vmKey;
    } catch (err) {
        return false;
    }
}

function updateExecuteCoreStatus(info = null) {
    if (!executeCoreStatusEl) return;
    const statusInfo = info || detectLocalEmulation();
    const classes = ['text-muted', 'text-success', 'text-warning', 'text-danger'];
    executeCoreStatusEl.classList.remove(...classes);
    if (statusInfo.verified) {
        executeCoreStatusEl.textContent = IS_BUILDER_VIEW
            ? 'CORE backend validated and ready.'
            : `Connected to CORE ${statusInfo.host}:${statusInfo.port}`;
        executeCoreStatusEl.classList.add('text-success');
    } else if (statusInfo.shouldFake) {
        executeCoreStatusEl.textContent = IS_BUILDER_VIEW
            ? 'Please test the connection. If it fails, contact your administrator.'
            : 'CORE not connected. Runs will fall back to local emulation.';
        executeCoreStatusEl.classList.add('text-danger');
    } else {
        executeCoreStatusEl.textContent = IS_BUILDER_VIEW
            ? 'CORE backend status unknown. Ask an admin to validate the connection.'
            : 'CORE connection not validated yet. Test before running remotely.';
        executeCoreStatusEl.classList.add('text-warning');
    }
}

function refreshExecuteRemoteToggleState() {
    const info = detectLocalEmulation();
    updateExecuteCoreStatus(info);
    const remoteSelected = isRemoteExecutionSelected();
    const coreVmConfigured = isExecuteCoreVmConfigured();
    const pushPref = getExecuteConfirmUpdateRemotePref();
    const showNotConfigured = remoteSelected && !coreVmConfigured && !IS_BUILDER_VIEW;

    if (executeCoreNotConfiguredRow) {
        executeCoreNotConfiguredRow.classList.toggle('d-none', !showNotConfigured);
    }
    if (executeRemoteTestRow) {
        executeRemoteTestRow.classList.toggle('d-none', !remoteSelected || showNotConfigured);
    }

    // If we're explicitly in the "CORE not connected; local emulation fallback" state,
    // never show push controls (there is no usable remote target).
    const hidePushControls = !remoteSelected || IS_BUILDER_VIEW || !!info.shouldFake || showNotConfigured;
    if (executePushUpdateWrap) {
        executePushUpdateWrap.classList.toggle('d-none', hidePushControls);
    }
    if (executeConfirmPushUpdateToggle) {
        if (IS_BUILDER_VIEW) {
            executeConfirmPushUpdateToggle.checked = false;
        } else if (hidePushControls) {
            executeConfirmPushUpdateToggle.checked = false;
        } else if (remoteSelected) {
            executeConfirmPushUpdateToggle.checked = pushPref;
        }
        executeConfirmPushUpdateToggle.disabled = hidePushControls;
    }
    if (executeConfirmPushUpdateHelpEl) {
        executeConfirmPushUpdateHelpEl.classList.remove('text-success', 'text-warning');
        if (IS_BUILDER_VIEW) {
            executeConfirmPushUpdateHelpEl.textContent = 'Repository uploads are managed by an admin.';
            executeConfirmPushUpdateHelpEl.classList.add('text-muted');
        } else {
            executeConfirmPushUpdateHelpEl.classList.toggle('text-muted', !remoteSelected);
            executeConfirmPushUpdateHelpEl.textContent = remoteSelected
                ? 'Sync the current repository snapshot to your CORE VM before execution.'
                : 'Enable remote execution to push the latest backend before running.';
            if (remoteSelected) {
                executeConfirmPushUpdateHelpEl.classList.add('text-success');
            }
        }
    }

    if (executeConfirmUpdateRemoteHelpEl) {
        executeConfirmUpdateRemoteHelpEl.classList.remove('text-muted', 'text-success', 'text-warning');
        if (remoteSelected) {
            const hideBuilderNotice = IS_BUILDER_VIEW && !info.verified;
            const remoteMsg = showNotConfigured
                ? 'CORE VM not configured. Select a CORE VM to enable remote execution.'
                : (info.verified
                    ? (IS_BUILDER_VIEW
                        ? 'Remote execution ready. Backend managed by an admin.'
                        : 'Remote execution ready. Runs will target your CORE VM.')
                    : (IS_BUILDER_VIEW
                        ? ''
                        : 'Remote execution requires a validated CORE connection. Test before running.'));
            executeConfirmUpdateRemoteHelpEl.textContent = remoteMsg;
            executeConfirmUpdateRemoteHelpEl.classList.toggle('d-none', hideBuilderNotice);
            if (!hideBuilderNotice) {
                executeConfirmUpdateRemoteHelpEl.classList.add(showNotConfigured ? 'text-warning' : (info.verified ? 'text-success' : 'text-warning'));
            }
        } else {
            executeConfirmUpdateRemoteHelpEl.textContent = 'Emulation mode runs locally on this workstation.';
            executeConfirmUpdateRemoteHelpEl.classList.remove('d-none');
            executeConfirmUpdateRemoteHelpEl.classList.add('text-muted');
        }
    }

    if (executeConfirmRunBtn) {
        const shouldDisable = showNotConfigured || (remoteSelected && !info.verified && !IS_BUILDER_VIEW);
        executeConfirmRunBtn.disabled = shouldDisable;
        if (shouldDisable) {
            executeConfirmRunBtn.setAttribute('title', showNotConfigured
                ? 'Select a CORE VM to enable remote execution.'
                : 'Test the CORE connection to enable remote execution.');
        } else {
            executeConfirmRunBtn.removeAttribute('title');
        }
    }

    // Advanced: only relevant for remote execution with a configured CORE VM.
    if (executeAdvancedWrap) {
        const showAdvanced = remoteSelected && !showNotConfigured && !IS_BUILDER_VIEW && !info.shouldFake;
        executeAdvancedWrap.classList.toggle('d-none', !showAdvanced);
    }
}

async function handleExecuteCoreTestClick() {
    const button = executeCoreTestBtn;
    const statusEl = executeCoreStatusEl;
    const { idx: scenarioIdx } = getActiveScenarioContext();
    if (!Number.isInteger(scenarioIdx)) {
        if (statusEl) {
            statusEl.textContent = 'Select a scenario before testing the CORE connection.';
            statusEl.classList.remove('text-success');
            statusEl.classList.add('text-danger');
        }
        return;
    }
    try {
        await validateCoreConnection(scenarioIdx, {
            triggerButton: button || undefined,
            statusEl: statusEl || undefined,
            workingLabel: 'Testing…',
            hintOnStart: 'Validating CORE connection…',
            hintOnSuccess: 'CORE connection validated for remote execution.',
            hintOnFailure: 'CORE connection test failed',
            suppressToasts: false,
        });
    } catch (err) {
        console.warn('CORE connection test from execute modal failed', err);
    } finally {
        refreshExecuteRemoteToggleState();
    }
}

async function ensureBuilderCoreReadyForExecute() {
    if (!IS_BUILDER_VIEW) {
        return true;
    }
    const scenarioIndex = Number.isInteger(executeConfirmState.scenarioIndex)
        ? executeConfirmState.scenarioIndex
        : getActiveScenarioContext().idx;
    if (!Number.isInteger(scenarioIndex)) {
        updateExecuteConfirmAlert('Select a scenario before executing.', 'warning');
        return false;
    }
    updateExecuteConfirmAlert('Validating CORE VM before execution…', 'info');
    try {
        const result = await validateCoreConnection(scenarioIndex, {
            triggerButton: executeConfirmRunBtn || undefined,
            workingLabel: 'Testing CORE…',
            statusEl: executeCoreStatusEl || undefined,
            hintOnStart: 'Checking CORE backend availability…',
            hintOnSuccess: 'CORE backend ready for execution.',
            hintOnFailure: 'CORE backend unavailable',
            suppressToasts: true,
            autoStartDaemon: true,
        });
        if (!result?.ok) {
            handleBuilderBackendUnavailable();
            return false;
        }
        updateExecuteConfirmAlert('', 'info');
        refreshExecuteRemoteToggleState();
        return true;
    } catch (err) {
        console.warn('Automatic CORE validation failed', err);
        handleBuilderBackendUnavailable();
        return false;
    }
}

function handleBuilderBackendUnavailable() {
    updateExecuteConfirmAlert(BUILDER_BACKEND_UNAVAILABLE_MESSAGE, 'danger');
    if (executeCoreStatusEl) {
        executeCoreStatusEl.textContent = BUILDER_BACKEND_UNAVAILABLE_MESSAGE;
        executeCoreStatusEl.classList.remove('text-success', 'text-warning', 'text-muted');
        executeCoreStatusEl.classList.add('text-danger');
    }
}

function ensureExecuteProgressElements() {
    if (!executeProgressWrap) executeProgressWrap = document.getElementById('executeProgressWrap');
    if (!executeProgressStatusEl) executeProgressStatusEl = document.getElementById('executeProgressStatus');
    if (!executeProgressMetaEl) executeProgressMetaEl = document.getElementById('executeProgressMeta');
    if (!executeProgressBarEl) executeProgressBarEl = document.getElementById('executeProgressBar');
    if (!executeProgressLogEl) executeProgressLogEl = document.getElementById('executeProgressLog');
    if (!executeProgressSpinnerEl) executeProgressSpinnerEl = document.getElementById('executeProgressSpinner');
    if (!executeProgressPopoutBtn) executeProgressPopoutBtn = document.getElementById('executeProgressPopoutBtn');
    if (!executePhaseHeaderEl) executePhaseHeaderEl = document.getElementById('executePhaseHeader');
    if (executeProgressPopoutBtn && !executeProgressPopoutBtn.dataset.execBound) {
        executeProgressPopoutBtn.addEventListener('click', () => {
            try {
                if (executeConfirmModalEl && window.bootstrap) {
                    bootstrap.Modal.getOrCreateInstance(executeConfirmModalEl).hide();
                }
            } catch (err) { /* ignore */ }
            openRunProgress('Run logs');
            maybeShowLocalEmulationHint();
            executeProgressPopoutBtn.classList.add('d-none');
        });
        executeProgressPopoutBtn.dataset.execBound = '1';
    }
}

const EXECUTE_PROGRESS_HEARTBEAT_MESSAGES = [
    'Establishing SSH tunnel to CORE host…',
    'Validating remote CORE environment…',
    'Syncing XML and preparing remote workspace…',
    'Starting CORE services on remote host…',
];
const EXECUTE_PROGRESS_HEARTBEAT_INTERVAL_MS = 4500;

function buildExecuteAdvancedPreflightSuffix() {
    try {
        if (!isRemoteExecutionSelected()) return '';
        const selections = (typeof getExecuteConfirmSelections === 'function') ? getExecuteConfirmSelections() : null;
        const adv = selections && selections.advanced && typeof selections.advanced === 'object' ? selections.advanced : null;
        if (!adv) return '';
        const enabled = [];
        if (adv.fixDockerDaemon) enabled.push('fix docker daemon');
        if (adv.runCoreCleanup) enabled.push('run core cleanup');
        if (adv.checkCoreVersion) enabled.push('check CORE version');
        if (adv.restartCoreDaemon) enabled.push('restart core-daemon');
        if (adv.autoKillSessions) enabled.push('auto-kill sessions');
        if (!enabled.length) return '';
        return ` (Advanced: ${enabled.join(', ')})`;
    } catch (_) {
        return '';
    }
}

function buildExecuteProgressDiagnosticsLines(){
    const lines = [];
    try {
        const info = detectLocalEmulation();
        const remoteSelected = isRemoteExecutionSelected();
        const selections = (typeof getExecuteConfirmSelections === 'function') ? getExecuteConfirmSelections() : null;
        const pushPref = selections && typeof selections.pushPreference !== 'undefined'
            ? !!selections.pushPreference
            : (typeof getExecuteConfirmUpdateRemotePref === 'function' ? !!getExecuteConfirmUpdateRemotePref() : false);
        const remoteMode = remoteSelected ? 'REMOTE' : 'LOCAL';
        lines.push(`[ui] Mode: ${remoteMode}${remoteSelected ? (info.verified ? ' (verified)' : ' (not verified)') : ''}`);
        if (remoteSelected) {
            lines.push(`[ui] Push updated backend: ${pushPref ? 'enabled' : 'disabled'}`);
            try {
                const adv = selections && selections.advanced && typeof selections.advanced === 'object' ? selections.advanced : null;
                if (adv) {
                    const enabled = [];
                    if (adv.fixDockerDaemon) enabled.push('fix docker daemon');
                    if (adv.runCoreCleanup) enabled.push('run core cleanup');
                    if (adv.checkCoreVersion) enabled.push('check CORE version');
                    if (adv.restartCoreDaemon) enabled.push('restart core-daemon');
                    if (adv.autoKillSessions) enabled.push('auto-kill sessions');
                    if (enabled.length) {
                        lines.push(`[ui] Advanced pre-flight: ${enabled.join(', ')}`);
                    }
                }
            } catch (_) {}
        }
        const core = (typeof getCoreConfig === 'function') ? getCoreConfig(false) : (state?.core || {});
        const sshHost = (core?.ssh_host || core?.host || 'localhost').toString().trim() || 'localhost';
        const sshPort = Number.isFinite(Number(core?.ssh_port)) && Number(core.ssh_port) > 0 ? Number(core.ssh_port) : 22;
        const sshUser = (core?.ssh_username || '').toString().trim();
        const grpcHost = (core?.grpc_host || core?.host || 'localhost').toString().trim() || 'localhost';
        const grpcPort = Number.isFinite(Number(core?.grpc_port)) && Number(core.grpc_port) > 0
            ? Number(core.grpc_port)
            : (Number.isFinite(Number(core?.port)) && Number(core.port) > 0 ? Number(core.port) : 50051);
        const venv = (core?.venv_bin || '').toString().trim();
        const daemonAuto = !!(core?.auto_start_daemon);
        const sshPrefix = sshUser ? `${sshUser}@` : '';
        lines.push(`[ui] SSH target: ${sshPrefix}${sshHost}:${sshPort}`);
        lines.push(`[ui] gRPC target: ${grpcHost}:${grpcPort}`);
        if (venv) lines.push(`[ui] Remote venv bin: ${venv}`);
        lines.push(`[ui] core-daemon auto-start: ${daemonAuto ? 'enabled' : 'disabled'}`);
        try {
            const testedHost = state?.core_tested_host || null;
            const testedPort = state?.core_tested_port || null;
            if (testedHost || testedPort) {
                lines.push(`[ui] Last validated: ${testedHost || '?'}:${testedPort || '?'}`);
            }
        } catch (_) {}
    } catch (e) {
        // best-effort; no throw
    }
    return lines;
}

function buildExecuteStartCoreServicesMessage(){
    try {
        const core = (typeof getCoreConfig === 'function') ? getCoreConfig(false) : (state?.core || {});
        const sshHost = (core?.ssh_host || core?.host || 'localhost').toString().trim() || 'localhost';
        const sshPort = Number.isFinite(Number(core?.ssh_port)) && Number(core.ssh_port) > 0 ? Number(core.ssh_port) : 22;
        const sshUser = (core?.ssh_username || '').toString().trim();
        const grpcHost = (core?.grpc_host || core?.host || 'localhost').toString().trim() || 'localhost';
        const grpcPort = Number.isFinite(Number(core?.grpc_port)) && Number(core.grpc_port) > 0
            ? Number(core.grpc_port)
            : (Number.isFinite(Number(core?.port)) && Number(core.port) > 0 ? Number(core.port) : 50051);
        const venv = (core?.venv_bin || '').toString().trim();
        const daemonAuto = !!(core?.auto_start_daemon);
        const sshPrefix = sshUser ? `${sshUser}@` : '';
        const venvSuffix = venv ? `, venv ${venv}` : '';
        const daemonSuffix = daemonAuto ? ', daemon auto-start enabled' : '';
        const advSuffix = buildExecuteAdvancedPreflightSuffix();
        return `Starting CORE services via SSH ${sshPrefix}${sshHost}:${sshPort} (gRPC ${grpcHost}:${grpcPort}${venvSuffix}${daemonSuffix})…${advSuffix}`;
    } catch (e) {
        return 'Starting CORE services on remote host…';
    }
}

function buildExecuteProgressStepMessage(stepIndex){
    try {
        const core = (typeof getCoreConfig === 'function') ? getCoreConfig(false) : (state?.core || {});
        const sshHost = (core?.ssh_host || core?.host || 'localhost').toString().trim() || 'localhost';
        const sshPort = Number.isFinite(Number(core?.ssh_port)) && Number(core.ssh_port) > 0 ? Number(core.ssh_port) : 22;
        const sshUser = (core?.ssh_username || '').toString().trim();
        const grpcHost = (core?.grpc_host || core?.host || 'localhost').toString().trim() || 'localhost';
        const grpcPort = Number.isFinite(Number(core?.grpc_port)) && Number(core.grpc_port) > 0
            ? Number(core.grpc_port)
            : (Number.isFinite(Number(core?.port)) && Number(core.port) > 0 ? Number(core.port) : 50051);
        const sshPrefix = sshUser ? `${sshUser}@` : '';
        const advSuffix = buildExecuteAdvancedPreflightSuffix();

        if (stepIndex === 0) {
            return `Establishing SSH tunnel to ${sshPrefix}${sshHost}:${sshPort}…${advSuffix}`;
        }
        if (stepIndex === 1) {
            return `Validating CORE backend (gRPC ${grpcHost}:${grpcPort})…${advSuffix}`;
        }
        if (stepIndex === 2) {
            const rp = (state?.result_path || '').toString().trim();
            const suffix = rp ? ` (XML ${rp.split(/[/\\]/).pop() || rp})` : '';
            return `Preparing remote workspace and syncing inputs${suffix}…${advSuffix}`;
        }
        return buildExecuteStartCoreServicesMessage();
    } catch (_) {
        return EXECUTE_PROGRESS_HEARTBEAT_MESSAGES[Math.min(stepIndex, EXECUTE_PROGRESS_HEARTBEAT_MESSAGES.length - 1)] || 'Working…';
    }
}

function emitExecuteProgressHeartbeatMessage() {
    if (!executeProgressState.active) return;
    const idx = Math.min(
        executeProgressState.heartbeatIndex,
        EXECUTE_PROGRESS_HEARTBEAT_MESSAGES.length - 1
    );
    const msg = buildExecuteProgressStepMessage(idx);
    appendExecuteProgressLog(`[ui] ${msg}`);
    setExecuteProgressStatus('Preparing CORE run…', msg);
    if (executeProgressState.heartbeatIndex < EXECUTE_PROGRESS_HEARTBEAT_MESSAGES.length - 1) {
        executeProgressState.heartbeatIndex += 1;
    }
}

function startExecuteProgressHeartbeat() {
    stopExecuteProgressHeartbeat();
    executeProgressState.heartbeatIndex = 0;
    emitExecuteProgressHeartbeatMessage();
    executeProgressState.heartbeatTimer = window.setInterval(() => {
        emitExecuteProgressHeartbeatMessage();
    }, EXECUTE_PROGRESS_HEARTBEAT_INTERVAL_MS);
}

function stopExecuteProgressHeartbeat() {
    if (executeProgressState.heartbeatTimer) {
        clearInterval(executeProgressState.heartbeatTimer);
        executeProgressState.heartbeatTimer = null;
    }
}

function resetExecuteProgressUI() {
    ensureExecuteProgressElements();
    stopExecuteProgressHeartbeat();
    executeProgressState.active = false;
    executeProgressState.logLines = [];
    executeProgressState.runId = null;
    executeProgressState.heartbeatIndex = 0;
    if (executeProgressWrap) executeProgressWrap.classList.add('d-none');
    if (executeProgressStatusEl) executeProgressStatusEl.textContent = '';
    if (executeProgressMetaEl) executeProgressMetaEl.textContent = '';
    if (executeProgressBarEl) {
        executeProgressBarEl.style.width = '0%';
        executeProgressBarEl.textContent = '0%';
        executeProgressBarEl.classList.remove('bg-success', 'bg-danger', 'progress-bar-animated');
        executeProgressBarEl.classList.add('progress-bar-striped');
    }
    if (executeProgressLogEl) executeProgressLogEl.textContent = '';
    if (executeProgressSpinnerEl) executeProgressSpinnerEl.classList.remove('d-none');
    if (executeProgressPopoutBtn) executeProgressPopoutBtn.classList.add('d-none');
    if (executePhaseHeaderEl) executePhaseHeaderEl.textContent = 'Phase: —';
    if (executeConfirmRunBtn) {
        if (!executeConfirmRunBtn.dataset.defaultLabel) {
            executeConfirmRunBtn.dataset.defaultLabel = executeConfirmRunBtn.textContent || 'Execute';
        }
        executeConfirmRunBtn.disabled = false;
        executeConfirmRunBtn.textContent = executeConfirmRunBtn.dataset.defaultLabel;
        executeConfirmRunBtn.removeAttribute('title');
    }
    if (executeConfirmCancelBtn) {
        if (!executeConfirmCancelBtn.dataset.cancelLabel) {
            executeConfirmCancelBtn.dataset.cancelLabel = executeConfirmCancelBtn.textContent || 'Cancel';
        }
        executeConfirmCancelBtn.disabled = false;
        executeConfirmCancelBtn.textContent = executeConfirmCancelBtn.dataset.cancelLabel;
    }
}

function showExecuteProgressPanel(status, meta) {
    ensureExecuteProgressElements();
    stopExecuteProgressHeartbeat();
    executeProgressState.active = true;
    executeProgressState.logLines = [];
    if (executeProgressWrap) executeProgressWrap.classList.remove('d-none');
    if (executeProgressSpinnerEl) executeProgressSpinnerEl.classList.remove('d-none');
    if (executeProgressBarEl) executeProgressBarEl.classList.add('progress-bar-animated');
    if (executeConfirmRunBtn) {
        if (!executeConfirmRunBtn.dataset.defaultLabel) {
            executeConfirmRunBtn.dataset.defaultLabel = executeConfirmRunBtn.textContent || 'Execute';
        }
        executeConfirmRunBtn.disabled = true;
        executeConfirmRunBtn.textContent = 'Executing…';
    }
    if (executeConfirmCancelBtn) {
        if (!executeConfirmCancelBtn.dataset.cancelLabel) {
            executeConfirmCancelBtn.dataset.cancelLabel = executeConfirmCancelBtn.textContent || 'Cancel';
        }
        executeConfirmCancelBtn.textContent = 'Hide';
        executeConfirmCancelBtn.disabled = false;
    }
    try {
        const diag = buildExecuteProgressDiagnosticsLines();
        if (Array.isArray(diag) && diag.length) {
            diag.forEach(line => { appendExecuteProgressLog(line); });
        }
    } catch (_) {}
    if (executePhaseHeaderEl) executePhaseHeaderEl.textContent = 'Phase: Preparing…';
    setExecuteProgressStatus(status || 'Preparing run…', meta || '');
    setExecuteProgressPercent(0, '0%');
    startExecuteProgressHeartbeat();
}

function setExecuteProgressStatus(main, meta) {
    if (!executeProgressState.active) return;
    if (executeProgressStatusEl && main !== undefined) {
        executeProgressStatusEl.textContent = main || '';
    }
    if (executeProgressMetaEl && meta !== undefined) {
        executeProgressMetaEl.textContent = meta || '';
    }
}

function setExecuteProgressPercent(percent, label) {
    if (!executeProgressState.active) return;
    if (!executeProgressBarEl) return;
    const clamped = Math.max(0, Math.min(100, Number(percent) || 0));
    executeProgressBarEl.style.width = clamped.toFixed(1).replace(/\.0$/, '') + '%';
    executeProgressBarEl.textContent = label || clamped.toFixed(0) + '%';
}

function appendExecuteProgressLog(line, options = {}) {
    if (!executeProgressState.active || !executeProgressLogEl) return;
    const normalized = (line || '').trimEnd();
    executeProgressState.logLines.push(normalized);
    if (executeProgressState.logLines.length > executeProgressState.maxLines) {
        executeProgressState.logLines.shift();
    }
    executeProgressLogEl.textContent = executeProgressState.logLines.join('\n');
    executeProgressLogEl.scrollTop = executeProgressLogEl.scrollHeight;
    try {
        const mirror = (options && typeof options === 'object' && Object.prototype.hasOwnProperty.call(options, 'mirrorToDock'))
            ? !!options.mirrorToDock
            : true;
        if (mirror && typeof dockLog === 'function') {
            let lvl = 'INFO';
            try {
                if (/\bERROR\b/.test(normalized)) lvl = 'ERROR';
                else if (/\bWARN(ING)?\b/.test(normalized)) lvl = 'WARN';
                else if (/\bDEBUG\b/.test(normalized)) lvl = 'DEBUG';
            } catch (e) {}
            dockLog(normalized, lvl);
        }
    } catch (e) {}
}

function bindExecuteProgressToRun(runId) {
    executeProgressState.runId = runId || null;
    stopExecuteProgressHeartbeat();
    if (executeProgressPopoutBtn) executeProgressPopoutBtn.classList.remove('d-none');
    setExecuteProgressStatus('Running CLI…', 'Streaming logs…');
}

function completeExecuteProgressPanel(success, message, meta) {
    if (!executeProgressState.active) return;
    stopExecuteProgressHeartbeat();
    if (executeProgressSpinnerEl) executeProgressSpinnerEl.classList.add('d-none');
    if (executeProgressBarEl) {
        executeProgressBarEl.classList.remove('progress-bar-striped', 'progress-bar-animated');
        executeProgressBarEl.classList.remove('bg-danger', 'bg-success');
        executeProgressBarEl.classList.add(success ? 'bg-success' : 'bg-danger');
        executeProgressBarEl.style.width = success ? '100%' : executeProgressBarEl.style.width || '100%';
        executeProgressBarEl.textContent = success ? 'Done' : 'Error';
    }
    setExecuteProgressStatus(message || (success ? 'Scenario started' : 'Failed to start'), meta || '');
    if (executePhaseHeaderEl) executePhaseHeaderEl.textContent = success ? 'Phase: Complete' : 'Phase: Error';
    if (executeConfirmCancelBtn) {
        executeConfirmCancelBtn.textContent = 'Close';
        executeConfirmCancelBtn.disabled = false;
    }
    if (executeConfirmRunBtn) {
        executeConfirmRunBtn.disabled = true;
    }
}

function handleExecuteProgressLog(line) {
    if (!executeProgressState.active) return;
    stopExecuteProgressHeartbeat();
    appendExecuteProgressLog(line);
    if (!line) return;
    if (/\[remote\]\s+Repo upload starting/i.test(line)) {
        setExecuteProgressStatus('Copying repository…', line.replace('[remote]', '').trim());
        setExecuteProgressPercent(1, 'Starting…');
        return;
    }
    const repoMatch = /\[remote\]\s+Repo upload\s+(\d+(?:\.\d+)?)%.*\((\d+)\/(\d+)\s*KiB/i.exec(line);
    if (repoMatch) {
        const pct = parseFloat(repoMatch[1]) || 0;
        const cur = repoMatch[2];
        const total = repoMatch[3];
        setExecuteProgressStatus('Copying repository…', `${cur} / ${total} KiB`);
        setExecuteProgressPercent(pct, `${pct.toFixed(1)}%`);
        return;
    }
    if (/\[remote\]\s+Repo upload complete/i.test(line)) {
        setExecuteProgressStatus('Repository copied', 'Preparing workspace…');
        setExecuteProgressPercent(100, '100%');
        return;
    }
    if (/\[remote\]\s+Workspace:/i.test(line)) {
        setExecuteProgressStatus('Remote workspace ready', line.replace('[remote]', '').trim());
        setExecuteProgressPercent(100, 'Workspace ready');
        return;
    }
}

function handleExecuteProgressPhase(payload) {
    if (!executeProgressState.active) return;
    const stage = (payload && payload.stage) ? String(payload.stage) : 'phase';
    const detail = (payload && payload.detail) ? String(payload.detail) : '';
    const meta = [];
    if (payload && payload.local && payload.remote) meta.push(`${payload.local} → ${payload.remote}`);
    if (payload && payload.exit !== undefined && payload.exit !== null) meta.push(`exit=${payload.exit}`);
    const metaText = meta.filter(Boolean).join(' · ');

    // Do not append synthetic "[phase]" lines here.
    // The backend already streams detailed logs for these phases, and duplicating them
    // makes the Execute log noisy (especially around repo push/finalize).

    if (executePhaseHeaderEl) executePhaseHeaderEl.textContent = `Phase: ${stage}`;

    if (stage === 'ssh.tunnel') {
        setExecuteProgressStatus('SSH tunnel established', metaText);
        setExecuteProgressPercent(2, 'Tunnel');
        return;
    }
    if (stage === 'core-daemon.startup') {
        setExecuteProgressStatus('Checking core-daemon…', detail || '');
        setExecuteProgressPercent(5, 'Daemon');
        return;
    }
    if (stage === 'core-daemon.start') {
        setExecuteProgressStatus('Starting core-daemon…', metaText);
        setExecuteProgressPercent(8, 'Starting');
        return;
    }
    if (stage === 'core-daemon.systemctl.is-active') {
        setExecuteProgressStatus('Validating core-daemon…', metaText);
        setExecuteProgressPercent(10, 'Validating');
        return;
    }
    if (stage === 'remote.workspace') {
        setExecuteProgressStatus('Remote workspace ready', (payload && payload.repo_dir) ? `repo=${payload.repo_dir}` : '');
        setExecuteProgressPercent(15, 'Workspace');
        return;
    }
    if (stage === 'remote.cli.launch') {
        setExecuteProgressStatus('Launching CLI…', (payload && payload.work_dir) ? `cwd=${payload.work_dir}` : '');
        setExecuteProgressPercent(20, 'Launching');
        return;
    }
    // If there's structured output, append a short excerpt.
    try {
        const out = (payload && payload.stdout) ? String(payload.stdout).trim() : '';
        const err = (payload && payload.stderr) ? String(payload.stderr).trim() : '';
        if (out) appendExecuteProgressLog(out);
        if (err) appendExecuteProgressLog(err);
    } catch (e) {}
}

function settleExecuteConfirm(result) {
    if (!executeConfirmState.pending) {
        return;
    }
    executeConfirmState.pending = false;
    executeConfirmState.keepOpenOnConfirm = false;
    const resolver = executeConfirmState.resolve;
    executeConfirmState.resolve = null;
    const scenarioIndex = executeConfirmState.scenarioIndex;
    executeConfirmState.scenarioIndex = null;
    let payload = {};
    if (typeof result === 'object' && result !== null) {
        payload = { ...result };
    } else {
        payload = { confirmed: false };
    }
    const selections = getExecuteConfirmSelections();
    if (selections) {
        if (typeof selections.updateRemote !== 'undefined' && typeof payload.updateRemote === 'undefined') {
            payload.updateRemote = selections.updateRemote;
        }
        if (typeof selections.remoteExecution !== 'undefined' && typeof payload.remoteExecution === 'undefined') {
            payload.remoteExecution = selections.remoteExecution;
        }
        if (typeof selections.pushPreference !== 'undefined' && typeof payload.pushPreference === 'undefined') {
            payload.pushPreference = selections.pushPreference;
        }
        if (typeof selections.advanced !== 'undefined' && typeof payload.advanced === 'undefined') {
            payload.advanced = selections.advanced;
        }
        if (typeof selections.pushPreference !== 'undefined') {
            setExecuteConfirmUpdateRemotePref(selections.pushPreference);
        } else if (typeof selections.updateRemote !== 'undefined') {
            setExecuteConfirmUpdateRemotePref(selections.updateRemote);
        }
        if (typeof selections.remoteExecution !== 'undefined') {
            setExecuteRemoteModePref(selections.remoteExecution);
        }
    }
    resolver?.({ ...payload, scenarioIndex });
}

function updateExecuteConfirmAlert(message, tone = 'warning') {
    if (!executeConfirmAlertEl) {
        return;
    }
    const toneClasses = ['alert-warning', 'alert-info', 'alert-danger', 'alert-success'];
    executeConfirmAlertEl.classList.remove(...toneClasses);
    if (!message) {
        executeConfirmAlertEl.textContent = '';
        executeConfirmAlertEl.classList.add('d-none');
        return;
    }
    executeConfirmAlertEl.textContent = message;
    const toneClass = tone === 'danger' ? 'alert-danger'
        : tone === 'info' ? 'alert-info'
        : tone === 'success' ? 'alert-success'
        : 'alert-warning';
    executeConfirmAlertEl.classList.remove('d-none');
    executeConfirmAlertEl.classList.add(toneClass);
}

async function promptExecuteConfirmation(options = {}) {
    const { idx: activeScenarioIdx } = getActiveScenarioContext();
    const scenarioIndex = Number.isInteger(options.scenarioIndex) ? options.scenarioIndex : activeScenarioIdx;
    const message = options.message || 'Execute this scenario now? This will start a CORE session.';
    const confirmLabel = options.confirmLabel || 'Execute';
    const alertMessage = options.alertMessage || '';
    const alertTone = options.alertTone || 'warning';
    const keepOpenOnConfirm = !!options.keepOpenOnConfirm;
    ensureExecuteConfirmElements();
    const remoteModeDefault = typeof options.remoteModeDefault === 'boolean'
        ? options.remoteModeDefault
        : getExecuteRemoteModePref();
    const updateRemoteDefault = typeof options.updateRemoteDefault === 'boolean'
        ? options.updateRemoteDefault
        : getExecuteConfirmUpdateRemotePref();
    if (executeConfirmUpdateRemoteToggle) {
        executeConfirmUpdateRemoteToggle.checked = !!remoteModeDefault;
    } else if (typeof remoteModeDefault === 'boolean') {
        setExecuteRemoteModePref(remoteModeDefault);
    }
    if (executeConfirmPushUpdateToggle) {
        executeConfirmPushUpdateToggle.checked = !!updateRemoteDefault;
    } else if (typeof updateRemoteDefault === 'boolean') {
        setExecuteConfirmUpdateRemotePref(updateRemoteDefault);
    }
    if (!executeConfirmModalEl || !window.bootstrap) {
        const confirmed = window.confirm(message);
        const remoteExecution = !!remoteModeDefault;
        const pushPreference = !!updateRemoteDefault;
        return {
            confirmed,
            scenarioIndex,
            updateRemote: remoteExecution && pushPreference,
            remoteExecution,
            pushPreference,
        };
    }
    executeConfirmState.pending = true;
    executeConfirmState.scenarioIndex = Number.isInteger(scenarioIndex) ? scenarioIndex : null;
    executeConfirmState.keepOpenOnConfirm = keepOpenOnConfirm;
    if (executeConfirmMessageEl) {
        executeConfirmMessageEl.textContent = message;
    }
    updateExecuteConfirmAlert(alertMessage, alertTone);
    resetExecuteProgressUI();
    if (executeConfirmRunBtn) {
        executeConfirmRunBtn.textContent = confirmLabel;
    }
    refreshExecuteRemoteToggleState();
    const modalInstance = bootstrap.Modal.getOrCreateInstance(executeConfirmModalEl);
    return new Promise((resolve) => {
        executeConfirmState.resolve = resolve;
        modalInstance.show();
    });
}

render();

// Restore scroll position if previously saved before a Save XML navigation
function restoreScrollIfAny() {
    try {
        const y = parseInt(sessionStorage.getItem('coretg_saved_scroll_y') || '', 10);
        if (!isNaN(y)) {
            window.scrollTo(0, y);
            sessionStorage.removeItem('coretg_saved_scroll_y');
        }
    } catch (e) { /* ignore */ }
}
// Use load to ensure layout (including dock sizing) has been applied
window.addEventListener('load', restoreScrollIfAny);

// Small helper to persist current scroll position prior to any navigation (form post or link)
function saveScrollBeforeNav(){
    try { sessionStorage.setItem('coretg_saved_scroll_y', String(window.scrollY || window.pageYOffset || 0)); } catch (e) { /* ignore */ }
}

// Always serialize state just before submitting the Save XML form
const editorForm = document.getElementById('editorForm');
const saveXmlBtn = document.getElementById('saveXmlBtn');
let saveXmlToastHandle = null;
let saveXmlToastStartedAt = 0;
let saveXmlToastToken = 0;

function setSaveXmlBusy(busy) {
    if (!saveXmlBtn) return;
    if (!saveXmlBtn.dataset.defaultLabel) {
        saveXmlBtn.dataset.defaultLabel = saveXmlBtn.innerHTML;
    }
    if (busy) {
        saveXmlBtn.disabled = true;
        saveXmlBtn.innerHTML = '<span class="spinner-border spinner-border-sm me-1" role="status" aria-hidden="true"></span>Saving…';
    } else {
        saveXmlBtn.disabled = false;
        saveXmlBtn.innerHTML = saveXmlBtn.dataset.defaultLabel;
    }
}

function flashSaveXmlSaved() {
    if (!saveXmlBtn) return;
    if (!saveXmlBtn.dataset.defaultLabel) {
        saveXmlBtn.dataset.defaultLabel = saveXmlBtn.innerHTML;
    }
    const token = String(Date.now());
    saveXmlBtn.dataset.flashToken = token;
    saveXmlBtn.innerHTML = 'Saved';
    window.setTimeout(() => {
        try {
            if (!saveXmlBtn) return;
            if (saveXmlBtn.dataset.flashToken !== token) return;
            saveXmlBtn.innerHTML = saveXmlBtn.dataset.defaultLabel;
        } catch (e) { /* ignore */ }
    }, 1200);
}

function setSaveXmlToastBusy(busy) {
    const MIN_TOAST_MS = 650;
    try {
        if (!busy && saveXmlToastHandle && saveXmlToastHandle.toast && typeof saveXmlToastHandle.toast.hide === 'function') {
            const now = Date.now();
            const elapsed = saveXmlToastStartedAt ? (now - saveXmlToastStartedAt) : MIN_TOAST_MS;
            const remaining = Math.max(0, MIN_TOAST_MS - elapsed);
            const token = saveXmlToastToken;
            if (remaining > 0) {
                window.setTimeout(() => {
                    try {
                        // Avoid hiding a newer toast if a second save started.
                        if (token !== saveXmlToastToken) return;
                        if (saveXmlToastHandle && saveXmlToastHandle.toast && typeof saveXmlToastHandle.toast.hide === 'function') {
                            saveXmlToastHandle.toast.hide();
                        }
                    } catch (e) { /* ignore */ }
                }, remaining);
                return;
            }
            saveXmlToastHandle.toast.hide();
        }
    } catch (e) { /* ignore */ }
    saveXmlToastHandle = null;
    saveXmlToastStartedAt = 0;
    if (!busy) return;
    try {
        // Keep it visible until the save completes.
        saveXmlToastToken += 1;
        saveXmlToastStartedAt = Date.now();
        saveXmlToastHandle = showToast('Saving XML…', { autohide: false });
    } catch (e) { /* ignore */ }
}

if (editorForm) {
    const handleEditorFormSubmit = async (event) => {
        if (event) {
            event.preventDefault();
        }
        setSaveXmlBusy(true);
        setSaveXmlToastBusy(true);
        // Yield a frame so the toast/spinner can paint before heavy work.
        try { await new Promise(requestAnimationFrame); } catch (_) {}
        try { sessionStorage.setItem('coretg_saved_scroll_y', String(window.scrollY || window.pageYOffset || 0)); } catch (e) { /* ignore */ }
        const scenariosInput = document.getElementById('scenarios_json');
        if (scenariosInput) {
            scenariosInput.value = JSON.stringify({ scenarios: state.scenarios, active_index: activeIdx });
        }
        const coreJsonInput = document.getElementById('core_json');
        if (coreJsonInput) {
            coreJsonInput.value = JSON.stringify(getCoreConfig(true));
        }
        const projectKeyInput = document.getElementById('project_key_hint');
        if (projectKeyInput) {
            projectKeyInput.value = currentProjectKey || DEFAULT_PROJECT_KEY;
        }
        const scenarioQueryInput = document.getElementById('scenario_query_input');
        if (scenarioQueryInput) {
            scenarioQueryInput.value = resolveScenarioQueryHint();
        }
        persistEditorState();
        if (typeof autoSaveXml === 'function') {
            try {
                await autoSaveXml();
                setSaveXmlBusy(false);
                setSaveXmlToastBusy(false);
                flashSaveXmlSaved();
                try { showToast('XML saved.', { autohide: true, delay: 2200 }); } catch (_) {}
                return;
            } catch (err) {
                console.warn('Auto Save XML failed, falling back to full form submit', err);
                setSaveXmlToastBusy(false);
                try { showToast('Auto-save failed; submitting form…', { autohide: true, delay: 2600 }); } catch (_) {}
            }
        }
        editorForm.removeEventListener('submit', handleEditorFormSubmit);
        try {
            editorForm.submit();
        } finally {
            editorForm.addEventListener('submit', handleEditorFormSubmit);
        }
    };
    editorForm.addEventListener('submit', handleEditorFormSubmit);
}

// Enable Bootstrap tooltips globally
document.addEventListener('DOMContentLoaded', () => {
    const tooltipTriggerList = [].slice.call(document.querySelectorAll('[data-bs-toggle="tooltip"]'));
    tooltipTriggerList.forEach(el => {
        // Bootstrap 5 throws if title option resolves to null; normalize to empty string
        const dt = el.getAttribute('data-bs-title') || el.getAttribute('title');
        if (dt === null) {
            // skip creating tooltip entirely if no title is present
            return;
        }
        if (dt.trim() === '') {
            el.setAttribute('data-bs-title', '');
        }
        try { new bootstrap.Tooltip(el); } catch (e) { /* ignore */ }
    });
    const proxAssignModal = document.getElementById('proxmoxAssignModal');
    const proxAssignSave = document.getElementById('proxmoxAssignSave');
    const proxAssignError = document.getElementById('proxmoxAssignError');
    const proxAssignHint = document.getElementById('proxmoxAssignHint');
    const proxAssignForm = document.getElementById('proxmoxAssignForm');
    const proxUrlInput = document.getElementById('proxmoxUrl');
    const proxPortInput = document.getElementById('proxmoxPort');
    const proxUserInput = document.getElementById('proxmoxUsername');
    const proxPassInput = document.getElementById('proxmoxPassword');
    const proxRememberInput = document.getElementById('proxmoxRememberCreds');
    const clearProxError = () => {
        if (!proxAssignError) return;
        proxAssignError.textContent = '';
        proxAssignError.classList.add('d-none');
    };
    const showProxError = (message) => {
        if (!proxAssignError) return;
        proxAssignError.textContent = message;
        proxAssignError.classList.remove('d-none');
    };
    const setProxAssignBusy = (busy) => {
        if (!proxAssignSave) return;
        if (!proxAssignSave.dataset.defaultLabel) {
            proxAssignSave.dataset.defaultLabel = proxAssignSave.innerHTML;
        }
        if (busy) {
            proxAssignSave.disabled = true;
            proxAssignSave.innerHTML = '<span class="spinner-border spinner-border-sm me-1" role="status" aria-hidden="true"></span>Validating…';
        } else {
            proxAssignSave.disabled = false;
            proxAssignSave.innerHTML = proxAssignSave.dataset.defaultLabel;
        }
        if (proxAssignForm) {
            proxAssignForm.querySelectorAll('input').forEach(inp => {
                if (busy) {
                    inp.setAttribute('data-prox-disabled-prev', inp.disabled ? '1' : '0');
                    inp.disabled = true;
                } else {
                    const prev = inp.getAttribute('data-prox-disabled-prev');
                    inp.disabled = prev === '1';
                    inp.removeAttribute('data-prox-disabled-prev');
                }
            });
        }
    };
    const setProxAssignHint = window.setProxAssignHint || ((message, tone = 'info') => {
        if (!proxAssignHint) return;
        proxAssignHint.textContent = message || '';
        proxAssignHint.style.display = message ? '' : 'none';
        proxAssignHint.classList.remove('alert-info', 'alert-success', 'alert-danger');
        const klass = tone === 'success' ? 'alert-success' : tone === 'danger' ? 'alert-danger' : 'alert-info';
        proxAssignHint.classList.add(klass);
    });
    if (!window.setProxAssignHint) {
        window.setProxAssignHint = setProxAssignHint;
    }
    proxAssignSave?.addEventListener('click', async () => {
        if (!proxAssignModal) return;
        const sidx = parseInt(proxAssignModal.getAttribute('data-scen-idx') || '', 10);
        if (isNaN(sidx) || !state.scenarios?.[sidx]) {
            showProxError('Scenario context unavailable.');
            return;
        }
    if (!proxAssignForm) return;
        if (!proxAssignForm.checkValidity()) {
            proxAssignForm.reportValidity();
            return;
        }
        clearProxError();
        const urlVal = (proxUrlInput?.value || '').trim();
        if (!/^https?:\/\//i.test(urlVal)) {
            showProxError('URL must start with http:// or https://');
            proxUrlInput?.focus();
            return;
        }
        const portVal = parseInt(proxPortInput?.value || '8006', 10);
        if (!Number.isFinite(portVal) || portVal < 1 || portVal > 65535) {
            showProxError('Port must be between 1 and 65535');
            proxPortInput?.focus();
            return;
        }
        const userVal = (proxUserInput?.value || '').trim();
        if (!userVal) {
            showProxError('Username is required.');
            proxUserInput?.focus();
            return;
        }
        const scenario = state.scenarios[sidx];
        const hitlState = ensureHitlStateForScenario(scenario);
        const prox = hitlState.proxmox || {};
        const rememberCreds = proxRememberInput ? !!proxRememberInput.checked : true;
        hitlState.proxmox.remember_credentials = rememberCreds;
        const passVal = proxPassInput?.value ?? '';
        if (!passVal && !prox.secret_id) {
            showProxError('Password is required.');
            proxPassInput?.focus();
            return;
        }
        const verifyInput = document.getElementById('proxmoxVerifySsl');
        const verifySsl = verifyInput ? !!verifyInput.checked : /^https:/i.test(urlVal);
        persistSavedProxmoxDefaults({ url: urlVal, port: portVal, username: userVal, verify_ssl: verifySsl });
        setProxAssignBusy(true);
        setProxAssignHint('Validating credentials with Proxmox…', 'info');
        let data = null;
        const requestPayload = {
            url: urlVal,
            port: portVal,
            username: userVal,
            password: passVal,
            verify_ssl: verifySsl,
            scenario_index: sidx,
            scenario_name: scenario?.name || '',
            timeout: 8.0,
            remember_credentials: rememberCreds,
        };
        if (rememberCreds && !passVal && prox.secret_id) {
            requestPayload.reuse_secret_id = prox.secret_id;
        }
        try {
            const resp = await fetch('/api/proxmox/validate', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                credentials: 'same-origin',
                body: JSON.stringify(requestPayload),
            });
            try {
                data = await resp.json();
            } catch (err) {
                data = null;
            }
            if (!resp.ok || !data || data.success === false) {
                const errMsg = (data && data.error) ? data.error : `Validation failed (HTTP ${resp.status})`;
                throw new Error(errMsg);
            }
        } catch (err) {
            const message = err instanceof Error ? err.message : 'Unknown error during validation';
            showProxError(message);
            setProxAssignHint('', 'info');
            setProxAssignBusy(false);
            return;
        }
        try {
            const summary = data?.summary || {};
            const previousSecretId = hitlState.proxmox?.secret_id || null;
            const nowIso = new Date().toISOString();
            const updatedProx = {
                ...hitlState.proxmox,
                url: urlVal,
                port: summary.port ?? portVal,
                username: summary.username ?? userVal,
                verify_ssl: summary.verify_ssl ?? verifySsl,
                last_message: data?.message || (rememberCreds ? 'Credentials validated.' : 'Credentials validated (not stored).'),
            };
            if (rememberCreds) {
                const newSecretId = data?.secret_id || summary.identifier || null;
                updatedProx.secret_id = newSecretId;
                updatedProx.validated = !!newSecretId;
                updatedProx.last_validated_at = summary.stored_at || nowIso;
            } else {
                updatedProx.secret_id = previousSecretId;
                if (!previousSecretId) {
                    updatedProx.validated = false;
                    updatedProx.last_validated_at = null;
                }
            }
            hitlState.proxmox = updatedProx;
            if ('password' in hitlState.proxmox) {
                delete hitlState.proxmox.password;
            }
            updateProxmoxSummary(sidx);
            persistEditorState();
            const hidden = document.getElementById('scenarios_json');
            if (hidden) hidden.value = JSON.stringify({ scenarios: state.scenarios, active_index: activeIdx });
            if (rememberCreds && hitlState.proxmox.secret_id) {
                try { showToast('Refreshing Proxmox VM inventory…', { autohide: true, delay: 1500 }); } catch (e) {}
                await fetchProxmoxInventory(sidx, { force: true });
            }
            if (proxPassInput) proxPassInput.value = '';
            const successMessage = data?.message || (rememberCreds ? 'Proxmox credentials validated and stored securely.' : 'Credentials validated but not stored. Re-enter credentials when needed.');
            const successTone = rememberCreds ? 'success' : 'warning';
            setProxAssignHint(successMessage, successTone);
            try { showToast(successMessage, { autohide: true, delay: 2500 }); } catch(e) {}
            const modalInstance = window.bootstrap ? bootstrap.Modal.getInstance(proxAssignModal) : null;
            setTimeout(() => { modalInstance?.hide(); }, 400);
        } catch (err) {
            const message = err instanceof Error ? err.message : 'Failed to persist Proxmox state locally';
            showProxError(message);
            setProxAssignHint('', 'info');
        } finally {
            setProxAssignBusy(false);
        }
    });
    if (proxAssignModal && window.bootstrap) {
        proxAssignModal.addEventListener('hidden.bs.modal', () => {
            proxAssignModal.removeAttribute('data-scen-idx');
            clearProxError();
            setProxAssignHint('', 'info');
            if (proxPassInput) proxPassInput.value = '';
            const verifyInput = document.getElementById('proxmoxVerifySsl');
            if (verifyInput) verifyInput.checked = true;
        });
    }
    if (coreConnectionModal && window.bootstrap) {
        coreConnectionModal.addEventListener('hidden.bs.modal', () => {
            coreConnectionModal.removeAttribute('data-scen-idx');
            if (coreConnectionForm) {
                coreConnectionForm.classList.remove('was-validated');
            }
            if (coreModalInputs.ssh_password) {
                coreModalInputs.ssh_password.value = '';
                coreModalInputs.ssh_password.removeAttribute('placeholder');
            }
            if (typeof setCoreConnectionHint === 'function') {
                setCoreConnectionHint('', 'info');
            }
        });
    }
    const externalIfxModal = document.getElementById('externalIfxModal');
    if (externalIfxModal) {
        externalIfxModal.addEventListener('hide.bs.modal', () => {
            const active = document.activeElement;
            if (active && externalIfxModal.contains(active) && typeof active.blur === 'function') {
                active.blur();
            }
        });
        externalIfxModal.addEventListener('hidden.bs.modal', () => {
            clearExternalIfxStatus();
            setExternalIfxApplyBusy(false);
            const triggerBtn = document.querySelector('[data-bs-target="\#externalIfxModal"]');
            if (triggerBtn && typeof triggerBtn.focus === 'function') {
                triggerBtn.focus();
            }
        });
    }
    const externalIfxApplyBtn = document.getElementById('externalIfxApplyBtn');
    if (externalIfxApplyBtn) {
        externalIfxApplyBtn.addEventListener('click', () => {
            if (externalIfxApplyBtn.disabled) return;
            handleExternalIfxApply();
        });
    }
    // Wire Download XML button
    const dlBtn = document.getElementById('downloadXmlBtn');
    if (dlBtn) {
        dlBtn.addEventListener('click', () => {
            const rp = state.result_path || '';
            if (!rp || !rp.endsWith('.xml')) { alert('Please Save XML first.'); return; }
            window.location.href = window.location.origin + '/download_report?path=' + encodeURIComponent(rp);
        });
        // Initial state based on state.result_path
        const rp0 = state.result_path || '';
        if (rp0 && rp0.endsWith('.xml')) { dlBtn.removeAttribute('disabled'); dlBtn.classList.remove('pe-none'); dlBtn.setAttribute('title',''); }
    }
    // Capture any server-rendered logs before we render from storage
    let __serverLogsAtLoad = '';
    try { __serverLogsAtLoad = (document.getElementById('logsPre')?.textContent || '').trim(); } catch(e){}
    setupVulnCatalog();
});

// Vulnerability catalog and UI helpers
async function setupVulnCatalog(){
        try {
                const res = await fetch('/vuln_catalog');
        if(res.ok){ window.VULN_CATALOG = await res.json(); }
    } catch(e) { window.VULN_CATALOG = { types: [], vectors: [], items: [] }; }
}

function populateVulnSelects() {
        document.querySelectorAll('.vuln-type').forEach(sel => {
                const sidx = parseInt(sel.getAttribute('data-scen-idx'));
                const sec = sel.getAttribute('data-sec');
                const iidx = parseInt(sel.getAttribute('data-item-idx'));
                const cur = (state.scenarios[sidx].sections[sec].items[iidx].v_type) || 'Random';
                const opts = ['Random', ...(window.VULN_CATALOG?.types || [])];
                sel.innerHTML = opts.map(o => `<option ${o===cur?'selected':''}>${o}</option>`).join('');
        });
        document.querySelectorAll('.vuln-vector').forEach(sel => {
                const sidx = parseInt(sel.getAttribute('data-scen-idx'));
                const sec = sel.getAttribute('data-sec');
                const iidx = parseInt(sel.getAttribute('data-item-idx'));
                const cur = (state.scenarios[sidx].sections[sec].items[iidx].v_vector) || 'Random';
                const opts = ['Random', ...(window.VULN_CATALOG?.vectors || [])];
                sel.innerHTML = opts.map(o => `<option ${o===cur?'selected':''}>${o}</option>`).join('');
        });
}

// Modal for Specific selection
function ensureVulnModal(){
        if(document.getElementById('vulnModal')) return;
        const modal = document.createElement('div');
        modal.className = 'modal fade';
        modal.id = 'vulnModal';
        modal.innerHTML = `
        <div class="modal-dialog modal-lg">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title">Select Vulnerability</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
                </div>
                <div class="modal-body">
                    <div id="vulnLoadingWrap" class="mb-3" style="display:none;">
                        <div class="d-flex align-items-center gap-2 mb-2 text-muted small">
                            <div class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></div>
                            <span id="vulnLoadMeta">Loading eligible items…</span>
                        </div>
                        <div class="progress" style="height: 14px;">
                            <div class="progress-bar" id="vulnLoadProgressBar" role="progressbar" style="width:0%" aria-valuenow="0" aria-valuemin="0" aria-valuemax="100">0%</div>
                        </div>
                    </div>
                    <div class="d-flex align-items-start gap-2 mb-2">
                        <div class="flex-grow-1">
                            <input class="form-control" placeholder="Filter (string or /regex/)" id="vulnFilter">
                            <div class="invalid-feedback" id="vulnFilterError">Invalid regex</div>
                        </div>
                        <button class="btn btn-outline-secondary" type="button" id="vulnFilterClear" title="Clear filter">Clear</button>
                    </div>
                    <div class="text-muted small mb-2" id="vulnFilterMeta"></div>
                    <div class="table-responsive" id="vulnTableWrap" style="max-height:50vh; overflow:auto; display:none;">
                        <table class="table table-sm">
                            <thead><tr><th>Name</th><th>Type</th><th>Vector</th><th>Path</th></tr></thead>
                            <tbody id="vulnList"></tbody>
                        </table>
                    </div>
                </div>
                <div class="modal-footer">
                    <button class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
                </div>
            </div>
        </div>`;
        document.body.appendChild(modal);
}

async function openVulnPicker(sidx, secName, iidx){
    ensureVulnModal();
    const modalEl = document.getElementById('vulnModal');
    if (!modalEl) {
        logError('Vulnerability modal element not found');
        return;
    }
    const modalObj = window.bootstrap ? (bootstrap.Modal.getInstance(modalEl) || new bootstrap.Modal(modalEl, { backdrop: true, keyboard: true })) : null;
    const filterInput = modalEl.querySelector('#vulnFilter');
    const filterClearBtn = modalEl.querySelector('#vulnFilterClear');
    const filterMeta = modalEl.querySelector('#vulnFilterMeta');
    const filterError = modalEl.querySelector('#vulnFilterError');
    const tbody = modalEl.querySelector('#vulnList');
    const tblWrap = modalEl.querySelector('#vulnTableWrap');
    const loadWrap = modalEl.querySelector('#vulnLoadingWrap');
    const loadBar = modalEl.querySelector('#vulnLoadProgressBar');
    const loadMeta = modalEl.querySelector('#vulnLoadMeta');
    const row = state.scenarios[sidx].sections[secName].items[iidx] || {};
    const selVector = (row.v_vector || 'Random');
    // Base: docker-compose only
    const all = (window.VULN_CATALOG?.items || []);
    let base = all.filter(it => (it.Type||'').toLowerCase() === 'docker-compose');
    if (selVector && selVector !== 'Random') {
        const vv = selVector.toLowerCase();
        base = base.filter(it => (it.Vector||'').toLowerCase() === vv);
    }
    // Do not compute eligibility; show immediately
    let eligible = base;
    try {
        if (modalObj) modalObj.show();
        if (loadWrap) loadWrap.style.display = 'none';
        if (tblWrap) tblWrap.style.display = '';
    } catch(e){}
    let current = eligible;
    const renderRows = () => {
        tbody.innerHTML = '';
        if (!current || current.length === 0) {
            const tr = document.createElement('tr');
            const td = document.createElement('td');
            td.colSpan = 4;
            td.className = 'text-center text-muted py-3';
            td.textContent = 'No results';
            tr.appendChild(td);
            tbody.appendChild(tr);
            return;
        }
        current.forEach((it) => {
            const tr = document.createElement('tr');
            tr.innerHTML = `<td>${it.Name}</td><td>${it.Type}</td><td>${it.Vector}</td><td>${it.Path}</td>`;
            tr.style.cursor = 'pointer';
            tr.onclick = () => {
                const item = state.scenarios[sidx].sections[secName].items[iidx];
                item.v_name = it.Name;
                item.v_path = it.Path;
                item.v_type = it.Type;
                item.v_vector = it.Vector;
                if (it.Description) item.v_desc = it.Description;
                // also set selected to Specific defensively
                item.selected = 'Specific';
                document.getElementById('scenarios_json').value = JSON.stringify({ scenarios: state.scenarios, active_index: activeIdx });
                try { if(window.bootstrap){ bootstrap.Modal.getInstance(modalEl)?.hide(); } } catch(e) {}
                renderMain();
            };
            tbody.appendChild(tr);
        });
    };
    const applyFilter = () => {
        const raw = (filterInput.value||'').trim();
        try { localStorage.setItem('vulnPickerFilter', raw); } catch(e){}
        filterInput.classList.remove('is-invalid');
        if (filterError) filterError.style.display = '';
        if(!raw){
            current = eligible;
            renderRows();
            if (filterMeta) filterMeta.textContent = `${current.length}/${eligible.length} shown`;
            return;
        }
        let matcher = null;
        if (raw.startsWith('/') && raw.endsWith('/') && raw.length >= 2) {
            try { matcher = new RegExp(raw.slice(1, -1), 'i'); } catch(e){ matcher = null; }
            if (!matcher) {
                filterInput.classList.add('is-invalid');
                if (filterMeta) filterMeta.textContent = `Invalid regex`;
                return;
            }
            current = eligible.filter((it) => {
                const haystack = `${it.Name||''} ${it.Type||''} ${it.Vector||''} ${it.Path||''}`;
                return matcher.test(haystack);
            });
        } else {
            const needle = raw.toLowerCase();
            current = eligible.filter((it) => {
                return [it.Name, it.Type, it.Vector, it.Path].some(val => (val||'').toLowerCase().includes(needle));
            });
        }
        renderRows();
        if (filterMeta) filterMeta.textContent = `${current.length}/${eligible.length} shown`;
    };
    filterInput.oninput = applyFilter;
    filterClearBtn.onclick = () => { filterInput.value = ''; applyFilter(); };
    // Load last-used filter, if any
    try {
        const saved = localStorage.getItem('vulnPickerFilter');
        if (saved) filterInput.value = saved;
    } catch(e){}
    // Render immediately and show counts
    try {
        renderRows();
        applyFilter();
    } catch(e){}
}

const RUN_CLI_URL = "{{ url_for('run_cli_async') }}";
const PUSH_REPO_URL = "{{ url_for('core_push_repo_route') }}";
const PUSH_REPO_STATUS_BASE = "{{ url_for('core_push_repo_status', progress_id='__PROGRESS__') }}";

function buildRunFormData(xmlPath, options = {}) {
    const form = new FormData();
    if (xmlPath) {
        form.append('xml_path', xmlPath);
    }
    appendScenarioContextToFormData(form, options);
    try {
        form.append('core_json', JSON.stringify(getCoreConfig(true)));
    } catch (err) {
        form.append('core_json', '{}');
    }
    if (options && options.updateRemoteRepo) {
        form.append('update_remote_repo', '1');
    }
    try {
        const adv = options && typeof options.advanced === 'object' ? options.advanced : null;
        if (adv && adv.fixDockerDaemon) form.append('adv_fix_docker_daemon', '1');
        if (adv && adv.runCoreCleanup) form.append('adv_run_core_cleanup', '1');
        if (adv && adv.checkCoreVersion) form.append('adv_check_core_version', '1');
        if (adv && adv.restartCoreDaemon) form.append('adv_restart_core_daemon', '1');
        if (adv && adv.autoKillSessions) form.append('adv_auto_kill_sessions', '1');
    } catch (err) { /* ignore */ }
    return form;
}

async function parseResponseJson(response) {
    if (!response || typeof response.clone !== 'function') {
        return null;
    }
    try {
        const text = await response.clone().text();
        if (!text) {
            return null;
        }
        return JSON.parse(text);
    } catch (err) {
        return null;
    }
}

async function extractResponseDetail(response) {
    if (!response) {
        return '';
    }
    const jsonData = await parseResponseJson(response);
    if (jsonData && typeof jsonData === 'object') {
        if (typeof jsonData.error === 'string' && jsonData.error.trim()) {
            return jsonData.error.trim();
        }
        try {
            return JSON.stringify(jsonData);
        } catch (err) {
            return '';
        }
    }
    try {
        const text = await response.clone().text();
        if (text && text.trim()) {
            return text.trim();
        }
    } catch (err) {
        return '';
    }
    const statusText = response.statusText ? ` ${response.statusText}` : '';
    return `HTTP ${response.status}${statusText}`.trim();
}

async function pushRepoToRemote(xmlPath, options = {}) {
    const formOptions = { ...options };
    const onProgress = typeof formOptions.onProgress === 'function' ? formOptions.onProgress : null;
    const onResponseProgress = typeof formOptions.onResponseProgress === 'function' ? formOptions.onResponseProgress : null;
    const onFinalizeProgress = typeof formOptions.onFinalizeProgress === 'function' ? formOptions.onFinalizeProgress : null;
    delete formOptions.onProgress;
    delete formOptions.onResponseProgress;
    delete formOptions.onFinalizeProgress;
    formOptions.updateRemoteRepo = false;
    const form = buildRunFormData(xmlPath, formOptions);
    logInfo('Uploading repository to CORE host…');
    if (typeof XMLHttpRequest === 'undefined') {
        // Fallback to fetch without rich progress reporting
        try {
            const res = await fetch(PUSH_REPO_URL, { method: 'POST', body: form });
            if (!res.ok) {
                const detail = await extractResponseDetail(res);
                const message = detail ? `Repo upload failed: ${detail}` : `Repo upload failed (HTTP ${res.status})`;
                logError(message);
                alert(message);
                return false;
            }
            const data = await parseResponseJson(res);
            const repoPath = data && typeof data === 'object' ? data.repo_path : null;
            const progressId = data && typeof data.progress_id === 'string' ? data.progress_id : null;
            logInfo(`Repository uploaded${repoPath ? ` to ${repoPath}` : ''}.`);
            if (progressId) {
                const finalized = await waitForRepoFinalize(progressId, { onProgress: onFinalizeProgress });
                if (!finalized) {
                    return false;
                }
            }
            return true;
        } catch (err) {
            const message = `Repo upload exception: ${err?.message || err}`;
            logError(message);
            alert(message);
            return false;
        }
    }
    const extractDetailFromXhr = (xhr) => {
        if (!xhr) {
            return '';
        }
        const response = xhr.response;
        if (response && typeof response === 'object') {
            if (typeof response.error === 'string' && response.error.trim()) {
                return response.error.trim();
            }
            try {
                return JSON.stringify(response);
            } catch (err) {
                return '';
            }
        }
        // NOTE: Some browsers throw if you read responseText when responseType !== ''/'text'.
        let text = '';
        try {
            if (!xhr.responseType || xhr.responseType === '' || xhr.responseType === 'text') {
                text = xhr.responseText || '';
            }
        } catch (err) {
            text = '';
        }
        if (text) {
            try {
                const parsed = JSON.parse(text);
                if (parsed && typeof parsed.error === 'string' && parsed.error.trim()) {
                    return parsed.error.trim();
                }
                return JSON.stringify(parsed);
            } catch (err) {
                return text.trim();
            }
        }
        return '';
    };
    return await new Promise((resolve) => {
        const xhr = new XMLHttpRequest();
        xhr.open('POST', PUSH_REPO_URL, true);
        xhr.responseType = 'json';
        if (xhr.upload && onProgress) {
            xhr.upload.onprogress = (event) => {
                if (!onProgress) {
                    return;
                }
                const loaded = event.loaded || 0;
                const total = event.lengthComputable ? event.total : null;
                const percent = total ? (loaded / total) * 100 : null;
                onProgress({ loaded, total, percent });
            };
        }
        if (onResponseProgress) {
            xhr.onprogress = (event) => {
                if (!onResponseProgress) {
                    return;
                }
                const loaded = event.loaded || 0;
                const total = event.lengthComputable ? event.total : null;
                const percent = total ? (loaded / total) * 100 : null;
                onResponseProgress({ loaded, total, percent });
            };
        }
        xhr.onerror = () => {
            const message = 'Repo upload exception: network error';
            logError(message);
            alert(message);
            resolve(false);
        };
        xhr.onreadystatechange = async () => {
            if (xhr.readyState !== XMLHttpRequest.DONE) {
                return;
            }
            if (xhr.status >= 200 && xhr.status < 300) {
                const data = xhr.response && typeof xhr.response === 'object' ? xhr.response : null;
                const repoPath = data && typeof data.repo_path === 'string' ? data.repo_path : null;
                const progressId = data && typeof data.progress_id === 'string' ? data.progress_id : null;
                logInfo(`Repository uploaded${repoPath ? ` to ${repoPath}` : ''}.`);
                if (progressId) {
                    const finalized = await waitForRepoFinalize(progressId, { onProgress: onFinalizeProgress });
                    if (!finalized) {
                        resolve(false);
                        return;
                    }
                }
                resolve(true);
                return;
            }
            const detail = extractDetailFromXhr(xhr);
            const message = detail ? `Repo upload failed: ${detail}` : `Repo upload failed (HTTP ${xhr.status})`;
            logError(message);
            alert(message);
            resolve(false);
        };
        try {
            xhr.send(form);
        } catch (err) {
            const message = `Repo upload exception: ${err?.message || err}`;
            logError(message);
            alert(message);
            resolve(false);
        }
    });
}

function buildRepoFinalizeStatusUrl(progressId) {
    if (!progressId || !PUSH_REPO_STATUS_BASE) {
        return null;
    }
    return PUSH_REPO_STATUS_BASE.replace('__PROGRESS__', encodeURIComponent(progressId));
}

async function waitForRepoFinalize(progressId, options = {}) {
    if (!progressId) {
        return true;
    }
    const onProgress = typeof options.onProgress === 'function' ? options.onProgress : null;
    const pollInterval = Math.max(500, options.intervalMs || 1500);
    const timeoutMs = Math.max(pollInterval * 20, options.timeoutMs || 240000);
    const started = Date.now();
    let consecutiveUnknown = 0;
    let lastProgressKey = '';
    const statusUrl = buildRepoFinalizeStatusUrl(progressId);
    if (!statusUrl) {
        onProgress?.({ status: 'error', detail: 'Missing finalize status endpoint.' });
        return false;
    }
    while (true) {
        let response = null;
        try {
            response = await fetch(statusUrl, { method: 'GET', cache: 'no-store' });
        } catch (err) {
            if (Date.now() - started > timeoutMs) {
                onProgress?.({ status: 'error', detail: `Finalize poll failed: ${err?.message || err}` });
                return false;
            }
            await new Promise((resolve) => setTimeout(resolve, pollInterval));
            continue;
        }
        if (response.status === 200) {
            const info = (await parseResponseJson(response)) || {};
            consecutiveUnknown = 0;
            try {
                const key = JSON.stringify({
                    status: info?.status || null,
                    stage: info?.stage || null,
                    detail: info?.detail || null,
                    percent: (info?.percent !== undefined && info?.percent !== null) ? Number(info.percent) : null,
                });
                if (key != lastProgressKey) {
                    lastProgressKey = key;
                    onProgress?.(info);
                }
            } catch (e) {
                onProgress?.(info);
            }
            if (info.status === 'complete') {
                return true;
            }
            if (info.status === 'error') {
                return false;
            }
        } else if (response.status === 404) {
            consecutiveUnknown += 1;
            // Avoid spamming the same waiting message every poll.
            if (consecutiveUnknown === 1) {
                onProgress?.({ status: 'pending', stage: 'waiting', detail: 'Waiting for remote finalize tracker…' });
            }
            if (consecutiveUnknown >= 5) {
                onProgress?.({ status: 'error', detail: 'Remote finalize tracker unavailable.' });
                return false;
            }
        } else {
            const detail = await extractResponseDetail(response);
            onProgress?.({ status: 'error', detail: detail || `Finalize status failed (HTTP ${response.status})` });
            return false;
        }
        if (Date.now() - started > timeoutMs) {
            onProgress?.({ status: 'error', detail: 'Remote finalize timed out.' });
            return false;
        }
        await new Promise((resolve) => setTimeout(resolve, pollInterval));
    }
}

async function handleMissingRepoResponse(response, context = {}) {
    const info = await parseResponseJson(response);
    const repoPath = info?.missing_repo || context.repoPath || 'remote CORE workspace';
    const reason = info?.error || 'Remote repository missing on CORE host.';
    const canPush = info?.can_push_repo !== false;
    if (!canPush) {
        alert(reason);
        return false;
    }
    const message = `${reason}\n\nRemote path: ${repoPath}\n\nUpload the current repository snapshot now?`;
    const confirmed = window.confirm(message);
    if (!confirmed) {
        logInfo('Remote repo upload declined; run aborted.');
        return false;
    }
    const pushed = await pushRepoToRemote(context.xmlPath || info?.xml_path || null, {
        scenarioIndex: context.scenarioIndex,
        onFinalizeProgress: (progressInfo) => {
            if (progressInfo && progressInfo.detail) {
                logInfo(`Remote finalize: ${progressInfo.detail}`);
            }
        },
    });
    if (!pushed) {
        return false;
    }
    logInfo('Remote repository uploaded; retrying run start.');
    return true;
}

async function submitRunCliRequest(buildRequest, options = {}) {
    const logRunRequestDebug = (message) => {
        const line = `[ui] ${message}`;
        try {
            if (typeof executeProgressState !== 'undefined' && executeProgressState && executeProgressState.active) {
                appendExecuteProgressLog(line);
            } else if (typeof runProgressLogLine === 'function') {
                runProgressLogLine(line);
            } else {
                logInfo(line);
            }
        } catch (e) {}
    };
    const attempts = Math.max(1, options.maxAttempts || 2);
    for (let attempt = 0; attempt < attempts; attempt += 1) {
        let request = null;
        try {
            request = typeof buildRequest === 'function' ? buildRequest() : null;
        } catch (err) {
            logRunRequestDebug(`Run request build failed: ${err?.message || err}`);
            throw err;
        }
        if (!request || !request.body) {
            throw new Error('buildRequest must return an object with a body property');
        }
        const init = { method: 'POST', body: request.body };
        if (request.headers) {
            init.headers = request.headers;
        }
        logRunRequestDebug(`Submitting run request: POST ${RUN_CLI_URL || '(missing URL)'} (attempt ${attempt + 1}/${attempts})`);
        let slowTimer = null;
        try {
            slowTimer = window.setTimeout(() => {
                logRunRequestDebug(`Still waiting for run start response from ${RUN_CLI_URL || '(missing URL)'}…`);
            }, 5000);
        } catch (e) {}
        let res;
        try {
            res = await fetch(RUN_CLI_URL, init);
        } catch (err) {
            logRunRequestDebug(`Run request fetch failed: ${err?.message || err}`);
            throw err;
        } finally {
            try { if (slowTimer) window.clearTimeout(slowTimer); } catch (e) {}
        }
        // Handle daemon-missing prompt (backend returns 428 with can_auto_start hint)
        if (res.status === 428) {
            const info = await parseResponseJson(res);
            const canAuto = !!(info && info.can_auto_start);
            const startCommand = (info && info.start_command) || 'sudo systemctl start core-daemon';
            const msg = (info && info.error) || 'core-daemon is not running on the CORE host.';
            const prompt = canAuto
                ? `${msg}\n\nEnable auto-start (runs "${startCommand}") and retry now?`
                : `${msg}\n\nAuto-start is unavailable. Start core-daemon on the CORE host, then retry.`;
            if (typeof runProgressLogLine === 'function') {
                runProgressLogLine(`Daemon check: ${msg}. Attempted command: ${startCommand}`);
            } else {
                logInfo(`Daemon check: ${msg}. Attempted command: ${startCommand}`);
            }
            const proceed = canAuto ? window.confirm(prompt) : (alert(prompt), false);
            if (proceed) {
                enableAutoStartDaemonPreference();
                try { logInfo(`Auto-start permission enabled; retrying run launch with ${startCommand}.`); } catch (e) {}
                // Do not consume an attempt when auto-start was just enabled
                if (attempt > 0) {
                    attempt -= 1;
                } else {
                    attempt = -1;
                }
                continue;
            }
            try { logWarn(`Daemon check aborted: ${msg}`); } catch (e) {}
            return null;
        }
        if (res.status === 423) {
            const info = await parseResponseJson(res);
            const sessionCount = Number(info?.session_count) || 0;
            const hostPart = info && info.core_host ? String(info.core_host) : 'CORE host';
            const portPart = info && (info.core_port || info.core_port === 0)
                ? `:${info.core_port}`
                : '';
            const sessions = Array.isArray(info?.active_sessions) ? info.active_sessions : [];
            const detailLines = sessions.slice(0, 3).map((entry) => {
                const sid = entry && entry.id !== undefined ? `#${entry.id}` : '#?';
                const state = entry && entry.state ? String(entry.state) : 'UNKNOWN';
                const file = entry && entry.file ? String(entry.file) : '';
                return `• Session ${sid} (${state}${file ? ` • ${file}` : ''})`;
            }).join('\n');
            const messageParts = [info?.error || `A run is already active on ${hostPart}${portPart}. Finish the active CORE session before starting another.`];
            if (detailLines) {
                messageParts.push('', 'Active sessions:', detailLines);
            }
            const promptText = messageParts.join('\n') + `\n\nKill the active CORE session(s) and retry now?`;
            const proceed = window.confirm(promptText);
            if (!proceed) {
                try { logWarn(`Active CORE session detected; user declined kill (${sessionCount}).`); } catch (e) {}
                return null;
            }
            try {
                const killRes = await fetch('/core/kill_active_sessions_api', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ kill_all: true })
                });
                const killInfo = await parseResponseJson(killRes);
                if (!killRes.ok || !killInfo || killInfo.ok === false) {
                    const errs = Array.isArray(killInfo?.errors) ? killInfo.errors.join('; ') : (killInfo?.error || 'Unknown error');
                    window.alert(`Failed to kill active CORE session(s): ${errs}`);
                    return null;
                }
                try {
                    const deleted = Array.isArray(killInfo?.deleted) ? killInfo.deleted.length : 0;
                    logInfo(`Killed ${deleted} active CORE session(s); retrying run launch.`);
                } catch (e) {}
                // Do not consume an attempt when we killed sessions to unblock the run.
                if (attempt > 0) {
                    attempt -= 1;
                } else {
                    attempt = -1;
                }
                continue;
            } catch (e) {
                window.alert('Failed to kill active CORE session(s).');
                return null;
            }
        }
        // Handle multiple daemons detected (409 with daemon_conflict)
        if (res.status === 409) {
            const info = await parseResponseJson(res);
            if (info && info.daemon_conflict) {
                const pids = Array.isArray(info.daemon_pids) ? info.daemon_pids.join(', ') : '';
                const message = `${info.error || 'Multiple core-daemon processes detected.'}${pids ? `\n\nPIDs: ${pids}` : ''}`;
                alert(message);
                return null;
            }
        }
        if (res.status === 409) {
            const retry = await handleMissingRepoResponse(res, {
                xmlPath: request.xmlPath || options.xmlPath || null,
                repoPath: request.repoPath,
                scenarioIndex: request.scenarioIndex ?? options.scenarioIndex ?? null,
            });
            if (retry) {
                continue;
            }
            return null;
        }
        return res;
    }
    logWarn('Exceeded automatic repository sync attempts; aborting run.');
    alert('Unable to start run until the repository is uploaded to the CORE host.');
    return null;
}


async function runAsync() {
    let rp = state.result_path || '';
    if (!rp.endsWith('.xml')) {
        const go = window.confirm('Your XML has not been saved. Save now and then run?');
        if (!go) { logInfo('Async run cancelled by user (declined save)'); return; }
        try {
            const ok = await saveXmlAjax();
            if (!ok) { logWarn('Save failed; aborting async run'); return; }
            rp = state.result_path || '';
            if (!rp.endsWith('.xml')) { logWarn('Save did not produce an XML path; aborting async run'); return; }
        } catch(e){ logError('Exception during auto-save; aborting async run'); return; }
    }
    const confirmMsg = 'This action will generate a new CORE scenario and attempt to start it asynchronously using the daemon connection.\n\nProceed?';
    if (!window.confirm(confirmMsg)) { logInfo('Async run cancelled by user at confirmation'); return; }
    const res = await submitRunCliRequest(() => ({ body: buildRunFormData(rp), xmlPath: rp }));
    if (!res) { logWarn('Async run aborted before launch'); return; }
    if (!res.ok) {
        const detail = await extractResponseDetail(res);
        alert(detail ? `Failed to start run: ${detail}` : 'Failed to start run');
        return;
    }
    const { run_id } = await res.json();
    logInfo(`Async run started id=${run_id}`);
    startLogStream(run_id);
    pollRunStatus(run_id);
}

// Save XML via JSON API without navigation
async function saveXmlAjax(){
    try {
        const payload = { scenarios: state.scenarios, core: getCoreConfig(true), active_index: activeIdx };
        if (state.base_upload) {
            payload.base_upload = state.base_upload;
        }
        const res = await fetch('/save_xml_api', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload)
        });
        if (!res.ok) { try { const err = await res.json(); logWarn('Save failed: ' + (err?.error || res.status)); } catch(e){ logWarn('Save failed'); } return false; }
        const data = await res.json();
        if (data && data.ok) {
            if (data.core) {
                state.core = normalizeCoreState(data.core, true);
                storeCorePasswordInSession();
            }
            if (data.result_path) {
                state.result_path = data.result_path;
            }
            try { updateDownloadButtonState(); } catch (err) {}
            persistEditorState();
            if (data.result_path) {
                logInfo('Scenarios saved to ' + data.result_path);
            } else {
                logInfo('Scenarios saved');
            }
            // Refresh XML preview lazily
            try {
                const xmlPre = document.getElementById('xmlPre');
                if (xmlPre && data.result_path) {
                    const txt = await (await fetch('/download_report?path=' + encodeURIComponent(data.result_path))).text();
                    xmlPre.textContent = txt;
                }
            } catch(e){}
            return true;
        }
        logWarn('Save did not return a valid path');
        return false;
    } catch(e) { logError('Save threw an exception'); return false; }
}

// Some flows historically used appendLog(level,msg) while the dock exposes logLine/logInfo/etc.
// Provide a compatibility shim so execution flows never crash on missing appendLog.

function dockLog(message, level = 'INFO') {
    const lvl = String(level || 'INFO').toUpperCase();
    const msg = String(message ?? '');
    try {
        if (typeof window.logLine === 'function') {
            window.logLine(lvl, msg);
            return;
        }
        if (lvl === 'ERROR' && typeof window.logError === 'function') {
            window.logError(msg);
            return;
        }
        if (lvl === 'WARN' && typeof window.logWarn === 'function') {
            window.logWarn(msg);
            return;
        }
        if (lvl === 'DEBUG' && typeof window.logDebug === 'function') {
            window.logDebug(msg);
            return;
        }
        if (typeof window.logInfo === 'function') {
            window.logInfo(msg);
            return;
        }
        if (typeof window.dispatchEvent === 'function' && typeof window.CustomEvent === 'function') {
            window.dispatchEvent(new CustomEvent('dock-log', { detail: { level: lvl, message: msg } }));
            return;
        }
    } catch (e) {}
    try {
        console.log(msg);
    } catch (e) {}
}

if (typeof window.appendLog !== 'function') {
    window.appendLog = dockLog;
}

let evtSrc = null;
function startLogStream(runId) {
    if (evtSrc) { try { evtSrc.close(); } catch(e){} }
    evtSrc = new EventSource('/stream/' + runId);
    // keep existing logs; do not auto-clear
    // Ensure dock is visible so users can see live logs
    try {
        const showBtn = document.getElementById('dockShowBtn');
        if (showBtn && !showBtn.classList.contains('d-none')) { showBtn.click(); }
    } catch(e){}
    // Toggle buttons
    document.getElementById('runAsyncBtn').classList.add('d-none');
    document.getElementById('runSyncBtn').classList.add('disabled');
    document.getElementById('cancelRunBtn').classList.remove('d-none');
    evtSrc.onmessage = (ev) => {
        const raw = ev.data || '';
        let lvl = 'INFO';
        if (/\bERROR\b/.test(raw)) lvl = 'ERROR';
        else if (/\bWARN(ING)?\b/.test(raw)) lvl = 'WARN';
        else if (/\bDEBUG\b/.test(raw)) lvl = 'DEBUG';
        dockLog(raw, lvl);
    };
    evtSrc.addEventListener('phase', (ev) => {
        try {
            const payload = JSON.parse(ev.data || '{}');
            // Only show phases if execute progress panel is open.
            handleExecuteProgressPhase(payload);
        } catch (e) {}
    });
    evtSrc.addEventListener('end', () => {
        evtSrc.close();
        document.getElementById('runAsyncBtn').classList.remove('d-none');
        document.getElementById('runSyncBtn').classList.remove('disabled');
        document.getElementById('cancelRunBtn').classList.add('d-none');
        logInfo('Async run ended');
    });
}

async function pollRunStatus(runId) {
    const xmlPre = document.getElementById('xmlPre');
    try {
    const res = await fetch('/run_status/' + runId);
        if (!res.ok) return;
        const data = await res.json();
        // Update download link
        const rp = data.report_path || data.xml_path;
        if (rp) { state.result_path = rp; persistEditorState(); }
        // Refresh XML preview if we have the xml path and it's changed
        if (data.xml_path && xmlPre && !xmlPre.textContent.trim()) {
                    try {
                        const txt = await (await fetch('/download_report?path=' + encodeURIComponent(data.xml_path))).text();
                        xmlPre.textContent = txt;
                    } catch(e){}
        }
        if (!data.done) {
            setTimeout(() => pollRunStatus(runId), 1000);
        } else {
            if (data.returncode === 0) {
                scheduleScenarioRedirect("{{ url_for('reports_page') }}", { delay: 500 });
            }
        }
    } catch(e) {
        // ignore transient errors
        setTimeout(() => pollRunStatus(runId), 1500);
    }
}

    async function cancelRun() {
        if (!evtSrc) return;
        // Extract runId from the EventSource URL
        const url = evtSrc.url;
        const runId = url.split('/').pop();
        try {
            await fetch('/cancel_run/' + runId, { method: 'POST' });
        } catch(e) {}
    try { evtSrc.close(); } catch(e){}
        document.getElementById('runAsyncBtn').classList.remove('d-none');
        document.getElementById('runSyncBtn').classList.remove('disabled');
        document.getElementById('cancelRunBtn').classList.add('d-none');
    logInfo('Run cancelled by user');
    }

// --- Run CLI via modal (async under the hood) ---
function ensureRunProgressModal(){
    if(!runProgressModalInst){
        const el = document.getElementById('runProgressModal');
        if(el){ runProgressModalInst = new bootstrap.Modal(el, { backdrop: 'static', keyboard: false }); }
    }
    return runProgressModalInst;
}

function markRunProgressComplete(){
    try {
        const hideBtn = document.getElementById('runProgressHideBtn');
        if (hideBtn) {
            hideBtn.textContent = 'Close';
            hideBtn.onclick = null;
        }
    } catch(e) {}
}
function runProgressLogLine(s){
    const pre = document.getElementById('runProgressLog');
    if(!pre) return;
    const line = (s||'');
    // Level detection first so we only log once with correct level
    let lvl = 'INFO';
    try {
        if(/\bERROR\b/.test(line)) lvl='ERROR';
        else if(/\bWARN(ING)?\b/.test(line)) lvl='WARN';
        else if(/\bDEBUG\b/.test(line)) lvl='DEBUG';
    } catch(e){}
    try {
        const text = line + '\n';
        if(typeof pre.append === 'function'){ pre.append(text); }
        else { pre.appendChild(document.createTextNode(text)); }
    } catch(e){}
    dockLog(line, lvl);
    pre.parentElement?.scrollTo({ top: pre.parentElement.scrollHeight });
    handleExecuteProgressLog(line);
}
function detectLocalEmulation(){
    const normalizeHost = (raw) => {
        if(raw === null || raw === undefined) return '';
        let h = String(raw).trim().toLowerCase();
        if(!h) return '';
        if(h.startsWith('[') && h.endsWith(']')){
            h = h.slice(1, -1);
        }
        if(h.startsWith('::ffff:') && /^::ffff:\d+\.\d+\.\d+\.\d+$/.test(h)){
            h = h.replace('::ffff:', '');
        }
        return h;
    };
    try {
        const hostRaw = (state?.core && state.core.host !== undefined) ? state.core.host : (initialPayload?.core?.host ?? 'localhost');
        let hostStr = (typeof hostRaw === 'string' && hostRaw.trim()) ? hostRaw.trim() : String(hostRaw ?? 'localhost');
        if(!hostStr) hostStr = 'localhost';
        const normHost = normalizeHost(hostStr);
        const isLoopback = !normHost || normHost === 'localhost' || normHost === '::1' || normHost === '0:0:0:0:0:0:0:1' || /^127(?:\.\d{1,3}){3}$/.test(normHost);
        const portRaw = (state?.core && state.core.port !== undefined) ? state.core.port : (initialPayload?.core?.port ?? 50051);
        const portNum = parseInt(portRaw, 10);
        const port = Number.isFinite(portNum) && portNum > 0 ? portNum : 50051;
        const testedHostRaw = (state?.core_tested_host !== undefined && state.core_tested_host !== null)
            ? state.core_tested_host
            : (initialPayload?.core_tested_host ?? null);
        const testedPortRaw = (state?.core_tested_port !== undefined && state.core_tested_port !== null)
            ? state.core_tested_port
            : (initialPayload?.core_tested_port ?? null);
        const normTestedHost = normalizeHost(testedHostRaw);
        const testedPortNum = parseInt(testedPortRaw ?? '', 10);
        const testedPort = Number.isFinite(testedPortNum) && testedPortNum > 0 ? testedPortNum : port;
        const testedMatches = !!normTestedHost && normTestedHost === normHost && testedPort === port;
        const hasVerifiedCore = !!state?.core_ok && testedMatches;
        const shouldFake = isLoopback && !hasVerifiedCore;
        return {
            shouldFake,
            isLoopback: !!isLoopback,
            verified: hasVerifiedCore,
            host: hostStr,
            port
        };
    } catch(e){
        return { shouldFake: false, isLoopback: false, verified: false, host: 'localhost', port: 50051 };
    }
}
function setRunProgressModeHint(message){
    const hintEl = document.getElementById('runProgressModeHint');
    if(!hintEl) return;
    if(message){
        hintEl.textContent = message;
        hintEl.classList.remove('d-none');
    } else {
        hintEl.textContent = '';
        hintEl.classList.add('d-none');
    }
}
function maybeShowLocalEmulationHint(){
    const info = detectLocalEmulation();
    if(info.shouldFake){
        setRunProgressModeHint(`LOCAL EMULATION • NO CONNECTED CORE SESSION`);
    } else if(info.verified){
        setRunProgressModeHint(`CONNECTED • CORE ${info.host}:${info.port}`);
    } else {
        setRunProgressModeHint('');
    }
}
function openRunProgress(title){
    const modalEl = document.getElementById('runProgressModal');
    ensureRunProgressModal();
    try {
        if(title) document.querySelector('#runProgressModal .modal-title').textContent = title;
        document.getElementById('runProgressStatus').textContent = 'Starting…';
        document.getElementById('runProgressMeta').textContent = '';
        document.getElementById('runProgressBar').classList.add('progress-bar-animated');
        setRunProgressModeHint('');
        const logEl = document.getElementById('runProgressLog');
        if(logEl) logEl.textContent = '';
    // Do NOT clear persistent log buffer; just re-render existing lines
    if(typeof renderDockLog === 'function'){ renderDockLog(); }
        // Reset footer buttons to default state
        const hideBtn = document.getElementById('runProgressHideBtn');
        if (hideBtn) {
            hideBtn.textContent = 'Hide';
            hideBtn.onclick = null; // remove any prior navigation handler
        }
        runProgressModalInst?.show();
    } catch(e){}
    try {
        if(modalEl && !modalEl.classList.contains('show')){
            modalEl.style.display = 'block';
            modalEl.removeAttribute('aria-hidden');
            modalEl.classList.add('show');
            if(!document.body.classList.contains('modal-open')){
                document.body.classList.add('modal-open');
                document.body.style.removeProperty('paddingRight');
                document.body.style.removeProperty('overflow');
            }
            if(!document.querySelector('.modal-backdrop')){
                const backdrop = document.createElement('div');
                backdrop.className = 'modal-backdrop fade show';
                document.body.appendChild(backdrop);
            }
        }
    } catch(e){}
}
function closeRunProgress(){
    try { if(runProgressEvtSrc) runProgressEvtSrc.close(); } catch(e){}
    runProgressEvtSrc = null;
    runProgressRunId = null;
    try { runProgressModalInst?.hide(); } catch(e){}
    try {
        const modalEl = document.getElementById('runProgressModal');
        if(modalEl){
            modalEl.classList.remove('show');
            modalEl.style.removeProperty('display');
            modalEl.setAttribute('aria-hidden','true');
        }
        const openModals = document.querySelectorAll('.modal.show');
        if(openModals.length === 0){
            document.querySelectorAll('.modal-backdrop').forEach(b => {
                try { b.remove(); } catch(_e){}
            });
            document.body.classList.remove('modal-open');
            document.body.style.removeProperty('paddingRight');
            document.body.style.removeProperty('overflow');
        }
    } catch(e){}
}
async function runSyncWithModal(arg){
    let opts = {};
    if(arg && typeof arg === 'object' && typeof arg.preventDefault === 'function'){
        arg.preventDefault();
    } else if(arg && typeof arg === 'object'){
        opts = arg;
    }
    const showProgressModal = opts.showProgressModal !== false;
    const skipConfirm = opts.skipConfirm === true;
    const activeScenarioCtx = getActiveScenarioContext();
    let scenarioIndexForRun = Number.isInteger(opts.scenarioIndex) ? opts.scenarioIndex : activeScenarioCtx.idx;
    let updateRemoteRepo = opts.updateRemoteRepo === true;
    // Some entrypoints perform confirmation externally and call with skipConfirm=true.
    // In that case, advanced selections must be passed in via opts.confirmResult or opts.advanced.
    let confirmResult = (opts && typeof opts === 'object' && opts.confirmResult) ? opts.confirmResult : null;
    const advancedFromOpts = (opts && typeof opts === 'object' && opts.advanced) ? opts.advanced : null;
    let waitingForRemoteLogs = false;
    let uploadHeartbeatTimer = null;
    let uploadStartTime = null;
    let uploadFinalizeStart = null;
    let lastUploadStats = null;
    let lastResponseStats = null;
    let lastLoggedUploadPercent = null;
    let lastLoggedUploadBytes = null;
    let lastLoggedResponsePercent = null;
    let lastLoggedResponseBytes = null;
    let uploadDelivered = false;
    let uploadRequestComplete = false;
    let lastFinalizeLogTs = null;
    let lastProgressPercent = 0;
    let lastFinalizeDetail = null;
    let finalizeAnnounced = false;
    let lastFinalizeInfo = null;
    const updateRunStatus = (status, meta) => {
        if (executeProgressState.active) {
            setExecuteProgressStatus(status, meta);
        } else if (showProgressModal) {
            const statusEl = document.getElementById('runProgressStatus');
            if (statusEl) statusEl.textContent = status || '';
            const metaEl = document.getElementById('runProgressMeta');
            if (metaEl) metaEl.textContent = meta || '';
        }
    };
    const appendExecuteDialogLog = (message) => {
        const line = `[ui] ${message}`;
        appendExecuteProgressLog(line, { mirrorToDock: !showProgressModal });
        if (showProgressModal) {
            runProgressLogLine(line);
        }
    };
    appendExecuteDialogLog('runSyncWithModal() entered.');
    const stopUploadHeartbeat = () => {
        if (uploadHeartbeatTimer) {
            clearInterval(uploadHeartbeatTimer);
            uploadHeartbeatTimer = null;
        }
        lastFinalizeLogTs = null;
    };
    const startUploadHeartbeat = () => {
        if (uploadHeartbeatTimer) {
            return;
        }
        uploadStartTime = Date.now();
        uploadHeartbeatTimer = window.setInterval(() => {
            const now = Date.now();
            const elapsedSec = Math.round((now - (uploadStartTime || now)) / 1000);
            if (uploadDelivered) {
                const finalizeElapsed = uploadFinalizeStart ? Math.round((now - uploadFinalizeStart) / 1000) : elapsedSec;
                if (!lastFinalizeLogTs || (now - lastFinalizeLogTs) >= 12000) {
                    lastFinalizeLogTs = now;
                    const suffix = lastFinalizeDetail ? ` (${lastFinalizeDetail})` : '';
                    const percent = lastFinalizeInfo && typeof lastFinalizeInfo.percent === 'number'
                        ? Math.max(0, Math.min(100, lastFinalizeInfo.percent))
                        : null;
                    const percentSuffix = percent !== null ? ` [server: ${percent.toFixed(0)}%]` : '';
                    let staleSuffix = '';
                    try {
                        const updatedAt = lastFinalizeInfo && typeof lastFinalizeInfo.updated_at === 'number' ? lastFinalizeInfo.updated_at : null;
                        if (updatedAt) {
                            const ageSec = Math.max(0, Math.round(now / 1000 - updatedAt));
                            staleSuffix = ` [last update: ${ageSec}s ago]`;
                        }
                    } catch (e) {}
                    appendExecuteDialogLog(`Waiting for CORE host to finalize (${finalizeElapsed}s)${suffix}${percentSuffix}${staleSuffix}.`);
                }
                // Keep the status/meta line accurate while waiting.
                try {
                    const parts = [];
                    if (lastFinalizeDetail) parts.push(lastFinalizeDetail);
                    if (lastUploadStats) {
                        const loaded = lastUploadStats.loaded || 0;
                        const total = lastUploadStats.total || null;
                        if (total) parts.push(`upload: ${formatBytes(loaded)} / ${formatBytes(total)}`);
                        else if (loaded) parts.push(`upload: ${formatBytes(loaded)} transferred`);
                    }
                    if (lastResponseStats) {
                        const loaded = lastResponseStats.loaded || 0;
                        const total = lastResponseStats.total || null;
                        if (total) parts.push(`response: ${formatBytes(loaded)} / ${formatBytes(total)}`);
                        else if (loaded) parts.push(`response: ${formatBytes(loaded)} received`);
                    }
                    updateRunStatus('Finishing repository sync… (this may take a few minutes)', parts.length ? parts.join(' | ') : 'Remote finalize in progress…');
                } catch (e) {}
                return;
            }
            if (uploadRequestComplete) {
                // Browser finished sending bytes, but the server is still packaging/uploading to CORE host.
                // This can take a while, so keep the log and status line honest.
                const phaseElapsed = uploadFinalizeStart ? Math.round((now - uploadFinalizeStart) / 1000) : elapsedSec;
                let uploadDetail = '';
                if (lastUploadStats) {
                    const loaded = lastUploadStats.loaded || 0;
                    const total = lastUploadStats.total || null;
                    if (total) {
                        uploadDetail = `${formatBytes(loaded)} / ${formatBytes(total)}`;
                    } else if (loaded) {
                        uploadDetail = `${formatBytes(loaded)} transferred`;
                    }
                }
                let responseDetail = '';
                if (lastResponseStats) {
                    const loaded = lastResponseStats.loaded || 0;
                    const total = lastResponseStats.total || null;
                    if (total) {
                        responseDetail = `${formatBytes(loaded)} / ${formatBytes(total)}`;
                    } else if (loaded) {
                        responseDetail = `${formatBytes(loaded)} received`;
                    }
                }
                const uploadSuffix = uploadDetail ? ` [upload: ${uploadDetail}]` : '';
                const responseSuffix = responseDetail ? ` [response: ${responseDetail}]` : '';
                appendExecuteDialogLog(`Repository upload request complete; server preparing snapshot (${phaseElapsed}s)${uploadSuffix}${responseSuffix}.`);
                try {
                    const parts = [];
                    if (lastUploadStats) parts.push(uploadDetail ? `upload: ${uploadDetail}` : 'upload: complete');
                    if (responseDetail) parts.push(`response: ${responseDetail}`);
                    updateRunStatus('Preparing repository snapshot…', parts.filter(Boolean).join(' | ') || 'Server preparing snapshot…');
                } catch (e) {}
                return;
            }
            let detail = 'transferring…';
            if (lastUploadStats) {
                const loaded = lastUploadStats.loaded || 0;
                if (lastUploadStats.total) {
                    detail = `${formatBytes(loaded)} / ${formatBytes(lastUploadStats.total)}`;
                } else if (loaded) {
                    detail = `${formatBytes(loaded)} transferred`;
                }
                if (typeof lastUploadStats.percent === 'number') {
                    detail += ` (${lastUploadStats.percent.toFixed(1)}%)`;
                }
            }
            appendExecuteDialogLog(`Repository upload still running (${elapsedSec}s): ${detail}`);
        }, 4000);
    };
    const logUploadSnapshot = (info) => {
        if (!info) {
            return;
        }
        const loaded = info.loaded || 0;
        const total = info.total || null;
        const percent = typeof info.percent === 'number' ? Math.max(0, Math.min(100, info.percent)) : null;
        if (percent !== null) {
            if (lastLoggedUploadPercent === null || Math.abs(percent - lastLoggedUploadPercent) >= 5) {
                const detail = total ? `${formatBytes(loaded)} / ${formatBytes(total)}` : `${formatBytes(loaded)} transferred`;
                appendExecuteDialogLog(`Repository upload ${percent.toFixed(1)}% (${detail})`);
                lastLoggedUploadPercent = percent;
            }
        } else if (loaded) {
            if (lastLoggedUploadBytes === null || (loaded - lastLoggedUploadBytes) >= (5 * 1024 * 1024)) {
                appendExecuteDialogLog(`Repository upload transferred ${formatBytes(loaded)}…`);
                lastLoggedUploadBytes = loaded;
            }
        }
    };
    const setUploadProgressValue = (percent, label) => {
        if (typeof percent !== 'number' || Number.isNaN(percent)) {
            return;
        }
        const clamped = Math.max(0, Math.min(100, percent));
        const pctValue = Math.max(clamped, lastProgressPercent || 0);
        lastProgressPercent = pctValue;
        if (executeProgressState.active) {
            setExecuteProgressPercent(pctValue, label || `${pctValue.toFixed(1)}%`);
        } else if (showProgressModal) {
            const bar = document.getElementById('runProgressBar');
            if (bar) {
                const pctText = pctValue.toFixed(1).replace(/\.0$/, '');
                bar.style.width = `${pctValue.toFixed(1)}%`;
                bar.textContent = label || `${pctText}%`;
            }
        }
    };
    const handleRepoUploadProgress = (info) => {
        if (!info) return;
        lastUploadStats = info;
        startUploadHeartbeat();
        const loaded = info.loaded || 0;
        const total = info.total || null;
        const percentRaw = typeof info.percent === 'number' ? info.percent : null;
        const percent = percentRaw !== null ? Math.max(0, Math.min(100, percentRaw)) : null;
        try {
            const totalComplete = total && loaded >= total;
            const percentComplete = percent !== null && percent >= 99.9;
            if (totalComplete || percentComplete) {
                uploadRequestComplete = true;
                if (!uploadFinalizeStart) {
                    uploadFinalizeStart = Date.now();
                }
            }
        } catch (e) {}
        let meta = `${formatBytes(loaded)} transferred`;
        if (total) {
            meta = `${formatBytes(loaded)} / ${formatBytes(total)}`;
            if (percent !== null) {
                meta += ` (${percent.toFixed(1)}%)`;
            }
        }
        updateRunStatus('Copying repository…', meta);
        if (percent !== null) {
            setUploadProgressValue(percent, `${percent.toFixed(1)}%`);
        }
        logUploadSnapshot(info);
    };

    const handleRepoResponseProgress = (info) => {
        if (!info) return;
        lastResponseStats = info;
        // Only log occasionally to avoid spamming.
        const percentRaw = typeof info.percent === 'number' ? info.percent : null;
        const percent = percentRaw !== null ? Math.max(0, Math.min(100, percentRaw)) : null;
        const loaded = info.loaded || 0;
        const total = info.total || null;
        if (percent !== null) {
            if (lastLoggedResponsePercent === null || Math.abs(percent - lastLoggedResponsePercent) >= 10) {
                const detail = total ? `${formatBytes(loaded)} / ${formatBytes(total)}` : `${formatBytes(loaded)} received`;
                appendExecuteDialogLog(`Repository response ${percent.toFixed(1)}% (${detail})`);
                lastLoggedResponsePercent = percent;
            }
        } else if (loaded) {
            if (lastLoggedResponseBytes === null || (loaded - lastLoggedResponseBytes) >= (2 * 1024 * 1024)) {
                appendExecuteDialogLog(`Repository response received ${formatBytes(loaded)}…`);
                lastLoggedResponseBytes = loaded;
            }
        }
    };
    const handleFinalizeProgress = (info) => {
        if (!info || typeof info !== 'object') {
            return;
        }
        lastFinalizeInfo = info;
        // Finalize polling only starts after the server has received the upload and returned a progress id.
        // This is the most reliable moment to switch the UI from "uploading" to "finalizing".
        if (!uploadDelivered) {
            uploadDelivered = true;
            uploadFinalizeStart = Date.now();
            lastFinalizeLogTs = Date.now();
        }
        const status = info.status || 'pending';
        const detail = info.detail || info.stage || 'Remote finalize in progress…';
        const percent = typeof info.percent === 'number' ? Math.max(0, Math.min(100, info.percent)) : null;
        if (!finalizeAnnounced) {
            finalizeAnnounced = true;
            let uploadDetail = '';
            if (lastUploadStats) {
                const loaded = lastUploadStats.loaded || 0;
                const total = lastUploadStats.total || null;
                if (total) uploadDetail = `${formatBytes(loaded)} / ${formatBytes(total)}`;
                else if (loaded) uploadDetail = `${formatBytes(loaded)} transferred`;
            }
            const suffix = uploadDetail ? ` (${uploadDetail})` : '';
            appendExecuteDialogLog(`Remote host is finalizing${suffix}.`);
        }
        if (detail && detail !== lastFinalizeDetail) {
            lastFinalizeDetail = detail;
            const pctText = percent !== null ? ` (${percent.toFixed(0)}%)` : '';
            appendExecuteDialogLog(`Remote finalize: ${detail}${pctText}`);
        }
        if (detail) {
            updateRunStatus('Finishing repository sync… (this may take a few minutes)', detail);
        }
        if (percent !== null) {
            setUploadProgressValue(percent, `${percent.toFixed(0)}%`);
        }
        if (status === 'error') {
            logError('Remote finalize reported an error; check server logs for details.');
        }
        if (status === 'complete') {
            stopUploadHeartbeat();
        }
    };
    // Validate saved XML
    let rp = state.result_path || '';
    if (!rp.endsWith('.xml')) {
        const go = window.confirm('Your XML has not been saved. Save now and then run?');
        if (!go) { logInfo('Run CLI cancelled by user (declined save)'); return false; }
        try {
            const ok = await saveXmlAjax();
            if (!ok) { logWarn('Save failed; aborting run'); return false; }
            rp = state.result_path || '';
            if (!rp.endsWith('.xml')) { logWarn('Save did not produce an XML path; aborting run'); return false; }
        } catch(e){ logError('Exception during auto-save; aborting run'); return false; }
    }
    const execInfo = detectLocalEmulation();
    const confirmMsg = 'This will generate a CORE scenario and attempt to start it. Proceed?';
    if (!skipConfirm) {
        confirmResult = await promptExecuteConfirmation({
            message: confirmMsg,
            scenarioIndex: scenarioIndexForRun,
            alertMessage: '',
            alertTone: 'info',
        });
        if (!confirmResult?.confirmed) {
            logInfo('Run CLI cancelled by user at confirmation');
            return false;
        }
        if (Number.isInteger(confirmResult.scenarioIndex)) {
            scenarioIndexForRun = confirmResult.scenarioIndex;
        }
        if (confirmResult.updateRemote) {
            updateRemoteRepo = true;
        }
    }
    if(showProgressModal){
        openRunProgress('Running CLI…');
        maybeShowLocalEmulationHint();
    }
    if(updateRemoteRepo){
        appendExecuteDialogLog('Repository sync requested by user.');
        updateRunStatus('Copying repository…', 'Uploading repository snapshot to CORE host…');
        if (executeProgressState.active) {
            stopExecuteProgressHeartbeat();
            setExecuteProgressPercent(0, '0%');
        } else if (showProgressModal) {
            const bar = document.getElementById('runProgressBar');
            if (bar) {
                bar.classList.add('progress-bar-animated');
                bar.classList.add('progress-bar-striped');
                bar.style.width = '0%';
                bar.textContent = '0%';
            }
        }
        startUploadHeartbeat();
        try {
            const pushed = await pushRepoToRemote(rp, {
                scenarioIndex: scenarioIndexForRun,
                onProgress: handleRepoUploadProgress,
                onResponseProgress: handleRepoResponseProgress,
                onFinalizeProgress: handleFinalizeProgress,
            });
            if(!pushed){
                appendExecuteDialogLog('Repository upload failed; aborting run.');
                updateRunStatus('Repository sync failed', 'Upload failed; canceling run.');
                stopUploadHeartbeat();
                if(executeProgressState.active){
                    completeExecuteProgressPanel(false, 'Repository sync failed', 'Upload failed; canceling run.');
                } else if(showProgressModal){
                    const bar = document.getElementById('runProgressBar');
                    if(bar){
                        bar.classList.remove('progress-bar-animated');
                        bar.textContent = 'Error';
                    }
                }
                return false;
            }
            stopUploadHeartbeat();
            const elapsedSec = uploadStartTime ? Math.round((Date.now() - uploadStartTime) / 1000) : null;
            let summaryDetail = 'Repository upload complete.';
            if (lastUploadStats) {
                const loaded = lastUploadStats.loaded || 0;
                const total = lastUploadStats.total || null;
                const portion = total ? `${formatBytes(loaded)} / ${formatBytes(total)}` : `${formatBytes(loaded)} transferred`;
                summaryDetail = `Repository upload complete (${portion}${elapsedSec ? ` in ${elapsedSec}s` : ''}).`;
            } else if (elapsedSec) {
                summaryDetail = `Repository upload complete in ${elapsedSec}s.`;
            }
            appendExecuteDialogLog(summaryDetail);
            updateRunStatus('Repository copied', 'Preparing remote workspace…');
            setUploadProgressValue(100, 'Upload complete');
            updateRemoteRepo = false;
        } catch(err) {
            appendExecuteDialogLog(`Repository upload exception: ${err?.message || err}`);
            updateRunStatus('Repository sync failed', 'Exception during upload.');
            stopUploadHeartbeat();
            if(executeProgressState.active){
                completeExecuteProgressPanel(false, 'Repository sync failed', 'Exception during upload.');
            } else if(showProgressModal){
                const bar = document.getElementById('runProgressBar');
                if(bar){
                    bar.classList.remove('progress-bar-animated');
                    bar.textContent = 'Error';
                }
            }
            return false;
        }
    }
    try {
        // Ensure dock is visible
        try {
            const showBtn = document.getElementById('dockShowBtn');
            if (showBtn && !showBtn.classList.contains('d-none')) { showBtn.click(); }
        } catch(e){}
        appendExecuteDialogLog('Requesting remote CLI run…');
        appendExecuteDialogLog(`RUN_CLI_URL=${RUN_CLI_URL || '(missing)'}`);
        updateRunStatus('Preparing remote workspace…', 'Submitting run request to CORE host…');
        const formOptions = { updateRemoteRepo };
        if (Number.isInteger(scenarioIndexForRun)) {
            formOptions.scenarioIndex = scenarioIndexForRun;
        }
        if (confirmResult && typeof confirmResult === 'object' && confirmResult.advanced) {
            formOptions.advanced = confirmResult.advanced;
        } else if (advancedFromOpts && typeof advancedFromOpts === 'object') {
            formOptions.advanced = advancedFromOpts;
        }
        const res = await submitRunCliRequest(() => ({ body: buildRunFormData(rp, formOptions), xmlPath: rp, scenarioIndex: scenarioIndexForRun }));
        if (res) {
            appendExecuteDialogLog(`Remote CLI request completed (HTTP ${res.status}).`);
        }
        if(!res){
            runProgressLogLine('Run start aborted.');
            if(showProgressModal){
                try {
                    const statusEl = document.getElementById('runProgressStatus');
                    if(statusEl) statusEl.textContent = 'Aborted';
                    const metaEl = document.getElementById('runProgressMeta');
                    if(metaEl) metaEl.textContent = 'Repository upload required';
                    const bar = document.getElementById('runProgressBar');
                    if(bar){ bar.classList.remove('progress-bar-animated'); bar.textContent = 'Aborted'; }
                    markRunProgressComplete();
                } catch(e){}
            }
            try { opts.onError?.(new Error('Run aborted before launch')); } catch(e){}
            return false;
        }
        if(!res.ok){
            const detail = await extractResponseDetail(res);
            const message = detail || `HTTP ${res.status}`;
            runProgressLogLine('Failed to start CLI' + (detail ? `: ${detail}` : ''));
            if(showProgressModal){
                try {
                    const statusEl = document.getElementById('runProgressStatus');
                    if(statusEl) statusEl.textContent = 'Failed to start';
                    const metaEl = document.getElementById('runProgressMeta');
                    if(metaEl) metaEl.textContent = message;
                    const bar = document.getElementById('runProgressBar');
                    if(bar){ bar.classList.remove('progress-bar-animated'); bar.textContent = 'Error'; }
                    markRunProgressComplete();
                } catch(e){}
            }
            try { opts.onError?.(new Error(message)); } catch(e){}
            return false;
        }
        const dataInit = await res.json();
        const run_id = dataInit?.run_id;
        if(run_id){
            runProgressRunId = run_id;
            waitingForRemoteLogs = true;
            appendExecuteDialogLog(`Remote CLI run id ${run_id} acknowledged; waiting for logs…`);
            updateRunStatus('Remote CLI starting…', 'Waiting for remote logs…');
            try { opts.onRunId?.(run_id); } catch(e){}
        }
        if(!run_id){
            runProgressLogLine('Execution start response missing run_id');
            if(showProgressModal){
                try {
                    const statusEl = document.getElementById('runProgressStatus');
                    if(statusEl) statusEl.textContent = 'Failed to start';
                    const metaEl = document.getElementById('runProgressMeta');
                    if(metaEl) metaEl.textContent = 'Missing run id';
                    const bar = document.getElementById('runProgressBar');
                    if(bar){ bar.classList.remove('progress-bar-animated'); bar.textContent = 'Error'; }
                    markRunProgressComplete();
                } catch(e){}
            }
            try { opts.onError?.(new Error('Missing run id')); } catch(e){}
            return false;
        }
        // No Cancel button in modal; runs cannot be cancelled here
        // Start SSE stream into modal
        try { if(runProgressEvtSrc) runProgressEvtSrc.close(); } catch(e){}
        runProgressEvtSrc = new EventSource('/stream/' + run_id);
        appendExecuteDialogLog('Subscribed to remote log stream. Awaiting first line…');
        runProgressEvtSrc.addEventListener('phase', (ev) => {
            try {
                const payload = JSON.parse(ev.data || '{}');
                handleExecuteProgressPhase(payload);
            } catch (e) {}
        });
        runProgressEvtSrc.onmessage = (ev)=>{
            if (waitingForRemoteLogs) {
                waitingForRemoteLogs = false;
                appendExecuteDialogLog('First remote log line received.');
                updateRunStatus('Running CLI…', 'Streaming remote logs…');
            }
            runProgressLogLine(ev.data||'');
        };
        runProgressEvtSrc.addEventListener('end', ()=>{
            waitingForRemoteLogs = false;
            try { runProgressEvtSrc.close(); } catch(e){}
            logInfo('Run (modal) ended');
        });
        // Poll for completion and update meta
        return await new Promise((resolve) => {
            (async function poll(){
                try{
                    const r = await fetch('/run_status/' + run_id);
                    if(!r.ok){ setTimeout(poll, 1200); return; }
                    const data = await r.json();
                    if(data.report_path || data.xml_path){
                        state.result_path = data.report_path || data.xml_path;
                        persistEditorState();
                    }
                    if(showProgressModal){
                        const metaEl = document.getElementById('runProgressMeta');
                        if(metaEl){ metaEl.textContent = data.done ? (data.returncode===0 ? 'Completed' : 'Failed') : 'Running…'; }
                    } else {
                        try { opts.onTick?.(data); } catch(e){}
                    }
                    if(!data.done){ setTimeout(poll, 1000); return; }
                    if(showProgressModal){
                        document.getElementById('runProgressStatus').textContent = (data.returncode===0) ? 'Scenario started' : 'Finished with errors';
                        document.getElementById('runProgressBar').classList.remove('progress-bar-animated');
                        markRunProgressComplete();
                    }
                    try { opts.onComplete?.(data); } catch(e){}
                    try {
                        if (data.returncode === 0) {
                            scheduleScenarioRedirect("{{ url_for('reports_page') }}", { delay: 500 });
                        }
                    } catch(e){}
                    resolve(data);
                } catch(e){ setTimeout(poll, 1500); }
            })();
        });
    } catch(e){
        runProgressLogLine('Exception starting CLI');
        try { if(!showProgressModal) opts.onError?.(e); } catch(_){}
        throw e;
    }
}

// Run deterministically with a seed (preview seed or input)
async function runWithSeedBuild(){
    // Ensure XML is saved
    let rp = state.result_path || '';
    if(!rp.endsWith('.xml')){
        const go = window.confirm('XML not saved yet. Save now?');
        if(!go) return;
        const saved = await saveXmlAjax();
        if(!saved){ alert('Auto-save failed; cannot run.'); return; }
        rp = state.result_path || '';
        if(!rp.endsWith('.xml')){ alert('Saved XML path unresolved.'); return; }
    }
    // Derive seed: prefer explicit input, else current preview seed
    // seedInputEl removed
    let seedVal = null;
    if(seedInputEl && seedInputEl.value.trim()){
        const num = parseInt(seedInputEl.value.trim(),10); if(!isNaN(num) && num>0) seedVal = num;
    } else if(previewState.fullPreview && previewState.fullPreview.seed){
        seedVal = previewState.fullPreview.seed;
    }
    if(seedVal===null){
        alert('Enter a seed or generate a Full Preview (which records a seed) first.');
        return;
    }
    const execInfo = detectLocalEmulation();
    const confirmMsg = `Run CLI with seed=${seedVal}? This will start a CORE session.`;
    const { idx: scenarioIdx } = getActiveScenarioContext();
    const confirmResult = await promptExecuteConfirmation({
        message: confirmMsg,
        scenarioIndex: scenarioIdx,
        alertMessage: '',
        alertTone: 'info',
        confirmLabel: 'Run with seed',
    });
    if(!confirmResult?.confirmed) return;
    const updateRemoteRepo = !!confirmResult?.updateRemote;
    const advancedSelections = (confirmResult && typeof confirmResult === 'object' && confirmResult.advanced) ? confirmResult.advanced : null;
    let sendUpdateRemoteFlag = updateRemoteRepo;
    let waitingForSeedLogs = false;
    openRunProgress('Running CLI (seed='+seedVal+')…');
    maybeShowLocalEmulationHint();
    const updateSeedUploadProgress = (info) => {
        if (!info) return;
        const loaded = info.loaded || 0;
        const total = info.total || null;
        const percent = typeof info.percent === 'number' ? info.percent : null;
        const statusEl = document.getElementById('runProgressStatus');
        if(statusEl) statusEl.textContent = 'Copying repository…';
        const metaEl = document.getElementById('runProgressMeta');
        if(metaEl){
            if(total){
                const base = `${formatBytes(loaded)} / ${formatBytes(total)}`;
                metaEl.textContent = percent !== null ? `${base} (${percent.toFixed(1)}%)` : base;
            } else {
                metaEl.textContent = `${formatBytes(loaded)} transferred`;
            }
        }
        const bar = document.getElementById('runProgressBar');
        if(bar && percent !== null){
            const clamped = Math.max(0, Math.min(100, percent));
            bar.style.width = `${clamped.toFixed(1)}%`;
            bar.textContent = `${clamped.toFixed(1)}%`;
        }
    };
    let lastSeedFinalizeDetail = null;
    const handleSeedFinalizeProgress = (info) => {
        if (!info || typeof info !== 'object') {
            return;
        }
        const detail = info.detail || info.stage || 'Remote finalize in progress…';
        const percent = typeof info.percent === 'number' ? Math.max(0, Math.min(100, info.percent)) : null;
        if (detail && detail !== lastSeedFinalizeDetail) {
            lastSeedFinalizeDetail = detail;
            runProgressLogLine(`[ui] Remote finalize: ${detail}${percent !== null ? ` (${percent.toFixed(0)}%)` : ''}`);
        }
        const metaEl = document.getElementById('runProgressMeta');
        if (metaEl && detail) {
            metaEl.textContent = detail;
        }
        if (percent !== null) {
            const bar = document.getElementById('runProgressBar');
            if (bar) {
                const pct = percent.toFixed(1);
                bar.style.width = `${pct}%`;
                bar.textContent = `${pct}%`;
            }
        }
    };
    if(updateRemoteRepo){
        runProgressLogLine('[ui] Repository sync requested by user.');
        const statusEl = document.getElementById('runProgressStatus');
        if(statusEl) statusEl.textContent = 'Copying repository…';
        const metaEl = document.getElementById('runProgressMeta');
        if(metaEl) metaEl.textContent = 'Uploading repository snapshot to CORE host…';
        const bar = document.getElementById('runProgressBar');
        if(bar){
            bar.classList.add('progress-bar-animated');
            bar.classList.add('progress-bar-striped');
            bar.style.width = '0%';
            bar.textContent = '0%';
        }
        const pushed = await pushRepoToRemote(rp, {
            scenarioIndex: scenarioIdx,
            onProgress: updateSeedUploadProgress,
            onFinalizeProgress: handleSeedFinalizeProgress,
        });
        if(!pushed){
            runProgressLogLine('[ui] Repository upload failed; aborting seeded run.');
            if(statusEl) statusEl.textContent = 'Repository sync failed';
            if(metaEl) metaEl.textContent = 'Upload failed; canceling run.';
            if(bar){
                bar.classList.remove('progress-bar-animated');
                bar.textContent = 'Error';
            }
            markRunProgressComplete();
            return;
        }
        runProgressLogLine('[ui] Repository upload complete.');
        if(statusEl) statusEl.textContent = 'Repository copied';
        if(metaEl) metaEl.textContent = 'Preparing remote workspace…';
        if(bar){
            bar.style.width = '100%';
            bar.textContent = 'Upload complete';
        }
        sendUpdateRemoteFlag = false;
    }
    try {
        // Show dock logs
        try { const showBtn=document.getElementById('dockShowBtn'); if(showBtn && !showBtn.classList.contains('d-none')) showBtn.click(); } catch(e){}
        runProgressLogLine('[ui] Requesting remote CLI run…');
        const seededStatusEl = document.getElementById('runProgressStatus');
        if(seededStatusEl) seededStatusEl.textContent = 'Preparing remote workspace…';
        const statusMetaEl = document.getElementById('runProgressMeta');
        if(statusMetaEl) statusMetaEl.textContent = 'Submitting run request to CORE host…';
        const buildRequest = () => {
            const payload = enrichPayloadWithScenarioContext({ xml_path: rp, seed: seedVal, core: getCoreConfig(true) });
            if (sendUpdateRemoteFlag) {
                payload.update_remote_repo = true;
            }
            try {
                if (advancedSelections && typeof advancedSelections === 'object') {
                    if (advancedSelections.fixDockerDaemon) payload.adv_fix_docker_daemon = true;
                    if (advancedSelections.runCoreCleanup) payload.adv_run_core_cleanup = true;
                    if (advancedSelections.checkCoreVersion) payload.adv_check_core_version = true;
                    if (advancedSelections.restartCoreDaemon) payload.adv_restart_core_daemon = true;
                    if (advancedSelections.autoKillSessions) payload.adv_auto_kill_sessions = true;
                }
            } catch (e) {}
            return {
                body: JSON.stringify(payload),
                headers: { 'Content-Type': 'application/json' },
                xmlPath: rp,
                scenarioIndex: scenarioIdx,
            };
        };
        const res = await submitRunCliRequest(buildRequest);
        if(res){
            runProgressLogLine(`[ui] Remote CLI request completed (HTTP ${res.status}).`);
        }
        if(!res){ runProgressLogLine('Seeded run aborted before launch'); return; }
        if(!res.ok){
            const detail = await extractResponseDetail(res);
            runProgressLogLine('Failed to start seeded run' + (detail ? `: ${detail}` : ''));
            markRunProgressComplete();
            return;
        }
        const { run_id } = await res.json();
        runProgressRunId = run_id;
        waitingForSeedLogs = true;
        runProgressLogLine(`[ui] Remote CLI run id ${run_id}; waiting for logs…`);
        if(seededStatusEl) seededStatusEl.textContent = 'Remote CLI starting…';
        if(statusMetaEl) statusMetaEl.textContent = 'Waiting for remote logs…';
        // Stream logs
        try { if(runProgressEvtSrc) runProgressEvtSrc.close(); } catch(e){}
        runProgressEvtSrc = new EventSource('/stream/' + run_id);
        runProgressLogLine('[ui] Subscribed to remote log stream. Awaiting first line…');
        runProgressEvtSrc.addEventListener('phase', (ev) => {
            try {
                const payload = JSON.parse(ev.data || '{}');
                handleExecuteProgressPhase(payload);
            } catch (e) {}
        });
        runProgressEvtSrc.onmessage = (ev)=> {
            if(waitingForSeedLogs){
                waitingForSeedLogs = false;
                runProgressLogLine('[ui] First remote log line received.');
                (document.getElementById('runProgressStatus')||{}).textContent = 'Running CLI…';
                const meta = document.getElementById('runProgressMeta');
                if(meta) meta.textContent = 'Streaming remote logs…';
            }
            runProgressLogLine(ev.data||'');
        };
        runProgressEvtSrc.addEventListener('end', ()=>{ waitingForSeedLogs = false; try { runProgressEvtSrc.close(); } catch(e){} });
        // Poll status similar to runSyncWithModal
        (async function poll(){
            try{
                const r = await fetch('/run_status/' + run_id);
                if(!r.ok){ setTimeout(poll, 1200); return; }
                const data = await r.json();
                if(data.report_path || data.xml_path){ state.result_path = data.report_path || data.xml_path; persistEditorState(); }
                const metaEl = document.getElementById('runProgressMeta'); if(metaEl) metaEl.textContent = data.done ? (data.returncode===0 ? 'Completed' : 'Failed') : 'Running…';
                if(!data.done){ setTimeout(poll, 1000); return; }
                document.getElementById('runProgressStatus').textContent = (data.returncode===0) ? 'Scenario started' : 'Finished with errors';
                document.getElementById('runProgressBar').classList.remove('progress-bar-animated');
                markRunProgressComplete();
                if(data.returncode===0){ scheduleScenarioRedirect("{{ url_for('reports_page') }}", { delay: 600 }); }
            } catch(e){ setTimeout(poll, 1500); }
        })();
    } catch(e){ runProgressLogLine('Exception starting seeded run'); }
}

    function redistributeEven(sidx, secName) {
        const items = state.scenarios[sidx].sections[secName].items;
        const n = items.length;
        if (n === 0) return;
    const weightIdxs = items.map((it,i) => ({i,it})).filter(x => ((x.it.v_metric|| (x.it.selected==='Specific'?'Count':'Weight')) === 'Weight')).map(x => x.i);
    const m = weightIdxs.length;
    if (m === 0) { return; }
    const even = Math.round((1.0 / m) * 1000) / 1000;
    weightIdxs.slice(0, -1).forEach(i => { items[i].factor = even; });
        // last item gets the residual to hit 1.0
    const sumOther = weightIdxs.slice(0, -1).reduce((a, i) => a + (parseFloat(items[i].factor)||0), 0);
    const lastIdx = weightIdxs[weightIdxs.length - 1];
    items[lastIdx].factor = Math.max(0, Math.round((1.0 - sumOther) * 1000) / 1000);
        updateWeightWarning(sidx, secName);
    }

    function adjustWeightsProportionally(sidx, secName, changedIdx) {
        const items = state.scenarios[sidx].sections[secName].items;
        const n = items.length;
    const weightIdxs = items.map((it,i) => ({i,it})).filter(x => ((x.it.v_metric|| (x.it.selected==='Specific'?'Count':'Weight')) === 'Weight')).map(x => x.i);
        const m = weightIdxs.length;
        if (m <= 1) { if (m === 1) items[weightIdxs[0]].factor = 1.0; return; }
        // clamp changed value
        items[changedIdx].factor = Math.max(0, Math.min(1, parseFloat(items[changedIdx].factor)||0));
        const targetSum = 1.0;
        const changed = parseFloat(items[changedIdx].factor)||0;
        const others = weightIdxs.map(i => i !== changedIdx ? (parseFloat(items[i].factor)||0) : 0);
        const sumOthers = others.reduce((a,b) => a + b, 0);
        const residual = Math.max(0, targetSum - changed);
        if (sumOthers <= 0) {
            // Distribute evenly across others
            const even = residual / (m - 1);
            weightIdxs.forEach(i => { if (i !== changedIdx) items[i].factor = Math.round(even * 1000) / 1000; });
        } else {
            // Scale others proportionally to keep overall sum 1.0
            weightIdxs.forEach((i, idx) => {
                if (i === changedIdx) return;
                const ratio = others[idx] / sumOthers;
                items[i].factor = Math.round((residual * ratio) * 1000) / 1000;
            });
        }
        // Final normalization to exact 1.000 with 3 decimals
        normalizeToThousandths(sidx, secName);
    }

    function updateWeightWarning(sidx, secName) {
        const items = state.scenarios[sidx].sections[secName].items;
    // Exempt Node Information from weight validation (single Random item default)
    if (secName === 'Node Information') return;
    if (!items || items.length === 0) return;
        const sum = Math.round(items.reduce((a,b) => {
            const metric = b.v_metric || (b.selected==='Specific'?'Count':'Weight');
            return a + (metric==='Weight' ? (parseFloat(b.factor)||0) : 0);
        }, 0) * 1000) / 1000;
    const warn = document.querySelector(".section-warning[data-scen-idx='" + sidx + "'][data-sec='" + secName + "']");
        if (warn) {
            const density = parseFloat((state.scenarios[sidx].sections[secName]||{}).density);
            const weightCount = items.filter(b => (b.v_metric || (b.selected==='Specific'?'Count':'Weight')) === 'Weight').length;
            const badWeights = weightCount > 0 ? (Math.abs(sum - 1.0) > 0.005) : false;
            // Routing density: allow any density >= 0 (>=1 means absolute router count)
            // Other sections: keep 0..1 constraint
            const badDensity = isNaN(density) ? false : (
                secName === 'Routing' ? (density < 0) : (density < 0 || density > 1)
            );
            warn.style.display = (badWeights || badDensity) ? 'block' : 'none';
            let msgs = [];
            if (badWeights) msgs.push('Weights must sum to 1.000 (current: ' + sum.toFixed(3) + ')');
            if (badDensity) {
                if (secName === 'Routing') {
                    msgs.push('Routing density must be >= 0 (current: ' + density.toFixed(2) + '). Tip: < 1 = fraction of hosts; ≥ 1 = absolute router count.');
                } else {
                    msgs.push('Density must be between 0 and 1 (current: ' + density.toFixed(2) + ')');
                }
            }
            warn.textContent = msgs.join(' • ');
        }
    }

    function normalizeToThousandths(sidx, secName) {
        const items = state.scenarios[sidx].sections[secName].items;
        if (!items || items.length === 0) return;
        const vals = items.map(it => {
            const metric = it.v_metric || (it.selected==='Specific'?'Count':'Weight');
            const v = Math.max(0, Math.min(1, parseFloat(it.factor)||0));
            return metric==='Weight' ? v : 0;
        });
        // Convert to thousandths without rounding first
        const thousandthsRaw = vals.map(v => v * 1000);
        const floors = thousandthsRaw.map(v => Math.floor(v));
        let sumFloors = floors.reduce((a,b) => a + b, 0);
        let remainder = 1000 - sumFloors;
        if (remainder > 0) {
            // Distribute +1 to largest fractional parts
            const remainders = thousandthsRaw.map((v, i) => ({ idx: i, frac: v - floors[i] }));
            remainders.sort((a,b) => b.frac - a.frac);
            for (let k = 0; k < remainders.length && remainder > 0; k++) {
                floors[remainders[k].idx] += 1; remainder -= 1;
            }
        } else if (remainder < 0) {
            // Remove -1 from largest values to reduce sum to 1000
            const order = floors.map((v,i) => ({ idx: i, v }));
            order.sort((a,b) => b.v - a.v);
            while (remainder < 0) {
                for (let k = 0; k < order.length && remainder < 0; k++) {
                    const i = order[k].idx;
                    if (floors[i] > 0) { floors[i] -= 1; remainder += 1; }
                }
                if (order.length === 0) break;
            }
        }
        for (let i = 0; i < items.length; i++) {
            const metric = items[i].v_metric || (items[i].selected==='Specific'?'Count':'Weight');
            items[i].factor = (metric==='Weight') ? (floors[i] / 1000.0) : (items[i].factor||0);
        }
    }

    function updateWeightInputsDisplay(sidx, secName) {
        const items = state.scenarios[sidx].sections[secName].items;
    document.querySelectorAll("input.weight-input[data-scen-idx='" + sidx + "'][data-sec='" + secName + "']").forEach(input => {
            const iidx = parseInt(input.getAttribute('data-item-idx'));
            if (!isNaN(iidx) && items[iidx]) {
                input.value = (parseFloat(items[iidx].factor) || 0).toFixed(3);
            }
        });
    }

    // Dock setup handled by partial
</script>
 </body>
<!-- Success Modal -->
<div class="modal fade" id="runSuccessModal" tabindex="-1" aria-hidden="true">
    <div class="modal-dialog modal-dialog-centered">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title">Run Completed</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <p class="mb-1" id="runSuccessBody">Generation complete.</p>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
            </div>
        </div>
    </div>
</div>
<script>
function showRunSuccessModal(msg){
    try { if(msg) document.getElementById('runSuccessBody').textContent = msg; new bootstrap.Modal(document.getElementById('runSuccessModal')).show(); } catch(e){}
}
document.addEventListener('DOMContentLoaded', () => {
    if (window.runSuccessFlag) {
        scheduleScenarioRedirect("{{ url_for('reports_page') }}", { delay: 300 });
    }
});
// Capture server-provided flag (injected if present)
// Inject run success flag
window.runSuccessFlag = ("{{ '1' if (run_success is defined and run_success) else '0' }}" === '1');
// Wrap pollRunStatus to detect async completion success
function installRunSuccessHook(){
    const original = window.pollRunStatus;
    if (typeof original !== 'function') {
        console.warn('pollRunStatus hook skipped: function unavailable');
        return;
    }
    if (original.__runSuccessWrapped) {
        return;
    }
    const wrapped = async function(runId){
        await original(runId);
        try {
            const res = await fetch('/run_status/' + runId);
            if(!res.ok) return;
            const data = await res.json();
            if(data.done && data.returncode === 0){
                showRunSuccessModal('Asynchronous run completed successfully.');
            } else if(!data.done) {
                setTimeout(() => pollRunStatus(runId), 800);
            }
        } catch(e){}
    };
    wrapped.__runSuccessWrapped = true;
    window.pollRunStatus = wrapped;
}
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', installRunSuccessHook);
} else {
    installRunSuccessHook();
}
</script>
{% endblock %}
