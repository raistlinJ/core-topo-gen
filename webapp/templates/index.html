{% extends 'layout.html' %}
{% block title %}Scenarios - CORE TopoGen{% endblock %}
{% block active_page %}{% set active_page = 'scenarios' %}{% endblock %}
{% block extra_head %}
<style>
    body { padding-bottom: 42vh; }
    .pulse-change { animation: pulseHighlight .9s ease-in-out; }
    @keyframes pulseHighlight { 0% { box-shadow:0 0 0 0 rgba(13,110,253,.7); transform:scale(1);} 40% { box-shadow:0 0 0 6px rgba(13,110,253,.0); transform:scale(1.03);} 100% { box-shadow:0 0 0 0 rgba(13,110,253,0); transform:scale(1); } }
    .popover { max-width: 420px; }
    .host-total-badge + .badge, .host-total-badge + button { margin-left: .25rem; }
    /* Hide H/S bounds by default; JS adds .hs-show to display them */
    .hs-bounds-wrapper { display: none; }
    .hs-bounds-wrapper.hs-show { display: flex; }
</style>
{% endblock %}
<!-- hs-bounds-wrapper styles moved into style block above -->
{% block content %}
    <div class="row">
        <div class="col-md-3 mb-3">
                <div class="card shadow-sm h-100 d-flex flex-column">
                            <div class="card-header d-flex justify-content-between align-items-center">
                                <span class="fw-bold">Scenarios</span>
                                <div class="btn-toolbar gap-2 align-items-center">
                                    <button type="button" class="btn btn-sm btn-outline-secondary" id="importBtn" title="Import scenarios XML">Import</button>
                                    <button type="button" class="btn btn-sm btn-outline-info" id="exportBtn" title="Export last saved XML">Export</button>
                                    <div class="btn-group" role="group" aria-label="Bulk scenario actions">
                                        <button type="button" class="btn btn-sm btn-outline-secondary" id="selectAllScenariosBtn" title="Select all (or clear if all selected)">All</button>
                                        <button type="button" class="btn btn-sm btn-outline-danger" id="deleteSelectedScenariosBtn" title="Delete selected scenarios" disabled>Delete</button>
                                    </div>
                                </div>
                            </div>
                    <div class="list-group list-group-flush flex-grow-1 overflow-auto" id="scenarioList" style="min-height:0;"></div>
                    <form id="hiddenLoadForm" class="d-none" action="{{ url_for('load_xml') }}" method="post" enctype="multipart/form-data">
                        <input type="file" name="scenarios_xml" id="hiddenLoadInput" accept=".xml">
                    </form>
                    <div class="card-footer" style="position: sticky; bottom: 0; background: #fff; z-index: 1;">
                        <button type="button" class="btn btn-sm btn-primary w-100" id="appendScenarioBtn">New Scenario</button>
                    </div>
                </div>
            </div>
    <div class="col-md-9">

            <div class="card shadow mt-3">
                <div class="card-body">
                    {% with messages = get_flashed_messages() %}
                        {% if messages %}
                            <div class="alert alert-info">{{ messages[0] }}</div>
                        {% endif %}
                    {% endwith %}

                    <div class="card mb-3" id="baseCoreScenarioCard">
                        <div class="card-header d-flex justify-content-between align-items-center">
                            <strong>Base CORE Scenario</strong>
                            <div class="d-flex align-items-center gap-2">
                                {% if payload.base_upload %}
                                    {% if payload.base_upload.valid %}
                                        <span class="badge text-bg-success">VALID</span>
                                    {% else %}
                                        <span class="badge text-bg-danger">INVALID</span>
                                    {% endif %}
                                    <a class="btn btn-sm btn-outline-secondary" href="{{ url_for('core_details') }}?path={{ payload.base_upload.path | urlencode }}" target="_blank">Details</a>
                                    <form action="{{ url_for('remove_base') }}" method="post" class="d-inline" onsubmit="saveScrollBeforeNav(); document.getElementById('scenarios_json').value = JSON.stringify({ scenarios: state.scenarios });">
                                        <button type="submit" class="btn btn-sm btn-outline-danger">Remove</button>
                                    </form>
                                {% endif %}
                            </div>
                        </div>
                        <div class="card-body">
                            <div class="mb-3">
                                <label class="form-label d-flex align-items-center justify-content-between">
                                    <span>Base Scenario File</span>
                                </label>
                                <input class="form-control" id="baseFileInput" readonly>
                                <div class="form-text">Shows the uploaded file name; full path is stored internally.</div>
                            </div>
                            <form class="d-flex gap-2" action="{{ url_for('upload_base') }}" method="post" enctype="multipart/form-data" onsubmit="saveScrollBeforeNav()">
                                <input type="file" class="form-control" name="base_xml" accept=".xml" required>
                                <button type="submit" class="btn btn-primary">{% if payload.base_upload %}Update{% else %}Upload{% endif %}</button>
                            </form>
                            {% if payload.base_upload and not payload.base_upload.valid and logs %}
                                <div class="alert alert-danger mt-3 mb-0" style="white-space: pre-wrap;">{{ logs }}</div>
                            {% endif %}
                        </div>
                    </div>

                    <form id="editorForm" action="{{ url_for('save_xml') }}" method="post">
                        <input type="hidden" name="scenarios_json" id="scenarios_json">
                        <input type="hidden" name="active_index" id="active_index" value="0">
                        <div id="editorRoot"></div>
                        <div class="d-flex gap-2 mt-3">
                            <button type="submit" class="btn btn-success">Save XML</button>
                            <button type="button" class="btn btn-outline-info" id="downloadXmlBtn" disabled title="Save XML first">Download XML</button>
                        </div>
                    </form>

                    <div class="card mt-3" id="coreConnectionCard">
                        <div class="card-header d-flex justify-content-between align-items-center">
                            <strong>CORE Connection</strong>
                            <button class="btn btn-sm btn-outline-secondary" type="button" data-bs-toggle="collapse" data-bs-target="#coreAdvancedCollapse" aria-expanded="false" aria-controls="coreAdvancedCollapse">Advanced</button>
                        </div>
                        <div class="card-body">
                            <div class="row g-2 align-items-end mb-1">
                                <div class="col-auto">
                                    <label for="coreHost" class="form-label mb-0">IP</label>
                                    <input type="text" class="form-control" id="coreHost" placeholder="localhost" value="{{ (payload.core.host if payload.core else 'localhost') | e }}">
                                </div>
                                <div class="col-auto">
                                    <label for="corePort" class="form-label mb-0">Port</label>
                                    <input type="number" class="form-control" id="corePort" placeholder="50051" value="{{ (payload.core.port if payload.core else 50051) }}">
                                </div>
                            </div>
                            <div class="collapse" id="coreAdvancedCollapse">
                                <hr class="my-2"/>
                                <div class="d-flex flex-wrap gap-2 align-items-center mb-2">
                                    <button class="btn btn-sm btn-outline-secondary" type="button" id="testCoreBtn">Test CORE Connection</button>
                                    <span id="coreStatus" class="small text-muted">Not tested </span>
                                </div>
                                <div class="form-text">Testing is optional; if you skip it the run will still attempt to connect using the provided host and port.</div>
                            </div>
                        </div>
                    </div>

                    

                    <!-- Planning Workflow card visually removed but retained (d-none) for underlying JS functionality -->
                    <div class="card mt-3 d-none" id="planWorkflowCard">
                        <div class="card-header d-flex justify-content-between align-items-center">
                            <strong>Planning Workflow</strong>
                            <div id="planStatusBadge" class="badge text-bg-secondary">No Preview</div>
                        </div>
                        <div class="card-body">
                            <div class="d-flex flex-wrap gap-2 align-items-center mb-2">
                                                                <button class="btn btn-sm btn-outline-primary" type="button" id="planPreviewBtn" title="Generate full preview (routers, IPs, services)" disabled>Full Preview</button>
                                                                <!-- Run (Seed) workflow removed: deterministic seed input and run button eliminated -->
                                <!-- Single Full Preview button (above) is authoritative; secondary button and strict checkbox removed -->
                            </div>
                            <div class="small text-muted" id="planHint">Save XML and test CORE connection to enable planning.</div>
                            <pre id="planPreviewJson" class="small bg-light p-2 border rounded d-none" style="max-height:260px;overflow:auto;font-size:0.65rem;"></pre>
                            <div id="fullPreviewStructured" class="mt-2 d-none">
                                <div class="d-flex flex-wrap gap-2 align-items-center mb-2">
                                    <div class="btn-group btn-group-sm" role="group" aria-label="Full preview sections" id="fullPreviewSectionTabs"></div>
                                    <button type="button" class="btn btn-sm btn-outline-secondary" id="toggleRawFullPreviewBtn" title="Toggle raw JSON / structured view">Raw JSON</button>
                                    <!-- Copy seed button removed -->
                                </div>
                                <div id="fullPreviewSectionContent" class="border rounded p-2 bg-white small" style="max-height:300px; overflow:auto; font-size:.7rem;"></div>
                            </div>
                            <div id="planViolationsWrap" class="d-none mt-2">
                                <div class="alert alert-warning py-2 mb-0"><strong>Violations</strong><ul id="planViolationsList" class="mb-0 small"></ul></div>
                            </div>
                        </div>
                    </div>
                    <!-- Run form repurposed: Run CLI now triggers Full Preview (no direct execution here) -->
                    <form class="d-flex gap-2 mt-3 align-items-center" action="javascript:void(0)" id="runLegacyForm">
                        <input type="hidden" name="xml_path" id="xml_path">
                        <span class="d-inline-block" tabindex="0" id="runSyncWrap" data-bs-toggle="tooltip" data-bs-title="Runs CLI using current XML">
                            <button class="btn btn-warning" type="button" id="runSyncBtn" disabled title="Generates a Full Preview (no execution)">Generate</button>
                        </span>
                        <button class="btn btn-outline-danger d-none" type="button" id="cancelRunBtn" onclick="cancelRun()">Cancel</button>
                    </form>
                </div>
            </div>
            
        </div>
    </div>
<!-- Run Progress Modal -->
<div class="modal fade" id="runProgressModal" tabindex="-1" aria-hidden="true">
    <div class="modal-dialog modal-dialog-centered modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title">Running CLI…</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <div class="d-flex justify-content-between align-items-center mb-2 small text-muted">
                    <div id="runProgressStatus">Starting…</div>
                    <div id="runProgressMeta"></div>
                </div>
                <div class="progress mb-2">
                    <div class="progress-bar progress-bar-striped progress-bar-animated" id="runProgressBar" style="width: 100%">Working…</div>
                </div>
                <div class="border rounded" style="max-height: 260px; overflow: auto;">
                    <pre class="m-0 p-2 small" id="runProgressLog" style="white-space: pre-wrap;"></pre>
                </div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" id="runProgressHideBtn" data-bs-dismiss="modal">Hide</button>
            </div>
        </div>
    </div>
</div>
{% set xml_preview_enabled = True %}
{% set xml_preview_text = xml_preview %}
{% include 'partials/dock.html' %}

<!-- Graph libraries for Full Preview Modal -->
<script src="https://cdn.jsdelivr.net/npm/d3@7/dist/d3.min.js"></script>
<script src="{{ url_for('static', filename='core_graph.js') }}"></script>

<!-- Toast container -->
<div aria-live="polite" aria-atomic="true" class="position-fixed" style="z-index: 1080; right: 12px; bottom: 12px;">
    <div id="toastContainer" class="toast-container"></div>
    <template id="toastTemplate">
        <div class="toast align-items-center text-bg-dark border-0" role="alert" aria-live="assertive" aria-atomic="true">
            <div class="d-flex">
                <div class="toast-body">Action completed.</div>
                <button type="button" class="btn-close btn-close-white me-2 m-auto" data-bs-dismiss="toast" aria-label="Close"></button>
            </div>
        </div>
    </template>
</div>
<!-- Success Modal -->
<div class="modal fade" id="runSuccessModal" tabindex="-1" aria-hidden="true">
    <div class="modal-dialog modal-dialog-centered">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title">Run Completed</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <p class="mb-1" id="runSuccessBody">Generation complete.</p>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
            </div>
        </div>
    </div>
</div>
<!-- Full Preview Modal -->
<div class="modal fade" id="fullPreviewModal" tabindex="-1" aria-hidden="true">
    <div class="modal-dialog modal-fullscreen-lg-down modal-xl modal-dialog-scrollable">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title">Full Preview <span class="text-muted small" id="fpModalSeed"></span></h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <div class="row g-3">
                    <div class="col-lg-8">
                        <div class="card" id="fpGraphCard">
                            <div class="card-header d-flex justify-content-between align-items-center">
                                <strong>Graph</strong>
                                <div class="btn-group btn-group-sm">
                                    <button class="btn btn-outline-secondary" type="button" id="fpGraphResetBtn">Reset</button>
                                    <button class="btn btn-outline-secondary" type="button" id="fpGraphPngBtn">PNG</button>
                                    <button class="btn btn-outline-secondary" type="button" id="fpOpenStandaloneBtn">Open Page</button>
                                </div>
                            </div>
                            <div class="card-body p-2">
                                <div id="fpGraph" style="height:480px; position:relative; background:#fafafa; border:1px solid #e0e0e0; border-radius:4px; overflow:hidden;">
                                    <div class="position-absolute top-50 start-50 translate-middle text-muted" id="fpGraphLoading">Rendering...</div>
                                </div>
                                <div class="form-text mt-1">Drag to reposition nodes. Hover for details. PNG exports current view.</div>
                            </div>
                        </div>
                        <div class="card mt-3">
                            <div class="card-header d-flex justify-content-between align-items-center">
                                <strong>Routers</strong>
                                <button class="btn btn-sm btn-outline-secondary" type="button" data-preview-collapse="fpRoutersWrap" data-label-collapse="Collapse" data-label-expand="Expand">Collapse</button>
                            </div>
                            <div class="card-body collapse p-2" id="fpRoutersWrap"><div class="text-muted small">No data</div></div>
                        </div>
                        <div class="card mt-3">
                            <div class="card-header d-flex justify-content-between align-items-center">
                                <strong>Hosts</strong>
                                <button class="btn btn-sm btn-outline-secondary" type="button" data-preview-collapse="fpHostsWrap" data-label-collapse="Collapse" data-label-expand="Expand">Collapse</button>
                            </div>
                            <div class="card-body collapse p-2" id="fpHostsWrap"><div class="text-muted small">No data</div></div>
                        </div>
                        <div class="card mt-3">
                            <div class="card-header d-flex justify-content-between align-items-center">
                                <strong>Switches</strong>
                                <button class="btn btn-sm btn-outline-secondary" type="button" data-preview-collapse="fpSwitchesWrap" data-label-collapse="Collapse" data-label-expand="Expand">Collapse</button>
                            </div>
                            <div class="card-body collapse p-2" id="fpSwitchesWrap"><div class="text-muted small">No data</div></div>
                        </div>
                        <div class="card mt-3">
                            <div class="card-header d-flex justify-content-between align-items-center">
                                <strong>Node Sections</strong>
                                <button class="btn btn-sm btn-outline-secondary" type="button" data-preview-collapse="fpNodeSectionsWrap" data-label-collapse="Collapse" data-label-expand="Expand">Collapse</button>
                            </div>
                            <div class="card-body collapse p-2" style="max-height:240px;overflow:auto;" id="fpNodeSectionsWrap"><div class="text-muted small">No data</div></div>
                        </div>
                    </div>
                    <div class="col-lg-4">
                        <div class="card mb-3">
                            <div class="card-header d-flex justify-content-between align-items-center">
                                <strong>Counts</strong>
                                <button class="btn btn-sm btn-outline-secondary" type="button" data-preview-collapse="fpCounts" data-label-collapse="Collapse" data-label-expand="Expand">Collapse</button>
                            </div>
                            <div class="card-body collapse p-2" id="fpCounts"></div>
                        </div>
                        <div class="card mb-3">
                            <div class="card-header d-flex justify-content-between align-items-center">
                                <strong>R2R Policy</strong>
                                <button class="btn btn-sm btn-outline-secondary" type="button" data-preview-collapse="fpR2RPolicyBody" data-label-collapse="Collapse" data-label-expand="Expand">Collapse</button>
                            </div>
                            <div class="card-body collapse p-2" id="fpR2RPolicyBody"><pre class="small mb-0" id="fpR2RPolicy" style="max-height:160px; overflow:auto;"></pre></div>
                        </div>
                        <div class="card mb-3">
                            <div class="card-header d-flex justify-content-between align-items-center">
                                <strong>R2S Policy</strong>
                                <button class="btn btn-sm btn-outline-secondary" type="button" data-preview-collapse="fpR2SPolicyBody" data-label-collapse="Collapse" data-label-expand="Expand">Collapse</button>
                            </div>
                            <div class="card-body collapse p-2" id="fpR2SPolicyBody"><pre class="small mb-0" id="fpR2SPolicy" style="max-height:160px; overflow:auto;"></pre></div>
                        </div>
                        <div class="card mb-3">
                            <div class="card-header d-flex justify-content-between align-items-center">
                                <strong>Segmentation Plan</strong>
                                <button class="btn btn-sm btn-outline-secondary" type="button" data-preview-collapse="fpSegmentationCardBody" data-label-collapse="Collapse" data-label-expand="Expand">Collapse</button>
                            </div>
                            <div class="card-body collapse p-2" id="fpSegmentationCardBody">
                                <div class="small mb-2" id="fpSegmentationTypes" hidden></div>
                                <pre class="small mb-0" id="fpSegmentation" style="max-height:220px; overflow:auto;"></pre>
                                <div class="mt-2" id="fpSegmentationRuntimeWrap" hidden>
                                    <h6 class="small text-uppercase text-muted mb-1">Runtime Segmentation Summary (segmentation_summary.json)</h6>
                                    <pre class="small bg-light p-2 mb-0" id="fpSegmentationRuntime" style="max-height:220px; overflow:auto;"></pre>
                                </div>
                                <div class="small text-muted mt-2" id="fpSegmentationHash" hidden></div>
                            </div>
                        </div>
                        <div class="card mb-3">
                            <div class="card-header d-flex justify-content-between align-items-center">
                                <strong>Router Plan</strong>
                                <button class="btn btn-sm btn-outline-secondary" type="button" data-preview-collapse="fpRouterPlanBody" data-label-collapse="Collapse" data-label-expand="Expand">Collapse</button>
                            </div>
                            <div class="card-body collapse p-2" id="fpRouterPlanBody"><pre class="small mb-0" id="fpRouterPlan" style="max-height:160px; overflow:auto;"></pre></div>
                        </div>
                        <div class="card mb-3">
                            <div class="card-header d-flex justify-content-between align-items-center">
                                <strong>Services Plan</strong>
                                <button class="btn btn-sm btn-outline-secondary" type="button" data-preview-collapse="fpServicesPlanBody" data-label-collapse="Collapse" data-label-expand="Expand">Collapse</button>
                            </div>
                            <div class="card-body collapse p-2" id="fpServicesPlanBody"><pre class="small mb-0" id="fpServicesPlan" style="max-height:160px; overflow:auto;"></pre></div>
                        </div>
                        <div class="card mb-3">
                            <div class="card-header d-flex justify-content-between align-items-center">
                                <strong>Vulnerabilities Plan</strong>
                                <button class="btn btn-sm btn-outline-secondary" type="button" data-preview-collapse="fpVulnPlanBody" data-label-collapse="Collapse" data-label-expand="Expand">Collapse</button>
                            </div>
                            <div class="card-body collapse p-2" id="fpVulnPlanBody"><pre class="small mb-0" id="fpVulnPlan" style="max-height:160px; overflow:auto;"></pre></div>
                        </div>
                        <div class="card mb-3">
                            <div class="card-header d-flex justify-content-between align-items-center">
                                <strong>Traffic Plan</strong>
                                <button class="btn btn-sm btn-outline-secondary" type="button" data-preview-collapse="fpTrafficPlanBody" data-label-collapse="Collapse" data-label-expand="Expand">Collapse</button>
                            </div>
                            <div class="card-body collapse p-2" id="fpTrafficPlanBody"><pre class="small mb-0" id="fpTrafficPlan" style="max-height:160px; overflow:auto;"></pre></div>
                        </div>
                        <!-- Removed History, Role Distribution, Service Distribution cards -->
                        <!-- Drift card removed (no approved plan concept) -->
                    </div>
                </div>
            </div>
            <div class="modal-footer d-flex justify-content-between align-items-center">
                <div class="d-flex gap-2">
                    <button class="btn btn-warning" type="button" id="fpExecuteBtn" title="Execute scenario now">Execute</button>
                </div>
                <button class="btn btn-secondary" data-bs-dismiss="modal" type="button">Close</button>
            </div>
        </div>
    </div>
</div>
<!-- Planning Semantics Modal -->
<div class="modal fade" id="planningSemanticsModal" tabindex="-1" aria-hidden="true">
    <div class="modal-dialog modal-lg modal-dialog-scrollable">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" data-i18n="modal.planningSemantics.title">Planning Semantics</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <div class="spinner-border text-primary d-none" id="planningSemanticsSpinner" role="status"><span class="visually-hidden">Loading...</span></div>
                <div id="planningSemanticsContent" class="small"></div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal" data-i18n="common.close">Close</button>
            </div>
        </div>
    </div>
</div>
{% endblock %}
{% block extra_scripts %}
<script id="payload-data" type="application/json">{{ payload | tojson }}</script>
<script>
// --- BEGIN PAGE JS ---
const payloadDataEl = document.getElementById('payload-data');
// Prevent TDZ: define catalog early on window
window.VULN_CATALOG = window.VULN_CATALOG || { types: [], vectors: [], items: [] };
// Prevent TDZ: define catalog early on window
window.VULN_CATALOG = window.VULN_CATALOG || { types: [], vectors: [], items: [] };
function setupPreviewCollapsers(){
    const toggles = document.querySelectorAll('[data-preview-collapse]');
    toggles.forEach(btn => {
        if(btn.dataset.collapserBound) return;
        const targetId = btn.getAttribute('data-preview-collapse');
        const target = document.getElementById(targetId);
        if(!target) return;
        btn.dataset.collapserBound = '1';
        const collapseLabel = btn.dataset.labelCollapse || 'Collapse';
        const expandLabel = btn.dataset.labelExpand || 'Expand';
        const hasBootstrap = !!(window.bootstrap && bootstrap.Collapse);
        if(hasBootstrap){
            const instance = bootstrap.Collapse.getOrCreateInstance(target, { toggle: false });
            const updateLabel = () => {
                btn.textContent = target.classList.contains('show') ? collapseLabel : expandLabel;
            };
            updateLabel();
            btn.addEventListener('click', ev => {
                ev.preventDefault();
                if(target.classList.contains('show')){
                    instance.hide();
                } else {
                    instance.show();
                }
            });
            target.addEventListener('shown.bs.collapse', updateLabel);
            target.addEventListener('hidden.bs.collapse', updateLabel);
        } else {
            if(!target.classList.contains('d-none')){
                target.classList.add('d-none');
            }
            const updateLabel = () => {
                btn.textContent = target.classList.contains('d-none') ? expandLabel : collapseLabel;
            };
            updateLabel();
            btn.addEventListener('click', ev => {
                ev.preventDefault();
                target.classList.toggle('d-none');
                updateLabel();
            });
        }
    });
}
window.setupPreviewCollapsers = setupPreviewCollapsers;
if(document.readyState === 'loading'){ document.addEventListener('DOMContentLoaded', () => setupPreviewCollapsers()); }
else { setupPreviewCollapsers(); }
// ---------------- Unified Logging Bridge -----------------
// Forward all app/UI logs into dock log system (defined in partial 'dock.html').
// We DO NOT override existing dock log functions if already present.
function appendLog(line, level){
    if(!line) return;
    let lvl = (level||'INFO').toString().toUpperCase();
    if(!['DEBUG','INFO','WARN','ERROR'].includes(lvl)) lvl='INFO';
    if(window.logLine){ window.logLine(lvl, line); return; }
    // Fallback: create a very small inline buffer if dock not initialized yet.
    try {
        const pre = document.getElementById('logsPre') || document.getElementById('runProgressLog');
        if(pre){
            const text = `[${new Date().toISOString()}] ${lvl} ${line}\n`;
            if(typeof pre.append === 'function'){ pre.append(text); }
            else { pre.appendChild(document.createTextNode(text)); }
        }
    } catch(e){}
}
if(!window.logInfo) window.logInfo = (m)=>appendLog(m,'INFO');
if(!window.logWarn) window.logWarn = (m)=>appendLog(m,'WARN');
if(!window.logError) window.logError = (m)=>appendLog(m,'ERROR');
if(!window.logDebug) window.logDebug = (m)=>appendLog(m,'DEBUG');
appendLog('UI initialized','INFO');
try {
    initialPayload = JSON.parse(payloadDataEl?.textContent || 'null');
} catch (e) {
    initialPayload = null;
}
// If server provides a fresh result_path (e.g., after Save XML), reflect it in localStorage early
try {
    if (initialPayload && initialPayload.result_path) {
        const persisted = JSON.parse(localStorage.getItem('coretg_editor_state') || 'null') || {};
        persisted.result_path = initialPayload.result_path;
        if (initialPayload.core) persisted.core = initialPayload.core;
        localStorage.setItem('coretg_editor_state', JSON.stringify(persisted));
    }
} catch(e){}

function defaultScenario(name) {
    return {
        name: name || `Scenario ${document.querySelectorAll('.scenario-card').length + 1}`,
        base: { filepath: '' },
        density_count: 10,
        sections: {
            // Default: one Count-based row; weight-based nodes/density start at 0
            'Node Information': { total_nodes: 0, density: 0, items: [ { selected: 'Random', factor: 1.0, v_metric: 'Count', v_count: 5 } ] },
            'Routing': { density: 0.5, items: [] },
            'Services': { density: 0.5, items: [] },
            'Traffic': { density: 0.5, items: [] },
            'Events': { density: 0.5, items: [] },
            'Vulnerabilities': { density: 0.5, items: [] },
            'Segmentation': { density: 0.5, items: [] }
        },
        notes: ''
    };
}

// Restore persisted editor state (scenarios and last saved xml) and active index from localStorage
let persistedState = null;
try { persistedState = JSON.parse(localStorage.getItem('coretg_editor_state') || 'null'); } catch(e){ persistedState = null; }
let persistedActiveIdx = 0;
try { const v = parseInt(localStorage.getItem('coretg_active_idx')||'0',10); if(!isNaN(v)) persistedActiveIdx = v; } catch(e){}
// Base state is from server payload or default
let state = initialPayload ?? { scenarios: [ defaultScenario('Scenario 1') ], result_path: null };
// If server provided a concrete result_path (save/load/run), prefer server scenarios; else, restore from localStorage if available
const serverHasResult = !!(initialPayload && initialPayload.result_path);
if (!serverHasResult && persistedState && Array.isArray(persistedState.scenarios) && persistedState.scenarios.length) {
    state.scenarios = persistedState.scenarios;
    if (persistedState.result_path) state.result_path = persistedState.result_path;
}
// Preview workflow state (in-memory only; persisted history handled separately)
let previewState = {
    fullPreview: null,
    fullPreviewHistory: [],
    xmlSaved: !!(state.result_path),
    dirty: false,
    coreTested: false
};
const FULL_PREVIEW_ARTIFACT_VERSION = 2;

function safeClone(value){
    if(value === null || typeof value !== 'object') return value;
    try { return structuredClone(value); }
    catch(e){
        try { return JSON.parse(JSON.stringify(value)); }
        catch(err){ return value; }
    }
}

function summarizeSegRule(rule){
    if(!rule) return '';
    const type = rule.type || rule.action || '';
    if(type === 'nat'){
        const mode = rule.mode ? `${rule.mode} ` : '';
        const internal = rule.internal || rule.internal_subnet || '';
        const external = rule.external || rule.external_subnet || '';
        return `${mode}${internal}${(internal && external)?' -> ':''}${external}`.trim();
    }
    if(type === 'host_block'){
        const src = rule.src || rule.source || '';
        const dst = rule.dst || rule.destination || '';
        return `${src} X ${dst}`.trim();
    }
    if(type === 'custom'){
        return rule.description || 'custom';
    }
    if(type){
        const src = rule.src || rule.source;
        const dst = rule.dst || rule.destination;
        if(src || dst){
            return `${type}: ${src || '*'} -> ${dst || '*'}`;
        }
        return type;
    }
    return '';
}

function buildSegmentationArtifacts(full){
    const seg = (full && full.segmentation_preview) || {};
    const rawRules = Array.isArray(seg.rules) ? seg.rules : [];
    const meta = safeClone(seg);
    if(meta && typeof meta === 'object') delete meta.rules;
    if(!rawRules.length){
        return {
            rows: [],
            tableRows: [],
            table_rows: [],
            json: {
                rules_count: 0,
                types_summary: {},
                rules: [],
                metadata: meta || null
            }
        };
    }
    const summaries = [];
    const tableRows = [];
    const typeCounts = {};
    for(const rawEntry of rawRules){
        const entry = safeClone(rawEntry);
        if(!entry || typeof entry !== 'object') continue;
        const rule = ('rule' in entry && entry.rule) ? safeClone(entry.rule) : safeClone(entry);
        if(!rule || typeof rule !== 'object') continue;
        const nodeId = (entry.node_id !== undefined) ? entry.node_id : (rule.node_id !== undefined ? rule.node_id : null);
        const typeRaw = (rule.type !== undefined && rule.type !== null) ? rule.type : rule.action;
        const type = (typeRaw !== undefined && typeRaw !== null) ? String(typeRaw) : null;
        const summary = summarizeSegRule(rule);
        const src = (rule.src !== undefined && rule.src !== null) ? rule.src : rule.source;
        const dst = (rule.dst !== undefined && rule.dst !== null) ? rule.dst : rule.destination;
        const internal = (rule.internal !== undefined && rule.internal !== null) ? rule.internal : rule.internal_subnet;
        const external = (rule.external !== undefined && rule.external !== null) ? rule.external : rule.external_subnet;
        const proto = (rule.proto !== undefined && rule.proto !== null) ? rule.proto : rule.protocol;
        const port = (rule.port !== undefined) ? rule.port : null;
        const scriptPath = typeof entry.script === 'string' ? entry.script : (typeof rule.script === 'string' ? rule.script : null);
        const scriptName = scriptPath ? scriptPath.split('/').pop() : null;
        const tableRow = {
            node_id: nodeId,
            type,
            summary,
            src: src ?? null,
            dst: dst ?? null,
            subnet: rule.subnet ?? null,
            internal: internal ?? null,
            external: external ?? null,
            proto: proto ?? null,
            port,
            script_path: scriptPath || null,
            script_name: scriptName || null,
            detail: rule
        };
        tableRows.push(tableRow);
        summaries.push({ node_id: nodeId, type, summary });
        const key = type || 'unknown';
        typeCounts[key] = (typeCounts[key] || 0) + 1;
    }
    return {
        rows: summaries,
        tableRows,
        table_rows: tableRows,
        json: {
            rules_count: tableRows.length,
            types_summary: typeCounts,
            rules: tableRows.map(row => ({ node_id: row.node_id, type: row.type, summary: row.summary, detail: safeClone(row.detail) })),
            metadata: meta || null
        }
    };
}

function buildFullPreviewArtifacts(full){
    if(!full) return { segmentation: buildSegmentationArtifacts(full) };
    if(full.__displayArtifactsVersion === FULL_PREVIEW_ARTIFACT_VERSION && full.__displayArtifacts){
        return full.__displayArtifacts;
    }
    let artifacts = null;
    if(full.display_artifacts_version === FULL_PREVIEW_ARTIFACT_VERSION && full.display_artifacts){
        artifacts = safeClone(full.display_artifacts);
    }
    if(!artifacts || !artifacts.segmentation){
        artifacts = { segmentation: buildSegmentationArtifacts(full) };
    } else {
        const seg = artifacts.segmentation;
        if(!seg.tableRows || !seg.table_rows || !Array.isArray(seg.rows)){
            artifacts.segmentation = buildSegmentationArtifacts(full);
        }
    }
    artifacts.__version = FULL_PREVIEW_ARTIFACT_VERSION;
    try {
        Object.defineProperty(full, '__displayArtifacts', { value: artifacts, enumerable: false, configurable: true, writable: true });
        Object.defineProperty(full, '__displayArtifactsVersion', { value: FULL_PREVIEW_ARTIFACT_VERSION, enumerable: false, configurable: true, writable: true });
    } catch(e){
        full.__displayArtifacts = artifacts;
        full.__displayArtifactsVersion = FULL_PREVIEW_ARTIFACT_VERSION;
    }
    return artifacts;
}
// Core settings: prefer server-provided if present; otherwise restore from persisted
// ---------------- Plan Workflow State -----------------
// (Legacy alias cleanup left intentionally blank. Using previewState below.)

// ---------- Full Preview History Persistence ----------
function loadFullPreviewHistory(){
    try { previewState.fullPreviewHistory = JSON.parse(localStorage.getItem('coretg_full_preview_history')||'[]'); } catch(e){ previewState.fullPreviewHistory = []; }
    if(!Array.isArray(previewState.fullPreviewHistory)) previewState.fullPreviewHistory = [];
}
function saveFullPreviewHistory(){
    try { localStorage.setItem('coretg_full_preview_history', JSON.stringify(previewState.fullPreviewHistory.slice(-25))); } catch(e){}
}
loadFullPreviewHistory();

// Run progress modal state (hoisted early to avoid TDZ issues)
let runProgressModalInst = null;
let runProgressEvtSrc = null;
let runProgressRunId = null;

function setupPreviewModalExecute(modalEl, modalInstance){
    if(!modalEl) return;
    const execBtn = modalEl.querySelector('#previewModalExecuteBtn');
    if(!execBtn) return;
    if(execBtn.dataset.enhanced === '1') return;
    execBtn.dataset.enhanced = '1';
    execBtn.addEventListener('click', async () => {
        if(execBtn.disabled) return;
        execBtn.disabled = true;
        execBtn.classList.add('disabled');
        const forceHideModal = () => {
            try { modalInstance?.hide(); } catch(e){}
            if(modalEl){
                modalEl.classList.remove('show');
                modalEl.setAttribute('aria-hidden','true');
                modalEl.style.display = 'none';
            }
            // Remove any lingering backdrop only if no other modals remain visible
            const openModals = document.querySelectorAll('.modal.show');
            if(openModals.length === 0){
                document.querySelectorAll('.modal-backdrop').forEach(b => {
                    try { b.remove(); } catch(e){}
                });
                document.body.classList.remove('modal-open');
                document.body.style.removeProperty('paddingRight');
                document.body.style.removeProperty('overflow');
            }
        };
        const restoreModal = () => {
            try {
                if(modalInstance){
                    modalInstance.show();
                } else if(modalEl){
                    modalEl.style.display = 'block';
                    modalEl.classList.add('show');
                    document.body.classList.add('modal-open');
                }
            } catch(e){}
        };
        const waitForPaint = async () => {
            await new Promise(resolve => requestAnimationFrame(() => resolve()));
        };
        try {
            if(!window.confirm('Execute this scenario now? This will start a CORE session.')){
                return;
            }
            forceHideModal();
            await waitForPaint();
            await new Promise(resolve => setTimeout(resolve, 0));
            openRunProgress('Running CLI…');
            try {
                const statusEl = document.getElementById('runProgressStatus');
                if(statusEl) statusEl.textContent = 'Starting…';
                const metaEl = document.getElementById('runProgressMeta');
                if(metaEl) metaEl.textContent = '';
                const bar = document.getElementById('runProgressBar');
                if(bar){
                    bar.classList.add('progress-bar-animated');
                    bar.textContent = 'Working…';
                }
            } catch(e){}
            try {
                const showBtn = document.getElementById('dockShowBtn');
                if(showBtn && !showBtn.classList.contains('d-none')) showBtn.click();
            } catch(e){}

            const setRunning = () => {
                try {
                    const statusEl = document.getElementById('runProgressStatus');
                    if(statusEl) statusEl.textContent = 'Running…';
                    const metaEl = document.getElementById('runProgressMeta');
                    if(metaEl) metaEl.textContent = 'Streaming logs…';
                    const bar = document.getElementById('runProgressBar');
                    if(bar){
                        bar.classList.add('progress-bar-animated');
                        bar.textContent = 'Working…';
                    }
                } catch(e){}
            };
            const setFinished = (data) => {
                try {
                    const statusEl = document.getElementById('runProgressStatus');
                    if(statusEl) statusEl.textContent = (data?.returncode === 0) ? 'Scenario started' : 'Finished with errors';
                    const metaEl = document.getElementById('runProgressMeta');
                    if(metaEl) metaEl.textContent = (data?.returncode === 0) ? 'Completed' : 'Finished';
                    const bar = document.getElementById('runProgressBar');
                    if(bar){
                        bar.classList.remove('progress-bar-animated');
                        bar.textContent = (data?.returncode === 0) ? 'Done' : 'Error';
                    }
                } catch(e){}
            };
            const setFailedToStart = (msg) => {
                try {
                    const statusEl = document.getElementById('runProgressStatus');
                    if(statusEl) statusEl.textContent = 'Failed to start';
                    const metaEl = document.getElementById('runProgressMeta');
                    if(metaEl) metaEl.textContent = msg || '';
                    const bar = document.getElementById('runProgressBar');
                    if(bar){
                        bar.classList.remove('progress-bar-animated');
                        bar.textContent = 'Error';
                    }
                } catch(e){}
            };

            let launchFailed = false;
            const result = await runSyncWithModal({
                showProgressModal: false,
                skipConfirm: true,
                onTick: (data) => {
                    if(data && !data.done){
                        setRunning();
                    }
                },
                onComplete: (data) => {
                    setFinished(data);
                    try {
                        if(data?.returncode === 0){
                            setTimeout(()=>{ window.location.href = "{{ url_for('reports_page') }}"; }, 500);
                        }
                    } catch(e){}
                },
                onError: () => {
                    setFailedToStart('Unable to launch CLI');
                    launchFailed = true;
                },
            });
            if(result === false){
                if(!launchFailed){
                    closeRunProgress();
                    restoreModal();
                }
                return;
            }
        } catch(err){
            console.error('Preview execute failed', err);
            closeRunProgress();
            restoreModal();
        } finally {
            execBtn.disabled = false;
            execBtn.classList.remove('disabled');
        }
    });
}

function updatePlanButtons(){
    const previewBtn = document.getElementById('planPreviewBtn');
    const statusBadge = document.getElementById('planStatusBadge');
    const hint = document.getElementById('planHint');
    const genBtn = document.getElementById('runSyncBtn');
    const xmlPathVal = (state.result_path || '').trim();
    previewState.xmlSaved = !!xmlPathVal;
    const canPreview = previewState.xmlSaved || previewState.dirty;
    if(previewBtn) previewBtn.disabled = !canPreview;
    if(genBtn) genBtn.disabled = !canPreview;
    if(hint){
    if(!previewState.xmlSaved) hint.textContent = 'Save XML to enable planning.';
    else hint.textContent = previewState.fullPreview ? 'Full preview ready.' : 'Generate a full preview.';
    }
    if(statusBadge){
    statusBadge.className = 'badge ' + (previewState.fullPreview ? 'text-bg-info' : 'text-bg-secondary');
    statusBadge.textContent = previewState.fullPreview ? 'Preview' : 'No Preview';
    }
}


function showPlanSummary(summary){
    const pre = document.getElementById('planPreviewJson');
    if(!pre) return;
    pre.classList.remove('d-none');
    try{ pre.textContent = JSON.stringify(summary, null, 2); }catch(e){ pre.textContent='(error displaying plan)'; }
}

async function computePlanPreview(){
    // Deprecated lightweight preview replaced by full preview; delegate
    return computeFullPlanPreview();
}

// Approval functions removed

function onCoreTestedSuccess(){ previewState.coreTested = true; updatePlanButtons(); }

// Hook into existing CORE test result update
const originalUpdateCoreStatus = window.updateCoreStatus; // if defined later, we patch after definition
window.updateCoreStatus = function(success, msg){
    if(typeof originalUpdateCoreStatus === 'function') originalUpdateCoreStatus(success, msg);
    if(success) onCoreTestedSuccess();
};

document.addEventListener('DOMContentLoaded', () => {
    document.getElementById('planPreviewBtn')?.addEventListener('click', computePlanPreview);
    // Repurpose Run CLI button to invoke Full Preview logic
    document.getElementById('runSyncBtn')?.addEventListener('click', ()=>{
        // Mirror enablement guard from preview button
        if(document.getElementById('planPreviewBtn')?.disabled){
            logWarn('Full Preview disabled; cannot run');
            return;
        }
        computePlanPreview();
    });
    try { updatePlanButtons(); } catch(e){}
});

async function computeFullPlanPreview(){
    const xmlPathVal = (state.result_path || '').trim();
    if(!xmlPathVal){
        try { await autoSaveXml(); } catch(e){ alert('Auto-save failed: '+e); return; }
    }
    const newXmlPath = (state.result_path || '').trim();
    if(!newXmlPath){ alert('XML path still unavailable after save.'); return; }
    const btn = document.getElementById('planPreviewBtn');
    const pre = document.getElementById('planPreviewJson');
    btn.disabled = true; btn.dataset.prevLabel = btn.textContent; btn.textContent='Full preview...';
    pre.classList.remove('d-none'); pre.textContent='Computing full preview...';
    try {
    // Collect routing row host-per-switch overrides (min/max)
    let r2sHostsMinList = [];
    let r2sHostsMaxList = [];
    try {
        const scen = state.scenarios[0];
        if (scen && scen.sections && scen.sections['Routing']) {
            (scen.sections['Routing'].items || []).forEach(it => {
                if (it) {
                    r2sHostsMinList.push(typeof it.r2s_hosts_min === 'number' ? it.r2s_hosts_min : null);
                    r2sHostsMaxList.push(typeof it.r2s_hosts_max === 'number' ? it.r2s_hosts_max : null);
                }
            });
        }
    } catch(e) { /* ignore */ }
    const body = { xml_path: newXmlPath, r2s_hosts_min_list: r2sHostsMinList, r2s_hosts_max_list: r2sHostsMaxList };
        const res = await fetch('/api/plan/preview_full', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(body) });
        const data = await res.json();
        try {
            if(window.logLine){ window.logLine('INFO', 'Preview: response received; parsing plan summary'); }
        } catch(e){}
    if(!data.ok){ pre.textContent='Full preview failed: '+(data.error||''); previewState.fullPreview=null; document.getElementById('fullPreviewStructured')?.classList.add('d-none'); }
        else {
            previewState.fullPreview = data.full_preview;
            buildFullPreviewArtifacts(previewState.fullPreview);
            pre.textContent = JSON.stringify(previewState.fullPreview, null, 2);
            renderFullPreviewStructured();
            // Emit detailed calculation logs into dock
            try {
                const fp = previewState.fullPreview || {};
                const counts = fp.counts || {};
                const routersPlanned = fp.routers_planned ?? counts.routers ?? 'n/a';
                const hostsPlanned = counts.hosts_total ?? counts.hosts ?? 'n/a';
                const switchesPlanned = counts.switches ?? 'n/a';
                const r2rEdges = (fp.r2r_edges_preview || []).length;
                let densityInfo = '';
                if(fp.router_plan && typeof fp.router_plan === 'object'){
                    const rp = fp.router_plan;
                    densityInfo = ` density_raw=${rp.density_raw} density_component=${rp.density_component} count_based=${rp.count_based_component} has_weight=${rp.has_weight_based}`;
                }
                window.logLine && window.logLine('INFO', `[preview.plan] Routers planned=${routersPlanned} Hosts=${hostsPlanned} Switches=${switchesPlanned} R2R_edges=${r2rEdges}${densityInfo}`);
                if(fp.routing_items && Array.isArray(fp.routing_items)){
                    fp.routing_items.forEach((ri, idx)=>{
                        try {
                            const proto = ri.protocol || `item${idx}`;
                            const abs_c = ri.abs_count || 0;
                            const factor = ri.factor || 0;
                            window.logLine && window.logLine('INFO', `[preview.plan.item] #${idx} protocol=${proto} abs_count=${abs_c} factor=${factor}`);
                        } catch(e){}
                    });
                }
                // Services breakdown
                try {
                    if(fp.services_plan){
                        const svcKeys = Object.keys(fp.services_plan);
                        window.logLine && window.logLine('INFO', `[preview.plan.services] total=${svcKeys.length} entries=${svcKeys.slice(0,10).join(',')}${svcKeys.length>10?'...':''}`);
                    }
                } catch(e){}
                // Vulnerabilities breakdown
                try {
                    if(fp.vulnerabilities_plan){
                        const vp = fp.vulnerabilities_plan;
                        const totalV = Object.values(vp).reduce((a,b)=> a + (typeof b==='number'? b:0), 0);
                        window.logLine && window.logLine('INFO', `[preview.plan.vuln] total_items=${Object.keys(vp).length} total_alloc=${totalV}`);
                    }
                } catch(e){}
                // Segmentation breakdown
                try {
                    if(fp.segmentation_preview){
                        const rules = (fp.segmentation_preview.rules||[]).length;
                        window.logLine && window.logLine('INFO', `[preview.plan.segmentation] rules=${rules}`);
                    }
                } catch(e){}
                // Traffic breakdown
                try {
                    if(fp.traffic_summary){
                        const ts = fp.traffic_summary;
                        const flows = ts.total_flows || ts.flows || 'n/a';
                        window.logLine && window.logLine('INFO', `[preview.plan.traffic] flows=${flows}`);
                    }
                } catch(e){}
            } catch(e){ /* ignore logging issues */ }
            try { showFullPreviewModal(previewState.fullPreview); } catch(e){ console.warn('Modal render failed', e); }
            // Append to history
            try {
                const fp = previewState.fullPreview;
                previewState.fullPreviewHistory.push({
                    ts: Date.now(),
                    seed: fp.seed,
                    seed_generated: fp.seed_generated,
                    stats: {
                        routers: (fp.routers||[]).length,
                        hosts: (fp.hosts||[]).length,
                        switches: (fp.switches||[]).length,
                        r2r_edges: (fp.r2r_edges_preview||[]).length,
                        seg_rules: (fp.segmentation_preview && fp.segmentation_preview.rules ? fp.segmentation_preview.rules.length : 0)
                    },
                    preview: fp
                });
                saveFullPreviewHistory();
            } catch(e){}
        }
    } catch(e){ pre.textContent='Error: '+e; previewState.fullPreview=null; }
    btn.disabled = false; btn.textContent = btn.dataset.prevLabel || 'Full Preview';
}

function renderFullPreviewStructured(){
    const wrap = document.getElementById('fullPreviewStructured');
    if(!wrap) return;
    const full = previewState.fullPreview;
    if(!full){ wrap.classList.add('d-none'); return; }
    wrap.classList.remove('d-none');
    const tabsEl = document.getElementById('fullPreviewSectionTabs');
    const contentEl = document.getElementById('fullPreviewSectionContent');
    if(!tabsEl || !contentEl) return;
    const sections = [
        { id:'overview', label:'Overview' },
        { id:'routers', label:`Routers (${(full.routers||[]).length})` },
        { id:'hosts', label:`Hosts (${(full.hosts||[]).length})` },
        { id:'switches', label:`Switches (${(full.switches||[]).length})` },
        { id:'subnets', label:'Subnets' },
        { id:'r2r', label:`R2R Edges (${(full.r2r_edges_preview||[]).length})` },
        { id:'seg', label:`Seg Rules (${(full.segmentation_preview && full.segmentation_preview.rules ? full.segmentation_preview.rules.length : 0)})` },
        { id:'services_bd', label:'Services Plan' },
        { id:'vuln_bd', label:'Vuln Plan' },
        { id:'seg_bd', label:'Seg Plan' },
        { id:'router_bd', label:'Router Plan' },
        { id:'traffic_bd', label:'Traffic Plan' },
        { id:'history', label:'History' },
    ];
    // Build tabs
    tabsEl.innerHTML = '';
    sections.forEach((s, idx) => {
        const b = document.createElement('button');
        b.type='button'; b.className='btn btn-outline-primary' + (idx===0?' active':'');
        b.textContent = s.label;
        b.dataset.section = s.id;
        b.onclick = () => { tabsEl.querySelectorAll('button').forEach(x=>x.classList.remove('active')); b.classList.add('active'); renderSectionContent(s.id); };
        tabsEl.appendChild(b);
    });
    function esc(x){ return (''+x).replace(/[&<>]/g,c=>({'&':'&amp;','<':'&lt;','>':'&gt;'}[c])); }
    function renderSectionContent(id){
        if(id==='overview'){
            const stats = [
                ['Routers', (full.routers||[]).length],
                ['Hosts', (full.hosts||[]).length],
                ['Switches', (full.switches||[]).length],
                ['R2R Edges', (full.r2r_edges_preview||[]).length],
                ['Avg R2R Deg', full.r2r_stats_preview && full.r2r_stats_preview.avg],
                ['Seg Rules', full.segmentation_preview && full.segmentation_preview.rules ? full.segmentation_preview.rules.length : 0],
                ['P2P /30', (full.ptp_subnets||[]).length],
                ['Router-Sw /30', (full.router_switch_subnets||[]).length],
                ['LAN /28', (full.lan_subnets||[]).length],
                // Seed removed from UI summary
            ];
            contentEl.innerHTML = '<div class="row g-2">' + stats.map(s=>`<div class="col-auto"><span class="badge text-bg-secondary">${esc(s[0])}: ${esc(s[1]??'-')}</span></div>`).join('') + '</div>';
            return;
        }
        if(id==='routers'){
            contentEl.innerHTML = tableFromObjects(full.routers || [], ['node_id','name','ip4']); return;
        }
        if(id==='hosts'){
            contentEl.innerHTML = tableFromObjects(full.hosts || [], ['node_id','name','role','ip4']); return;
        }
        if(id==='switches'){
            const rows = full.switches_detail || [];
            contentEl.innerHTML = tableFromObjects(rows, ['switch_id','router_id','hosts','rsw_subnet','lan_subnet']); return;
        }
        if(id==='subnets'){
            const p2p = (full.ptp_subnets||[]).map(s=>`<li>${esc(s)}</li>`).join('');
            const rs = (full.router_switch_subnets||[]).map(s=>`<li>${esc(s)}</li>`).join('');
            const lan = (full.lan_subnets||[]).map(s=>`<li>${esc(s)}</li>`).join('');
            contentEl.innerHTML = `<div class="row small g-3"><div class="col"><h6 class="fw-bold">Host P2P (/30)</h6><ul class="mb-0">${p2p||'<li>(none)</li>'}</ul></div><div class="col"><h6 class="fw-bold">Router-Switch (/30)</h6><ul class="mb-0">${rs||'<li>(none)</li>'}</ul></div><div class="col"><h6 class="fw-bold">LAN (/28)</h6><ul class="mb-0">${lan||'<li>(none)</li>'}</ul></div></div>`; return;
        }
        if(id==='r2r'){
            const edges = full.r2r_edges_preview || [];
            const deg = full.r2r_degree_preview || {};
            const degList = Object.entries(deg).map(([k,v])=>`r${k}:${v}`).join(', ');
            const spark = Object.values(deg).join(' ');
            const edgesSample = edges.slice(0,200).map(e=>`(${e[0]}-${e[1]})`).join(' ');
            contentEl.innerHTML = `<div><div class="mb-2"><strong>Degree Stats:</strong> ${esc(JSON.stringify(full.r2r_stats_preview||{}))}</div><div class="mb-2"><strong>Degrees:</strong> ${esc(degList||'(none)')}</div><div class="mb-2"><strong>Edges (${edges.length}):</strong> ${esc(edgesSample||'(none)')} ${edges.length>200?'...':''}</div><div><strong>Spark:</strong> ${esc(spark)}</div></div>`; return;
        }
        if(id==='seg'){
            const artifacts = buildFullPreviewArtifacts(full);
            const segRows = (artifacts && artifacts.segmentation && artifacts.segmentation.rows) || [];
            contentEl.innerHTML = tableFromObjects(segRows, ['node_id','type','summary']);
            return;
        }
        if(id==='router_bd'){
            const rp = (full.router_plan)||{};
            contentEl.innerHTML = `<pre class="small mb-0">${esc(JSON.stringify(rp,null,2))}</pre>`; return;
        }
        if(id==='services_bd'){
            const sp = (full.services_plan)||{};
            contentEl.innerHTML = `<pre class="small mb-0">${esc(JSON.stringify(sp,null,2))}</pre>`; return;
        }
        if(id==='vuln_bd'){
            const vp = (full.vulnerabilities_plan)||{};
            contentEl.innerHTML = `<pre class="small mb-0">${esc(JSON.stringify(vp,null,2))}</pre>`; return;
        }
        if(id==='seg_bd'){
            const sb = (full.segmentation_preview)||{};
            contentEl.innerHTML = `<pre class="small mb-0">${esc(JSON.stringify(sb,null,2))}</pre>`; return;
        }
        if(id==='traffic_bd'){
            const tp = (full.traffic_summary)||{};
            contentEl.innerHTML = `<pre class="small mb-0">${esc(JSON.stringify(tp,null,2))}</pre>`; return;
        }
        if(id==='history'){
            renderPreviewHistory(contentEl, full);
            return;
        }
        contentEl.textContent='Unknown section';
    }
    function tableFromObjects(arr, cols){
        if(!arr.length) return '<div class="text-muted fst-italic">(none)</div>';
        const head = '<thead><tr>' + cols.map(c=>`<th>${esc(c)}</th>`).join('') + '</tr></thead>';
        const body = '<tbody>' + arr.map(o=>'<tr>'+cols.map(c=>`<td>${esc((o[c]!==undefined && o[c]!==null)? (Array.isArray(o[c])? o[c].join(','): o[c]): '')}</td>`).join('')+'</tr>').join('') + '</tbody>';
        return `<div class="table-responsive"><table class="table table-sm table-bordered mb-0">${head}${body}</table></div>`;
    }
    // Initial load
    renderSectionContent('overview');
    // Wire toggle button
    const toggleBtn = document.getElementById('toggleRawFullPreviewBtn');
    if(toggleBtn){
        toggleBtn.onclick = () => {
            const raw = document.getElementById('planPreviewJson');
            const struct = document.getElementById('fullPreviewStructured');
            if(raw.classList.contains('d-none')){ raw.classList.remove('d-none'); toggleBtn.textContent='Structured'; }
            else { raw.classList.add('d-none'); toggleBtn.textContent='Raw JSON'; }
        };
    }
    // Seed copy button removed
}

function renderPreviewHistory(contentEl, currentFull){
    loadFullPreviewHistory();
    if(!previewState.fullPreviewHistory.length){ contentEl.innerHTML = '<div class="text-muted fst-italic">No previous full previews</div>'; return; }
    function esc(x){ return (''+x).replace(/[&<>]/g,c=>({'&':'&amp;','<':'&lt;','>':'&gt;'}[c])); }
    const rows = previewState.fullPreviewHistory.slice().reverse().map((rec,idx) => {
        const dt = new Date(rec.ts).toLocaleTimeString();
        const diffBtn = `<button class="btn btn-sm btn-outline-primary" data-action="diff" data-seed="${esc(rec.seed)}">Diff</button>`;
        return `<tr><td>${idx+1}</td><td>${esc(rec.seed)}</td><td>${esc(rec.stats.routers)}/${esc(rec.stats.hosts)}/${esc(rec.stats.switches)}</td><td>${esc(rec.stats.r2r_edges)}</td><td>${esc(rec.stats.seg_rules)}</td><td>${dt}</td><td class="text-nowrap">${diffBtn}</td></tr>`;
    }).join('');
    contentEl.innerHTML = `<div class="table-responsive"><table class="table table-sm table-bordered mb-2"><thead><tr><th>#</th><th>Seed</th><th>R/H/S</th><th>R2R</th><th>Seg</th><th>Time</th><th></th></tr></thead><tbody>${rows}</tbody></table></div><div id="previewDiffOutput" class="small"></div>`;
    // Seed load buttons removed
    contentEl.querySelectorAll('button[data-action="diff"]').forEach(btn => {
        btn.addEventListener('click', () => { const seed = btn.getAttribute('data-seed'); const rec = previewState.fullPreviewHistory.find(r=> String(r.seed)===seed); if(!rec){ return; } const diffHtml = buildPreviewDiff(rec.preview, currentFull); document.getElementById('previewDiffOutput').innerHTML = diffHtml; });
    });
}

function buildPreviewDiff(a,b){
    const metrics = [
        ['Routers', (a.routers||[]).length, (b.routers||[]).length],
        ['Hosts', (a.hosts||[]).length, (b.hosts||[]).length],
        ['Switches', (a.switches||[]).length, (b.switches||[]).length],
        ['R2R Edges', (a.r2r_edges_preview||[]).length, (b.r2r_edges_preview||[]).length],
        ['Seg Rules', (a.segmentation_preview && a.segmentation_preview.rules ? a.segmentation_preview.rules.length : 0), (b.segmentation_preview && b.segmentation_preview.rules ? b.segmentation_preview.rules.length : 0)]
    ];
    function esc(x){ return (''+x).replace(/[&<>]/g,c=>({'&':'&amp;','<':'&lt;','>':'&gt;'}[c])); }
    const rows = metrics.map(m => { const delta = m[2]-m[1]; const cls = delta===0?'text-secondary':(delta>0?'text-success':'text-danger'); return `<tr><td>${esc(m[0])}</td><td>${esc(m[1])}</td><td>${esc(m[2])}</td><td class="${cls}">${delta>0?'+':''}${esc(delta)}</td></tr>`; }).join('');
    return `<div class="card border-info"><div class="card-header py-1 small">Diff vs current preview</div><div class="card-body p-2"><div class="table-responsive"><table class="table table-sm table-bordered mb-0"><thead><tr><th>Metric</th><th>Old</th><th>Current</th><th>Δ</th></tr></thead><tbody>${rows}</tbody></table></div></div></div>`;
}

// ---------- Full Preview Modal Rendering ----------
function showFullPreviewModal(full){
    if(!full) return;
    const modalEl = document.getElementById('fullPreviewModal');
    if(!modalEl) return;
    document.getElementById('fpModalSeed').textContent = `seed=${full.seed}`;
    // Counts
    const countsEl = document.getElementById('fpCounts');
    const stats = [
        ['Routers',(full.routers||[]).length],
        ['Hosts',(full.hosts||[]).length],
        ['Switches',(full.switches||[]).length],
        ['R2R Edges',(full.r2r_edges_preview||[]).length],
        ['Seg Rules', (full.segmentation_preview && full.segmentation_preview.rules ? full.segmentation_preview.rules.length:0)],
        ['P2P /30',(full.ptp_subnets||[]).length],
        ['R-Sw /30',(full.router_switch_subnets||[]).length],
        ['LAN /28',(full.lan_subnets||[]).length],
    ];
    countsEl.innerHTML = '<div class="row g-1">' + stats.map(s=>`<div class="col-auto"><span class="badge text-bg-secondary">${s[0]}: ${s[1]}</span></div>`).join('') + '</div>';
    // Policies & segmentation
    function setJson(id, obj){ const el=document.getElementById(id); if(el) el.textContent = JSON.stringify(obj||{}, null, 2); }
    setJson('fpR2RPolicy', full.r2r_policy_preview);
    setJson('fpR2SPolicy', full.r2s_policy_preview);
    // Render segmentation plan using shared artifacts so modal and structured views match
    (function(){
        const segEl = document.getElementById('fpSegmentation');
        if(!segEl) return;
        const typesEl = document.getElementById('fpSegmentationTypes');
        const runtimeWrap = document.getElementById('fpSegmentationRuntimeWrap');
        const runtimeEl = document.getElementById('fpSegmentationRuntime');
        const hashEl = document.getElementById('fpSegmentationHash');
        const artifacts = buildFullPreviewArtifacts(full) || {};
        const segArtifacts = artifacts.segmentation || null;
        const segJson = segArtifacts && segArtifacts.json;
        const hasRules = !!(segJson && typeof segJson === 'object' && segJson.rules_count > 0);
        if(hasRules){
            try {
                segEl.textContent = JSON.stringify(segJson, null, 2);
            } catch(e){
                segEl.textContent = '[error rendering segmentation plan JSON]';
            }
        } else {
            segEl.textContent = '(no segmentation plan rules)';
        }
        if(typesEl){
            typesEl.innerHTML = '';
            const typesSummary = hasRules ? (segJson.types_summary || {}) : {};
            const entries = Object.entries(typesSummary).filter(([, count]) => count !== undefined && count !== null);
            if(entries.length){
                typesEl.hidden = false;
                entries.forEach(([type, count]) => {
                    const badge = document.createElement('span');
                    badge.className = 'badge text-bg-light border me-1';
                    badge.textContent = `${type}: ${count}`;
                    typesEl.appendChild(badge);
                });
            } else {
                typesEl.hidden = true;
            }
        }
        const segPreview = (full && full.segmentation_preview) || {};
        const runtimeSummary = segPreview && segPreview.runtime_summary;
        if(runtimeWrap){
            if(runtimeSummary){
                runtimeWrap.hidden = false;
                if(runtimeEl){
                    try {
                        runtimeEl.textContent = JSON.stringify(runtimeSummary, null, 2);
                    } catch(e){
                        runtimeEl.textContent = '[error rendering runtime segmentation summary]';
                    }
                }
            } else {
                runtimeWrap.hidden = true;
                if(runtimeEl){ runtimeEl.textContent = ''; }
            }
        }
        if(hashEl){
            const hashVal = segPreview && segPreview.scripts_hash_sha256;
            if(hashVal){
                hashEl.hidden = false;
                hashEl.textContent = `Scripts Hash (SHA-256): ${hashVal}`;
            } else {
                hashEl.hidden = true;
                hashEl.textContent = '';
            }
        }
    })();
    // Breakdown plans
    try { setJson('fpRouterPlan', full.router_plan); } catch(e){}
    try { setJson('fpServicesPlan', full.services_plan); } catch(e){}
    try { setJson('fpVulnPlan', full.vulnerabilities_plan); } catch(e){}
    try { setJson('fpTrafficPlan', full.traffic_summary || full.traffic_plan || {}); } catch(e){}
    // Tables
    function tableHtml(arr, cols){ if(!arr||!arr.length) return '<div class="text-muted small">(none)</div>'; const head='<thead><tr>'+cols.map(c=>`<th>${c}</th>`).join('')+'</tr></thead>'; const body='<tbody>'+arr.map(o=>'<tr>'+cols.map(c=>`<td>${(o[c]!==undefined&&o[c]!==null)? (Array.isArray(o[c])? o[c].join(','): o[c]): ''}</td>`).join('')+'</tr>').join('')+'</tbody>'; return `<div class="table-responsive"><table class="table table-sm table-bordered mb-0">${head}${body}</table></div>`; }
    function summarizeRouterInterfaces(full){
        const routers = full.routers || [];
        if(!routers.length) return [];
        const r2rLinks = full.r2r_links_preview || [];
        const switches = full.switches_detail || [];
        const r2rMap = {};
        r2rLinks.forEach(link => {
            const routersList = link.routers || [];
            if(routersList.length < 2) return;
            const subnet = link.subnet || '';
            const [ra, rb] = routersList;
            const entryA = `r${rb.id ?? '?'}: ${(ra.ip || '-')}${subnet ? ` [${subnet}]` : ''}`;
            const entryB = `r${ra.id ?? '?'}: ${(rb.ip || '-')}${subnet ? ` [${subnet}]` : ''}`;
            if(ra && ra.id !== undefined){
                const listA = r2rMap[ra.id] || (r2rMap[ra.id] = []);
                listA.push(entryA);
            }
            if(rb && rb.id !== undefined){
                const listB = r2rMap[rb.id] || (r2rMap[rb.id] = []);
                listB.push(entryB);
            }
        });
        const switchMap = {};
        switches.forEach(sw => {
            if(sw.router_id === undefined) return;
            const label = `sw-${sw.switch_id ?? '?'}: ${(sw.router_ip || '-')}${sw.rsw_subnet ? ` [${sw.rsw_subnet}]` : ''}`;
            const list = switchMap[sw.router_id] || (switchMap[sw.router_id] = []);
            list.push(label);
        });
        return routers.map(r => {
            const r2rList = (r2rMap[r.node_id] || []).slice().sort();
            const swList = (switchMap[r.node_id] || []).slice().sort();
            return {
                'ID': r.node_id,
                'Name': r.name || `r${r.node_id}`,
                'Primary IP': r.ip4 || '-',
                'R2R Interfaces': r2rList.length ? r2rList.join('; ') : '-',
                'Switch Links': swList.length ? swList.join('; ') : '-',
            };
        });
    }
    const routersWrap = document.getElementById('fpRoutersWrap'); if(routersWrap) routersWrap.innerHTML = tableHtml(summarizeRouterInterfaces(full),['ID','Name','Primary IP','R2R Interfaces','Switch Links']);
    const hostsWrap = document.getElementById('fpHostsWrap'); if(hostsWrap) hostsWrap.innerHTML = tableHtml(full.hosts,['node_id','name','role','ip4']);
    const switchesWrap = document.getElementById('fpSwitchesWrap'); if(switchesWrap) switchesWrap.innerHTML = tableHtml(full.switches_detail,['switch_id','router_id','hosts','rsw_subnet','lan_subnet']);
    // Graph
    buildFullPreviewModalGraph(full);
    setupPreviewCollapsers();
    try { buildNodeSectionsTable(full); } catch(e){ console.warn('Node sections table failed', e); }
        // Removed history, role distribution, service distribution
    // Approval & drift removed
    document.getElementById('fpExportJsonBtn')?.addEventListener('click', ()=>{ try { const blob=new Blob([JSON.stringify(full,null,2)],{type:'application/json'}); const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download='full_preview_seed_'+(full.seed||'na')+'.json'; document.body.appendChild(a); a.click(); a.remove(); setTimeout(()=>URL.revokeObjectURL(a.href),4000);} catch(e){} });
    // Open standalone full preview page via POST (original GET caused 405 Method Not Allowed)
    document.getElementById('fpOpenStandaloneBtn')?.addEventListener('click', ()=>{
        const xmlPath = state.result_path || '';
        if(!xmlPath.endsWith('.xml')){ alert('Save XML first to open standalone preview.'); return; }
        const scen = state.scenarios && state.scenarios[activeIdx] ? state.scenarios[activeIdx].name : '';
        const form = document.createElement('form');
        form.method='POST';
        form.action='/plan/full_preview_page';
        form.target='_blank';
        const inXml = document.createElement('input'); inXml.type='hidden'; inXml.name='xml_path'; inXml.value=xmlPath; form.appendChild(inXml);
        if(scen){ const inSc = document.createElement('input'); inSc.type='hidden'; inSc.name='scenario'; inSc.value=scen; form.appendChild(inSc); }
        if(full && full.seed){ const inSeed=document.createElement('input'); inSeed.type='hidden'; inSeed.name='seed'; inSeed.value=full.seed; form.appendChild(inSeed); }
        document.body.appendChild(form);
        form.submit();
        setTimeout(()=>{ try { form.remove(); } catch(e){} }, 1000);
    });
    (new bootstrap.Modal(modalEl)).show();
}

// Removed history and distribution functions

// Drift function removed

function normalizeVulnerabilitiesByNode(source){
    const out = {};
    if(!source) return out;
    Object.entries(source).forEach(([key, value])=>{
        if(key === '__density_pool__') return;
        if(Array.isArray(value)){
            out[String(key)] = value;
            const numericKey = Number(key);
            if(Number.isFinite(numericKey)){
                out[numericKey] = value;
            }
        }
    });
    return out;
}

function buildFullPreviewModalGraph(full){
    if(!window.d3){ const g=document.getElementById('fpGraphLoading'); if(g) g.textContent='d3 not loaded'; return; }
    const container = d3.select('#fpGraph');
    container.selectAll('*').remove();
    const w = container.node().clientWidth || 800; const h = container.node().clientHeight || 480;
    const svg = container.append('svg').attr('width', w).attr('height', h).style('cursor','grab');
    const zoomLayer = svg.append('g').attr('class','zoom-layer');
    let currentTransform = d3.zoomIdentity;
    const zoom = d3.zoom().scaleExtent([0.2,4]).on('zoom', (ev)=>{
        currentTransform = ev.transform; zoomLayer.attr('transform', currentTransform);
    });
    svg.call(zoom).on('dblclick.zoom', null);
        const vulnerabilitiesByNode = normalizeVulnerabilitiesByNode(full.vulnerabilities_by_node);
        const nodes=[];
        const linkDescriptors=[];
        (full.routers||[]).forEach(r=>nodes.push({id:r.node_id, label:r.name, type:'router'}));
        (full.hosts||[]).forEach(hn=>{
            const hostId = hn.node_id;
            const keyStr = String(hostId);
            const assignment = Array.isArray(hn.vulnerabilities) ? hn.vulnerabilities : vulnerabilitiesByNode[keyStr] || vulnerabilitiesByNode[hostId] || [];
            const vulnList = Array.isArray(assignment) ? assignment : [];
            const hasVuln = vulnList.length > 0;
            nodes.push({id:hostId, label:hn.name, type:'host', hasVuln: hasVuln, vulnerabilities: vulnList});
        });
        (full.switches_detail||[]).forEach(sw=>nodes.push({id:sw.switch_id, label:'sw-'+sw.switch_id, type:'switch'}));
        (full.r2r_edges_preview||[]).forEach(e=>linkDescriptors.push({sourceId:e[0], targetId:e[1], kind:'r2r'}));
        (full.switches_detail||[]).forEach(sw=>{ (sw.hosts||[]).forEach(hid=>linkDescriptors.push({sourceId:sw.switch_id, targetId:hid, kind:'sw-host'})); linkDescriptors.push({sourceId:sw.router_id, targetId:sw.switch_id, kind:'r-sw'}); });
        const hr = full.host_router_map || {}; Object.entries(hr).forEach(([hid,rid])=>{ const hIdNum=parseInt(hid,10); if(!linkDescriptors.find(l=>l.kind==='sw-host' && l.targetId===hIdNum)){ linkDescriptors.push({sourceId:rid, targetId:hIdNum, kind:'r-host'}); }});

        const layoutPositions = full.layout_positions;
        const layoutMaps = (layoutPositions && !layoutPositions.error && typeof layoutPositions === 'object')
            ? {
                    routers: layoutPositions.routers || {},
                    switches: layoutPositions.switches || {},
                    hosts: layoutPositions.hosts || {},
                }
            : null;
        function layoutCoordForNode(node){
            if(!layoutMaps) return null;
            let table = null;
            if(node.type==='router') table = layoutMaps.routers;
            else if(node.type==='switch') table = layoutMaps.switches;
            else table = layoutMaps.hosts;
            if(!table) return null;
            const key = String(node.id);
            const raw = table[key] || table[node.id];
            if(!raw) return null;
            const x = Number(raw.x);
            const y = Number(raw.y);
            if(Number.isFinite(x) && Number.isFinite(y)) return {x, y};
            return null;
        }
        const layoutCoords = [];
        if(layoutMaps){
            nodes.forEach(n=>{
                const pos = layoutCoordForNode(n);
                if(pos){
                    n._layout = pos;
                    layoutCoords.push(pos);
                }
            });
        }
        const margin = 40;
        const innerWidth = Math.max(w - margin*2, 200);
        const innerHeight = Math.max(h - margin*2, 200);
        let usingLayout = layoutCoords.length > 0;
        const originalPositions = new Map();
        function applyRowJitter(list){
            const buckets = new Map();
            list.forEach(node=>{
                if(!Number.isFinite(node.y)) return;
                const base = node._layout ? node._layout.y : node.y;
                if(!Number.isFinite(base)) return;
                const key = Math.round(base * 1000);
                const bucket = buckets.get(key);
                if(bucket){
                    bucket.push(node);
                } else {
                    buckets.set(key, [node]);
                }
            });
            buckets.forEach(group=>{
                if(group.length <= 1) return;
                group.sort((a,b)=> String(a.id).localeCompare(String(b.id)));
                const mid = (group.length - 1) / 2;
                const spacing = 8;
                group.forEach((node, idx)=>{
                    node.y += (idx - mid) * spacing;
                });
            });
        }
        let scale = 1;
        let offsetX = margin;
        let offsetY = margin;
        if(usingLayout && layoutCoords.length){
            let minX = layoutCoords[0].x, maxX = layoutCoords[0].x;
            let minY = layoutCoords[0].y, maxY = layoutCoords[0].y;
            layoutCoords.forEach(c=>{ if(c.x<minX) minX=c.x; if(c.x>maxX) maxX=c.x; if(c.y<minY) minY=c.y; if(c.y>maxY) maxY=c.y; });
            const spanX = Math.max(1, maxX - minX);
            const spanY = Math.max(1, maxY - minY);
            scale = Math.min(innerWidth/spanX, innerHeight/spanY);
            if(!Number.isFinite(scale) || scale <= 0){
                scale = 1;
                usingLayout = false;
            } else {
                offsetX = margin + (innerWidth - spanX * scale) / 2 - minX * scale;
                offsetY = margin + (innerHeight - spanY * scale) / 2 - minY * scale;
            }
        }

        if(usingLayout){
            nodes.forEach(n=>{
                if(n._layout){
                    n.x = offsetX + n._layout.x * scale;
                    n.y = offsetY + n._layout.y * scale;
                } else {
                    n.x = w/2 + Math.random()*40 - 20;
                    n.y = h/2 + Math.random()*40 - 20;
                }
            });
            applyRowJitter(nodes);
            nodes.forEach(n=>{
                n.layoutX = n.x;
                n.layoutY = n.y;
                if(Number.isFinite(n.x) && Number.isFinite(n.y)){
                    originalPositions.set(n.id, { x: n.x, y: n.y });
                }
            });
        } else {
            nodes.forEach(n=>{
                n.x = w/2 + Math.random()*80 - 40;
                n.y = h/2 + Math.random()*80 - 40;
                n.layoutX = undefined;
                n.layoutY = undefined;
            });
        }

        const simLinks = linkDescriptors.map(l=>({...l, source:l.sourceId, target:l.targetId}));

        const link = zoomLayer.selectAll('line').data(simLinks).enter().append('line').attr('stroke', l=> l.kind==='r2r'? '#0d6efd': (l.kind==='r-sw'? '#198754':'#999')).attr('stroke-width', l=> l.kind==='r2r'? 2:1.2).attr('stroke-dasharray', l=> l.kind==='r-host'? '3,3': null).attr('opacity', .9);
        const node = zoomLayer.selectAll('g').data(nodes).enter().append('g');
        const vulnerabilityColor = '#28a745';
        const hasVulnerableHosts = nodes.some(n => n.type === 'host' && n.hasVuln);
        const normalNode = node.filter(d => !(d.type === 'host' && d.hasVuln));
        normalNode.append('circle')
            .attr('r', d=> d.type==='router'? 11: (d.type==='switch'? 8:5))
            .attr('fill', d=> {
                if(d.type==='router') return '#ff7043';
                if(d.type==='switch') return '#17a2b8';
                return '#ffc107';
            })
            .attr('stroke','#333')
            .attr('stroke-width',1.1);
        const vulnNode = node.filter(d => d.type === 'host' && d.hasVuln);
        const vulnSymbol = d3.symbol().type(d3.symbolStar).size(170);
        vulnNode.append('path')
            .attr('d', vulnSymbol)
            .attr('fill', vulnerabilityColor)
            .attr('stroke', '#333')
            .attr('stroke-width', 1.1);
        const simulation = d3.forceSimulation(nodes)
            .force('link', d3.forceLink(simLinks).id(d=>d.id).distance(l=> l.kind==='r2r'? 80 : (l.kind==='r-sw'? 60 : 40)))
            .force('charge', d3.forceManyBody().strength(-220))
            .force('center', d3.forceCenter(w/2,h/2))
            .force('layoutX', d3.forceX(d => Number.isFinite(d.layoutX) ? d.layoutX : w/2).strength(usingLayout ? 0.2 : 0.04))
            .force('layoutY', d3.forceY(d => Number.isFinite(d.layoutY) ? d.layoutY : h/2).strength(usingLayout ? 0.2 : 0.04));

        link.data(simLinks, d=>`${d.source}-${d.target}`);

        simulation.on('tick', ()=>{
            link.attr('x1', d=>d.source.x).attr('y1', d=>d.source.y).attr('x2', d=>d.target.x).attr('y2', d=>d.target.y);
            node.attr('transform', d=>`translate(${d.x},${d.y})`);
        });

        node.call(d3.drag().on('start', dragstarted).on('drag', dragged).on('end', dragended));

        let sim = simulation;

        let resetStaticPositions = null;
        if(usingLayout){
            resetStaticPositions = () => {
                nodes.forEach(n => {
                    const orig = originalPositions.get(n.id);
                    if(orig){
                        n.layoutX = orig.x;
                        n.layoutY = orig.y;
                        n.x = orig.x;
                        n.y = orig.y;
                        n.vx = 0;
                        n.vy = 0;
                        n.fx = null;
                        n.fy = null;
                    }
                });
                simulation.alpha(0.55).restart();
            };
        }
    // Legend
    const legend = svg.append('g').attr('class','legend').attr('transform','translate(8,8)');
    const legendItems = [
        {label:'Router', color:'#ff7043', r:11},
        {label:'Switch', color:'#17a2b8', r:8},
        {label:'Host', color:'#ffc107', r:5},
    ];
    legendItems.forEach((li,i)=>{
        const g=legend.append('g').attr('transform',`translate(0,${i*20})`);
        g.append('circle').attr('r',li.r).attr('cx',li.r).attr('cy',li.r).attr('fill',li.color).attr('stroke','#333').attr('stroke-width',1);
        g.append('text').text(li.label).attr('x', li.r*2 + 6).attr('y', li.r+4).attr('font-size','11px');
    });
    if(hasVulnerableHosts){
        const offset = legendItems.length*20;
        const g=legend.append('g').attr('transform',`translate(0,${offset})`);
        const vulnLegendSymbol = d3.symbol().type(d3.symbolStar).size(80);
        g.append('path')
            .attr('d', vulnLegendSymbol)
            .attr('transform','translate(8,8)')
            .attr('fill', vulnerabilityColor)
            .attr('stroke','#333')
            .attr('stroke-width',1);
        g.append('text').text('Host (vulnerable)').attr('x', 20).attr('y', 12).attr('font-size','11px');
    }
    // Node labels removed per request
    // Build section lookups
    const servicesByNode = full.services_preview || {}; // node_id -> [services]
    const vulnByNode = vulnerabilitiesByNode; // node_id -> [vulns]
    const segRules = (full.segmentation_preview && full.segmentation_preview.rules) || [];
    const segCnt = {}; segRules.forEach(r=>{ segCnt[r.node_id] = (segCnt[r.node_id]||0)+1; });
    const traffic = full.traffic_summary || {};
    const tSend = {}; const tRecv = {};
    try { (traffic.flows || traffic || []).forEach(f=>{ const s=f.src_id??f.src; const d=f.dst_id??f.dst; if(s!==undefined) tSend[s]=(tSend[s]||0)+1; if(d!==undefined) tRecv[d]=(tRecv[d]||0)+1; }); } catch(e){}
    // Tooltip functionality removed per request
    function dragstarted(event,d){
        try { event.sourceEvent?.stopPropagation?.(); } catch(e){}
        if(sim && !event.active) sim.alphaTarget(.35).restart();
        d.fx=d.x; d.fy=d.y;
    }
    function dragged(event,d){ d.fx=event.x; d.fy=event.y; }
    function dragended(event,d){
        if(sim && !event.active) sim.alphaTarget(0);
        d.fx=null; d.fy=null;
        if(usingLayout){
            d.layoutX = d.x;
            d.layoutY = d.y;
        }
    }
    document.getElementById('fpGraphLoading')?.remove();
    const resetBtn = document.getElementById('fpGraphResetBtn');
    if(resetBtn){
        resetBtn.addEventListener('click', ()=>{
            if(sim){
                sim.alpha(1).restart();
                nodes.forEach(n=>{ n.fx=null; n.fy=null; });
            }
            if(resetStaticPositions){
                resetStaticPositions();
            }
            svg.transition().duration(250).call(zoom.transform, d3.zoomIdentity);
        });
    }
    // Removed zoom hint tooltip
    svg.on('mousedown', ()=> svg.style('cursor','grabbing'));
    window.addEventListener('mouseup', ()=> svg.style('cursor','grab'));
    document.getElementById('fpGraphPngBtn')?.addEventListener('click', ()=>{ try { const serializer=new XMLSerializer(); const svgStr=serializer.serializeToString(svg.node()); const canvas=document.createElement('canvas'); canvas.width=w*2; canvas.height=h*2; const ctx=canvas.getContext('2d'); const img=new Image(); img.onload=function(){ ctx.fillStyle='#fff'; ctx.fillRect(0,0,canvas.width,canvas.height); ctx.drawImage(img,0,0,canvas.width,canvas.height); canvas.toBlob(b=>{ const a=document.createElement('a'); a.href=URL.createObjectURL(b); a.download='full_preview_graph_'+(full.seed||'na')+'.png'; document.body.appendChild(a); a.click(); a.remove(); setTimeout(()=>URL.revokeObjectURL(a.href),4000); }); }; img.src='data:image/svg+xml;base64,'+btoa(unescape(encodeURIComponent(svgStr))); } catch(e){ console.error('PNG export failed', e); } });
}

function buildNodeSectionsTable(full){
    const wrap = document.getElementById('fpNodeSectionsWrap'); if(!wrap) return;
    const servicesByNode = full.services_preview || {};
    const vulnByNode = normalizeVulnerabilitiesByNode(full.vulnerabilities_by_node);
    const segRules = (full.segmentation_preview && full.segmentation_preview.rules) || [];
    const segCnt = {}; segRules.forEach(r=>{ segCnt[r.node_id]=(segCnt[r.node_id]||0)+1; });
    const traffic = full.traffic_summary || {};
    const tSend = {}; const tRecv = {};
    try { (traffic.flows || traffic || []).forEach(f=>{ const s=f.src_id??f.src; const d=f.dst_id??f.dst; if(s!==undefined) tSend[s]=(tSend[s]||0)+1; if(d!==undefined) tRecv[d]=(tRecv[d]||0)+1; }); } catch(e){}
    const all = [];
    (full.routers||[]).forEach(r=> all.push({id:r.node_id, name:r.name, type:'router'}));
    (full.hosts||[]).forEach(h=> all.push({id:h.node_id, name:h.name, type:h.role||'host'}));
    (full.switches_detail||[]).forEach(sw=> all.push({id:sw.switch_id, name:'sw-'+sw.switch_id, type:'switch'}));
    if(!all.length){ wrap.innerHTML='<div class="text-muted small">No nodes</div>'; return; }
    const rows = all.map(n=>{
        const svc=(servicesByNode[n.id]||[]).join(',');
        const vul=(vulnByNode[n.id]||[]).join(',');
        const sc=segCnt[n.id]||0; const ts=tSend[n.id]||0; const tr=tRecv[n.id]||0;
        return `<tr><td>${n.id}</td><td>${n.name}</td><td>${n.type}</td><td>${svc}</td><td>${vul}</td><td>${sc}</td><td>${ts}</td><td>${tr}</td></tr>`;
    }).join('');
    wrap.innerHTML = `<div class='table-responsive'><table class='table table-sm table-bordered mb-0'><thead><tr><th>ID</th><th>Name</th><th>Type</th><th>Services</th><th>Vulns</th><th>Seg Rules</th><th>Traffic S</th><th>Traffic R</th></tr></thead><tbody>${rows}</tbody></table></div>`;
}

// Execute button in Full Preview modal
document.addEventListener('DOMContentLoaded', ()=>{
    const execBtn = document.getElementById('fpExecuteBtn');
    if(execBtn && !execBtn.dataset.boundExecute){
        execBtn.dataset.boundExecute = '1';
        let executing = false;
        const originalLabel = execBtn.textContent;
        const modalEl = document.getElementById('fullPreviewModal');
        const resolveModalInstance = () => {
            if(!modalEl || !window.bootstrap) return null;
            try {
                return bootstrap.Modal.getInstance(modalEl) || new bootstrap.Modal(modalEl);
            } catch(e){
                console.error('Failed to resolve full preview modal instance', e);
                return null;
            }
        };
        execBtn.addEventListener('click', async ()=>{
            if(executing) return;
            if(!state.result_path || !state.result_path.endsWith('.xml')){
                alert('Save XML before executing.');
                return;
            }
            if(!window.confirm('Execute this scenario now? This will start a CORE session.')) return;
            const modalInstance = resolveModalInstance();
            const forceHideModal = () => {
                try { modalInstance?.hide(); } catch(e){}
                if(modalEl){
                    modalEl.classList.remove('show');
                    modalEl.setAttribute('aria-hidden','true');
                    modalEl.style.display = 'none';
                }
                const openModals = document.querySelectorAll('.modal.show');
                if(openModals.length === 0){
                    document.querySelectorAll('.modal-backdrop').forEach(b => { try { b.remove(); } catch(e){} });
                    document.body.classList.remove('modal-open');
                    document.body.style.removeProperty('paddingRight');
                    document.body.style.removeProperty('overflow');
                }
            };
            const restoreModal = () => {
                try {
                    if(modalInstance){
                        modalInstance.show();
                    } else if(modalEl){
                        modalEl.style.display = 'block';
                        modalEl.classList.add('show');
                        document.body.classList.add('modal-open');
                    }
                } catch(e){}
            };
            const waitForPaint = async () => {
                await new Promise(resolve => requestAnimationFrame(() => resolve()));
            };
            executing = true;
            execBtn.disabled = true;
            execBtn.classList.add('disabled');
            if(originalLabel){ execBtn.textContent = 'Executing…'; }
            let runStarted = false;
            try {
                forceHideModal();
                await waitForPaint();
                openRunProgress('Executing scenario…');
                try {
                    document.getElementById('runProgressStatus').textContent = 'Starting…';
                    document.getElementById('runProgressMeta').textContent = '';
                    const bar = document.getElementById('runProgressBar');
                    if(bar){ bar.classList.add('progress-bar-animated'); bar.textContent = 'Working…'; }
                } catch(e){}
                // Ensure dock visible
                try { const showBtn=document.getElementById('dockShowBtn'); if(showBtn && !showBtn.classList.contains('d-none')) showBtn.click(); } catch(e){}
                appendLog('--- Execute (Full Preview) start: '+state.result_path+' ---','info');
                const form = new FormData(); form.append('xml_path', state.result_path);
                const res = await fetch("{{ url_for('run_cli_async') }}", { method: 'POST', body: form });
                if(!res.ok){
                    appendLog('Failed to start execution (HTTP '+res.status+')','error');
                    try {
                        const statusEl = document.getElementById('runProgressStatus');
                        if(statusEl) statusEl.textContent = 'Failed to start';
                        const metaEl = document.getElementById('runProgressMeta');
                        if(metaEl) metaEl.textContent = 'HTTP '+res.status;
                        const bar = document.getElementById('runProgressBar');
                        if(bar) bar.classList.remove('progress-bar-animated');
                    } catch(e){}
                    closeRunProgress();
                    restoreModal();
                    return;
                }
                const dataInit = await res.json();
                const run_id = dataInit.run_id;
                if(!run_id){
                    appendLog('Execution start response missing run_id','error');
                    try {
                        const statusEl = document.getElementById('runProgressStatus');
                        if(statusEl) statusEl.textContent = 'Failed to start';
                        const metaEl = document.getElementById('runProgressMeta');
                        if(metaEl) metaEl.textContent = 'Missing run id';
                        const bar = document.getElementById('runProgressBar');
                        if(bar) bar.classList.remove('progress-bar-animated');
                    } catch(e){}
                    closeRunProgress();
                    restoreModal();
                    return;
                }
                runStarted = true;
                appendLog('Run ID: '+run_id,'info');
                try {
                    const statusEl = document.getElementById('runProgressStatus');
                    if(statusEl) statusEl.textContent = 'Running…';
                    const metaEl = document.getElementById('runProgressMeta');
                    if(metaEl) metaEl.textContent = 'Streaming logs…';
                } catch(e){}
                runProgressRunId = run_id;
                try { if(runProgressEvtSrc) runProgressEvtSrc.close(); } catch(e){}
                runProgressEvtSrc = new EventSource('/stream/' + run_id);
                runProgressEvtSrc.onmessage = ev => {
                    if(ev && typeof ev.data === 'string') {
                        try {
                            runProgressLogLine(ev.data);
                        } catch(e) { /* swallow */ }
                    }
                };
                runProgressEvtSrc.addEventListener('end', ()=>{
                    try { runProgressEvtSrc?.close(); } catch(e){}
                    runProgressEvtSrc = null;
                    runProgressLogLine('Execution stream ended');
                });
                // Poll status until done
                (async function poll(){
                    try {
                        const r = await fetch('/run_status/' + run_id);
                        if(!r.ok){ setTimeout(poll, 1200); return; }
                        const st = await r.json();
                        if(!st.done){ setTimeout(poll, 1000); return; }
                        try {
                            const metaEl = document.getElementById('runProgressMeta');
                            if(metaEl) metaEl.textContent = st.returncode===0 ? 'Completed' : 'Finished';
                            const bar = document.getElementById('runProgressBar');
                            if(bar){ bar.classList.remove('progress-bar-animated'); bar.textContent = st.returncode===0 ? 'Done' : 'Error'; }
                        } catch(e){}
                        if(st.returncode===0){
                            appendLog('Execution complete: success; redirecting to Reports','info');
                            try {
                                const statusEl = document.getElementById('runProgressStatus');
                                if(statusEl) statusEl.textContent = 'Scenario started';
                            } catch(e){}
                            setTimeout(()=>{ window.location.href = "{{ url_for('reports_page') }}"; }, 700);
                        } else {
                            appendLog('Execution finished with errors (code '+st.returncode+')','error');
                            try {
                                const statusEl = document.getElementById('runProgressStatus');
                                if(statusEl) statusEl.textContent = 'Finished with errors';
                            } catch(e){}
                        }
                    } catch(e){ setTimeout(poll, 1500); }
                })();
            } catch(e){
                appendLog('Execution exception: '+e,'error');
                try {
                    const statusEl = document.getElementById('runProgressStatus');
                    if(statusEl) statusEl.textContent = 'Exception starting run';
                    const metaEl = document.getElementById('runProgressMeta');
                    if(metaEl) metaEl.textContent = '';
                    const bar = document.getElementById('runProgressBar');
                    if(bar) bar.classList.remove('progress-bar-animated');
                } catch(_){}
                if(!runStarted){
                    closeRunProgress();
                    restoreModal();
                }
            }
            finally {
                execBtn.disabled = false;
                execBtn.classList.remove('disabled');
                if(originalLabel){ execBtn.textContent = originalLabel; }
                executing = false;
            }
        });
    }
});

// Seed clear button
document.addEventListener('DOMContentLoaded', () => {
  const scb = document.getElementById('seedClearBtn');
    // seed clear button removed
});

// ------------- Auto-Save Support for Planning -------------
async function autoSaveXml(){
    return new Promise((resolve, reject) => {
        try {
            // Mirror logic from manual Save XML submission but use fetch
            const scenariosJsonInput = document.getElementById('scenarios_json');
            if(!scenariosJsonInput){ reject('Editor form missing'); return; }
            try { scenariosJsonInput.value = JSON.stringify({ scenarios: state.scenarios, active_index: activeIdx }); } catch(e){ reject('Serialize failed'); return; }
            const formData = new FormData();
            formData.append('scenarios_json', scenariosJsonInput.value);
            fetch('/save_xml', { method:'POST', body: formData })
                .then(r=>r.text())
                .then(html => {
                    // Parse returned HTML for updated payload JSON script tag
                    try {
                        const parser = new DOMParser();
                        const doc = parser.parseFromString(html, 'text/html');
                        const payloadScript = doc.querySelector('#payload-data');
                        if(payloadScript){
                            const newPayload = JSON.parse(payloadScript.textContent || 'null');
                            if(newPayload && newPayload.result_path){
                                state.result_path = newPayload.result_path;
                                try { const persisted = JSON.parse(localStorage.getItem('coretg_editor_state')||'{}'); persisted.result_path = state.result_path; localStorage.setItem('coretg_editor_state', JSON.stringify(persisted)); } catch(e){}
                                previewState.xmlSaved = true;
                                updatePlanButtons();
                                resolve();
                                return;
                            }
                        }
                        reject('Could not detect saved XML path in response');
                    } catch(e){ reject(e); }
                })
                .catch(err => reject(err));
        } catch(e){ reject(e); }
    });
}

if (persistedState && !initialPayload?.core && persistedState.core) {
    state.core = persistedState.core;
}
if (persistedState) {
    if (persistedState.core_ok !== undefined) state.core_ok = persistedState.core_ok;
    if (persistedState.core_tested_host !== undefined) state.core_tested_host = persistedState.core_tested_host;
    if (persistedState.core_tested_port !== undefined) state.core_tested_port = persistedState.core_tested_port;
}
let activeIdx = Math.min(Math.max(0, persistedActiveIdx), (state.scenarios.length||1)-1);

function persistEditorState(){
    try {
        localStorage.setItem('coretg_editor_state', JSON.stringify({
            scenarios: state.scenarios,
            result_path: state.result_path || null,
            core: state.core || null,
            core_ok: !!state.core_ok,
            core_tested_host: state.core_tested_host || null,
            core_tested_port: state.core_tested_port || null
        }));
        localStorage.setItem('coretg_active_idx', String(activeIdx||0));
    } catch(e){}
}
// Persist initial merged state so it survives cross-page navigation immediately
persistEditorState();

const dropdownsBySection = {
    'Node Information': ['Server','Workstation','PC','Random'],
    // Added 'Random' entry so user can explicitly request a random routing protocol.
    'Routing': ['RIP','RIPv2','BGP','OSPFv2','OSPFv3','Random'],
    'Services': ['SSH','HTTP','DHCPClient','Random'],
    'Traffic': ['Random','TCP','UDP','CUSTOM'],
    'Events': ['Script Path'],
    'Vulnerabilities': ['Category','Specific','Random'],
    'Segmentation': ['Random','Firewall','NAT','CUSTOM']
};

function render() {
    renderSidebar();
    renderMain();
    // Ensure H/S bounds visibility reflects initial r2s_mode values
    updateHsBoundsVisibility();
    // Download link visibility if provided
    // Enable/disable Download XML button based on saved xml path
    const dlBtn = document.getElementById('downloadXmlBtn');
    if (dlBtn) {
        const rp = state.result_path || '';
        if (rp && rp.endsWith('.xml')) { dlBtn.removeAttribute('disabled'); dlBtn.classList.remove('pe-none'); dlBtn.setAttribute('title',''); }
        else { dlBtn.setAttribute('disabled','disabled'); dlBtn.classList.add('pe-none'); dlBtn.setAttribute('title','Save XML first'); }
    }
    // Sync Base Scenario File input with active scenario
    const baseIn = document.getElementById('baseFileInput');
    if (baseIn && state.scenarios.length) {
        const full = state.scenarios[activeIdx]?.base?.filepath || '';
        const baseName = full.split(/[/\\]/).pop();
        if (baseIn.value !== baseName) baseIn.value = baseName;
        // Read-only display: no input handler needed to modify state
    }
}

// --- Scenario multi-select support ---
let selectedScenarioIds = new Set();
try {
    const savedSel = JSON.parse(localStorage.getItem('coretg_selected_scenarios')||'[]');
    if (Array.isArray(savedSel)) savedSel.forEach(id => selectedScenarioIds.add(id));
} catch(e){}

function persistScenarioSelection() {
    try { localStorage.setItem('coretg_selected_scenarios', JSON.stringify(Array.from(selectedScenarioIds))); } catch(e){}
}

function ensureScenarioIds() {
    let changed = false;
    state.scenarios.forEach(s => {
        if (!s._sid) { s._sid = 'scen_' + Date.now().toString(36) + '_' + Math.random().toString(36).slice(2,8); changed = true; }
    });
    if (changed) persistEditorState();
}

function toggleScenarioSelection(id, checked) {
    if (checked) selectedScenarioIds.add(id); else selectedScenarioIds.delete(id);
    persistScenarioSelection();
    updateBulkButtonsState();
}

function selectAllScenarios() {
    ensureScenarioIds();
    const allIds = state.scenarios.map(s => s._sid);
    const allSelected = allIds.every(id => selectedScenarioIds.has(id));
    if (allSelected) { selectedScenarioIds.clear(); }
    else { allIds.forEach(id => selectedScenarioIds.add(id)); }
    persistScenarioSelection();
    renderSidebar();
}

function deleteSelectedScenarios() {
    if (!selectedScenarioIds.size) return;
    const count = selectedScenarioIds.size;
    if (!confirm(`Delete ${count} selected scenario${count>1?'s':''}? This cannot be undone.`)) return;
    const beforeLen = state.scenarios.length;
    state.scenarios = state.scenarios.filter(s => !selectedScenarioIds.has(s._sid));
    selectedScenarioIds.clear();
    if (!state.scenarios.length) {
        // Always keep at least one blank scenario to avoid empty editor state hassles
        state.scenarios.push(defaultScenario());
        activeIdx = 0;
    } else {
        if (activeIdx >= state.scenarios.length) activeIdx = state.scenarios.length - 1;
    }
    logInfo(`Deleted ${beforeLen - state.scenarios.length} scenarios`);
    persistEditorState();
    persistScenarioSelection();
    try { previewState.dirty = true; updatePlanButtons(); } catch(e){}
    render();
}

function updateBulkButtonsState() {
    const delBtn = document.getElementById('deleteSelectedScenariosBtn');
    if (!delBtn) return;
    if (selectedScenarioIds.size) { delBtn.removeAttribute('disabled'); delBtn.title = 'Delete selected'; }
    else { delBtn.setAttribute('disabled','disabled'); delBtn.title = 'No scenarios selected'; }
}

function renderSidebar() {
    ensureScenarioIds();
    const list = document.getElementById('scenarioList');
    list.innerHTML = '';
    state.scenarios.forEach((scen, idx) => {
        const sid = scen._sid;
        const a = document.createElement('a');
        a.href = '#';
        a.className = 'list-group-item list-group-item-action py-1' + (idx === activeIdx ? ' active bg-primary text-white' : '');
        // Build inner HTML with checkbox
        const isChecked = selectedScenarioIds.has(sid);
        const name = scen.name || `Scenario ${idx+1}`;
        a.innerHTML = `<div class="d-flex align-items-center">
            <input type="checkbox" class="form-check-input me-2 scenario-select" data-sid="${sid}" ${isChecked? 'checked':''} onclick="event.stopPropagation(); toggleScenarioSelection('${sid}', this.checked);" />
            <span class="flex-grow-1 text-truncate" title="${name.replace(/"/g,'&quot;')}">${name}</span>
        </div>`;
        a.onclick = (e) => { e.preventDefault(); activeIdx = idx; persistEditorState(); render(); };
        list.appendChild(a);
    });
    const appendScenarioBtn = document.getElementById('appendScenarioBtn');
    const importBtn = document.getElementById('importBtn');
    const exportBtn = document.getElementById('exportBtn');
    const selectAllBtn = document.getElementById('selectAllScenariosBtn');
    const deleteSelectedBtn = document.getElementById('deleteSelectedScenariosBtn');
    const hiddenLoadInput = document.getElementById('hiddenLoadInput');
    const hiddenLoadForm = document.getElementById('hiddenLoadForm');
    if (appendScenarioBtn) appendScenarioBtn.onclick = (e) => { e.preventDefault(); logInfo('New scenario created'); state.scenarios.push(defaultScenario()); activeIdx = state.scenarios.length - 1; persistEditorState(); try { previewState.dirty = true; updatePlanButtons(); } catch(e){} render(); };
    if (importBtn) importBtn.onclick = (e) => { e.preventDefault(); logInfo('Import scenarios clicked'); hiddenLoadInput.click(); };
    if (hiddenLoadInput) hiddenLoadInput.onchange = () => { if (hiddenLoadInput.files && hiddenLoadInput.files.length > 0) { saveScrollBeforeNav(); hiddenLoadForm.submit(); } };
    if (exportBtn) exportBtn.onclick = (e) => {
        e.preventDefault();
        logInfo('Export clicked');
        const rp = state.result_path || '';
        if (!rp.endsWith('.xml')) {
            logWarn('Export blocked: no saved XML');
            alert('Please Save XML first (middle panel) to export the current scenarios.');
            return;
        }
        window.location.href = window.location.origin + '/download_report?path=' + encodeURIComponent(rp);
    };
    if (selectAllBtn) selectAllBtn.onclick = (e) => { e.preventDefault(); selectAllScenarios(); };
    if (deleteSelectedBtn) deleteSelectedBtn.onclick = (e) => { e.preventDefault(); deleteSelectedScenarios(); };
    updateBulkButtonsState();
}

function renderMain() {
    const root = document.getElementById('editorRoot');
    root.innerHTML = '';
    if (!state.scenarios.length) { return; }
    const scen = state.scenarios[activeIdx] || state.scenarios[0];
    // --- Host density normalization for Node Information ---
    try {
        const ni = scen.sections && scen.sections['Node Information'];
        if (ni) {
            ni.items = ni.items || [];
            // Ensure at least one weight row (Random) exists for fallback if all removed
            let randomRow = ni.items.find(it => !(it.v_metric==='Count') && (it.selected||'').toLowerCase()==='random');
            if (!randomRow) {
                // Add with temporary factor 0 (will be set if needed)
                ni.items.unshift({ selected:'Random', factor: 0.0 });
                randomRow = ni.items[0];
            }
            // Mark the first Random weight row as protected residual; unmark any other Random weight rows
            randomRow._protected_random = true;
            ni.items.forEach(it => {
                if (it !== randomRow && (it.v_metric !== 'Count') && ((it.selected||'').toLowerCase()==='random')) {
                    if (it._protected_random) delete it._protected_random;
                }
            });
            const weightRows = ni.items.filter(it => !(it.v_metric==='Count'));
            weightRows.forEach(it => { let f = parseFloat(it.factor); if (isNaN(f) || f < 0) f = 0; it.factor = f; });
            // Sum excluding Random for decision
            const nonRandom = weightRows.filter(it => (it.selected||'').toLowerCase()!=='random');
            let nonRandomSum = nonRandom.reduce((a,b)=> a + (parseFloat(b.factor)||0), 0);
            if (nonRandom.length === 0) {
                // Only Random exists; set to 1.0
                randomRow.factor = 1.0; nonRandomSum = 0;
            } else {
                if (nonRandomSum >= 1.0) {
                    randomRow.factor = 0.0; // others define full density
                } else {
                    randomRow.factor = 1.0 - nonRandomSum;
                }
            }
            // Final normalization (should already sum to 1.0)
            const finalSum = weightRows.reduce((a,b)=> a + (parseFloat(b.factor)||0), 0);
            if (Math.abs(finalSum - 1.0) > 1e-6 && finalSum > 0) {
                // scale all
                weightRows.forEach(it => { it.factor = (parseFloat(it.factor)||0)/finalSum; });
            }
        }
    } catch(e) { console.warn('Normalization error', e); }
    // Load persisted section collapse state (per scenario + section)
    let collapseState = {};
    try { collapseState = JSON.parse(localStorage.getItem('sectionCollapseState') || '{}'); } catch(e) { collapseState = {}; }
    // No auto-insertion of Count rows for Node Information; totals should only include user-added Count rows
    // Scenario header with Count for Density (base host pool) restored
    const niSec = scen.sections['Node Information'] || { items: [] };
    const niItems = niSec.items || [];
    const niWeightRows = niItems.filter(it => (it.v_metric || (it.selected==='Specific'?'Count':'Weight')) === 'Weight');
    const niCountRows = niItems.filter(it => (it.v_metric || (it.selected==='Specific'?'Count':'Weight')) === 'Count');
    // Base removed: host total now purely additive Count rows when no base; or proportional part is implied but base count is scenario-level (not editable here)
    let densityCountVal = 10;
    try {
        if (scen.density_count !== undefined && scen.density_count !== null && scen.density_count !== '') {
            const parsed = parseInt(scen.density_count, 10);
            if (!isNaN(parsed)) densityCountVal = parsed;
        }
    } catch(e) { densityCountVal = 10; }
    if (densityCountVal < 0) densityCountVal = 0;
    const niBase = densityCountVal;
    const niAdd = niCountRows.reduce((a,it)=> a + (parseInt(it.v_count,10)||0), 0);
    const niTotal = niBase + niAdd;
    const niTitle = 'Hosts = Base (Count for Density) allocated by weight rows + additive Count rows';
    // Build allocation breakdown tooltip for weight rows
    let allocTip = niTitle;
    if (niWeightRows.length) {
        const wTotal = niWeightRows.reduce((a,it)=> a + (parseFloat(it.factor)||0), 0) || 0;
        if (wTotal > 0) {
            const parts = niWeightRows.map(it => {
                const f = parseFloat(it.factor)||0;
                const pct = wTotal ? ((f / wTotal) * 100).toFixed(1) : '0.0';
                const label = (it.selected || 'Row');
                return `${label}:${f}(${pct}%)`;
            });
            allocTip += ' | Weights: ' + parts.join(', ');
        }
    }
    const hostBadgeClass = (niWeightRows.length && niBase === 0 && niAdd > 0) ? 'text-bg-warning' : 'text-bg-primary';
    // Simplified host summary: remove ΣW badge, allocation popover, and auto-scale functionality
    const hostSummaryHtml = `<span class=\"badge rounded-pill ${hostBadgeClass} host-total-badge ms-2\" data-bs-toggle=\"tooltip\" title=\"${allocTip.replace(/"/g,'&quot;')}\">Hosts: ${niWeightRows.length ? (niBase + ' + ' + niAdd + ' = ' + niTotal) : (niAdd)}</span>`;
    const densityBaseHtml = `<div class=\"d-flex align-items-center gap-1\" title=\"Base host pool used only for weight-based density calculations; Count rows are additive beyond this.\"><label class=\"form-label mb-0\">Count for Density</label><input type=\"number\" min=\"0\" max=\"5000\" step=\"1\" class=\"form-control form-control-sm\" style=\"width:120px\" value=\"${densityCountVal}\" data-scen-idx=\"${activeIdx}\" data-field=\"scenario_density_count\" /></div>`;
    const headerRow = document.createElement('div');
    const rawSectionNames = Object.keys(scen.sections || {});
    const filteredSectionNames = rawSectionNames.filter(name => name !== 'Notes');
    const secNames = [];
    if (filteredSectionNames.includes('Node Information')) {
        secNames.push('Node Information');
    }
    filteredSectionNames.forEach(name => {
        if (name !== 'Node Information') {
            secNames.push(name);
        }
    });
    // Base host pool for density-driven (weight) allocations comes from scenario.density_count
    const baseHostPool = (scen.density_count !== undefined && scen.density_count !== null && scen.density_count !== '' ? (parseInt(scen.density_count,10)||0) : 10);
    secNames.forEach(name => {
        const sec = scen.sections[name] || { items: [] };
    const hasNodes = (name === 'Node Information');
        const itemCount = (sec.items || []).length;
        // Determine if any weight rows exist in this section (used for Node Information behavior)
        const hasWeightRowsPre = hasNodes ? ((sec.items || []).some(it => ((it.v_metric || (it.selected==='Specific'? 'Count' : 'Weight')) === 'Weight'))) : false;
        // Always ensure density has a sensible default value
        if (!hasNodes) {
            if (sec.density === undefined || sec.density === null || isNaN(sec.density)) {
                sec.density = 0.5;
            }
        }
        const densVal = sec.density;
        const nodesVal = '';
        const extraNodeCount = hasNodes ? ((sec.items || []).reduce((acc, it) => {
            const metric = it.v_metric || (it.selected==='Specific'?'Count':'Weight');
            return acc + (metric === 'Count' ? (parseInt(it.v_count) || 0) : 0);
        }, 0)) : 0;
    const hasWeightRows = hasNodes ? hasWeightRowsPre : false;
    const totalNodeCount = hasNodes ? (extraNodeCount + (hasWeightRowsPre ? niBase : 0)) : 0;
    const totalNodesLabel = hasNodes ? (totalNodeCount === 1 ? 'Total Node' : 'Total Nodes') : '';
    // Define totalPlanned (was previously referenced but never declared, causing a ReferenceError that prevented section rendering)
    const totalPlanned = hasNodes ? totalNodeCount : 0;
        // Improved initial collapse behavior:
        // - Always expand Node Information (primary planning surface)
        // - Other sections start collapsed only if empty
        let collapsed;
        if (name === 'Node Information') collapsed = false; else collapsed = (itemCount === 0);
        // Override with persisted state if present
        const collapseKey = `${activeIdx}::${name}`;
        if (collapseState.hasOwnProperty(collapseKey)) {
            collapsed = !!collapseState[collapseKey];
        }
        const card = document.createElement('div');
        card.className = 'card mb-3';
        const collapseId = `collapse-${name.replace(/\s+/g,'-')}`;
        const iconHtml = itemCount > 0
            ? `<i class='bi bi-collection-fill text-success' data-bs-toggle="tooltip" data-bs-title="${itemCount} item(s)"></i>`
            : `<i class='bi bi-collection text-muted' data-bs-toggle="tooltip" data-bs-title="No items"></i>`;
        // Enhanced tooltip text clarifying how combined total is derived.
        const totalNodesTooltip = hasNodes ? 'Combined total = (sum of all Count-based row counts) + (Total Nodes if any Weight-based rows exist). Weight rows allocate Total Nodes by their weights; Count rows are absolute and do not affect weights.' : '';
        // Compute planned badges (hosts / routers / vulns) for this section
        let hostBadge = '';
        if (name === 'Node Information') {
            const basePart = hasWeightRows ? niBase : 0;
            const additivePart = extraNodeCount;
            const totalPlannedHosts = basePart + additivePart;
            if (hasWeightRows || additivePart > 0) {
                const display = hasWeightRows ? `${basePart} + ${additivePart} = ${totalPlannedHosts}` : `${additivePart}`;
                hostBadge = `<span class=\"badge rounded-pill text-bg-primary ms-2 host-total-badge\" data-bs-toggle=\"tooltip\" title=\"${allocTip.replace(/"/g,'&quot;')}\">Hosts: ${display}</span>`;
            }
        }
        const hostSummaryBlock = (name === 'Node Information' && (niBase > 0 || niAdd > 0 || hasWeightRows))
            ? `<div class="d-flex align-items-center gap-2">${hostSummaryHtml}</div>`
            : '';
        const nodeMetaHtml = (name === 'Node Information')
            ? `<div class="d-flex flex-wrap align-items-center justify-content-between gap-3 mb-3">
                    ${densityBaseHtml}
                    ${hostSummaryBlock}
               </div>`
            : '';
        let routingBadge = '';
        if (name === 'Routing') {
            const rItems = sec.items || [];
            const rRows = rItems.map(it => ({ metric: (it.v_metric || 'Weight'), it }));
            const rCountRows = rRows.filter(r => r.metric === 'Count');
            const rWeightRows = rRows.filter(r => r.metric === 'Weight');
            const densR = (typeof sec.density === 'number') ? sec.density : 0;
            const explicit = rCountRows.reduce((a,r)=> a + (parseInt(r.it.v_count,10)||0), 0);
            let derived = 0;
            if (rWeightRows.length && densR > 0) {
                const frac = Math.max(0, Math.min(1, densR));
                derived = Math.round(baseHostPool * frac);
            }
            const total = explicit + derived;
            if (total > 0) routingBadge = `<span class=\"badge rounded-pill text-bg-secondary ms-2\" title=\"Routers planned additively: Count rows + (Density * Base Hosts). Density constrained 0..1.\">Routers: ${total}</span>`;
        }
        let vulnBadge = '';
        if (name === 'Vulnerabilities') {
            const vItems = sec.items || [];
            const vRows = vItems.map(it => ({ metric: (it.v_metric || (it.selected==='Specific'?'Count':'Weight')), it }));
            const vCountRows = vRows.filter(r => r.metric === 'Count');
            const vWeightRows = vRows.filter(r => r.metric === 'Weight');
            const densV = (typeof sec.density === 'number') ? sec.density : 0;
            const explicit = vCountRows.reduce((a,r)=> a + (parseInt(r.it.v_count,10)||0), 0);
            let derived = 0;
            if (vWeightRows.length && densV > 0) derived = Math.round(baseHostPool * Math.min(1, densV));
            const total = explicit + derived;
            if (total > 0) vulnBadge = `<span class=\"badge rounded-pill text-bg-info ms-2\" title=\"Vulnerability assignments additive: Count rows + (Density * Base Hosts). Density clipped to 1.0 when fractional.\">Vulns: ${total}</span>`;
        }
    const badgeSpan = hostBadge + routingBadge + vulnBadge;
        card.innerHTML = `
            <div class="card-header d-flex align-items-center gap-2">
                ${iconHtml}
                <strong>${name}</strong>${badgeSpan}
                <div class="ms-auto d-flex gap-2">
                    <button class="btn btn-sm btn-outline-primary" data-action="add-item" data-scen-idx="${activeIdx}" data-sec="${name}">Add</button>
                    <button class="btn btn-sm btn-outline-secondary" type="button" data-action="toggle-collapse" data-target="#${collapseId}">${collapsed ? 'Expand' : 'Collapse'}</button>
                </div>
            </div>
            <div id="${collapseId}" class="card-body" style="display:${collapsed ? 'none':'block'};">
                ${nodeMetaHtml}
                                <div class="table-responsive">
                                                                                <table class="table table-sm align-middle">
                                                                                        <thead>
                                                                                            <tr>
                                                                                                <th style="width:280px"></th>
                                                                                                <th></th>
                                                                                                <th style="width:160px"></th>
                                                                                                <th style="width:80px"></th>
                                                                                            </tr>
                                                                                        </thead>
                                                                    <tbody>
                                                                                ${(() => {
                                                                                const items = sec.items || [];
                                                                                const rowsByMetric = items.map((it, iidx) => ({ it, iidx, metric: (it.v_metric || (name==='Vulnerabilities' && (it.selected||'Category')==='Specific' ? 'Count' : 'Weight')) }));
                                                                                const weights = rowsByMetric.filter(x => x.metric === 'Weight');
                                                                                const counts = rowsByMetric.filter(x => x.metric === 'Count');
                                                                                // If there are no remaining weight rows but a stale total_nodes exists, clear it (frontend-only cleanup)
                                                                                if (name === 'Node Information' && weights.length === 0) {
                                                                                    const secRef = state.scenarios[activeIdx].sections[name];
                                                                                    if (secRef && secRef.total_nodes) { secRef.total_nodes = 0; }
                                                                                }
                                                                                const parts = [];
                                                                                const showWeightHeader = (weights.length > 0);
                                        if (showWeightHeader) {
                                                                                    const densCtrl = (
                                                                                        name === 'Node Information'
                                                                                            ? `<div class=\"d-flex align-items-center justify-content-end gap-2 small text-muted\"><span>Density</span><input disabled class=\"form-control form-control-sm\" style=\"width:80px\" value=\"1.0\"></div>`
                                                                                                : (name === 'Routing'
                                                                                                                                                                                                ? `<div class=\"d-flex align-items-center justify-content-end gap-2\">`
                                                                                                                                                                                                        + `<span>Density</span>`
                                                                                                                                                                                                        + `<input type=\"number\" step=\"0.01\" min=\"0\" max=\"1\" class=\"form-control form-control-sm\" style=\"width:120px\" placeholder=\"e.g., 0.25\" value=\"${densVal}\" data-scen-idx=\"${activeIdx}\" data-sec=\"${name}\" data-field=\"density\">`
                                                                                                                                                                                                    + `</div>`
                                                                                                                                                                                                : (() => {
                                                                                                                                                                                                    const tooltip = (name === 'Services')
                                                                                                                                                                                                        ? 'Services: per-item Count overrides density; assigns exactly that many hosts the selected service.'
                                                                                                                                                                                                        : (name === 'Traffic')
                                                                                                                                                                                                            ? 'Traffic: per-item Count overrides density; creates exactly that many sender/receiver pairs.'
                                                                                                                                                                                                            : (name === 'Segmentation')
                                                                                                                                                                                                                ? 'Segmentation: per-item Count overrides density; plans exactly that many slots (NAT prioritized).'
                                                                                                                                                                                                                : '';
                                                                                                                                                                                                    let info = '';
                                                                                                                                                                                                    // Density tooltip removed
                                                                                                                                                                                                    return '<div class="d-flex align-items-center justify-content-end gap-2">'
                                                                                                                                                                                                        + '<span>Density</span>'
                                                                                                                                                                                                        + info
                                                                                                                                                                                                        + '<input type="number" step="0.01" min="0" max="1" class="form-control form-control-sm" style="width:100px" value="' + densVal + '" data-scen-idx="' + activeIdx + '" data-sec="' + name + '" data-field="density">'
                                                                                                                                                                                                    + '</div>';
                                                                                                                                                                                                })()
                                                                                                                                                                                            )
                                                                                                                                                                        );
                                                                                    parts.push(`<tr class=\"table-light\"><td colspan=\"2\"><strong>Weight-based</strong></td><td class=\"text-end\">${densCtrl}</td><td></td></tr>`);
                                                                                    if (weights.length) { parts.push(weights.map(x => renderItemRow(activeIdx, name, x.iidx, x.it)).join('')); }
                                                                                }
                                                                                if (counts.length) {
                                                                                    const countHdr = (name === 'Node Information') ? 'Count-based' : 'Count-based';
                                                                                    parts.push(`<tr class=\"table-light\"><td colspan=\"4\"><strong>${countHdr}</strong></td></tr>`);
                                                                                    parts.push(counts.map(x => renderItemRow(activeIdx, name, x.iidx, x.it)).join(''));
                                                                                }
                                                                                return parts.join('');
                                                                            })()}
                                                                    </tbody>
                    </table>
                </div>
                                        <div class="text-danger small mt-1 section-warning" data-scen-idx="${activeIdx}" data-sec="${name}" style="display:none">Weights must sum to 1.000</div>
                                        ${name==='Routing' ? `
                                        <div id="routingEdgesWarnings" class="alert alert-warning py-2 px-3 small mt-3 d-none"></div>
                                        <div class="d-flex flex-wrap align-items-center gap-3 mt-3 small" id="routingEdgesSummary" style="display:none;">
                                                <div><strong>Policy:</strong> <span data-role="edges-policy">(pending)</span></div>
                                        </div>
                                        ` : ''}
            </div>`;
        root.appendChild(card);
    });
    // Apply visibility rule for H/S bounds after DOM built
    updateHsBoundsVisibility();
        // activate tooltips for icons
        if(window.bootstrap){
            const tts = root.querySelectorAll('[data-bs-toggle="tooltip"]');
            tts.forEach(el => new bootstrap.Tooltip(el));
        }

    // Notes card (collapsible, collapsed by default)
    const notesCard = document.createElement('div');
    notesCard.className = 'card mb-3';
    const hasNotes = (scen.notes||'').trim().length>0;
    const collapseId = `notesCollapse_${activeIdx}`;
    notesCard.innerHTML = `
        <div class="card-header d-flex justify-content-between align-items-center">
            <button class="btn btn-sm btn-link text-decoration-none p-0 d-flex align-items-center gap-2" type="button" data-bs-toggle="collapse" data-bs-target="#${collapseId}" aria-expanded="false" aria-controls="${collapseId}">
                <span class="me-1">Notes</span>
                <span id="notesIndicator_${activeIdx}" class="d-inline-flex align-items-center" data-bs-toggle="tooltip" data-bs-title="${hasNotes? 'Notes present':'No notes'}">
                    ${hasNotes ? `<i class='bi bi-journal-text text-success'></i>` : `<i class='bi bi-journal text-muted'></i>`}
                </span>
            </button>
            <small class="text-muted">optional</small>
        </div>
        <div id="${collapseId}" class="collapse">
            <div class="card-body p-2">
                <textarea class="form-control" rows="3" data-scen-idx="${activeIdx}" data-field="notes" placeholder="Add scenario notes (markdown supported)">${scen.notes || ''}</textarea>
            </div>
        </div>`;
    root.appendChild(notesCard);

    wireHandlers();
    wireCoreControls();
    // Populate dynamic vuln selects after DOM paint
    populateVulnSelects();
    // Hook up Specific picker buttons
    document.querySelectorAll('[data-action="pick-specific"]').forEach(btn => {
        const handler = () => {
            const sidx = parseInt(btn.getAttribute('data-scen-idx'));
            const sec = btn.getAttribute('data-sec');
            const iidx = parseInt(btn.getAttribute('data-item-idx'));
            openVulnPicker(sidx, sec, iidx);
        };
        // Attach the click handler (fix: previously not wired)
        btn.addEventListener('click', handler);
    });
}

function updateHsBoundsVisibility(){
    try {
        document.querySelectorAll('[data-field="r2s_mode"]').forEach(selEl => {
            const modeVal = selEl.value;
            const wrapper = selEl.closest('.routing-edge-groups')?.querySelector('.hs-bounds-wrapper');
            if (wrapper) {
                if (modeVal === 'NonUniform') {
                    wrapper.classList.add('hs-show');
                } else {
                    wrapper.classList.remove('hs-show');
                }
            }
        });
    } catch(e) { /* ignore */ }
}

// renderSections was deprecated and removed; rendering is handled in renderMain()
function renderItemRow(sidx, secName, iidx, it) {
    // Build Selected options and current weight
    const weight = ((parseFloat(it.factor) || 0).toFixed(3));
    let opts = '';
    if (secName === 'Vulnerabilities') {
        const cur = it.selected || 'Category';
        const options = ['Category', 'Specific', 'Random'];
        opts = options.map(o => `<option ${o===cur?'selected':''}>${o}</option>`).join('');
    } else {
        const cur = it.selected || 'Random';
        // Per-section allowed options (excluding 'auto')
        let options = ['Random'];
        switch (secName) {
            case 'Node Information':
                options = ['Server', 'Workstation', 'PC', 'Random'];
                break;
            case 'Routing':
                options = ['RIP', 'RIPv2', 'BGP', 'OSPFv2', 'OSPFv3', 'Random'];
                break;
            case 'Services':
                options = ['SSH', 'HTTP', 'DHCPClient', 'Random'];
                break;
            case 'Traffic':
                options = ['Random', 'TCP', 'UDP', 'CUSTOM'];
                break;
            case 'Events':
                options = ['Script Path'];
                break;
            case 'Segmentation':
                options = ['Random', 'Firewall', 'NAT', 'CUSTOM'];
                break;
            default:
                options = ['Random'];
        }
        opts = options.map(o => `<option ${o===cur?'selected':''}>${o}</option>`).join('');
    }

    const extras = (() => {
        if (secName === 'Events') {
            return `<input class="form-control form-control-sm" placeholder="script path" value="${it.script_path || ''}" data-scen-idx="${sidx}" data-sec="${secName}" data-item-idx="${iidx}" data-field="script_path">`;
        }
        if (secName === 'Routing') {
            // Edges mode (Random/Min/Max/Exact). Random now acts like previous Auto (no extra links augmentation).
            const mode = it.r2r_mode || (it.r2r_edges !== undefined ? 'Exact' : 'Random');
            const val = (it.r2r_edges !== undefined && it.r2r_edges !== null) ? it.r2r_edges : '';
            const options = [
                {v:'Random', l:'Random'},
                {v:'Min', l:'Min'},
                {v:'Uniform', l:'Uniform'},
                {v:'Exact', l:'Exact'},
                {v:'NonUniform', l:'NonUniform'}
            ];
            const selHtml = `<select class="form-select form-select-sm routing-mode-select" style="width:105px" data-field="r2r_mode" data-scen-idx="${sidx}" data-sec="${secName}" data-item-idx="${iidx}">${options.map(o => `<option value="${o.v}" ${o.v===mode?'selected':''}>${o.l}</option>`).join('')}</select>`;
            // R-to-S (router to switch) connectivity policy (same option set)
            const r2sMode = it.r2s_mode || 'Random';
            const r2sVal = (it.r2s_edges !== undefined && it.r2s_edges !== null) ? it.r2s_edges : '';
            const r2sSel = `<select class="form-select form-select-sm routing-mode-select" style="width:105px" data-field="r2s_mode" data-scen-idx="${sidx}" data-sec="${secName}" data-item-idx="${iidx}">${options.map(o => `<option value="${o.v}" ${o.v===r2sMode?'selected':''}>${o.l}</option>`).join('')}</select>`;
            const r2sHostsMin = (it.r2s_hosts_min !== undefined && it.r2s_hosts_min !== null) ? it.r2s_hosts_min : 1;
            const r2sHostsMax = (it.r2s_hosts_max !== undefined && it.r2s_hosts_max !== null) ? it.r2s_hosts_max : 4;
            const showHsBounds = (r2sMode === 'NonUniform');
            return `
                <div class="d-flex flex-column gap-1 routing-edge-groups">
                    <div class="d-flex flex-wrap gap-2 align-items-center">
                        <label class="form-label mb-0 me-1" style="min-width:110px" title="Router-to-Router edge policy. Random = spanning tree; Min = chain; Uniform = balanced degrees; Exact = chain+augment to target; NonUniform = heterogeneous.">R-to-R Edges</label>
                        <div class="d-flex gap-3 align-items-end">
                            <div>${selHtml}</div>
                            <div class="edges-exact-input" style="display:${mode==='Exact'?'block':'none'};">
                                <input type="number" min="1" class="form-control form-control-sm edges-degree-input" style="width:110px" value="${val}" data-field="r2r_edges" data-scen-idx="${sidx}" data-sec="${secName}" data-item-idx="${iidx}" placeholder="Exact (e.g. 3)" aria-label="Exact router degree target" title="Target degree each router should attempt to reach (cannot reduce existing higher degrees).">
                            </div>
                        </div>
                    </div>
                    <div class="d-flex flex-wrap gap-2 align-items-center">
                        <label class="form-label mb-0 me-1" style="min-width:110px" title="Router-to-Switch attachment policy; controls how many distinct switches each router connects to.">R-to-S Edges</label>
                        <div class="d-flex gap-3 align-items-end flex-wrap align-items-center">
                            <div>${r2sSel}</div>
                            <div class="r2s-exact-input" style="display:${r2sMode==='Exact'?'block':'none'};">
                                <input type="number" min="1" class="form-control form-control-sm r2s-degree-input" style="width:110px" value="${r2sVal}" data-field="r2s_edges" data-scen-idx="${sidx}" data-sec="${secName}" data-item-idx="${iidx}" placeholder="Exact (e.g. 2)" aria-label="Exact router-to-switch target" title="Target number of switches per router (Exact mode).">
                            </div>
                            <div class="gap-2 align-items-end small hs-bounds-wrapper">
                                <div>
                                    <label class="form-label mb-0" style="font-size:0.7rem" title="Minimum hosts per created switch for this router row (preview & build).">H/S Min</label>
                                    <input type="number" min="1" max="32" class="form-control form-control-sm hs-min-input" style="width:70px" value="${r2sHostsMin}" data-field="r2s_hosts_min" data-scen-idx="${sidx}" data-sec="${secName}" data-item-idx="${iidx}" placeholder="min">
                                </div>
                                <div>
                                    <label class="form-label mb-0" style="font-size:0.7rem" title="Maximum hosts per created switch for this router row (preview & build).">H/S Max</label>
                                    <input type="number" min="1" max="64" class="form-control form-control-sm hs-max-input" style="width:70px" value="${r2sHostsMax}" data-field="r2s_hosts_max" data-scen-idx="${sidx}" data-sec="${secName}" data-item-idx="${iidx}" placeholder="max">
                                </div>
                            </div>
                        </div>
                    </div>
                </div>`;
        }
        if (secName === 'Traffic') {
            return `
                <div class="d-flex flex-wrap gap-2">
                    <div>
                        <label class="form-label mb-0">Payload</label>
                        <select class="form-select form-select-sm" data-field="content_type" data-scen-idx="${sidx}" data-sec="${secName}" data-item-idx="${iidx}">
                            ${['Random','text','photo','audio','video','gibberish'].map(ct => `<option value="${ct}" ${((it.content_type||'Random')===ct)?'selected':''}>${ct}</option>`).join('')}
                        </select>
                    </div>
                    <div class="traffic-config" style="display:${((it.content_type||'Random')==='Random')?'none':'block'};">
                        <label class="form-label mb-0">Pattern</label>
                        <select class="form-select form-select-sm" data-field="pattern" data-scen-idx="${sidx}" data-sec="${secName}" data-item-idx="${iidx}">
                            ${['continuous','periodic','burst','poisson','ramp'].map(p => `<option ${((it.pattern||'')===p)?'selected':''}>${p}</option>`).join('')}
                        </select>
                    </div>
                    <div class="traffic-config" style="display:${((it.content_type||'Random')==='Random')?'none':'block'};">
                        <label class="form-label mb-0">Rate (kbps)</label>
                        <input type="number" step="0.1" class="form-control form-control-sm" value="${it.rate_kbps ?? 64.0}" data-field="rate_kbps" data-scen-idx="${sidx}" data-sec="${secName}" data-item-idx="${iidx}">
                    </div>
                    <div class="traffic-config" style="display:${((it.content_type||'Random')==='Random')?'none':'block'};">
                        <label class="form-label mb-0">Period (s)</label>
                        <input type="number" step="0.1" class="form-control form-control-sm" value="${it.period_s ?? 1.0}" data-field="period_s" data-scen-idx="${sidx}" data-sec="${secName}" data-item-idx="${iidx}">
                    </div>
                    <div class="traffic-config" style="display:${((it.content_type||'Random')==='Random')?'none':'block'};">
                        <label class="form-label mb-0">Jitter (%)</label>
                        <input type="number" step="0.1" class="form-control form-control-sm" value="${it.jitter_pct ?? 10.0}" data-field="jitter_pct" data-scen-idx="${sidx}" data-sec="${secName}" data-item-idx="${iidx}">
                    </div>
                </div>`;
        }
        if (secName === 'Vulnerabilities') {
            const mode = it.selected || 'Type/Vector';
            if (mode === 'Specific') {
                const nm = it.v_name || '';
                // Try to obtain full description (prefer stored v_desc, else look up in catalog)
                let fullDesc = it.v_desc || '';
                if (!fullDesc && nm && window.VULN_CATALOG && Array.isArray(window.VULN_CATALOG.items)) {
                    const match = window.VULN_CATALOG.items.find(x => x.Name === nm && (!it.v_path || x.Path === it.v_path));
                    if (match && match.Description) { fullDesc = match.Description; }
                }
                const abbr = (s, n=80) => (s && s.length > n ? (s.slice(0, n-1) + '…') : (s||''));
                const esc = (s) => (s||'')
                    .replace(/&/g,'&amp;')
                    .replace(/</g,'&lt;')
                    .replace(/>/g,'&gt;')
                    .replace(/"/g,'&quot;')
                    .replace(/'/g,'&#39;');
                const descShort = abbr(fullDesc);
                const centerText = nm ? `${nm}${descShort ? ' — ' + descShort : ''}` : '<span class="text-muted">No selection</span>';
                return `<span class="small" ${fullDesc ? `data-bs-toggle="tooltip" data-bs-title="${esc(fullDesc)}"` : ''}>${centerText}</span>`;
            }
            return '';
        }
        return '';
    })();
    // Build first cell content, optionally augmenting Selected with Vulnerabilities controls
    const firstCell = (() => {
        const isProtectedRandom = (secName === 'Node Information') && ((it.selected||'').toLowerCase()==='random') && it._protected_random;
        const disabledAttr = isProtectedRandom ? 'disabled title="Residual Random row is auto-managed"' : '';
        const selectedCtl = `<select class="form-select form-select-sm" ${disabledAttr} data-field="selected" data-scen-idx="${sidx}" data-sec="${secName}" data-item-idx="${iidx}">${opts}</select>`;
        if (secName !== 'Vulnerabilities') return selectedCtl;
    const mode = it.selected || 'Category';
    if (mode === 'Category') {
            return `
            <div class="d-flex flex-wrap gap-2 align-items-end">
                <div style="min-width:160px">${selectedCtl}</div>
                <div>
                    <label class="form-label mb-0">Type</label>
                    <select class="form-select form-select-sm vuln-type" data-field="v_type" data-scen-idx="${sidx}" data-sec="${secName}" data-item-idx="${iidx}"></select>
                </div>
                <div>
                    <label class="form-label mb-0">Vector</label>
                    <select class="form-select form-select-sm vuln-vector" data-field="v_vector" data-scen-idx="${sidx}" data-sec="${secName}" data-item-idx="${iidx}"></select>
                </div>
            </div>`;
        } else if (mode === 'Specific') {
            const nm = it.v_name || '';
            // Try to obtain full description (prefer stored v_desc, else look up in catalog)
            let fullDesc = it.v_desc || '';
            if (!fullDesc && nm && window.VULN_CATALOG && Array.isArray(window.VULN_CATALOG.items)) {
                const match = window.VULN_CATALOG.items.find(x => x.Name === nm && (!it.v_path || x.Path === it.v_path));
                if (match && match.Description) { fullDesc = match.Description; }
            }
            const abbr = (s, n=80) => (s && s.length > n ? (s.slice(0, n-1) + '…') : (s||''));
            const esc = (s) => (s||'')
                .replace(/&/g,'&amp;')
                .replace(/</g,'&lt;')
                .replace(/>/g,'&gt;')
                .replace(/"/g,'&quot;')
                .replace(/'/g,'&#39;');
            const descShort = abbr(fullDesc);
            return `
            <div class="d-flex flex-wrap gap-2 align-items-center">
                <div style="min-width:160px">${selectedCtl}</div>
                <button type="button" class="btn btn-sm btn-outline-primary" data-action="pick-specific" data-scen-idx="${sidx}" data-sec="${secName}" data-item-idx="${iidx}">Choose...</button>
            </div>`;
        }
        return selectedCtl;
    })();
    // Right-most: Weight or Count cell
    const weightCell = (() => {
        if (secName === 'Vulnerabilities') {
            const mode = it.selected || 'Type/Vector';
            const metric = it.v_metric || (mode === 'Specific' ? 'Count' : 'Weight');
            const metricSel = `<select class="form-select form-select-sm" style="min-width: 140px" data-field="v_metric" data-scen-idx="${sidx}" data-sec="${secName}" data-item-idx="${iidx}"><option ${metric==='Weight'?'selected':''}>Weight</option><option ${metric==='Count'?'selected':''}>Count</option></select>`;
            if (metric === 'Count') {
                const count = (parseInt(it.v_count, 10) || 5);
                return `<div class="d-flex gap-2">${metricSel}<input type="number" min="1" step="1" class="form-control form-control-sm" style="min-width: 120px" value="${count}" data-field="v_count" data-scen-idx="${sidx}" data-sec="${secName}" data-item-idx="${iidx}"></div>`;
            }
            return `<div class="d-flex gap-2">${metricSel}<input type="number" step="0.01" min="0" max="1" class="form-control form-control-sm weight-input" style="min-width: 120px" value="${weight}" data-field="factor" data-scen-idx="${sidx}" data-sec="${secName}" data-item-idx="${iidx}"></div>`;
        }
        // For all other sections, provide a Count/Weight selector as well
        const metric = it.v_metric || 'Weight';
        const metricSel = `<select class="form-select form-select-sm" style="min-width: 140px" data-field="v_metric" data-scen-idx="${sidx}" data-sec="${secName}" data-item-idx="${iidx}"><option ${metric==='Weight'?'selected':''}>Weight</option><option ${metric==='Count'?'selected':''}>Count</option></select>`;
        if (metric === 'Count') {
            const count = (parseInt(it.v_count, 10) || 5);
            return `<div class="d-flex gap-2">${metricSel}<input type="number" min="1" step="1" class="form-control form-control-sm" style="min-width: 120px" value="${count}" data-field="v_count" data-scen-idx="${sidx}" data-sec="${secName}" data-item-idx="${iidx}"></div>`;
        }
    const isProtectedRandom = (secName === 'Node Information') && ((it.selected||'').toLowerCase()==='random') && it._protected_random;
    const metricDisabled = isProtectedRandom ? 'disabled title="Residual Random row metric locked"' : '';
    const metricSelProtected = `<select class="form-select form-select-sm" ${metricDisabled} style="min-width: 140px" data-field="v_metric" data-scen-idx="${sidx}" data-sec="${secName}" data-item-idx="${iidx}"><option ${metric==='Weight'?'selected':''}>Weight</option><option ${metric==='Count'?'selected':''}>Count</option></select>`;
    const ro = isProtectedRandom ? 'readonly class="form-control form-control-sm weight-input bg-light" title="Auto-adjusted to keep sum=1.0"' : 'class="form-control form-control-sm weight-input"';
    return `<div class="d-flex gap-2">${metricSelProtected}<input type="number" step="0.01" min="0" max="1" ${ro} style="min-width: 120px" value="${weight}" data-field="factor" data-scen-idx="${sidx}" data-sec="${secName}" data-item-idx="${iidx}"></div>`;
    })();
    const removeBtnHtml = ((secName === 'Node Information') && ((it.selected||'').toLowerCase()==='random') && it._protected_random)
        ? '<span class="text-muted small" title="Residual Random row">&mdash;</span>'
        : `<button type="button" class="btn btn-sm btn-outline-danger" data-action="remove-item" data-scen-idx="${sidx}" data-sec="${secName}" data-item-idx="${iidx}">Remove</button>`;
    return `
        <tr>
            <td>${firstCell}</td>
            <td>${extras}</td>
            <td>${weightCell}</td>
            <td>${removeBtnHtml}</td>
        </tr>`;
}
// Render Vulnerabilities rows grouped with two row-headers
function renderVulnRows(sidx, secName, items) {
    const withIdx = items.map((it, iidx) => ({ it, iidx }));
    const typeOrRandom = withIdx.filter(x => (x.it.selected || 'Category') !== 'Specific');
    const specifics = withIdx.filter(x => (x.it.selected || 'Category') === 'Specific');
    const parts = [];
    if (typeOrRandom.length) {
        parts.push(`<tr class="table-light"><td colspan="4"><strong>Category or Random</strong></td></tr>`);
        parts.push(typeOrRandom.map(x => renderItemRow(sidx, secName, x.iidx, x.it)).join(''));
    }
    if (specifics.length) {
        parts.push(`<tr class="table-light"><td colspan="4"><strong>Specific</strong></td></tr>`);
        parts.push(specifics.map(x => renderItemRow(sidx, secName, x.iidx, x.it)).join(''));
    }
    return parts.join('');
}

function wireHandlers() {
    // Count for Density input handler
    document.querySelectorAll('input[data-field="scenario_density_count"]').forEach(inp => {
        inp.addEventListener('change', () => {
            const idx = parseInt(inp.getAttribute('data-scen-idx'));
            let val = parseInt(inp.value, 10); if (isNaN(val) || val < 0) val = 0; if (val > 5000) val = 5000;
            state.scenarios[idx].density_count = val; // store at scenario level; do NOT mutate node rows
            if (val === '' || val === null) {
                // If cleared, revert to default 10 in UI but keep undefined so save omits and parser falls back.
                delete state.scenarios[idx].density_count;
            }
            renderMain();
        });
        // Prevent Enter key from triggering unintended form behavior (like adding a row)
        inp.addEventListener('keydown', (ev) => {
            if (ev.key === 'Enter') { ev.preventDefault(); inp.blur(); }
        });
    });
    document.querySelectorAll('[data-field]').forEach(el => {
        const sidx = parseInt(el.getAttribute('data-scen-idx'));
        const sec = el.getAttribute('data-sec');
        const field = el.getAttribute('data-field');
        const iidx = el.getAttribute('data-item-idx');
        const handler = () => {
            if (field === 'scenario_base_hosts') { return; }
            if (sec) {
                if (iidx !== null) {
                    const item = state.scenarios[sidx].sections[sec].items[parseInt(iidx)];
                    if (['factor','rate_kbps','period_s','jitter_pct','total_nodes','density','r2r_edges','r2s_edges','r2s_hosts_min','r2s_hosts_max'].includes(field)) {
                        item ? (item[field] = parseFloat(el.value)) : state.scenarios[sidx].sections[sec][field] = parseFloat(el.value);
                        if ((field === 'edges' || field === 'r2s_edges') && (isNaN(item[field]) || el.value === '')) {
                            // Allow blank to mean "unset" so generator can apply defaults
                            delete item[field];
                        }
                        if ((field === 'r2s_hosts_min' || field === 'r2s_hosts_max')) {
                            const mn = parseInt(item.r2s_hosts_min || 1, 10);
                            const mx = parseInt(item.r2s_hosts_max || 4, 10);
                            if (!isNaN(mn) && !isNaN(mx) && mn > mx) {
                                item.r2s_hosts_max = mn;
                            }
                            persistEditorState();
                        }
                        if (field === 'factor') {
                            adjustWeightsProportionally(sidx, sec, parseInt(iidx));
                            updateWeightWarning(sidx, sec);
                            updateWeightInputsDisplay(sidx, sec);
                        }
                        if (field === 'edges' || field === 'r2s_edges') {
                            setTimeout(validateRoutingEdges, 20);
                        }
                    } else if (['pattern','content_type','selected','script_path','v_type','v_vector','v_name','v_path','v_count','v_metric','r2r_mode','r2s_mode'].includes(field)) {
                        const prev = item[field];
                        if (field === 'v_count') {
                            const n = parseInt(el.value, 10) || 1;
                            item[field] = n;
                        } else {
                            item[field] = el.value;
                        }
                        if(field === 'r2r_mode') {
                            item.r2r_mode = el.value;
                            if(el.value !== 'Exact') { delete item.edges; }
                            renderMain();
                            updateHsBoundsVisibility();
                            setTimeout(validateRoutingEdges, 50);
                        }
                        if(field === 'r2s_mode') {
                            item.r2s_mode = el.value;
                            if(el.value !== 'Exact') { delete item.r2s_edges; }
                            renderMain();
                            updateHsBoundsVisibility();
                            setTimeout(validateRoutingEdges, 50);
                        }
                        if (field === 'edges') {
                            setTimeout(validateRoutingEdges, 20);
                        } else if (field === 'content_type') {
                            // Re-render to reflect show/hide of traffic-config inputs when Random is selected
                            renderMain();
                        } else if (field === 'selected') {
                            if (item.selected === 'Specific') {
                                if (!item.v_count) item.v_count = 5;
                                if (!item.v_metric) item.v_metric = 'Count';
                            } else {
                                if (!item.v_metric) item.v_metric = 'Weight';
                            }
                            // Re-render to show/hide appropriate controls and recalc weight warnings
                            renderMain();
                        } else if (field === 'v_metric') {
                            // On metric toggle, normalize weights for current section and re-render
                            if (item.v_metric === 'Count' && (item.v_count === undefined || item.v_count === null || isNaN(parseInt(item.v_count, 10)))) {
                                item.v_count = 5;
                            }
                            redistributeEven(sidx, sec);
                            if (sec === 'Node Information') {
                                const secRef = state.scenarios[sidx].sections[sec];
                                const hasWeight = (secRef.items || []).some(it => (it.v_metric || 'Weight') === 'Weight');
                                if (!hasWeight && secRef.total_nodes) { secRef.total_nodes = 0; }
                            }
                            updateWeightWarning(sidx, sec);
                            renderMain();
                        } else if (field === 'v_count') {
                            // Count change affects Total Nodes label
                            renderMain();
                        }
                    } else {
                        state.scenarios[sidx].sections[sec][field] = el.value;
                    }
                } else {
                    if (field === 'density' || field === 'total_nodes') {
                        let v = parseFloat(el.value);
                        if (field === 'density') {
                            if (isNaN(v)) v = 0.0;
                            v = Math.max(0, Math.min(1, v)); // Clamp globally 0..1
                        }
                        state.scenarios[sidx].sections[sec][field] = v;
                        // keep hidden for submit and update any warnings
                        if (field === 'density') { updateWeightWarning(sidx, sec); }
                        // Ensure Total Nodes label refreshes on total_nodes edits
                        if (field === 'total_nodes') { renderMain(); }
                    } else {
                        state.scenarios[sidx].sections[sec][field] = el.value;
                    }
                }
            } else {
                if (field === 'name') state.scenarios[sidx].name = el.value;
                if (field === 'base-file') state.scenarios[sidx].base.filepath = el.value;
                if (field === 'notes') state.scenarios[sidx].notes = el.value;
                if(field === 'notes'){
                    try {
                        const ind = document.getElementById('notesIndicator_'+sidx);
                        if(ind){
                            const has = (el.value||'').trim().length>0;
                            ind.innerHTML = has ? `<i class='bi bi-journal-text text-success'></i>` : `<i class='bi bi-journal text-muted'></i>`;
                            ind.setAttribute('data-bs-title', has ? 'Notes present' : 'No notes');
                            if(window.bootstrap){ try { new bootstrap.Tooltip(ind); } catch(e){} }
                        }
                    } catch(e){}
                }
            }
            // keep hidden for submit
            document.getElementById('scenarios_json').value = JSON.stringify({ scenarios: state.scenarios, active_index: activeIdx });
            // persist edits across navigation
            persistEditorState();
            logDebug(`Field change: scen=${sidx} sec=${sec||''} field=${field}`);
            try { previewState.dirty = true; updatePlanButtons(); } catch(e){}
        };
        el.addEventListener('input', handler);
        el.addEventListener('change', handler);
    });
    document.querySelectorAll('[data-action="remove-item"]').forEach(btn => {
        btn.onclick = () => {
            const sidx = parseInt(btn.getAttribute('data-scen-idx'));
            const sec = btn.getAttribute('data-sec');
            const iidx = parseInt(btn.getAttribute('data-item-idx'));
            state.scenarios[sidx].sections[sec].items.splice(iidx,1);
                        logInfo(`Removed item ${iidx} from ${sec}`);
              redistributeEven(sidx, sec);
              // Auto-clear total_nodes if Node Information loses its last weight-based row
              if (sec === 'Node Information') {
                  const secRef = state.scenarios[sidx].sections[sec];
                  const hasWeight = (secRef.items || []).some(it => (it.v_metric || 'Weight') === 'Weight');
                  if (!hasWeight && secRef.total_nodes) { secRef.total_nodes = 0; }
              }
              // Re-render to refresh totals and labels
                            renderMain();
                            persistEditorState();
                            try { previewState.dirty = true; updatePlanButtons(); } catch(e){}
        };
    });
    document.querySelectorAll('[data-action="add-item"]').forEach(btn => {
        btn.onclick = () => {
            const sidx = parseInt(btn.getAttribute('data-scen-idx'));
            const sec = btn.getAttribute('data-sec');
            // Default selection logic: for Routing we prefer the first concrete protocol (not Random) so
            // routers don't silently become 'Random' unless user explicitly chooses it. Other sections
            // still start at 'Random' (or specialized default) as before.
            let defaultSelected = 'Random';
            if (sec === 'Routing') {
                try {
                    const opts = dropdownsBySection['Routing'] || [];
                    // pick the first option that isn't 'Random'
                    const concrete = opts.find(o => o !== 'Random');
                    if (concrete) defaultSelected = concrete;
                } catch(e){}
            }
            const item = { selected: defaultSelected, factor: 1.0 };
            if (sec === 'Events') item.script_path = '';
            if (sec === 'Traffic') { item.pattern = 'continuous'; item.rate_kbps = 64.0; item.period_s = 1.0; item.jitter_pct = 10.0; item.content_type = 'Random'; }
            if (sec === 'Vulnerabilities') { item.selected = 'Category'; item.v_type = 'Random'; item.v_vector = 'Random'; }
            // Default new rows: Node Information -> Count; others -> Weight.
            if (sec === 'Node Information') { item.v_metric = 'Count'; item.v_count = 5; }
            else { item.v_metric = 'Weight'; }
            state.scenarios[sidx].sections[sec].items.push(item);
                        logInfo(`Added item to ${sec}`);
              redistributeEven(sidx, sec);
                            renderMain();
                            persistEditorState();
                            try { previewState.dirty = true; updatePlanButtons(); } catch(e){}
        };
    });
    document.querySelectorAll('[data-action="toggle-collapse"]').forEach(btn => {
        btn.onclick = () => {
            const targetSel = btn.getAttribute('data-target');
            const target = document.querySelector(targetSel);
            if (!target) return;
            const visible = target.style.display !== 'none';
            target.style.display = visible ? 'none' : 'block';
            btn.textContent = visible ? 'Expand' : 'Collapse';
            const secName = targetSel.replace('#collapse-','').replace(/-/g,' ');
            const collapseKey = `${activeIdx}::${secName}`;
            collapseState[collapseKey] = visible; // store collapsed state (true means now collapsed)
            try { localStorage.setItem('sectionCollapseState', JSON.stringify(collapseState)); } catch(e) {}
            logDebug(`Section toggle ${targetSel} -> ${visible ? 'collapsed':'expanded'}`);
        };
    });
    // Export preview handler
    const previewBtn = document.querySelector('[data-action="preview-plan"]');
    if (previewBtn) {
        previewBtn.onclick = () => {
            const scen = state.scenarios[activeIdx];
            if (!scen) return;
            const ni = scen.sections['Node Information'] || { items: [], total_nodes:0 };
            const weightRows = (ni.items||[]).filter(it => (it.v_metric || (it.selected==='Specific'? 'Count':'Weight'))==='Weight');
            const countRows = (ni.items||[]).filter(it => (it.v_metric || (it.selected==='Specific'? 'Count':'Weight'))==='Count');
            const base = weightRows.length ? (parseInt(scen.density_count || 0) || 0) : 0;
            const addHosts = countRows.reduce((a,it)=> a + (parseInt(it.v_count,10)||0),0);
            const totalHosts = base + addHosts;
            let allocTable = [];
            if (base>0 && weightRows.length) {
                const sumW = weightRows.reduce((a,it)=> a + (parseFloat(it.factor)||0),0) || 1;
                const temp = weightRows.map(it => {
                    const f = parseFloat(it.factor)||0; const share = sumW? f/sumW:0; const raw = base*share; const alloc = Math.floor(raw);
                    return { it, share, raw, alloc, frac: raw - alloc };
                });
                let assigned = temp.reduce((a,r)=> a + r.alloc,0);
                let remain = base - assigned;
                temp.sort((a,b)=> b.frac - a.frac);
                for (let i=0;i<temp.length && remain>0;i++) { temp[i].alloc += 1; remain--; }
                allocTable = temp.sort((a,b)=> (ni.items.indexOf(a.it) - ni.items.indexOf(b.it))).map(r => ({ label: r.it.selected || 'Row', weight: (parseFloat(r.it.factor)||0), percent: (r.share*100), alloc: r.alloc }));
            }
            const routing = scen.sections['Routing'] || { items: [], density: 0 };
            const rWeight = (routing.items||[]).filter(it => (it.v_metric||'Weight')==='Weight');
            const rCount = (routing.items||[]).filter(it => (it.v_metric||'Weight')==='Count');
            const rExplicit = rCount.reduce((a,it)=> a + (parseInt(it.v_count,10)||0),0);
            let rDerived = 0; if (rWeight.length) { const d = parseFloat(routing.density)||0; rDerived = (d>=1)? d : Math.round((totalHosts - addHosts) * d); }
            const totalRouters = rExplicit + rDerived;
            const vulns = scen.sections['Vulnerabilities'] || { items: [], density: 0 };
            const vWeight = (vulns.items||[]).filter(it => (it.v_metric || (it.selected==='Specific'?'Count':'Weight'))==='Weight');
            const vCount = (vulns.items||[]).filter(it => (it.v_metric || (it.selected==='Specific'?'Count':'Weight'))==='Count');
            const vExplicit = vCount.reduce((a,it)=> a + (parseInt(it.v_count,10)||0),0);
            let vDerived = 0; if (vWeight.length) { const d = Math.min(1, Math.max(0, parseFloat(vulns.density)||0)); vDerived = Math.round((totalHosts - addHosts) * d); }
            const totalVulns = vExplicit + vDerived;
            const rowsHtml = allocTable.length ? allocTable.map(r => `<tr><td>${r.label}</td><td>${r.weight.toFixed(3)}</td><td>${r.percent.toFixed(1)}%</td><td>${r.alloc}</td></tr>`).join('') : '<tr><td colspan="4" class="text-muted">No weight allocation</td></tr>';
            const modalHtml = `
<div class=\"modal fade\" id=\"previewModal\" tabindex=\"-1\" aria-hidden=\"true\">\n  <div class=\"modal-dialog modal-lg modal-dialog-scrollable\">\n    <div class=\"modal-content\">\n      <div class=\"modal-header\">\n        <h5 class=\"modal-title\">Plan Preview: ${scen.name}</h5>\n        <button type=\"button\" class=\"btn-close\" data-bs-dismiss=\"modal\" aria-label=\"Close\"></button>\n      </div>\n      <div class=\"modal-body\">\n        <div class=\"progress mb-3 d-none\" id=\"previewExecuteProgress\">\n          <div class=\"progress-bar progress-bar-striped progress-bar-animated\" id=\"previewExecuteProgressBar\" style=\"width:100%\">Running…</div>\n        </div>\n        <div class=\"row mb-3\">\n          <div class=\"col-md-4\"><div class=\"card card-body p-2\"><small class=\"text-muted\">Hosts Total</small><div class=\"fs-5\">${totalHosts}</div><div class=\"small text-muted\">Base ${base} + Add ${addHosts}</div></div></div>\n          <div class=\"col-md-4\"><div class=\"card card-body p-2\"><small class=\"text-muted\">Routers</small><div class=\"fs-5\">${totalRouters}</div><div class=\"small text-muted\">Explicit ${rExplicit} + Derived ${rDerived}</div></div></div>\n          <div class=\"col-md-4\"><div class=\"card card-body p-2\"><small class=\"text-muted\">Vulns</small><div class=\"fs-5\">${totalVulns}</div><div class=\"small text-muted\">Explicit ${vExplicit} + Derived ${vDerived}</div></div></div>\n        </div>\n        <h6>Host Weight Allocation</h6>\n        <div class=\"table-responsive\">\n          <table class=\"table table-sm\">\n            <thead><tr><th>Row</th><th>Weight</th><th>%</th><th>Alloc</th></tr></thead>\n            <tbody>${rowsHtml}</tbody>\n          </table>\n        </div>\n      </div>\n      <div class=\"modal-footer\">\n        <button type=\"button\" class=\"btn btn-sm btn-warning\" id=\"previewModalExecuteBtn\">Execute</button>\n        <button type=\"button\" class=\"btn btn-sm btn-outline-secondary\" data-bs-dismiss=\"modal\">Close</button>\n      </div>\n    </div>\n  </div>\n</div>`;
            let container = document.getElementById('previewModalContainer');
            if (!container) { container = document.createElement('div'); container.id = 'previewModalContainer'; document.body.appendChild(container); }
            container.innerHTML = modalHtml;
            const modalEl = container.querySelector('#previewModal');
            let modalInstance = null;
            if (window.bootstrap) {
                try {
                    modalInstance = new bootstrap.Modal(modalEl);
                } catch(e) {
                    alert('Bootstrap modal failed; see console');
                    console.error(e);
                }
            } else {
                alert('Bootstrap not loaded.');
            }
            setupPreviewModalExecute(modalEl, modalInstance);
            try { modalInstance?.show(); } catch(e) {}
        };
    }
    // Initialize popovers & tooltips (Bootstrap 5)
    if (window.bootstrap) {
        document.querySelectorAll('[data-bs-toggle="popover"]').forEach(el => { try { new bootstrap.Popover(el); } catch(e) {} });
        document.querySelectorAll('[data-bs-toggle="tooltip"]').forEach(el => { try { new bootstrap.Tooltip(el); } catch(e) {} });
    }
    // Flash animation on Base input change
    document.querySelectorAll('.base-input').forEach(inp => {
        inp.addEventListener('change', () => {
            const badge = document.querySelector('.host-total-badge');
            if (!badge) return;
            badge.classList.add('pulse-change');
            setTimeout(()=> badge.classList.remove('pulse-change'), 900);
        });
    });
    document.querySelectorAll('[data-action="remove-scenario"]').forEach(btn => {
        btn.onclick = async (ev) => {
            if (ev && typeof ev.preventDefault === 'function') ev.preventDefault();
            if (ev && typeof ev.stopPropagation === 'function') ev.stopPropagation();
            const sidx = parseInt(btn.getAttribute('data-scen-idx'));
            const scen = state.scenarios[sidx];
            if (!scen) { return; }
            let runCount = 0;
            try {
                const resp = await fetch('/reports_data');
                if (resp.ok) {
                    const data = await resp.json();
                    runCount = (data.history || []).filter(r => (r.scenario_names || []).includes(scen.name)).length;
                }
            } catch (e) {}
            const lines = [];
            lines.push(`Delete scenario "${scen.name}"?`);
            if (runCount > 0) {
                lines.push("");
                lines.push(`WARNING: ${runCount} run history entr${runCount===1?'y':'ies'} and their artifact files (XML, report, pre-session XML) will be permanently deleted.`);
            }
            lines.push("");
            lines.push("This action cannot be undone.");
            lines.push("");
            lines.push("Proceed?");
            const msg = lines.join('\n');
            if (!window.confirm(msg)) { return; }

            // Remove scenario
            state.scenarios.splice(sidx, 1);
            // Leave list empty if last scenario removed
            activeIdx = state.scenarios.length === 0 ? 0 : Math.min(sidx, state.scenarios.length - 1);
            // Persist immediately before re-render so state survives any navigation
            const hidden = document.getElementById('scenarios_json');
            if (hidden) hidden.value = JSON.stringify({ scenarios: state.scenarios });
            persistEditorState();
            logInfo(`Deleted scenario: ${scen.name}`);
            // Re-render UI
            render();
            try { showToast(`Scenario "${scen.name}" deleted`); } catch(e){}

            // Purge matching run history and artifacts in background
            if (runCount > 0) {
                try {
                    await fetch('/purge_history_for_scenario', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ name: scen.name })
                    });
                } catch (e) {}
            }
        };
    });
    // keep hidden JSON synced
    const aiHidden = document.getElementById('active_index'); if(aiHidden) aiHidden.value = String(activeIdx);
    document.getElementById('scenarios_json').value = JSON.stringify({ scenarios: state.scenarios, active_index: activeIdx });
    persistEditorState();
        // Initialize warnings per section
        const scen = state.scenarios[activeIdx];
        if (scen) {
            ['Node Information','Routing','Services','Traffic','Events','Vulnerabilities','Segmentation'].forEach(sec => updateWeightWarning(activeIdx, sec));
        }
}
// Routing edges validation utilities
function validateRoutingEdges(){
    const scen = state.scenarios[activeIdx]; if(!scen) return;
    const routing = (scen.sections && scen.sections['Routing'] && scen.sections['Routing'].items) || [];
    const warn = [];
    routing.forEach((r,i)=>{ const m = r.r2r_mode; if(m==='Exact' && !(r.edges>=1)) warn.push(`Row ${i+1}: Exact mode requires a degree ≥ 1`); });
    routing.forEach((r,i)=>{ if(r.r2s_mode==='Exact' && !(r.r2s_edges>=1)) warn.push(`Row ${i+1}: R-to-S Exact requires a value ≥ 1`); });
    // Highlight inputs
    document.querySelectorAll('.edges-degree-input').forEach(inp => {
        const v = parseInt(inp.value,10); const tr = inp.closest('tr');
    const sel = tr ? tr.querySelector('[data-field="r2r_mode"]') : null;
        const mode = sel ? sel.value : '';
        if(mode==='Exact' && !(v>=1)) inp.classList.add('is-invalid'); else inp.classList.remove('is-invalid');
    });
    document.querySelectorAll('.r2s-degree-input').forEach(inp => {
        const v = parseInt(inp.value,10); const tr = inp.closest('tr');
        const sel = tr ? tr.querySelector('[data-field="r2s_mode"]') : null;
        const mode = sel ? sel.value : '';
        if(mode==='Exact' && !(v>=1)) inp.classList.add('is-invalid'); else inp.classList.remove('is-invalid');
    });
    // If a separate warning container existed we could populate it here later.
    computeRoutingEdgePolicyPreview();
}
setTimeout(validateRoutingEdges, 500);

// Derive a lightweight preview (pre-generation) of intended policy and an estimated degree band
function computeRoutingEdgePolicyPreview(){
    const scen = state.scenarios[activeIdx]; if(!scen) return;
    const routing = (scen.sections && scen.sections['Routing'] && scen.sections['Routing'].items) || [];
    const summaryEl = document.getElementById('routingEdgesSummary');
    if(!summaryEl) return;
    if(!routing.length){ summaryEl.style.display='none'; return; }
    // Determine target policy: Exact avg > Max > Min > Random (mirrors backend)
    const exactVals = routing.filter(r=> r.r2r_mode==='Exact' && r.edges>=1).map(r=>r.edges);
    let mode='Random'; let target=0;
    if(exactVals.length){
        target = Math.round(exactVals.reduce((a,b)=>a+b,0)/exactVals.length);
        if(target<1) target=1; mode='Exact';
    } else {
    const modes = routing.map(r=> r.r2r_mode).filter(Boolean);
    if(modes.includes('Uniform')) mode='Uniform';
        else if(modes.includes('Min')) mode='Min';
        else if(modes.includes('NonUniform')) mode='NonUniform';
        else mode='Random';
    }
    // Determine predominant R-to-S mode (simple precedence similar to R-to-R)
    let r2sMode = 'Random';
    const r2sExactVals = routing.filter(r=>r.r2s_mode==='Exact' && r.r2s_edges>=1).map(r=>r.r2s_edges);
    if(r2sExactVals.length){
        r2sMode = 'Exact';
    } else {
        const r2sModes = routing.map(r=>r.r2s_mode).filter(Boolean);
    if(r2sModes.includes('Uniform')) r2sMode='Uniform';
        else if(r2sModes.includes('Min')) r2sMode='Min';
        else if(r2sModes.includes('NonUniform')) r2sMode='NonUniform';
        else r2sMode='Random';
    }
    const policySpan = summaryEl.querySelector('[data-role="edges-policy"]');
    if(policySpan){ policySpan.textContent = `R-R: ${mode}${mode==='Exact'?`(≈${target})`:''} | R-S: ${r2sMode}`; }
    // Estimate degree distribution preview (pure heuristic):
    let minD=0, avgD=0, maxD=0;
    if(mode==='Exact'){ minD=target; avgD=target+1; maxD=target+2; }
    else if(mode==='Uniform'){ minD=4; avgD=4; maxD=5; }
    else if(mode==='NonUniform'){ minD=1; avgD=3; maxD=8; }
    else if(mode==='Min'){ minD=2; avgD=3; maxD=4; }
    else { minD=1; avgD=2; maxD=4; }
    // Removed Min/Avg/Max and sparkline visualization per request
    // Resource warning for Uniform (previously Max) mode – still warn if near-dense
	const warnEl = document.getElementById('routingEdgesWarnings');
	if(warnEl){
	    warnEl.classList.add('d-none');
	    warnEl.innerHTML='';
        if(mode==='Uniform'){
	        // Approximate router count: we don't know exact until build; use routing item count as lower bound
	        let approxRouters = routing.length || 0;
	        // If scenario embeds an explicit router count in future, prefer it; attempt common field names
	        if(typeof scen.router_count === 'number' && scen.router_count > approxRouters) approxRouters = scen.router_count;
	        if(typeof scen.routers_total === 'number' && scen.routers_total > approxRouters) approxRouters = scen.routers_total;
	        // Compute full mesh edges estimate
	        const estEdges = approxRouters > 1 ? (approxRouters * (approxRouters - 1) / 2) : 0;
	        // Thresholds: warn if routers >= 25 OR estimated edges >= 300
	        if(approxRouters >= 25 || estEdges >= 300){
	            const edgesFmt = estEdges.toLocaleString();
                warnEl.innerHTML = `<strong>Uniform Mode:</strong> balanced high degree connectivity can grow ~O(n²). With ~${approxRouters} routers this implies about ${edgesFmt} potential links. This may increase session startup time and resource usage.`;
	            warnEl.classList.remove('d-none');
	        } else {
	            // Light advisory (still show something so users understand cost) for smaller counts
	            if(approxRouters >= 10){
                    warnEl.innerHTML = `<strong>Heads up:</strong> Uniform mode aims for evenly high degrees (approaches dense graph). Routers: ~${approxRouters}.`;
	                warnEl.classList.remove('d-none');
	            }
	        }
	    }
	}
    summaryEl.style.display='flex';
}

function wireCoreControls() {
    // defaults
    if (!state.core) state.core = { host: (initialPayload?.core?.host || 'localhost'), port: (initialPayload?.core?.port || 50051) };
    const hostEl = document.getElementById('coreHost');
    const portEl = document.getElementById('corePort');
    const btn = document.getElementById('testCoreBtn');
    const statusEl = document.getElementById('coreStatus');
    const runSync = document.getElementById('runSyncBtn');
    const cancelBtn = document.getElementById('cancelRunBtn');
    const runSyncWrap = document.getElementById('runSyncWrap');

    // Always enable run buttons (CORE test optional now)
    const setRunEnabled = () => {
        runSync?.removeAttribute('disabled');
        runSync?.classList.remove('pe-none');
        runSyncWrap?.setAttribute('data-bs-title', '');
        statusEl.classList.remove('text-danger','text-success');
        statusEl.textContent = 'Not tested (runs allowed)';
    };

    // initialize values
    if (hostEl) hostEl.value = state.core.host || 'localhost';
    if (portEl) portEl.value = state.core.port || 50051;
    // Immediately enable regardless of prior test
    setRunEnabled();

    const onEdit = () => {
    state.core.host = hostEl.value.trim();
    state.core.port = parseInt(portEl.value || '50051', 10) || 50051;
    state.core_ok = false; // changing values invalidates previous test
        // any edit resets test state
    setRunEnabled();
    };
    hostEl?.addEventListener('input', () => { onEdit(); persistEditorState(); });
    portEl?.addEventListener('input', () => { onEdit(); persistEditorState(); });

    btn?.addEventListener('click', async () => {
    btn.disabled = true;
    logInfo('Testing CORE connection');
        statusEl.classList.remove('text-danger', 'text-success');
        statusEl.textContent = 'Testing...';
        try {
            const res = await fetch("{{ url_for('test_core') }}", {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ host: hostEl.value.trim() || 'localhost', port: parseInt(portEl.value || '50051', 10) || 50051 })
            });
            const data = await res.json();
            if (data && data.ok) {
                // persist success and the tested values
                state.core_ok = true;
                state.core_tested_host = hostEl.value.trim() || 'localhost';
                state.core_tested_port = parseInt(portEl.value || '50051', 10) || 50051;
                logInfo(`CORE reachable at ${data.host||hostEl.value}:${data.port||portEl.value}`);
                statusEl.classList.add('text-success');
                statusEl.textContent = 'CORE reachable (optional)';
                persistEditorState();
            } else {
                statusEl.classList.remove('text-success');
                statusEl.classList.add('text-danger');
                statusEl.textContent = 'Connection failed (run still allowed)' + (data?.error ? `: ${data.error}` : '');
                logWarn(`CORE connection failed: ${data?.error||'unknown'}`);
                state.core_ok = false;
                persistEditorState();
            }
        } catch (e) {
            statusEl.classList.remove('text-success');
            statusEl.classList.add('text-danger');
            statusEl.textContent = 'Connection failed (run still allowed)';
            logError('CORE test threw exception');
            state.core_ok = false;
            persistEditorState();
        } finally {
            btn.disabled = false;
        }
    });
}

function prepareRunCli() {
    // prefer the last saved XML path or result_path if it's XML
    const rp = state.result_path || '';
    if (!rp.endsWith('.xml')) {
        alert('Please save XML first.');
        logWarn('Run CLI blocked: no saved XML');
        return false;
    }
    // confirmation dialog warning user a CORE scenario will be created and started
    const confirmMsg = 'This action will generate a new CORE scenario and attempt to start it using the provided daemon connection.\n\nProceed?';
    if (!window.confirm(confirmMsg)) {
        logInfo('Run CLI cancelled by user at confirmation');
        return false;
    }
    document.getElementById('xml_path').value = rp;
    logInfo('Running CLI sync');
    // Preserve scroll so after the round trip we land where we were
    try { saveScrollBeforeNav(); } catch(e){}
    return true;
}

render();

// Restore scroll position if previously saved before a Save XML navigation
function restoreScrollIfAny() {
    try {
        const y = parseInt(sessionStorage.getItem('coretg_saved_scroll_y') || '', 10);
        if (!isNaN(y)) {
            window.scrollTo(0, y);
            sessionStorage.removeItem('coretg_saved_scroll_y');
        }
    } catch (e) { /* ignore */ }
}
// Use load to ensure layout (including dock sizing) has been applied
window.addEventListener('load', restoreScrollIfAny);

// Small helper to persist current scroll position prior to any navigation (form post or link)
function saveScrollBeforeNav(){
    try { sessionStorage.setItem('coretg_saved_scroll_y', String(window.scrollY || window.pageYOffset || 0)); } catch (e) { /* ignore */ }
}

// Always serialize state just before submitting the Save XML form
const editorForm = document.getElementById('editorForm');
if (editorForm) {
    editorForm.addEventListener('submit', () => {
        // preserve current scroll so we can restore after the server round-trip
        try { sessionStorage.setItem('coretg_saved_scroll_y', String(window.scrollY || window.pageYOffset || 0)); } catch (e) { /* ignore */ }
    document.getElementById('scenarios_json').value = JSON.stringify({ scenarios: state.scenarios, active_index: activeIdx });
        persistEditorState();
    });
}

// Enable Bootstrap tooltips globally
document.addEventListener('DOMContentLoaded', () => {
    const tooltipTriggerList = [].slice.call(document.querySelectorAll('[data-bs-toggle="tooltip"]'));
    tooltipTriggerList.forEach(el => {
        // Bootstrap 5 throws if title option resolves to null; normalize to empty string
        const dt = el.getAttribute('data-bs-title') || el.getAttribute('title');
        if (dt === null) {
            // skip creating tooltip entirely if no title is present
            return;
        }
        if (dt.trim() === '') {
            el.setAttribute('data-bs-title', '');
        }
        try { new bootstrap.Tooltip(el); } catch (e) { /* ignore */ }
    });
    // Wire Download XML button
    const dlBtn = document.getElementById('downloadXmlBtn');
    if (dlBtn) {
        dlBtn.addEventListener('click', () => {
            const rp = state.result_path || '';
            if (!rp || !rp.endsWith('.xml')) { alert('Please Save XML first.'); return; }
            window.location.href = window.location.origin + '/download_report?path=' + encodeURIComponent(rp);
        });
        // Initial state based on state.result_path
        const rp0 = state.result_path || '';
        if (rp0 && rp0.endsWith('.xml')) { dlBtn.removeAttribute('disabled'); dlBtn.classList.remove('pe-none'); dlBtn.setAttribute('title',''); }
    }
    // Capture any server-rendered logs before we render from storage
    let __serverLogsAtLoad = '';
    try { __serverLogsAtLoad = (document.getElementById('logsPre')?.textContent || '').trim(); } catch(e){}
    setupVulnCatalog();
});

// Vulnerability catalog and UI helpers
async function setupVulnCatalog(){
        try {
                const res = await fetch('/vuln_catalog');
        if(res.ok){ window.VULN_CATALOG = await res.json(); }
    } catch(e) { window.VULN_CATALOG = { types: [], vectors: [], items: [] }; }
}

function populateVulnSelects() {
        document.querySelectorAll('.vuln-type').forEach(sel => {
                const sidx = parseInt(sel.getAttribute('data-scen-idx'));
                const sec = sel.getAttribute('data-sec');
                const iidx = parseInt(sel.getAttribute('data-item-idx'));
                const cur = (state.scenarios[sidx].sections[sec].items[iidx].v_type) || 'Random';
                const opts = ['Random', ...(window.VULN_CATALOG?.types || [])];
                sel.innerHTML = opts.map(o => `<option ${o===cur?'selected':''}>${o}</option>`).join('');
        });
        document.querySelectorAll('.vuln-vector').forEach(sel => {
                const sidx = parseInt(sel.getAttribute('data-scen-idx'));
                const sec = sel.getAttribute('data-sec');
                const iidx = parseInt(sel.getAttribute('data-item-idx'));
                const cur = (state.scenarios[sidx].sections[sec].items[iidx].v_vector) || 'Random';
                const opts = ['Random', ...(window.VULN_CATALOG?.vectors || [])];
                sel.innerHTML = opts.map(o => `<option ${o===cur?'selected':''}>${o}</option>`).join('');
        });
}

// Modal for Specific selection
function ensureVulnModal(){
        if(document.getElementById('vulnModal')) return;
        const modal = document.createElement('div');
        modal.className = 'modal fade';
        modal.id = 'vulnModal';
        modal.innerHTML = `
        <div class="modal-dialog modal-lg">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title">Select Vulnerability</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
                </div>
                <div class="modal-body">
                    <div id="vulnLoadingWrap" class="mb-3" style="display:none;">
                        <div class="d-flex align-items-center gap-2 mb-2 text-muted small">
                            <div class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></div>
                            <span id="vulnLoadMeta">Loading eligible items…</span>
                        </div>
                        <div class="progress" style="height: 14px;">
                            <div class="progress-bar" id="vulnLoadProgressBar" role="progressbar" style="width:0%" aria-valuenow="0" aria-valuemin="0" aria-valuemax="100">0%</div>
                        </div>
                    </div>
                    <div class="d-flex align-items-start gap-2 mb-2">
                        <div class="flex-grow-1">
                            <input class="form-control" placeholder="Filter (string or /regex/)" id="vulnFilter">
                            <div class="invalid-feedback" id="vulnFilterError">Invalid regex</div>
                        </div>
                        <button class="btn btn-outline-secondary" type="button" id="vulnFilterClear" title="Clear filter">Clear</button>
                    </div>
                    <div class="text-muted small mb-2" id="vulnFilterMeta"></div>
                    <div class="table-responsive" id="vulnTableWrap" style="max-height:50vh; overflow:auto; display:none;">
                        <table class="table table-sm">
                            <thead><tr><th>Name</th><th>Type</th><th>Vector</th><th>Path</th></tr></thead>
                            <tbody id="vulnList"></tbody>
                        </table>
                    </div>
                </div>
                <div class="modal-footer">
                    <button class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
                </div>
            </div>
        </div>`;
        document.body.appendChild(modal);
}

async function openVulnPicker(sidx, secName, iidx){
    ensureVulnModal();
    const modalEl = document.getElementById('vulnModal');
    const modalObj = window.bootstrap ? new bootstrap.Modal(modalEl, { backdrop: true, keyboard: true }) : null;
    const filterInput = modalEl.querySelector('#vulnFilter');
    const filterClearBtn = modalEl.querySelector('#vulnFilterClear');
    const filterMeta = modalEl.querySelector('#vulnFilterMeta');
    const filterError = modalEl.querySelector('#vulnFilterError');
    const tbody = modalEl.querySelector('#vulnList');
    const tblWrap = modalEl.querySelector('#vulnTableWrap');
    const loadWrap = modalEl.querySelector('#vulnLoadingWrap');
    const loadBar = modalEl.querySelector('#vulnLoadProgressBar');
    const loadMeta = modalEl.querySelector('#vulnLoadMeta');
    const row = state.scenarios[sidx].sections[secName].items[iidx] || {};
    const selVector = (row.v_vector || 'Random');
    // Base: docker-compose only
    const all = (window.VULN_CATALOG?.items || []);
    let base = all.filter(it => (it.Type||'').toLowerCase() === 'docker-compose');
    if (selVector && selVector !== 'Random') {
        const vv = selVector.toLowerCase();
        base = base.filter(it => (it.Vector||'').toLowerCase() === vv);
    }
    // Do not compute eligibility; show immediately
    let eligible = base;
    try {
        if (modalObj) modalObj.show();
        if (loadWrap) loadWrap.style.display = 'none';
        if (tblWrap) tblWrap.style.display = '';
    } catch(e){}
    let current = eligible;
    const renderRows = () => {
        tbody.innerHTML = '';
        if (!current || current.length === 0) {
            const tr = document.createElement('tr');
            const td = document.createElement('td');
            td.colSpan = 4;
            td.className = 'text-center text-muted py-3';
            td.textContent = 'No results';
            tr.appendChild(td);
            tbody.appendChild(tr);
            return;
        }
        current.forEach((it) => {
            const tr = document.createElement('tr');
            tr.innerHTML = `<td>${it.Name}</td><td>${it.Type}</td><td>${it.Vector}</td><td>${it.Path}</td>`;
            tr.style.cursor = 'pointer';
            tr.onclick = () => {
                const item = state.scenarios[sidx].sections[secName].items[iidx];
                item.v_name = it.Name;
                item.v_path = it.Path;
                item.v_type = it.Type;
                item.v_vector = it.Vector;
                if (it.Description) item.v_desc = it.Description;
                // also set selected to Specific defensively
                item.selected = 'Specific';
                document.getElementById('scenarios_json').value = JSON.stringify({ scenarios: state.scenarios, active_index: activeIdx });
                try { if(window.bootstrap){ bootstrap.Modal.getInstance(modalEl)?.hide(); } } catch(e) {}
                renderMain();
            };
            tbody.appendChild(tr);
        });
    };
    const applyFilter = () => {
        const raw = (filterInput.value||'').trim();
        try { localStorage.setItem('vulnPickerFilter', raw); } catch(e){}
        filterInput.classList.remove('is-invalid');
        if (filterError) filterError.style.display = '';
        if(!raw){
            current = eligible;
            renderRows();
            if (filterMeta) filterMeta.textContent = `${current.length}/${eligible.length} shown`;
            return;
        }
        let matcher = null;
        if (raw.startsWith('/') && raw.endsWith('/') && raw.length >= 2) {
            try { matcher = new RegExp(raw.slice(1, -1), 'i'); } catch(e){ matcher = null; }
            if (!matcher) {
                filterInput.classList.add('is-invalid');
                if (filterMeta) filterMeta.textContent = `Invalid regex`;
                return;
            }
        }
        if (matcher) {
            current = eligible.filter(it => matcher.test(it.Name) || matcher.test(it.Type) || matcher.test(it.Vector) || matcher.test(it.Path));
        } else {
            const lower = raw.toLowerCase();
            current = eligible.filter(it => (it.Name||'').toLowerCase().includes(lower) || (it.Type||'').toLowerCase().includes(lower) || (it.Vector||'').toLowerCase().includes(lower) || (it.Path||'').toLowerCase().includes(lower));
        }
        renderRows();
        if (filterMeta) filterMeta.textContent = `${current.length}/${eligible.length} shown`;
    };
    filterInput.oninput = applyFilter;
    filterClearBtn.onclick = () => { filterInput.value = ''; applyFilter(); };
    // Load last-used filter, if any
    try {
        const saved = localStorage.getItem('vulnPickerFilter');
        if (saved) filterInput.value = saved;
    } catch(e){}
    // Render immediately and show counts
    try {
        renderRows();
        applyFilter();
    } catch(e){}
}


async function runAsync() {
    let rp = state.result_path || '';
    if (!rp.endsWith('.xml')) {
        const go = window.confirm('Your XML has not been saved. Save now and then run?');
        if (!go) { logInfo('Async run cancelled by user (declined save)'); return; }
        try {
            const ok = await saveXmlAjax();
            if (!ok) { logWarn('Save failed; aborting async run'); return; }
            rp = state.result_path || '';
            if (!rp.endsWith('.xml')) { logWarn('Save did not produce an XML path; aborting async run'); return; }
        } catch(e){ logError('Exception during auto-save; aborting async run'); return; }
    }
    const confirmMsg = 'This action will generate a new CORE scenario and attempt to start it asynchronously using the daemon connection.\n\nProceed?';
    if (!window.confirm(confirmMsg)) { logInfo('Async run cancelled by user at confirmation'); return; }
    const form = new FormData(); form.append('xml_path', rp);
        const res = await fetch("{{ url_for('run_cli_async') }}", { method: 'POST', body: form });
    if (!res.ok) { alert('Failed to start run'); return; }
    const { run_id } = await res.json();
    logInfo(`Async run started id=${run_id}`);
    startLogStream(run_id);
    pollRunStatus(run_id);
}

// Save XML via JSON API without navigation
async function saveXmlAjax(){
    try {
        const payload = { scenarios: state.scenarios };
        const res = await fetch('/save_xml_api', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload)
        });
        if (!res.ok) { try { const err = await res.json(); logWarn('Save failed: ' + (err?.error || res.status)); } catch(e){ logWarn('Save failed'); } return false; }
        const data = await res.json();
        if (data && data.ok && data.result_path) {
            state.result_path = data.result_path;
            persistEditorState();
            logInfo('Scenarios saved to ' + data.result_path);
            // Refresh XML preview lazily
            try {
                const xmlPre = document.getElementById('xmlPre');
                if (xmlPre) {
                    const txt = await (await fetch('/download_report?path=' + encodeURIComponent(data.result_path))).text();
                    xmlPre.textContent = txt;
                }
            } catch(e){}
            return true;
        }
        logWarn('Save did not return a valid path');
        return false;
    } catch(e) { logError('Save threw an exception'); return false; }
}
let evtSrc = null;
function startLogStream(runId) {
    if (evtSrc) { try { evtSrc.close(); } catch(e){} }
    evtSrc = new EventSource('/stream/' + runId);
    // keep existing logs; do not auto-clear
    // Ensure dock is visible so users can see live logs
    try {
        const showBtn = document.getElementById('dockShowBtn');
        if (showBtn && !showBtn.classList.contains('d-none')) { showBtn.click(); }
    } catch(e){}
    // Toggle buttons
    document.getElementById('runAsyncBtn').classList.add('d-none');
    document.getElementById('runSyncBtn').classList.add('disabled');
    document.getElementById('cancelRunBtn').classList.remove('d-none');
    evtSrc.onmessage = (ev) => {
        const raw = ev.data || '';
        let lvl = 'INFO';
        if (/\bERROR\b/.test(raw)) lvl = 'ERROR';
        else if (/\bWARN(ING)?\b/.test(raw)) lvl = 'WARN';
        else if (/\bDEBUG\b/.test(raw)) lvl = 'DEBUG';
    appendLog(raw, lvl);
    };
    evtSrc.addEventListener('end', () => {
        evtSrc.close();
        document.getElementById('runAsyncBtn').classList.remove('d-none');
        document.getElementById('runSyncBtn').classList.remove('disabled');
        document.getElementById('cancelRunBtn').classList.add('d-none');
        logInfo('Async run ended');
    });
}

async function pollRunStatus(runId) {
    const xmlPre = document.getElementById('xmlPre');
    try {
    const res = await fetch('/run_status/' + runId);
        if (!res.ok) return;
        const data = await res.json();
        // Update download link
        const rp = data.report_path || data.xml_path;
        if (rp) { state.result_path = rp; persistEditorState(); }
        // Refresh XML preview if we have the xml path and it's changed
        if (data.xml_path && xmlPre && !xmlPre.textContent.trim()) {
                    try {
                        const txt = await (await fetch('/download_report?path=' + encodeURIComponent(data.xml_path))).text();
                        xmlPre.textContent = txt;
                    } catch(e){}
        }
        if (!data.done) {
            setTimeout(() => pollRunStatus(runId), 1000);
        } else {
            if (data.returncode === 0) {
                setTimeout(() => { window.location.href = "{{ url_for('reports_page') }}"; }, 500);
            }
        }
    } catch(e) {
        // ignore transient errors
        setTimeout(() => pollRunStatus(runId), 1500);
    }
}

    async function cancelRun() {
        if (!evtSrc) return;
        // Extract runId from the EventSource URL
        const url = evtSrc.url;
        const runId = url.split('/').pop();
        try {
            await fetch('/cancel_run/' + runId, { method: 'POST' });
        } catch(e) {}
    try { evtSrc.close(); } catch(e){}
        document.getElementById('runAsyncBtn').classList.remove('d-none');
        document.getElementById('runSyncBtn').classList.remove('disabled');
        document.getElementById('cancelRunBtn').classList.add('d-none');
    logInfo('Run cancelled by user');
    }

// --- Run CLI via modal (async under the hood) ---
function ensureRunProgressModal(){
    if(!runProgressModalInst){
        const el = document.getElementById('runProgressModal');
        if(el){ runProgressModalInst = new bootstrap.Modal(el, { backdrop: 'static', keyboard: false }); }
    }
    return runProgressModalInst;
}
function runProgressLogLine(s){
    const pre = document.getElementById('runProgressLog');
    if(!pre) return;
    const line = (s||'');
    // Level detection first so we only log once with correct level
    let lvl = 'INFO';
    try {
        if(/\bERROR\b/.test(line)) lvl='ERROR';
        else if(/\bWARN(ING)?\b/.test(line)) lvl='WARN';
        else if(/\bDEBUG\b/.test(line)) lvl='DEBUG';
    } catch(e){}
    try {
        const text = line + '\n';
        if(typeof pre.append === 'function'){ pre.append(text); }
        else { pre.appendChild(document.createTextNode(text)); }
    } catch(e){}
    appendLog(line, lvl);
    pre.parentElement?.scrollTo({ top: pre.parentElement.scrollHeight });
}
function openRunProgress(title){
    const modalEl = document.getElementById('runProgressModal');
    ensureRunProgressModal();
    try {
        if(title) document.querySelector('#runProgressModal .modal-title').textContent = title;
        document.getElementById('runProgressStatus').textContent = 'Starting…';
        document.getElementById('runProgressMeta').textContent = '';
        document.getElementById('runProgressBar').classList.add('progress-bar-animated');
        const logEl = document.getElementById('runProgressLog');
        if(logEl) logEl.textContent = '';
    // Do NOT clear persistent log buffer; just re-render existing lines
    if(typeof renderDockLog === 'function'){ renderDockLog(); }
        // Reset footer buttons to default state
        const hideBtn = document.getElementById('runProgressHideBtn');
        if (hideBtn) {
            hideBtn.textContent = 'Hide';
            hideBtn.onclick = null; // remove any prior navigation handler
        }
        runProgressModalInst?.show();
    } catch(e){}
    try {
        if(modalEl && !modalEl.classList.contains('show')){
            modalEl.style.display = 'block';
            modalEl.removeAttribute('aria-hidden');
            modalEl.classList.add('show');
            if(!document.body.classList.contains('modal-open')){
                document.body.classList.add('modal-open');
                document.body.style.removeProperty('paddingRight');
                document.body.style.removeProperty('overflow');
            }
            if(!document.querySelector('.modal-backdrop')){
                const backdrop = document.createElement('div');
                backdrop.className = 'modal-backdrop fade show';
                document.body.appendChild(backdrop);
            }
        }
    } catch(e){}
}
function closeRunProgress(){
    try { if(runProgressEvtSrc) runProgressEvtSrc.close(); } catch(e){}
    runProgressEvtSrc = null;
    runProgressRunId = null;
    try { runProgressModalInst?.hide(); } catch(e){}
    try {
        const modalEl = document.getElementById('runProgressModal');
        if(modalEl){
            modalEl.classList.remove('show');
            modalEl.style.removeProperty('display');
            modalEl.setAttribute('aria-hidden','true');
        }
        const openModals = document.querySelectorAll('.modal.show');
        if(openModals.length === 0){
            document.querySelectorAll('.modal-backdrop').forEach(b => {
                try { b.remove(); } catch(_e){}
            });
            document.body.classList.remove('modal-open');
            document.body.style.removeProperty('paddingRight');
            document.body.style.removeProperty('overflow');
        }
    } catch(e){}
}
async function runSyncWithModal(arg){
    let opts = {};
    if(arg && typeof arg === 'object' && typeof arg.preventDefault === 'function'){
        arg.preventDefault();
    } else if(arg && typeof arg === 'object'){
        opts = arg;
    }
    const showProgressModal = opts.showProgressModal !== false;
    const skipConfirm = opts.skipConfirm === true;
    // Validate saved XML
    let rp = state.result_path || '';
    if (!rp.endsWith('.xml')) {
        const go = window.confirm('Your XML has not been saved. Save now and then run?');
        if (!go) { logInfo('Run CLI cancelled by user (declined save)'); return false; }
        try {
            const ok = await saveXmlAjax();
            if (!ok) { logWarn('Save failed; aborting run'); return false; }
            rp = state.result_path || '';
            if (!rp.endsWith('.xml')) { logWarn('Save did not produce an XML path; aborting run'); return false; }
        } catch(e){ logError('Exception during auto-save; aborting run'); return false; }
    }
    const confirmMsg = 'This will generate a CORE scenario and attempt to start it. Proceed?';
    if (!skipConfirm && !window.confirm(confirmMsg)) { logInfo('Run CLI cancelled by user at confirmation'); return false; }
    if(showProgressModal){
        openRunProgress('Running CLI…');
    }
    try {
        // Ensure dock is visible
        try {
            const showBtn = document.getElementById('dockShowBtn');
            if (showBtn && !showBtn.classList.contains('d-none')) { showBtn.click(); }
        } catch(e){}
        const form = new FormData(); form.append('xml_path', rp);
        const res = await fetch("{{ url_for('run_cli_async') }}", { method: 'POST', body: form });
        if(!res.ok){
            runProgressLogLine('Failed to start CLI');
            if(showProgressModal){
                try {
                    const statusEl = document.getElementById('runProgressStatus');
                    if(statusEl) statusEl.textContent = 'Failed to start';
                    const metaEl = document.getElementById('runProgressMeta');
                    if(metaEl) metaEl.textContent = 'HTTP ' + res.status;
                    const bar = document.getElementById('runProgressBar');
                    if(bar){ bar.classList.remove('progress-bar-animated'); bar.textContent = 'Error'; }
                } catch(e){}
            }
            try { opts.onError?.(new Error('Failed to start CLI')); } catch(e){}
            return false;
        }
        const dataInit = await res.json();
        const run_id = dataInit?.run_id;
        runProgressRunId = run_id;
        if(!run_id){
            runProgressLogLine('Execution start response missing run_id');
            if(showProgressModal){
                try {
                    const statusEl = document.getElementById('runProgressStatus');
                    if(statusEl) statusEl.textContent = 'Failed to start';
                    const metaEl = document.getElementById('runProgressMeta');
                    if(metaEl) metaEl.textContent = 'Missing run id';
                    const bar = document.getElementById('runProgressBar');
                    if(bar){ bar.classList.remove('progress-bar-animated'); bar.textContent = 'Error'; }
                } catch(e){}
            }
            try { opts.onError?.(new Error('Missing run id')); } catch(e){}
            return false;
        }
        // No Cancel button in modal; runs cannot be cancelled here
        // Start SSE stream into modal
        try { if(runProgressEvtSrc) runProgressEvtSrc.close(); } catch(e){}
        runProgressEvtSrc = new EventSource('/stream/' + run_id);
        runProgressEvtSrc.onmessage = (ev)=>{ runProgressLogLine(ev.data||''); };
        runProgressEvtSrc.addEventListener('end', ()=>{ try { runProgressEvtSrc.close(); } catch(e){} logInfo('Run (modal) ended'); });
        // Poll for completion and update meta
        return await new Promise((resolve) => {
            (async function poll(){
                try{
                    const r = await fetch('/run_status/' + run_id);
                    if(!r.ok){ setTimeout(poll, 1200); return; }
                    const data = await r.json();
                    if(data.report_path || data.xml_path){
                        state.result_path = data.report_path || data.xml_path;
                        persistEditorState();
                    }
                    if(showProgressModal){
                        const metaEl = document.getElementById('runProgressMeta');
                        if(metaEl){ metaEl.textContent = data.done ? (data.returncode===0 ? 'Completed' : 'Failed') : 'Running…'; }
                    } else {
                        try { opts.onTick?.(data); } catch(e){}
                    }
                    if(!data.done){ setTimeout(poll, 1000); return; }
                    if(showProgressModal){
                        document.getElementById('runProgressStatus').textContent = (data.returncode===0) ? 'Scenario started' : 'Finished with errors';
                        document.getElementById('runProgressBar').classList.remove('progress-bar-animated');
                    }
                    try { opts.onComplete?.(data); } catch(e){}
                    try {
                        if (data.returncode === 0) {
                            setTimeout(() => { window.location.href = "{{ url_for('reports_page') }}"; }, 500);
                        }
                    } catch(e){}
                    resolve(data);
                } catch(e){ setTimeout(poll, 1500); }
            })();
        });
    } catch(e){
        runProgressLogLine('Exception starting CLI');
        try { if(!showProgressModal) opts.onError?.(e); } catch(_){}
        throw e;
    }
}

// Run deterministically with a seed (preview seed or input)
async function runWithSeedBuild(){
    // Ensure XML is saved
    let rp = state.result_path || '';
    if(!rp.endsWith('.xml')){
        const go = window.confirm('XML not saved yet. Save now?');
        if(!go) return;
        const saved = await saveXmlAjax();
        if(!saved){ alert('Auto-save failed; cannot run.'); return; }
        rp = state.result_path || '';
        if(!rp.endsWith('.xml')){ alert('Saved XML path unresolved.'); return; }
    }
    // Derive seed: prefer explicit input, else current preview seed
    // seedInputEl removed
    let seedVal = null;
    if(seedInputEl && seedInputEl.value.trim()){
        const num = parseInt(seedInputEl.value.trim(),10); if(!isNaN(num) && num>0) seedVal = num;
    } else if(previewState.fullPreview && previewState.fullPreview.seed){
        seedVal = previewState.fullPreview.seed;
    }
    if(seedVal===null){
        alert('Enter a seed or generate a Full Preview (which records a seed) first.');
        return;
    }
    const confirmMsg = `Run CLI with seed=${seedVal}? This will start a CORE session.`;
    if(!window.confirm(confirmMsg)) return;
    openRunProgress('Running CLI (seed='+seedVal+')…');
    try {
        // Show dock logs
        try { const showBtn=document.getElementById('dockShowBtn'); if(showBtn && !showBtn.classList.contains('d-none')) showBtn.click(); } catch(e){}
        const res = await fetch("{{ url_for('run_cli_async') }}", {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ xml_path: rp, seed: seedVal })
        });
        if(!res.ok){ runProgressLogLine('Failed to start seeded run'); return; }
        const { run_id } = await res.json();
        runProgressRunId = run_id;
        // Stream logs
        try { if(runProgressEvtSrc) runProgressEvtSrc.close(); } catch(e){}
        runProgressEvtSrc = new EventSource('/stream/' + run_id);
        runProgressEvtSrc.onmessage = (ev)=> runProgressLogLine(ev.data||'');
        runProgressEvtSrc.addEventListener('end', ()=>{ try { runProgressEvtSrc.close(); } catch(e){} });
        // Poll status similar to runSyncWithModal
        (async function poll(){
            try{
                const r = await fetch('/run_status/' + run_id);
                if(!r.ok){ setTimeout(poll, 1200); return; }
                const data = await r.json();
                if(data.report_path || data.xml_path){ state.result_path = data.report_path || data.xml_path; persistEditorState(); }
                const metaEl = document.getElementById('runProgressMeta'); if(metaEl) metaEl.textContent = data.done ? (data.returncode===0 ? 'Completed' : 'Failed') : 'Running…';
                if(!data.done){ setTimeout(poll, 1000); return; }
                document.getElementById('runProgressStatus').textContent = (data.returncode===0) ? 'Scenario started' : 'Finished with errors';
                document.getElementById('runProgressBar').classList.remove('progress-bar-animated');
                if(data.returncode===0){ setTimeout(()=>{ window.location.href = "{{ url_for('reports_page') }}"; }, 600); }
            } catch(e){ setTimeout(poll, 1500); }
        })();
    } catch(e){ runProgressLogLine('Exception starting seeded run'); }
}

    function redistributeEven(sidx, secName) {
        const items = state.scenarios[sidx].sections[secName].items;
        const n = items.length;
        if (n === 0) return;
    const weightIdxs = items.map((it,i) => ({i,it})).filter(x => ((x.it.v_metric|| (x.it.selected==='Specific'?'Count':'Weight')) === 'Weight')).map(x => x.i);
    const m = weightIdxs.length;
    if (m === 0) { return; }
    const even = Math.round((1.0 / m) * 1000) / 1000;
    weightIdxs.slice(0, -1).forEach(i => { items[i].factor = even; });
        // last item gets the residual to hit 1.0
    const sumOther = weightIdxs.slice(0, -1).reduce((a, i) => a + (parseFloat(items[i].factor)||0), 0);
    const lastIdx = weightIdxs[weightIdxs.length - 1];
    items[lastIdx].factor = Math.max(0, Math.round((1.0 - sumOther) * 1000) / 1000);
        updateWeightWarning(sidx, secName);
    }

    function adjustWeightsProportionally(sidx, secName, changedIdx) {
        const items = state.scenarios[sidx].sections[secName].items;
        const n = items.length;
    const weightIdxs = items.map((it,i) => ({i,it})).filter(x => ((x.it.v_metric|| (x.it.selected==='Specific'?'Count':'Weight')) === 'Weight')).map(x => x.i);
        const m = weightIdxs.length;
        if (m <= 1) { if (m === 1) items[weightIdxs[0]].factor = 1.0; return; }
        // clamp changed value
        items[changedIdx].factor = Math.max(0, Math.min(1, parseFloat(items[changedIdx].factor)||0));
        const targetSum = 1.0;
        const changed = parseFloat(items[changedIdx].factor)||0;
        const others = weightIdxs.map(i => i !== changedIdx ? (parseFloat(items[i].factor)||0) : 0);
        const sumOthers = others.reduce((a,b) => a + b, 0);
        const residual = Math.max(0, targetSum - changed);
        if (sumOthers <= 0) {
            // Distribute evenly across others
            const even = residual / (m - 1);
            weightIdxs.forEach(i => { if (i !== changedIdx) items[i].factor = Math.round(even * 1000) / 1000; });
        } else {
            // Scale others proportionally to keep overall sum 1.0
            weightIdxs.forEach((i, idx) => {
                if (i === changedIdx) return;
                const ratio = others[idx] / sumOthers;
                items[i].factor = Math.round((residual * ratio) * 1000) / 1000;
            });
        }
        // Final normalization to exact 1.000 with 3 decimals
        normalizeToThousandths(sidx, secName);
    }

    function updateWeightWarning(sidx, secName) {
        const items = state.scenarios[sidx].sections[secName].items;
    // Exempt Node Information from weight validation (single Random item default)
    if (secName === 'Node Information') return;
    if (!items || items.length === 0) return;
        const sum = Math.round(items.reduce((a,b) => {
            const metric = b.v_metric || (b.selected==='Specific'?'Count':'Weight');
            return a + (metric==='Weight' ? (parseFloat(b.factor)||0) : 0);
        }, 0) * 1000) / 1000;
    const warn = document.querySelector(".section-warning[data-scen-idx='" + sidx + "'][data-sec='" + secName + "']");
        if (warn) {
            const density = parseFloat((state.scenarios[sidx].sections[secName]||{}).density);
            const weightCount = items.filter(b => (b.v_metric || (b.selected==='Specific'?'Count':'Weight')) === 'Weight').length;
            const badWeights = weightCount > 0 ? (Math.abs(sum - 1.0) > 0.005) : false;
            // Routing density: allow any density >= 0 (>=1 means absolute router count)
            // Other sections: keep 0..1 constraint
            const badDensity = isNaN(density) ? false : (
                secName === 'Routing' ? (density < 0) : (density < 0 || density > 1)
            );
            warn.style.display = (badWeights || badDensity) ? 'block' : 'none';
            let msgs = [];
            if (badWeights) msgs.push('Weights must sum to 1.000 (current: ' + sum.toFixed(3) + ')');
            if (badDensity) {
                if (secName === 'Routing') {
                    msgs.push('Routing density must be >= 0 (current: ' + density.toFixed(2) + '). Tip: < 1 = fraction of hosts; ≥ 1 = absolute router count.');
                } else {
                    msgs.push('Density must be between 0 and 1 (current: ' + density.toFixed(2) + ')');
                }
            }
            warn.textContent = msgs.join(' • ');
        }
    }

    function normalizeToThousandths(sidx, secName) {
        const items = state.scenarios[sidx].sections[secName].items;
        if (!items || items.length === 0) return;
        const vals = items.map(it => {
            const metric = it.v_metric || (it.selected==='Specific'?'Count':'Weight');
            const v = Math.max(0, Math.min(1, parseFloat(it.factor)||0));
            return metric==='Weight' ? v : 0;
        });
        // Convert to thousandths without rounding first
        const thousandthsRaw = vals.map(v => v * 1000);
        const floors = thousandthsRaw.map(v => Math.floor(v));
        let sumFloors = floors.reduce((a,b) => a + b, 0);
        let remainder = 1000 - sumFloors;
        if (remainder > 0) {
            // Distribute +1 to largest fractional parts
            const remainders = thousandthsRaw.map((v, i) => ({ idx: i, frac: v - floors[i] }));
            remainders.sort((a,b) => b.frac - a.frac);
            for (let k = 0; k < remainders.length && remainder > 0; k++) {
                floors[remainders[k].idx] += 1; remainder -= 1;
            }
        } else if (remainder < 0) {
            // Remove -1 from largest values to reduce sum to 1000
            const order = floors.map((v,i) => ({ idx: i, v }));
            order.sort((a,b) => b.v - a.v);
            while (remainder < 0) {
                for (let k = 0; k < order.length && remainder < 0; k++) {
                    const i = order[k].idx;
                    if (floors[i] > 0) { floors[i] -= 1; remainder += 1; }
                }
                if (order.length === 0) break;
            }
        }
        for (let i = 0; i < items.length; i++) {
            const metric = items[i].v_metric || (items[i].selected==='Specific'?'Count':'Weight');
            items[i].factor = (metric==='Weight') ? (floors[i] / 1000.0) : (items[i].factor||0);
        }
    }

    function updateWeightInputsDisplay(sidx, secName) {
        const items = state.scenarios[sidx].sections[secName].items;
    document.querySelectorAll("input.weight-input[data-scen-idx='" + sidx + "'][data-sec='" + secName + "']").forEach(input => {
            const iidx = parseInt(input.getAttribute('data-item-idx'));
            if (!isNaN(iidx) && items[iidx]) {
                input.value = (parseFloat(items[iidx].factor) || 0).toFixed(3);
            }
        });
    }

    // Dock setup handled by partial
</script>
</body>
<!-- Toast container -->
<div aria-live="polite" aria-atomic="true" class="position-fixed" style="z-index: 1080; right: 12px; bottom: 12px;">
    <div id="toastContainer" class="toast-container"></div>
    <template id="toastTemplate">
        <div class="toast align-items-center text-bg-dark border-0" role="alert" aria-live="assertive" aria-atomic="true">
            <div class="d-flex">
                <div class="toast-body">Action completed.</div>
                <button type="button" class="btn-close btn-close-white me-2 m-auto" data-bs-dismiss="toast" aria-label="Close"></button>
            </div>
        </div>
    </template>
    <script>
        function showToast(message, opts){
            try {
                const container = document.getElementById('toastContainer');
                const tmpl = document.getElementById('toastTemplate');
                if(!container || !tmpl) return;
                const node = tmpl.content.firstElementChild.cloneNode(true);
                node.querySelector('.toast-body').textContent = message || 'Done';
                container.appendChild(node);
                const t = new bootstrap.Toast(node, Object.assign({ delay: 2500, autohide: true }, (opts||{})));
                t.show();
                node.addEventListener('hidden.bs.toast', () => { try { node.remove(); } catch(e){} });
            } catch(e){}
        }
    </script>
</div>
<!-- Success Modal -->
<div class="modal fade" id="runSuccessModal" tabindex="-1" aria-hidden="true">
    <div class="modal-dialog modal-dialog-centered">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title">Run Completed</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <p class="mb-1" id="runSuccessBody">Generation complete.</p>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
            </div>
        </div>
    </div>
</div>
<script>
function showRunSuccessModal(msg){
    try { if(msg) document.getElementById('runSuccessBody').textContent = msg; new bootstrap.Modal(document.getElementById('runSuccessModal')).show(); } catch(e){}
}
document.addEventListener('DOMContentLoaded', () => {
    if (window.runSuccessFlag) {
        setTimeout(() => { window.location.href = "{{ url_for('reports_page') }}"; }, 300);
    }
});
// Capture server-provided flag (injected if present)
// Inject run success flag
window.runSuccessFlag = ("{{ '1' if (run_success is defined and run_success) else '0' }}" === '1');
// Wrap pollRunStatus to detect async completion success
const __origPollRunStatus = pollRunStatus;
pollRunStatus = async function(runId){
    await __origPollRunStatus(runId);
    try {
        const res = await fetch('/run_status/' + runId);
        if(!res.ok) return;
        const data = await res.json();
        if(data.done && data.returncode === 0){
            showRunSuccessModal('Asynchronous run completed successfully.');
        } else if(!data.done) {
            setTimeout(() => pollRunStatus(runId), 800);
        }
    } catch(e){}
};
</script>
{% endblock %}
