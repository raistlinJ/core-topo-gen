{% extends 'layout.html' %}
{% block title %}Scenarios - CORE TopoGen{% endblock %}
{% block active_page %}{% set active_page = 'scenarios' %}{% endblock %}
{% set scenario_tab = request.args.get('scenario', '').strip() if request else '' %}
{% set requested_tab = request.args.get('tab', '').strip() if request else '' %}
{% if requested_tab in ['connection-setup', 'topology'] %}
    {% set scenarios_active_tab = requested_tab %}
{% else %}
    {% set scenarios_active_tab = 'topology' %}
{% endif %}
{% block extra_head %}
<style>
    body { padding-bottom: 42vh; }
    .pulse-change { animation: pulseHighlight .9s ease-in-out; }
    @keyframes pulseHighlight { 0% { box-shadow:0 0 0 0 rgba(13,110,253,.7); transform:scale(1);} 40% { box-shadow:0 0 0 6px rgba(13,110,253,.0); transform:scale(1.03);} 100% { box-shadow:0 0 0 0 rgba(13,110,253,0); transform:scale(1); } }
    .popover { max-width: 420px; }
    .host-total-badge + .badge, .host-total-badge + button { margin-left: .25rem; }
    /* Hide H/S bounds by default; JS adds .hs-show to display them */
    .hs-bounds-wrapper { display: none; }
    .hs-bounds-wrapper.hs-show { display: flex; }
    .form-switch.form-switch-sm .form-check-input {
        height: 1rem;
        width: 2rem;
        transform: scale(0.85);
        margin-top: 0.15rem;
    }
    .form-switch.form-switch-sm .form-check-label {
        padding-left: .35rem;
    }
    fieldset.hitl-step-fieldset {
        border: 0;
        padding: 0;
        margin: 0;
        min-width: 0;
    }
    fieldset.hitl-step-fieldset[disabled] {
        opacity: 0.6;
        pointer-events: none;
    }
    .hitl-entry-btn {
        min-height: 38px;
    }
    .hitl-step-disabled {
        filter: grayscale(0.3);
        opacity: 0.85;
    }
    #executeConfirmModal .modal-dialog {
        max-width: min(960px, 95vw);
    }
    #executeConfirmModal .modal-content {
        min-height: auto;
    }
    #executeProgressWrap .progress {
        height: 18px;
    }
    #executeProgressLog {
        height: 320px;
    }
</style>
{% endblock %}
<!-- hs-bounds-wrapper styles moved into style block above -->
{% set is_builder_view = (ui_view_mode == 'builder') %}
{% block content %}
    {% include 'partials/scenarios_tabs.html' with context %}
    <div class="row">
        <div class="col-md-3 mb-3">
            <div class="card shadow-sm h-100 d-flex flex-column">
                <div class="card-header d-flex justify-content-between align-items-center flex-nowrap gap-2">
                    <div class="d-flex align-items-center gap-1 flex-nowrap">
                        <span class="fw-bold">Scenarios</span>
                        {% if not is_builder_view %}
                        <button type="button" class="btn btn-sm btn-outline-primary py-0 px-1" id="appendScenarioBtn" title="New" aria-label="New">
                            <i class="bi bi-plus-lg" aria-hidden="true"></i>
                        </button>
                        {% endif %}
                    </div>
                    <div class="btn-toolbar gap-1 align-items-center flex-nowrap">
                        {% if not is_builder_view %}
                        <button type="button" class="btn btn-sm btn-outline-secondary" id="importBtn" title="Import scenarios XML">Import</button>
                        <button type="button" class="btn btn-sm btn-outline-info" id="exportBtn" title="Export last saved XML">Export</button>
                        <div class="btn-group" role="group" aria-label="Bulk scenario actions">
                            <button type="button" class="btn btn-sm btn-outline-secondary" id="selectAllScenariosBtn" title="Select all (or clear if all selected)">All</button>
                            <button type="button" class="btn btn-sm btn-outline-danger" id="deleteSelectedScenariosBtn" title="Delete selected scenarios" disabled>Delete</button>
                        </div>
                        {% endif %}
                    </div>
                </div>
                <div class="list-group list-group-flush flex-grow-1 overflow-auto" id="scenarioList" style="min-height:0;"></div>
                <form id="hiddenLoadForm" class="d-none" action="{{ url_for('load_xml') }}" method="post" enctype="multipart/form-data">
                    <input type="file" name="scenarios_xml" id="hiddenLoadInput" accept=".xml">
                </form>
            </div>
        </div>
        <div class="col-md-9">
            <div class="card shadow mt-3">
                <div class="card-body">
                    <div id="connectionSetupRoot" class="{% if scenarios_active_tab == 'connection-setup' %}d-block{% else %}d-none{% endif %}"></div>
                    {% if scenarios_active_tab != 'connection-setup' %}
                    <div class="card mb-3" id="baseCoreScenarioCard">
                        <div class="card-header d-flex justify-content-between align-items-center">
                            <strong>Base CORE Scenario</strong>
                            <div class="d-flex align-items-center gap-2" id="baseScenarioControls">
                                {% set has_base = payload.base_upload is defined and payload.base_upload %}
                                {% if is_builder_view %}
                                <a id="baseDetailsLink" class="btn btn-sm btn-outline-secondary {% if not has_base %}d-none{% endif %}" href="{% if has_base %}{{ url_for('core_details') }}?path={{ payload.base_upload.path | urlencode }}{% else %}#{% endif %}" target="_blank" data-base-url="{{ url_for('core_details') }}?path=">Details</a>
                                {% else %}
                                <span id="baseValidityBadge" class="badge {% if not has_base %}d-none{% else %}{% if payload.base_upload.valid %}text-bg-success{% else %}text-bg-danger{% endif %}{% endif %}">
                                    {% if has_base %}{% if payload.base_upload.valid %}VALID{% else %}INVALID{% endif %}{% else %}VALID{% endif %}
                                </span>
                                <a id="baseDetailsLink" class="btn btn-sm btn-outline-secondary {% if not has_base %}d-none{% endif %}" href="{% if has_base %}{{ url_for('core_details') }}?path={{ payload.base_upload.path | urlencode }}{% else %}#{% endif %}" target="_blank" data-base-url="{{ url_for('core_details') }}?path=">Details</a>
                                <form action="{{ url_for('remove_base') }}" method="post" class="d-inline {% if not has_base %}d-none{% endif %}" id="baseRemoveForm" onsubmit="saveScrollBeforeNav(); document.getElementById('scenarios_json').value = JSON.stringify({ scenarios: state.scenarios });">
                                    <button type="submit" class="btn btn-sm btn-outline-danger">Remove</button>
                                </form>
                                <button class="btn btn-sm btn-outline-secondary" type="button" id="baseCoreCollapseBtn" data-preview-collapse="baseCoreScenarioBody" data-label-collapse="Collapse" data-label-expand="Expand">Collapse</button>
                                {% endif %}
                            </div>
                        </div>
                        <div class="card-body collapse show" id="baseCoreScenarioBody">
                            {% if is_builder_view %}
                            <div class="mb-0">
                                <label class="form-label mb-1">Base Scenario File</label>
                                <input class="form-control" id="baseFileInput" readonly>
                            </div>
                            {% else %}
                            <div class="mb-3">
                                <label class="form-label d-flex align-items-center justify-content-between">
                                    <span>Base Scenario File</span>
                                </label>
                                <input class="form-control" id="baseFileInput" readonly>
                                <div class="form-text">Shows the uploaded file name; full path is stored internally.</div>
                            </div>
                            <form class="d-flex gap-2" action="{{ url_for('upload_base') }}" method="post" enctype="multipart/form-data" onsubmit="saveScrollBeforeNav()">
                                <input type="file" class="form-control" name="base_xml" accept=".xml" required>
                                <button type="submit" class="btn btn-primary">{% if payload.base_upload %}Update{% else %}Upload{% endif %}</button>
                            </form>
                            {% if payload.base_upload and not payload.base_upload.valid and logs %}
                                <div class="alert alert-danger mt-3 mb-0" style="white-space: pre-wrap;">{{ logs }}</div>
                            {% endif %}
                            {% endif %}
                        </div>
                    </div>

                    <div class="card mt-3" id="scenarioEditorCard">
                        <div class="card-header d-flex justify-content-between align-items-center flex-wrap gap-2">
                            <strong>Scenario Editor</strong>
                            <div class="d-flex flex-wrap align-items-center gap-2">
                                <div id="hitlEntryButtonsWrap" class="d-flex align-items-center gap-2">
                                    {% if not is_builder_view %}
                                    <div class="btn-group btn-group-sm d-none" role="group" aria-label="HITL setup actions">
                                        <button class="btn btn-outline-primary" type="button" id="selectCoreVmBtn">Select CORE VM</button>
                                        <span class="d-inline-block" tabindex="0" id="configHitlBtnWrap">
                                            <button class="btn btn-primary" type="button" id="configHitlBtn" disabled>Config HITL</button>
                                        </span>
                                    </div>
                                    {% else %}
                                    <span class="badge text-bg-secondary">HITL settings managed by admin</span>
                                    {% endif %}
                                </div>
                            </div>
                        </div>
                        <div class="card-body">
                            <form id="editorForm" action="{{ url_for('save_xml') }}" method="post">
                                <input type="hidden" name="scenarios_json" id="scenarios_json">
                                <input type="hidden" name="active_index" id="active_index" value="0">
                                <input type="hidden" name="core_json" id="core_json">
                                <input type="hidden" name="project_key_hint" id="project_key_hint">
                                <input type="hidden" name="scenario_query" id="scenario_query_input">
                                <div id="editorRoot" class="{% if scenarios_active_tab == 'connection-setup' %}d-none{% endif %}"></div>
                            </form>
                        </div>
                    </div>
                    {% else %}
                    {# Connection Setup tab: keep required DOM hooks, but do not show the Base/Editor cards. #}
                    <div class="d-none" id="connectionSetupHiddenHooks">
                        <div id="hitlEntryButtonsWrap" class="d-flex align-items-center gap-2">
                            {% if not is_builder_view %}
                            <div class="btn-group btn-group-sm" role="group" aria-label="HITL setup actions">
                                <button class="btn btn-outline-primary" type="button" id="selectCoreVmBtn">Select CORE VM</button>
                                <span class="d-inline-block" tabindex="0" id="configHitlBtnWrap">
                                    <button class="btn btn-primary" type="button" id="configHitlBtn" disabled>Config HITL</button>
                                </span>
                            </div>
                            {% else %}
                            <span class="badge text-bg-secondary">HITL settings managed by admin</span>
                            {% endif %}
                        </div>
                        <form id="editorForm" action="{{ url_for('save_xml') }}" method="post">
                            <input type="hidden" name="scenarios_json" id="scenarios_json">
                            <input type="hidden" name="active_index" id="active_index" value="0">
                            <input type="hidden" name="core_json" id="core_json">
                            <input type="hidden" name="project_key_hint" id="project_key_hint">
                            <input type="hidden" name="scenario_query" id="scenario_query_input">
                            <div id="editorRoot" class="d-none"></div>
                        </form>
                    </div>
                    {% endif %}

                    <!-- Planning Workflow card visually removed but retained (d-none) for underlying JS functionality -->
                    <div class="card mt-3 d-none" id="planWorkflowCard">
                        <div class="card-header d-flex justify-content-between align-items-center">
                            <strong>Planning Workflow</strong>
                            <div id="planStatusBadge" class="badge text-bg-secondary">No Preview</div>
                        </div>
                        <div class="card-body">
                            <div class="d-flex flex-wrap gap-2 align-items-center mb-2">
                                <button class="btn btn-sm btn-outline-primary" type="button" id="planPreviewBtn" title="Generate full preview (routers, IPs, services)" disabled>Full Preview</button>
                                <!-- Run (Seed) workflow removed: deterministic seed input and run button eliminated -->
                                <!-- Single Full Preview button (above) is authoritative; secondary button and strict checkbox removed -->
                            </div>
                            <div class="small text-muted" id="planHint">Save XML and test CORE connection to enable planning.</div>
                            <pre id="planPreviewJson" class="small bg-light p-2 border rounded d-none" style="max-height:260px;overflow:auto;font-size:0.65rem;"></pre>
                            <div id="fullPreviewStructured" class="mt-2 d-none">
                                <div class="d-flex flex-wrap gap-2 align-items-center mb-2">
                                    <div class="btn-group btn-group-sm" role="group" aria-label="Full preview sections" id="fullPreviewSectionTabs"></div>
                                    <button type="button" class="btn btn-sm btn-outline-secondary" id="toggleRawFullPreviewBtn" title="Toggle raw JSON / structured view">Raw JSON</button>
                                    <!-- Copy seed button removed -->
                                </div>
                                <div id="fullPreviewSectionContent" class="border rounded p-2 bg-white small" style="max-height:300px; overflow:auto; font-size:.7rem;"></div>
                            </div>
                            <div id="planViolationsWrap" class="d-none mt-2">
                                <div class="alert alert-warning py-2 mb-0"><strong>Violations</strong><ul id="planViolationsList" class="mb-0 small"></ul></div>
                            </div>
                        </div>
                    </div>
                    <!-- Keep xml_path hidden input for existing JS; Preview button moved to shared Scenarios header -->
                    <input type="hidden" name="xml_path" id="xml_path">
                </div>
            </div>

        </div>
    </div>
    <!-- Run Progress Modal -->
<div class="modal fade" id="runProgressModal" tabindex="-1" aria-hidden="true">
    <div class="modal-dialog modal-dialog-centered modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title">Running CLI…</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <div class="d-flex justify-content-between align-items-center mb-2 small text-muted">
                    <div id="runProgressStatus">Starting…</div>
                    <div id="runProgressMeta"></div>
                </div>
                <div id="runProgressModeHint" class="mb-2 fw-bold text-warning d-none"></div>
                <div class="progress mb-2">
                    <div class="progress-bar progress-bar-striped progress-bar-animated" id="runProgressBar" style="width: 100%">Working…</div>
                </div>
                <div class="border rounded" style="max-height: 260px; overflow: auto;">
                    <pre class="m-0 p-2 small" id="runProgressLog" style="white-space: pre-wrap;"></pre>
                </div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" id="runProgressHideBtn" data-bs-dismiss="modal">Hide</button>
            </div>
        </div>
    </div>
</div>
{% set xml_preview_enabled = True %}
{% set xml_preview_text = xml_preview %}

<!-- CORE VM Selection Modal -->
<div class="modal fade" id="coreVmSelectModal" tabindex="-1" aria-hidden="true">
    <div class="modal-dialog modal-lg modal-dialog-scrollable">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title">Select CORE VM</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <p class="small text-muted">Complete Steps 1 and 2 to choose a Proxmox resource and CORE VM with credentials.</p>
                <div id="coreVmSelectContainer" class="d-flex flex-column gap-3"></div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-outline-secondary" data-bs-dismiss="modal">Cancel</button>
                <button type="button" class="btn btn-primary" id="coreVmModalSaveBtn">Verify &amp; Save</button>
            </div>
        </div>
    </div>
</div>
<!-- Config HITL Modal (Steps 3 & 4) -->
<div class="modal fade" id="externalIfxModal" tabindex="-1" aria-hidden="true">
    <div class="modal-dialog modal-lg modal-dialog-scrollable">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title">Config HITL</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <p class="small text-muted">Configure Steps 3 &amp; 4: enable HITL interfaces and map participant VMs.</p>
                <div id="externalIfxBusyNotice" class="alert alert-info small d-none" role="status" aria-live="polite"></div>
                <div id="externalIfxHitlContainer" class="d-flex flex-column gap-3"></div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-outline-secondary" data-bs-dismiss="modal">Cancel</button>
                <button type="button" class="btn btn-primary" id="externalIfxModalSaveBtn">Validate &amp; Save</button>
            </div>
        </div>
    </div>
</div>
<!-- Proxmox Assignment Modal -->
<div class="modal fade" id="proxmoxAssignModal" tabindex="-1" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title">Assign Proxmox Resource</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <div class="alert alert-info small" id="proxmoxAssignHint" style="display:none;"></div>
                <form id="proxmoxAssignForm">
                    <div class="mb-3">
                        <label for="proxmoxUrl" class="form-label">URL</label>
                        <input type="url" class="form-control" id="proxmoxUrl" placeholder="https://proxmox.example.local" autocomplete="url" required>
                        <div class="form-text">Provide the base URL to the Proxmox API (https://host.domain).</div>
                    </div>
                    <div class="mb-3">
                        <label for="proxmoxPort" class="form-label">Port</label>
                        <input type="number" class="form-control" id="proxmoxPort" placeholder="8006" min="1" max="65535" autocomplete="on" required>
                    </div>
                    <div class="form-check form-switch mb-3">
                        <input class="form-check-input" type="checkbox" role="switch" id="proxmoxVerifySsl" checked>
                        <label class="form-check-label" for="proxmoxVerifySsl">Enforce SSL certificate verification</label>
                        <div class="form-text">Uncheck when connecting to Proxmox with self-signed or invalid certificates.</div>
                    </div>
                    <div class="mb-3">
                        <label for="proxmoxUsername" class="form-label">Username</label>
                        <input type="text" class="form-control" id="proxmoxUsername" placeholder="root@pam" autocomplete="username" required>
                    </div>
                    <div class="mb-3">
                        <label for="proxmoxPassword" class="form-label">Password</label>
                        <input type="password" class="form-control" id="proxmoxPassword" placeholder="••••••" autocomplete="current-password">
                    </div>
                    <div class="form-check form-switch mb-3">
                        <input class="form-check-input" type="checkbox" id="proxmoxRememberCreds" checked>
                        <label class="form-check-label" for="proxmoxRememberCreds">Save credentials after validation</label>
                        <div class="form-text">Disable to validate against Proxmox without storing secrets in the vault.</div>
                    </div>
                </form>
                <div class="alert alert-danger d-none" id="proxmoxAssignError"></div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-outline-secondary" data-bs-dismiss="modal">Cancel</button>
                <button type="button" class="btn btn-primary" id="proxmoxAssignSave">Validate &amp; Save</button>
            </div>
        </div>
    </div>
</div>
<!-- CORE Connection Modal -->
<div class="modal fade" id="coreConnectionModal" tabindex="-1" aria-hidden="true">
    <div class="modal-dialog modal-xl">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title">CORE Connection</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <div class="alert alert-info small d-none" id="coreConnectionHint" style="white-space: pre-wrap;"></div>
                <form id="coreConnectionForm" class="needs-validation" novalidate>
                    <div class="row g-2">
                        <div class="col-md-8">
                            <div class="mb-3">
                                <label for="coreSshHost" class="form-label">SSH Host</label>
                                <input type="text" class="form-control" id="coreSshHost" placeholder="Defaults to gRPC host" data-hitl-core-field="ssh_host" autocomplete="off">
                            </div>
                        </div>
                        <div class="col-md-4">
                            <div class="mb-3">
                                <label for="coreSshPort" class="form-label">SSH Port</label>
                                <input type="number" class="form-control" id="coreSshPort" min="1" max="65535" data-hitl-core-field="ssh_port" autocomplete="off">
                            </div>
                        </div>
                    </div>
                    <div class="row g-2">
                        <div class="col-md-6">
                            <div class="mb-3">
                                <label for="coreSshUsername" class="form-label">SSH Username</label>
                                <input type="text" class="form-control" id="coreSshUsername" data-hitl-core-field="ssh_username" autocomplete="username" required>
                            </div>
                        </div>
                        <div class="col-md-6">
                            <div class="mb-3">
                                <label for="coreSshPassword" class="form-label">SSH Password</label>
                                <input type="password" class="form-control" id="coreSshPassword" data-hitl-core-field="ssh_password" autocomplete="current-password">
                                <div class="form-text">Passwords are stored in the secure credential vault after a successful test.</div>
                            </div>
                        </div>
                    </div>
                    <div class="form-check form-switch mb-3">
                        <input class="form-check-input" type="checkbox" id="coreRememberCreds" checked>
                        <label class="form-check-label" for="coreRememberCreds">Save username &amp; password after validation</label>
                        <div class="form-text">Disable to require manual entry each time; secrets remain only in the vault.</div>
                    </div>
                    <div class="form-check form-switch mb-3">
                        <input class="form-check-input" type="checkbox" id="coreAutoStartDaemon">
                        <label class="form-check-label" for="coreAutoStartDaemon">Auto-start core-daemon if not running</label>
                        <div class="form-text">Runs 'sudo core-daemon -d' on the CORE VM during connection validation.</div>
                    </div>
                    <div class="form-check form-switch mb-3">
                        <input class="form-check-input" type="checkbox" id="coreInstallCustomServices">
                        <label class="form-check-label" for="coreInstallCustomServices">Install custom services</label>
                        <div class="form-text">Copies services from <code>on_core_machine/custom_services</code> to the CORE VM, restarts core-daemon, and verifies they load.</div>
                    </div>

                    <div class="row g-2 mb-3">
                        <div class="col-12 col-md-6">
                            <div class="form-check form-switch">
                                <input class="form-check-input" type="checkbox" role="switch" id="coreAdvFixDockerDaemon">
                                <label class="form-check-label" for="coreAdvFixDockerDaemon">Fix Docker daemon for CORE (disable default bridge + iptables)</label>
                            </div>
                        </div>
                        <div class="col-12 col-md-6">
                            <div class="form-check form-switch">
                                <input class="form-check-input" type="checkbox" role="switch" id="coreAdvRunCoreCleanup">
                                <label class="form-check-label" for="coreAdvRunCoreCleanup">Run core-cleanup</label>
                            </div>
                        </div>
                        <div class="col-12 col-md-6">
                            <div class="form-check form-switch">
                                <input class="form-check-input" type="checkbox" role="switch" id="coreAdvCheckCoreVersion">
                                <label class="form-check-label" for="coreAdvCheckCoreVersion">Check CORE version is 9.2.1</label>
                            </div>
                        </div>
                        <div class="col-12 col-md-6">
                            <div class="form-check form-switch">
                                <input class="form-check-input" type="checkbox" role="switch" id="coreAdvRestartCoreDaemon">
                                <label class="form-check-label" for="coreAdvRestartCoreDaemon">Restart core-daemon</label>
                            </div>
                        </div>
                        <div class="col-12 col-md-6">
                            <div class="form-check form-switch">
                                <input class="form-check-input" type="checkbox" role="switch" id="coreAdvAutoKillSessions">
                                <label class="form-check-label" for="coreAdvAutoKillSessions">Auto-kill any running sessions</label>
                            </div>
                        </div>
                    </div>
                    <div class="mt-4">
                        <button class="btn btn-link p-0" type="button" data-bs-toggle="collapse" data-bs-target="#coreConnAdvanced" aria-expanded="false" aria-controls="coreConnAdvanced">Advanced</button>
                        <div class="collapse" id="coreConnAdvanced">
                            <div class="border rounded p-2 mt-2">
                                <div class="small text-muted mb-2">Usually you don’t need to change these.</div>
                                <div class="mb-3">
                                    <label for="coreGrpcHost" class="form-label">gRPC Host</label>
                                    <input type="text" class="form-control" id="coreGrpcHost" placeholder="core-host.example" data-hitl-core-field="grpc_host" autocomplete="off" required>
                                </div>
                                <div class="mb-1">
                                    <label for="coreGrpcPort" class="form-label">gRPC Port</label>
                                    <input type="number" class="form-control" id="coreGrpcPort" min="1" max="65535" data-hitl-core-field="grpc_port" autocomplete="off" required>
                                </div>
                                <div class="mb-1">
                                    <label for="coreVenvBin" class="form-label">Remote CORE venv bin</label>
                                    <input type="text" class="form-control" id="coreVenvBin" placeholder="/opt/core/venv/bin" data-hitl-core-field="venv_bin" autocomplete="off">
                                    <div class="form-text">Python commands run over SSH will use this directory (include the <code>/bin</code> path inside the CORE virtualenv).</div>
                                </div>
                                <div class="d-flex align-items-center gap-2 mb-1">
                                    <button type="button" class="btn btn-outline-secondary btn-sm" id="coreTestVenvBtn">Test Venv</button>
                                    <div id="coreVenvTestStatus" class="form-text mb-0 text-muted">Not tested.</div>
                                </div>
                            </div>
                        </div>
                    </div>
                </form>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-outline-secondary" data-bs-dismiss="modal">Cancel</button>
                <button type="button" class="btn btn-primary" id="coreConnectionSaveBtn">Save &amp; Validate</button>
            </div>
        </div>
    </div>
</div>

<!-- CORE Nav Blocked Modal (missing Proxmox setup) -->
<div class="modal fade" id="coreNavBlockedModal" tabindex="-1" aria-hidden="true">
    <div class="modal-dialog modal-dialog-centered">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title">CORE</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                You must first select a CORE VM in the Scenarios Page to view this page.
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
            </div>
        </div>
    </div>
</div>
{% include 'partials/dock.html' %}

<!-- Toast container (used only for explicit, forced prompts). -->
<div id="coretgToastContainer" class="toast-container position-fixed top-0 end-0 p-3" style="z-index: 2000;"></div>

<!-- Toast helper: keep legacy behavior (no toasts) unless explicitly forced. -->
<script>
    function showToast(message, opts){
        try {
            const options = (opts && typeof opts === 'object') ? opts : {};
            if(options.force !== true){
                return null;
            }
            if(!window.bootstrap || !bootstrap.Toast){
                // Best-effort fallback.
                try { console.log(String(message || '')); } catch (e) {}
                return null;
            }
            const container = document.getElementById('coretgToastContainer');
            if(!container){
                return null;
            }
            const el = document.createElement('div');
            el.className = 'toast';
            el.setAttribute('role','alert');
            el.setAttribute('aria-live','assertive');
            el.setAttribute('aria-atomic','true');
            el.innerHTML = `
              <div class="toast-header">
                <strong class="me-auto">${String(options.title || 'Notice')}</strong>
                <button type="button" class="btn-close" data-bs-dismiss="toast" aria-label="Close"></button>
              </div>
              <div class="toast-body" style="white-space: pre-wrap;">${String(message || '')}</div>
            `;
            container.appendChild(el);
            const inst = new bootstrap.Toast(el, { autohide: options.autohide === true, delay: Number(options.delay) || 5000 });
            el.addEventListener('hidden.bs.toast', ()=>{ try { el.remove(); } catch(e){} });
            inst.show();
            return inst;
        } catch (e) {
            return null;
        }
    }
</script>

<!-- Graph libraries for Full Preview Modal -->
<script src="https://cdn.jsdelivr.net/npm/d3@7/dist/d3.min.js"></script>
<script src="{{ url_for('static', filename='core_graph.js') }}"></script>

<!-- Toast container removed (requested) -->
<!-- Verify Setup Modal -->
<div class="modal fade" id="verifySetupModal" tabindex="-1" aria-hidden="true">
    <div class="modal-dialog modal-dialog-centered modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" id="verifySetupTitle">Verify</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <div class="border rounded p-3 bg-body-tertiary" id="verifySetupProgressWrap">
                    <div class="d-flex align-items-center gap-2">
                        <div class="spinner-border spinner-border-sm text-primary" role="status" aria-hidden="true" id="verifySetupSpinner"></div>
                        <div class="flex-grow-1">
                            <div class="fw-semibold" id="verifySetupStatus">Preparing…</div>
                            <div class="small text-muted" id="verifySetupMeta"></div>
                        </div>
                        <span class="badge text-bg-secondary" id="verifySetupResultBadge">Running</span>
                    </div>
                    <pre class="form-control bg-dark text-white border-0 mt-3 small" id="verifySetupLog" style="height: 190px; overflow:auto; font-family: SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace;"></pre>
                </div>
                <div class="alert d-none mt-3" id="verifySetupFinalAlert" role="alert"></div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal" id="verifySetupCloseBtn">Close</button>
            </div>
        </div>
    </div>
</div>

<!-- Success Modal -->
<div class="modal fade" id="runSuccessModal" tabindex="-1" aria-hidden="true">
    <div class="modal-dialog modal-dialog-centered">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title">Run Completed</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <p class="mb-1" id="runSuccessBody">Generation complete.</p>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
            </div>
        </div>
    </div>
</div>
<!-- Execute Confirm Modal -->
<div class="modal fade" id="executeConfirmModal" tabindex="-1" aria-hidden="true">
    <div class="modal-dialog modal-dialog-centered">
        <div class="modal-content">
            <div class="modal-header">
                <div>
                    <h5 class="modal-title mb-0">Execute Scenario</h5>
                    <div class="small text-muted" id="executePhaseHeader">Phase: —</div>
                </div>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <p class="mb-3" id="executeConfirmMessage">Execute this scenario now?</p>
                <div class="alert alert-warning small d-none" id="executeConfirmAlert"></div>
                <div class="border rounded-3 p-3 bg-body-tertiary mb-3">
                    <div class="d-flex flex-wrap align-items-center justify-content-between gap-3">
                        <div class="flex-grow-1"></div>
                    </div>
                    <div class="d-flex flex-wrap align-items-center justify-content-between gap-3 mt-3 d-none" id="executeCoreNotConfiguredRow">
                        <div class="flex-grow-1">
                            <div class="text-uppercase small text-muted fw-semibold">Remote CORE Connection</div>
                            <div class="small text-danger" id="executeCoreNotConfiguredStatus">CORE VM not configured.</div>
                        </div>
                        <button type="button" class="btn btn-outline-primary btn-sm" id="executeSelectCoreVmBtn">Select CORE VM</button>
                    </div>
                    <div class="d-flex flex-wrap align-items-center justify-content-between gap-3 mt-3 d-none" id="executeCoreTestRow">
                        <div class="flex-grow-1">
                            <div class="text-uppercase small text-muted fw-semibold">Remote CORE Connection</div>
                            <div class="small text-muted" id="executeCoreStatus">Connection status unknown.</div>
                        </div>
                        <div class="d-flex align-items-center gap-2">
                            <div class="form-check form-check-inline mb-0">
                                <input class="form-check-input" type="checkbox" id="executeAdvStartCoreDaemon">
                                <label class="form-check-label small" for="executeAdvStartCoreDaemon">Start core-daemon if stopped</label>
                            </div>
                            <button type="button" class="btn btn-outline-primary btn-sm" id="executeCoreTestBtn">Test Connection</button>
                        </div>
                    </div>
                    <div class="form-check form-switch mt-3 d-none" id="executePushUpdateToggleWrap">
                        <input class="form-check-input" type="checkbox" role="switch" id="executeConfirmPushUpdateToggle">
                        <label class="form-check-label fw-semibold" for="executeConfirmPushUpdateToggle">Push updated backend (may take several minutes)</label>
                        <div class="form-text" id="executeConfirmPushUpdateHelp">Sync the current repository snapshot to your CORE VM before execution.</div>
                    </div>
                </div>

                <details class="border rounded-3 p-3 bg-body-tertiary mb-3 d-none" id="executeAdvancedWrap">
                    <summary class="fw-semibold">Advanced</summary>
                    <div class="small text-muted mt-2">Applies to remote execution only.</div>
                    <div class="mt-3 d-grid gap-2">
                        <div class="form-check">
                            <input class="form-check-input" type="checkbox" id="executeAdvUploadOnlyInjectedArtifacts" checked>
                            <label class="form-check-label" for="executeAdvUploadOnlyInjectedArtifacts">Upload only injected artifacts (inject_files allowlist)</label>
                            <div class="form-text">Uploads only the plan's <span class="font-monospace">mount_dir</span> (typically <span class="font-monospace">.../injected</span>) instead of the full <span class="font-monospace">artifacts_dir</span>.</div>
                        </div>
                        <div class="form-check">
                            <input class="form-check-input" type="checkbox" id="executeAdvFixDockerDaemon">
                            <label class="form-check-label" for="executeAdvFixDockerDaemon">Fix Docker daemon for CORE (disable default bridge + iptables)</label>
                        </div>
                        <div class="form-check">
                            <input class="form-check-input" type="checkbox" id="executeAdvRunCoreCleanup" checked>
                            <label class="form-check-label" for="executeAdvRunCoreCleanup">Run core-cleanup</label>
                        </div>
                        <div class="form-check">
                            <input class="form-check-input" type="checkbox" id="executeAdvDockerCleanupBeforeRun" checked>
                            <label class="form-check-label" for="executeAdvDockerCleanupBeforeRun">Remove old Docker containers/images before run</label>
                        </div>
                        <div class="form-check">
                            <input class="form-check-input" type="checkbox" id="executeAdvDockerNukeAll">
                            <label class="form-check-label" for="executeAdvDockerNukeAll">Delete all docker containers (use with caution!)</label>
                            <div class="form-text">This will stop and remove all containers (does not remove images).</div>
                        </div>
                        <div class="form-check">
                            <input class="form-check-input" type="checkbox" id="executeAdvCheckCoreVersion">
                            <label class="form-check-label" for="executeAdvCheckCoreVersion">Check CORE version is 9.2.1</label>
                        </div>
                        <div class="form-check">
                            <input class="form-check-input" type="checkbox" id="executeAdvRestartCoreDaemon">
                            <label class="form-check-label" for="executeAdvRestartCoreDaemon">Restart core-daemon</label>
                        </div>
                        <div class="form-check">
                            <input class="form-check-input" type="checkbox" id="executeAdvAutoKillSessions">
                            <label class="form-check-label" for="executeAdvAutoKillSessions">Auto-kill any running sessions</label>
                        </div>
                    </div>
                </details>

                <div class="border rounded p-3 mt-3 bg-body-tertiary d-none" id="executeProgressWrap">
                    <div class="d-flex align-items-center gap-2">
                        <div class="spinner-border spinner-border-sm text-primary" role="status" aria-hidden="true" id="executeProgressSpinner"></div>
                        <div class="flex-grow-1">
                            <div class="fw-semibold" id="executeProgressStatus">Preparing…</div>
                            <div class="small text-muted" id="executeProgressMeta"></div>
                        </div>
                        <button type="button" class="btn btn-sm btn-outline-danger d-none" id="executeProgressCancelBtn">Cancel run</button>
                        <button type="button" class="btn btn-sm btn-outline-secondary d-none" id="executeProgressPopoutBtn">Open run logs</button>
                    </div>
                    <div class="progress mt-3" style="height: 12px;">
                        <div class="progress-bar progress-bar-striped" id="executeProgressBar" role="progressbar" style="width: 0%" aria-valuemin="0" aria-valuemax="100">0%</div>
                    </div>
                    <pre class="form-control bg-dark text-white border-0 mt-3 small" id="executeProgressLog" style="height: 190px; overflow:auto; font-family: SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace;"></pre>
                </div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-outline-secondary" data-bs-dismiss="modal" id="executeConfirmCancelBtn">Cancel</button>
                <button type="button" class="btn btn-primary" id="executeConfirmRunBtn">Execute</button>
            </div>
        </div>
    </div>
</div>
<!-- Full Preview Modal -->
<div class="modal fade" id="fullPreviewModal" tabindex="-1" aria-hidden="true">
    <div class="modal-dialog modal-fullscreen-lg-down modal-xl modal-dialog-scrollable">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title">Full Preview <span class="text-muted small" id="fpModalSeed"></span></h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <div class="row g-3">
                    <div class="col-lg-8">
                        <div class="card" id="fpGraphCard">
                            <div class="card-header d-flex justify-content-between align-items-center">
                                <strong>Graph</strong>
                                <div class="d-flex align-items-center gap-2">
                                    <div class="form-check form-switch form-switch-sm mb-0">
                                        <input class="form-check-input" type="checkbox" role="switch" id="fpGraphLabelsToggle">
                                        <label class="form-check-label small" for="fpGraphLabelsToggle">Show labels</label>
                                    </div>
                                    <div class="btn-group btn-group-sm">
                                        <button class="btn btn-outline-secondary" type="button" id="fpGraphResetBtn">Reset</button>
                                        <button class="btn btn-outline-secondary" type="button" id="fpGraphPngBtn">PNG</button>
                                        <button class="btn btn-outline-secondary" type="button" id="fpOpenStandaloneBtn">Open Page</button>
                                    </div>
                                </div>
                            </div>
                            <div class="card-body p-2">
                                <div id="fpGraph" style="height:480px; position:relative; background:#fafafa; border:1px solid #e0e0e0; border-radius:4px; overflow:hidden;">
                                    <div class="position-absolute top-50 start-50 translate-middle text-muted" id="fpGraphLoading">Rendering...</div>
                                </div>
                                <div class="form-text mt-1">Drag to reposition nodes. Hover for details. PNG exports current view.</div>
                            </div>
                        </div>
                        <div class="card mt-3">
                            <div class="card-header d-flex justify-content-between align-items-center">
                                <strong>Routers</strong>
                                <button class="btn btn-sm btn-outline-secondary" type="button" data-preview-collapse="fpRoutersWrap" data-label-collapse="Collapse" data-label-expand="Expand">Collapse</button>
                            </div>
                            <div class="card-body collapse p-2" id="fpRoutersWrap"><div class="text-muted small">No data</div></div>
                        </div>
                        <div class="card mt-3">
                            <div class="card-header d-flex justify-content-between align-items-center">
                                <strong>Hosts</strong>
                                <button class="btn btn-sm btn-outline-secondary" type="button" data-preview-collapse="fpHostsWrap" data-label-collapse="Collapse" data-label-expand="Expand">Collapse</button>
                            </div>
                            <div class="card-body collapse p-2" id="fpHostsWrap"><div class="text-muted small">No data</div></div>
                        </div>
                        <div class="card mt-3">
                            <div class="card-header d-flex justify-content-between align-items-center">
                                <strong>Switches</strong>
                                <button class="btn btn-sm btn-outline-secondary" type="button" data-preview-collapse="fpSwitchesWrap" data-label-collapse="Collapse" data-label-expand="Expand">Collapse</button>
                            </div>
                            <div class="card-body collapse p-2" id="fpSwitchesWrap"><div class="text-muted small">No data</div></div>
                        </div>
                        <div class="card mt-3">
                            <div class="card-header d-flex justify-content-between align-items-center">
                                <strong>Node Sections</strong>
                                <button class="btn btn-sm btn-outline-secondary" type="button" data-preview-collapse="fpNodeSectionsWrap" data-label-collapse="Collapse" data-label-expand="Expand">Collapse</button>
                            </div>
                            <div class="card-body collapse p-2" style="max-height:240px;overflow:auto;" id="fpNodeSectionsWrap"><div class="text-muted small">No data</div></div>
                        </div>
                    </div>
                    <div class="col-lg-4">
                        <div class="card mb-3">
                            <div class="card-header d-flex justify-content-between align-items-center">
                                <strong>Counts</strong>
                                <button class="btn btn-sm btn-outline-secondary" type="button" data-preview-collapse="fpCounts" data-label-collapse="Collapse" data-label-expand="Expand">Collapse</button>
                            </div>
                            <div class="card-body collapse p-2" id="fpCounts"></div>
                        </div>
                        <div class="card mb-3">
                            <div class="card-header d-flex justify-content-between align-items-center">
                                <strong>R2R Policy</strong>
                                <button class="btn btn-sm btn-outline-secondary" type="button" data-preview-collapse="fpR2RPolicyBody" data-label-collapse="Collapse" data-label-expand="Expand">Collapse</button>
                            </div>
                            <div class="card-body collapse p-2" id="fpR2RPolicyBody"><pre class="small mb-0" id="fpR2RPolicy" style="max-height:160px; overflow:auto;"></pre></div>
                        </div>
                        <div class="card mb-3">
                            <div class="card-header d-flex justify-content-between align-items-center">
                                <strong>R2S Policy</strong>
                                <button class="btn btn-sm btn-outline-secondary" type="button" data-preview-collapse="fpR2SPolicyBody" data-label-collapse="Collapse" data-label-expand="Expand">Collapse</button>
                            </div>
                            <div class="card-body collapse p-2" id="fpR2SPolicyBody"><pre class="small mb-0" id="fpR2SPolicy" style="max-height:160px; overflow:auto;"></pre></div>
                        </div>
                        <div class="card mb-3">
                            <div class="card-header d-flex justify-content-between align-items-center">
                                <strong>Segmentation Plan</strong>
                                <button class="btn btn-sm btn-outline-secondary" type="button" data-preview-collapse="fpSegmentationCardBody" data-label-collapse="Collapse" data-label-expand="Expand">Collapse</button>
                            </div>
                            <div class="card-body collapse p-2" id="fpSegmentationCardBody">
                                <div class="small mb-2" id="fpSegmentationTypes" hidden></div>
                                <pre class="small mb-0" id="fpSegmentation" style="max-height:220px; overflow:auto;"></pre>
                                <div class="mt-2" id="fpSegmentationRuntimeWrap" hidden>
                                    <h6 class="small text-uppercase text-muted mb-1">Runtime Segmentation Summary (segmentation_summary.json)</h6>
                                    <pre class="small bg-light p-2 mb-0" id="fpSegmentationRuntime" style="max-height:220px; overflow:auto;"></pre>
                                </div>
                                <div class="small text-muted mt-2" id="fpSegmentationHash" hidden></div>
                            </div>
                        </div>
                        <div class="card mb-3">
                            <div class="card-header d-flex justify-content-between align-items-center">
                                <strong>Router Plan</strong>
                                <button class="btn btn-sm btn-outline-secondary" type="button" data-preview-collapse="fpRouterPlanBody" data-label-collapse="Collapse" data-label-expand="Expand">Collapse</button>
                            </div>
                            <div class="card-body collapse p-2" id="fpRouterPlanBody"><pre class="small mb-0" id="fpRouterPlan" style="max-height:160px; overflow:auto;"></pre></div>
                        </div>
                        <div class="card mb-3">
                            <div class="card-header d-flex justify-content-between align-items-center">
                                <strong>Services Plan</strong>
                                <button class="btn btn-sm btn-outline-secondary" type="button" data-preview-collapse="fpServicesPlanBody" data-label-collapse="Collapse" data-label-expand="Expand">Collapse</button>
                            </div>
                            <div class="card-body collapse p-2" id="fpServicesPlanBody"><pre class="small mb-0" id="fpServicesPlan" style="max-height:160px; overflow:auto;"></pre></div>
                        </div>
                        <div class="card mb-3">
                            <div class="card-header d-flex justify-content-between align-items-center">
                                <strong>Vulnerabilities Plan</strong>
                                <button class="btn btn-sm btn-outline-secondary" type="button" data-preview-collapse="fpVulnPlanBody" data-label-collapse="Collapse" data-label-expand="Expand">Collapse</button>
                            </div>
                            <div class="card-body collapse p-2" id="fpVulnPlanBody"><pre class="small mb-0" id="fpVulnPlan" style="max-height:160px; overflow:auto;"></pre></div>
                        </div>
                        <div class="card mb-3">
                            <div class="card-header d-flex justify-content-between align-items-center">
                                <strong>Traffic Plan</strong>
                                <button class="btn btn-sm btn-outline-secondary" type="button" data-preview-collapse="fpTrafficPlanBody" data-label-collapse="Collapse" data-label-expand="Expand">Collapse</button>
                            </div>
                            <div class="card-body collapse p-2" id="fpTrafficPlanBody"><pre class="small mb-0" id="fpTrafficPlan" style="max-height:160px; overflow:auto;"></pre></div>
                        </div>
                        <!-- Removed History, Role Distribution, Service Distribution cards -->
                        <!-- Drift card removed (no approved plan concept) -->
                    </div>
                </div>
            </div>
            <div class="modal-footer d-flex justify-content-between align-items-center">
                <div class="d-flex gap-2">
                    <button class="btn btn-warning" type="button" id="fpExecuteBtn" title="Execute scenario now">Execute</button>
                </div>
                <button class="btn btn-secondary" data-bs-dismiss="modal" type="button">Close</button>
            </div>
        </div>
    </div>
</div>
<!-- Planning Semantics Modal -->
<div class="modal fade" id="planningSemanticsModal" tabindex="-1" aria-hidden="true">
    <div class="modal-dialog modal-lg modal-dialog-scrollable">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" data-i18n="modal.planningSemantics.title">Planning Semantics</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <div class="spinner-border text-primary d-none" id="planningSemanticsSpinner" role="status"><span class="visually-hidden">Loading...</span></div>
                <div id="planningSemanticsContent" class="small"></div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal" data-i18n="common.close">Close</button>
            </div>
        </div>
    </div>
</div>
{% endblock %}
{% block extra_scripts %}
<script id="payload-data" type="application/json">{{ payload | tojson }}</script>
<script id="current-user-meta" type="application/json">{{ {'username': current_user.username, 'role': current_user.role}|tojson }}</script>
<script>
// --- BEGIN PAGE JS ---
const payloadDataEl = document.getElementById('payload-data');
let initialPayload = null;
try {
    initialPayload = JSON.parse(payloadDataEl?.textContent || 'null');
} catch (err) {
    console.warn('Failed to parse payload data', err);
    initialPayload = null;
}
const currentUserDataEl = document.getElementById('current-user-meta');
let currentUserMeta = null;
try {
    currentUserMeta = JSON.parse(currentUserDataEl?.textContent || 'null');
} catch (e) {
    currentUserMeta = null;
}
const CORETG_USERNAME = (currentUserMeta && typeof currentUserMeta.username === 'string') ? currentUserMeta.username : '';
const CORETG_USER_ROLE = (currentUserMeta && typeof currentUserMeta.role === 'string') ? currentUserMeta.role : '';
window.CORETG_USERNAME = CORETG_USERNAME;
window.CORETG_USER_ROLE = CORETG_USER_ROLE;
const IS_BUILDER_VIEW = (window.CORETG_VIEW_MODE || '') === 'builder';
const IS_ADMIN_USER = (CORETG_USER_ROLE || '') === 'admin';
const SCENARIOS_ACTIVE_TAB = '{{ scenarios_active_tab }}';
window.CORETG_SCENARIOS_ACTIVE_TAB = SCENARIOS_ACTIVE_TAB;
// Local editor state is only trusted for admins.
// Builder/participant roles must rely on server-restricted scenario lists.
const USE_LOCAL_EDITOR_STATE = IS_ADMIN_USER && !IS_BUILDER_VIEW;
// Builder view is read-only; never write local snapshots from it.
const ALLOW_LOCAL_EDITOR_PERSISTENCE = IS_ADMIN_USER && !IS_BUILDER_VIEW;
const BUILDER_BACKEND_UNAVAILABLE_MESSAGE = 'Backend temporarily unavailable. Please ask an admin.';
window.IS_BUILDER_VIEW = IS_BUILDER_VIEW;
const DEFAULT_INTERNAL_BRIDGE_NAME = 'corebridge';
function computeInternalBridgeName(usernameValue) {
    const base = (usernameValue || window.CORETG_USERNAME || '').toString().trim();
    if (!base) return DEFAULT_INTERNAL_BRIDGE_NAME;
    let normalized = base.replace(/[^A-Za-z0-9]+/g, '-').replace(/-+/g, '-').replace(/^-|-$/g, '');
    if (!normalized) {
        normalized = base.replace(/\s+/g, '').replace(/[^A-Za-z0-9]/g, '');
    }
    if (!normalized) return DEFAULT_INTERNAL_BRIDGE_NAME;
    normalized = normalized.toLowerCase();
    let truncated = normalized.slice(0, 10);
    if (!truncated) return DEFAULT_INTERNAL_BRIDGE_NAME;
    let trimmed = truncated.replace(/[-_]+$/g, '');
    if (!trimmed) {
        trimmed = truncated.replace(/[-_]+/g, '');
    }
    if (!trimmed) return DEFAULT_INTERNAL_BRIDGE_NAME;
    return trimmed;
}
// Prevent TDZ: define catalog early on window
window.VULN_CATALOG = window.VULN_CATALOG || { types: [], vectors: [], items: [] };
// Prevent TDZ: define catalog early on window
window.VULN_CATALOG = window.VULN_CATALOG || { types: [], vectors: [], items: [] };
function setupPreviewCollapsers(){
    const toggles = document.querySelectorAll('[data-preview-collapse]');
    toggles.forEach(btn => {
        if(btn.dataset.collapserBound) return;
        const targetId = btn.getAttribute('data-preview-collapse');
        const target = document.getElementById(targetId);
        if(!target) return;
        btn.dataset.collapserBound = '1';
        const collapseLabel = btn.dataset.labelCollapse || 'Collapse';
        const expandLabel = btn.dataset.labelExpand || 'Expand';
        const hasBootstrap = !!(window.bootstrap && bootstrap.Collapse);
        const inPreviewDialog = !!(target && target.closest && target.closest('#fullPreviewModal'));
        if(hasBootstrap){
            const instance = bootstrap.Collapse.getOrCreateInstance(target, { toggle: false });
            const updateLabel = () => {
                btn.textContent = target.classList.contains('show') ? collapseLabel : expandLabel;
            };
            target.addEventListener('shown.bs.collapse', updateLabel);
            target.addEventListener('hidden.bs.collapse', updateLabel);
            // Default behavior:
            // - Inside the Full Preview modal, start collapsed.
            // - Elsewhere, preserve prior behavior (auto-expand).
            if(inPreviewDialog){
                try { instance.hide(); } catch(e){}
            } else {
                if(!target.classList.contains('show')){
                    instance.show();
                }
            }
            updateLabel();
            btn.addEventListener('click', ev => {
                ev.preventDefault();
                if(target.classList.contains('show')){
                    instance.hide();
                } else {
                    instance.show();
                }
            });
        } else {
            const updateLabel = () => {
                btn.textContent = target.classList.contains('d-none') ? expandLabel : collapseLabel;
            };
            if(inPreviewDialog){
                target.classList.add('d-none');
            } else {
                target.classList.remove('d-none');
            }
            updateLabel();
            btn.addEventListener('click', ev => {
                ev.preventDefault();
                target.classList.toggle('d-none');
                updateLabel();
            });
        }
    });
}
window.setupPreviewCollapsers = setupPreviewCollapsers;
if(document.readyState === 'loading'){ document.addEventListener('DOMContentLoaded', () => setupPreviewCollapsers()); }
else { setupPreviewCollapsers(); }
const DENSITY_COUNT_MIN = 1;
const DENSITY_COUNT_MAX = 5000;
const NODE_COUNT_MIN = 1;
const NODE_COUNT_MAX = 5000;
const initialScenarioQuery = (initialPayload && typeof initialPayload.scenario_query === 'string')
    ? initialPayload.scenario_query.trim()
    : '';
const LEGACY_EDITOR_STATE_STORAGE_KEY = 'coretg_editor_state';
const PROJECT_STATE_STORAGE_KEY = 'coretg_project_state_map_v1';
const PROJECT_ACTIVE_IDX_STORAGE_KEY = 'coretg_active_idx_map_v1';
const LAST_PROJECT_KEY_STORAGE_KEY = 'coretg_last_project_key';
const DEFAULT_PROJECT_KEY = '__default_project__';
const DELETED_SCENARIO_IDS_STORAGE_KEY = 'coretg_deleted_scenario_ids_v1';
const DELETED_SCENARIO_NAME_KEYS_STORAGE_KEY = 'coretg_deleted_scenario_name_keys_v1';

// HITL attachment constants must be defined early because the editor can merge
// persisted snapshots during initial load, and that merge path calls
// normalizeHitlAttachment()/prettyHitlAttachment().
const HITL_ATTACHMENT_CHOICES = [
    { value: 'existing_router', label: 'Existing Router' },
    { value: 'existing_switch', label: 'Existing Switch' },
    { value: 'new_router', label: 'New Router' },
];
const HITL_ATTACHMENT_ALLOWED = new Set(HITL_ATTACHMENT_CHOICES.map(opt => opt.value));
const DEFAULT_HITL_ATTACHMENT = 'existing_router';

const NULLISH_TEXT_SENTINELS = new Set(['none', 'null', 'undefined', 'no error', 'ok', 'success']);

function readLastProjectKeyFromStorage() {
    try {
        const raw = localStorage.getItem(LAST_PROJECT_KEY_STORAGE_KEY);
        return raw ? raw.trim() : '';
    } catch (err) {
        return '';
    }
}

function readJsonFromLocalStorage(key, fallback) {
    try {
        const raw = localStorage.getItem(key);
        if (raw === null || raw === undefined) return fallback;
        const parsed = JSON.parse(raw);
        return (parsed && typeof parsed === 'object') ? parsed : fallback;
    } catch (err) {
        return fallback;
    }
}

function writeJsonToLocalStorage(key, value) {
    try {
        localStorage.setItem(key, JSON.stringify(value));
    } catch (err) {}
}

function readStringSetFromLocalStorage(key) {
    try {
        const raw = localStorage.getItem(key);
        if (!raw) return new Set();
        const parsed = JSON.parse(raw);
        if (!Array.isArray(parsed)) return new Set();
        return new Set(parsed.map(v => (v === null || v === undefined) ? '' : String(v)).filter(Boolean));
    } catch (err) {
        return new Set();
    }
}

function writeStringSetToLocalStorage(key, setValue) {
    try {
        const arr = Array.from(setValue || []).map(v => String(v)).filter(Boolean);
        localStorage.setItem(key, JSON.stringify(arr));
    } catch (err) {}
}

let deletedScenarioIds = readStringSetFromLocalStorage(DELETED_SCENARIO_IDS_STORAGE_KEY);
let deletedScenarioNameKeys = readStringSetFromLocalStorage(DELETED_SCENARIO_NAME_KEYS_STORAGE_KEY);

function rememberDeletedScenarioMarks({ ids, names } = {}) {
    try {
        for (const id of (ids || [])) {
            const sid = (id === null || id === undefined) ? '' : String(id);
            if (sid) deletedScenarioIds.add(sid);
        }
        writeStringSetToLocalStorage(DELETED_SCENARIO_IDS_STORAGE_KEY, deletedScenarioIds);

        for (const nm of (names || [])) {
            const key = scenarioNameKey(nm);
            if (key) deletedScenarioNameKeys.add(key);
        }
        writeStringSetToLocalStorage(DELETED_SCENARIO_NAME_KEYS_STORAGE_KEY, deletedScenarioNameKeys);
    } catch (e) {}
}

function pruneDeletedScenariosInState() {
    try {
        const hasIds = !!(deletedScenarioIds && deletedScenarioIds.size);
        const hasNames = !!(deletedScenarioNameKeys && deletedScenarioNameKeys.size);
        if (!hasIds && !hasNames) return;
        if (!state || !Array.isArray(state.scenarios) || !state.scenarios.length) return;
        const before = state.scenarios.length;
        state.scenarios = state.scenarios.filter(s => {
            try {
                const sid = (s && s._sid !== undefined && s._sid !== null) ? String(s._sid) : '';
                if (sid && hasIds && deletedScenarioIds.has(sid)) return false;
                const name = (s && typeof s.name === 'string') ? s.name : '';
                const nkey = name ? scenarioNameKey(name) : '';
                if (nkey && hasNames && deletedScenarioNameKeys.has(nkey)) return false;
                return true;
            } catch (e) {
                return true;
            }
        });
        if (!state.scenarios.length) {
            state.scenarios.push(defaultScenario());
            activeIdx = 0;
        } else if (activeIdx >= state.scenarios.length) {
            activeIdx = Math.max(0, state.scenarios.length - 1);
        }
        const after = state.scenarios.length;
        if (before !== after) {
            try { logInfo(`Pruned ${before - after} locally-deleted scenarios after restore`); } catch (e) {}
        }
    } catch (e) {}
}

function deriveProjectKey(snapshot, fallbackKey = DEFAULT_PROJECT_KEY) {
    if (!snapshot || typeof snapshot !== 'object') return fallbackKey;
    const candidates = [];
    const pushCandidate = (val) => {
        if (typeof val !== 'string') return;
        const normalized = val.trim();
        if (normalized) candidates.push(normalized);
    };
    pushCandidate(snapshot.project_key_hint);
    pushCandidate(snapshot.scenario_query);
    pushCandidate(snapshot.result_path || snapshot.resultPath);
    const resolvedScenarioToken = resolveScenarioQueryHintFromSource(snapshot);
    if (resolvedScenarioToken) pushCandidate(resolvedScenarioToken);
    const baseUpload = (snapshot.base_upload && typeof snapshot.base_upload === 'object') ? snapshot.base_upload : null;
    if (baseUpload) pushCandidate(baseUpload.path);
    if (Array.isArray(snapshot.scenarios)) {
        const basePaths = snapshot.scenarios
            .map(scen => (scen && typeof scen === 'object' && scen.base && typeof scen.base === 'object') ? scen.base.filepath : '')
            .filter(val => typeof val === 'string' && val.trim());
        basePaths.forEach(pushCandidate);
        if (!basePaths.length) {
            const scenarioNames = snapshot.scenarios
                .map(scen => (scen && typeof scen === 'object' && typeof scen.name === 'string') ? scen.name.trim() : '')
                .filter(Boolean);
            if (scenarioNames.length) {
                pushCandidate(`scenarios:${scenarioNames.join('|')}`);
            }
        }
    }
    return candidates.find(Boolean) || fallbackKey;
}

function resolveScenarioQueryHintFromSource(source) {
    if (!source) return '';
    try {
        const token = (source.scenario_query || '').trim();
        if (token) return token;
        return deriveScenarioSignature(source);
    } catch (err) {
        return '';
    }
}

function deriveScenarioSignature(source) {
    const scenarios = Array.isArray(source)
        ? source
        : (source && Array.isArray(source.scenarios) ? source.scenarios : []);
    if (!Array.isArray(scenarios) || !scenarios.length) {
        return '';
    }
    const scenarioNames = scenarios
        .map(scen => (scen && typeof scen.name === 'string') ? scen.name.trim() : '')
        .filter(Boolean);
    if (scenarioNames.length) {
        return `names:${scenarioNames.join('|')}`;
    }
    const basePaths = scenarios
        .map(scen => {
            if (!scen || typeof scen !== 'object') return '';
            const base = scen.base && typeof scen.base === 'object' ? scen.base : null;
            return base && typeof base.filepath === 'string' ? base.filepath.trim() : '';
        })
        .filter(Boolean);
    if (basePaths.length) {
        return `base:${basePaths.join('|')}`;
    }
    return '';
}

function scrubScenarioTransientErrors(scenario) {
    if (!scenario || typeof scenario !== 'object') return;
    const hitlState = (scenario.hitl && typeof scenario.hitl === 'object') ? scenario.hitl : null;
    if (!hitlState) return;
    const prox = (hitlState.proxmox && typeof hitlState.proxmox === 'object') ? hitlState.proxmox : null;
    if (!prox) return;
    if (Object.prototype.hasOwnProperty.call(prox, 'inventory_error')) {
        delete prox.inventory_error;
    }
}

function scrubSnapshotTransientErrors(snapshot) {
    if (!snapshot || typeof snapshot !== 'object') return snapshot;
    const scenarios = Array.isArray(snapshot.scenarios) ? snapshot.scenarios : null;
    if (scenarios) {
        scenarios.forEach(scrubScenarioTransientErrors);
    }
    return snapshot;
}

function cloneScenariosForSnapshot(source) {
    if (!Array.isArray(source)) return [];
    if (typeof structuredClone === 'function') {
        try {
            return structuredClone(source);
        } catch (err) {
            // fall through to JSON-based clone
        }
    }
    try {
        return JSON.parse(JSON.stringify(source));
    } catch (err) {
        return source.map(item => {
            if (!item || typeof item !== 'object') return item;
            try {
                return JSON.parse(JSON.stringify(item));
            } catch (nestedErr) {
                return { ...item };
            }
        });
    }
}

function pickBestLocalSnapshotByScenarioCount(snapshotMap) {
    try {
        if (!snapshotMap || typeof snapshotMap !== 'object') return { key: '', snapshot: null, count: 0 };
        let bestKey = '';
        let bestSnapshot = null;
        let bestCount = 0;
        Object.keys(snapshotMap).forEach(key => {
            const entry = snapshotMap[key];
            if (!entry || typeof entry !== 'object') return;
            const scenarios = Array.isArray(entry.scenarios) ? entry.scenarios : null;
            if (!scenarios || !scenarios.length) return;
            const count = scenarios.length;
            if (count > bestCount) {
                bestCount = count;
                bestKey = key;
                bestSnapshot = entry;
            }
        });
        return { key: bestKey, snapshot: bestSnapshot, count: bestCount };
    } catch (err) {
        return { key: '', snapshot: null, count: 0 };
    }
}

let projectStateMap = readJsonFromLocalStorage(PROJECT_STATE_STORAGE_KEY, {});
if (!projectStateMap || typeof projectStateMap !== 'object') projectStateMap = {};
let legacyEditorState = readJsonFromLocalStorage(LEGACY_EDITOR_STATE_STORAGE_KEY, null);
legacyEditorState = scrubSnapshotTransientErrors(legacyEditorState);
const lastProjectKeyFromStorage = readLastProjectKeyFromStorage();
const legacyProjectKeyHint = legacyEditorState ? deriveProjectKey(legacyEditorState, DEFAULT_PROJECT_KEY) : '';
try {
    Object.keys(projectStateMap).forEach(key => {
        const entry = projectStateMap[key];
        if (!entry || typeof entry !== 'object') return;
        projectStateMap[key] = scrubSnapshotTransientErrors(entry);
    });
} catch (err) {}
let currentProjectKey = deriveProjectKey(initialPayload, DEFAULT_PROJECT_KEY);
if ((!currentProjectKey || currentProjectKey === DEFAULT_PROJECT_KEY) && legacyProjectKeyHint) {
    currentProjectKey = legacyProjectKeyHint;
}
let activeIdxMap = readJsonFromLocalStorage(PROJECT_ACTIVE_IDX_STORAGE_KEY, {});

// Persisted collapse state (shared across cards/sections).
// Must be in the outer scope because multiple handlers (including the generic
// [data-action="toggle-collapse"] handler) reference it.
let collapseState = {};
try { collapseState = JSON.parse(localStorage.getItem('sectionCollapseState') || '{}'); } catch(e) { collapseState = {}; }
if (!activeIdxMap || typeof activeIdxMap !== 'object') activeIdxMap = {};
const serverEditorSnapshot = (initialPayload && typeof initialPayload.editor_snapshot === 'object')
    ? initialPayload.editor_snapshot
    : null;
const serverProjectKeyHint = (serverEditorSnapshot && typeof serverEditorSnapshot.project_key_hint === 'string')
    ? serverEditorSnapshot.project_key_hint.trim()
    : '';
const serverScenarioQuery = (serverEditorSnapshot && typeof serverEditorSnapshot.scenario_query === 'string')
    ? serverEditorSnapshot.scenario_query.trim()
    : '';
let serverSnapshotKey = '';
if (ALLOW_LOCAL_EDITOR_PERSISTENCE && serverEditorSnapshot && typeof serverEditorSnapshot === 'object') {
    try {
        const cloned = JSON.parse(JSON.stringify(serverEditorSnapshot));
        const sanitized = scrubSnapshotTransientErrors(cloned);
        const candidateKey = deriveProjectKey(
            sanitized,
            serverProjectKeyHint || currentProjectKey || DEFAULT_PROJECT_KEY
        );
        if (candidateKey) {
            const existing = projectStateMap[candidateKey];
            const serverSignature = resolveScenarioQueryHintFromSource(sanitized);
            const existingSignature = resolveScenarioQueryHintFromSource(existing);
            const serverResult = (sanitized && typeof sanitized.result_path === 'string')
                ? sanitized.result_path.trim()
                : '';
            const existingResult = (existing && typeof existing.result_path === 'string')
                ? existing.result_path.trim()
                : '';
            const needsSync = !existing
                || (serverResult && serverResult !== existingResult)
                || (serverSignature && serverSignature !== existingSignature);
            if (needsSync) {
                let preferLocalSync = false;
                try {
                    const localScenarios = existing && Array.isArray(existing.scenarios) ? existing.scenarios : null;
                    const serverScenarios = Array.isArray(sanitized.scenarios) ? sanitized.scenarios : null;
                    // IMPORTANT: On refresh, the server snapshot can lag behind the browser state.
                    // Never let a stale server snapshot shrink the scenario list and make a newly
                    // created scenario disappear; instead, prefer the local snapshot and merge
                    // only validated HITL/core metadata from the server into it.
                    const localCount = localScenarios ? localScenarios.length : 0;
                    const serverCount = serverScenarios ? serverScenarios.length : 0;
                    if (existing && localScenarios && localCount >= serverCount) {
                        // Merge any validated HITL state from server -> local.
                        if (serverScenarios) {
                            mergePersistedHitlStateIntoScenarios(localScenarios, serverScenarios);
                        }
                        const merged = JSON.parse(JSON.stringify(existing));
                        merged.scenarios = localScenarios;
                        if (serverResult) {
                            merged.result_path = serverResult;
                        }
                        if (sanitized && typeof sanitized.scenario_query === 'string' && sanitized.scenario_query.trim()) {
                            merged.scenario_query = sanitized.scenario_query.trim();
                        }
                        if (sanitized && typeof sanitized.project_key_hint === 'string' && sanitized.project_key_hint.trim()) {
                            merged.project_key_hint = sanitized.project_key_hint.trim();
                        }
                        if (sanitized && sanitized.core && typeof sanitized.core === 'object') {
                            // Server snapshot only includes validated CORE details; keep local unless missing.
                            if (!merged.core || typeof merged.core !== 'object') {
                                merged.core = sanitized.core;
                            }
                        }
                        projectStateMap[candidateKey] = scrubSnapshotTransientErrors(merged);
                        legacyEditorState = projectStateMap[candidateKey];
                        writeJsonToLocalStorage(LEGACY_EDITOR_STATE_STORAGE_KEY, legacyEditorState);
                        writeJsonToLocalStorage(PROJECT_STATE_STORAGE_KEY, projectStateMap);
                        preferLocalSync = true;
                    }

                    // Default behavior: server wins; merge local validated HITL into server snapshot.
                    if (!preferLocalSync && localScenarios && serverScenarios) {
                        mergePersistedHitlStateIntoScenarios(serverScenarios, localScenarios);
                    }
                } catch (mergeErr) {
                    console.warn('Editor snapshot merge failed; falling back to server snapshot', mergeErr);
                }
                if (!preferLocalSync) {
                    projectStateMap[candidateKey] = sanitized;
                    legacyEditorState = sanitized;
                    writeJsonToLocalStorage(LEGACY_EDITOR_STATE_STORAGE_KEY, legacyEditorState);
                    writeJsonToLocalStorage(PROJECT_STATE_STORAGE_KEY, projectStateMap);
                }
            }
            serverSnapshotKey = candidateKey;
        }
    } catch (err) {
        console.warn('Unable to sync server snapshot into local cache', err);
    }
}
const derivedInitialSignature =
    deriveScenarioSignature(initialPayload)
    || deriveScenarioSignature(serverEditorSnapshot)
    || deriveScenarioSignature(legacyEditorState)
    || '';
let scenarioQueryToken = (initialScenarioQuery || serverScenarioQuery || derivedInitialSignature || '').trim();
if ((!currentProjectKey || currentProjectKey === DEFAULT_PROJECT_KEY) && serverProjectKeyHint) {
    currentProjectKey = serverProjectKeyHint;
}
if ((!currentProjectKey || currentProjectKey === DEFAULT_PROJECT_KEY) && scenarioQueryToken) {
    currentProjectKey = `${DEFAULT_PROJECT_KEY}::${scenarioQueryToken.toLowerCase()}`;
}
if ((!currentProjectKey || currentProjectKey === DEFAULT_PROJECT_KEY) && serverSnapshotKey) {
    currentProjectKey = serverSnapshotKey;
}
if (!currentProjectKey || !projectStateMap[currentProjectKey]) {
    if (lastProjectKeyFromStorage && projectStateMap[lastProjectKeyFromStorage]) {
        currentProjectKey = lastProjectKeyFromStorage;
    } else if (legacyProjectKeyHint && projectStateMap[legacyProjectKeyHint]) {
        currentProjectKey = legacyProjectKeyHint;
    }
}
if (!currentProjectKey) currentProjectKey = DEFAULT_PROJECT_KEY;
const serverResultPath = (initialPayload && typeof initialPayload.result_path === 'string')
    ? initialPayload.result_path.trim()
    : '';
if (serverResultPath) {
    try {
        const keyProbe = {
            project_key_hint: (initialPayload && initialPayload.project_key_hint) || serverResultPath,
            result_path: serverResultPath,
        };
        const serverKeyCandidate = deriveProjectKey(keyProbe, serverResultPath) || serverResultPath;
        if (serverKeyCandidate && projectStateMap[serverKeyCandidate]) {
            currentProjectKey = serverKeyCandidate;
        }
    } catch (err) {
        console.warn('Failed to align project key with server result path', err);
    }
}

// View-mode switches (admin <-> builder) should not change which local project snapshot we load.
// Otherwise, a derived key from a minimal builder payload can select a different/older snapshot
// and make CORE/Participant settings appear to be "cleared".
try {
    if (USE_LOCAL_EDITOR_STATE && !serverResultPath) {
        const lastKey = (lastProjectKeyFromStorage || '').trim();
        if (lastKey && projectStateMap && typeof projectStateMap === 'object' && projectStateMap[lastKey]) {
            currentProjectKey = lastKey;
        }
    }
} catch (err) {}

let persistedState = null;
if (USE_LOCAL_EDITOR_STATE) {
    const keyedStateForCurrentProject = projectStateMap[currentProjectKey];
    if (keyedStateForCurrentProject) {
        persistedState = keyedStateForCurrentProject;
    }
}
const CORE_DEFAULT_VENV_BIN = (initialPayload && typeof initialPayload.core === 'object' && typeof initialPayload.core.venv_bin === 'string' && initialPayload.core.venv_bin.trim())
    ? initialPayload.core.venv_bin.trim()
    : '/opt/core/venv/bin';
const PARTICIPANT_STATUS_EMPTY_TEXT = 'No Participant UI URL saved yet. Apply one to expose the Participant UI tab during HITL runs.';
const PARTICIPANT_STATUS_SAVED_TEXT = 'Participant UI link saved. The navigation tab is enabled for this scenario.';
// If server provides a fresh result_path (e.g., after Save XML), reflect it in localStorage early
try {
    if (ALLOW_LOCAL_EDITOR_PERSISTENCE && serverResultPath) {
        const existingSnapshot = projectStateMap[currentProjectKey] || legacyEditorState || {};
        const persisted = { ...existingSnapshot };
        const existingCoreSnapshot = (existingSnapshot && existingSnapshot.core)
            ? normalizeCoreState(existingSnapshot.core, true)
            : null;
        persisted.result_path = serverResultPath;
        if (initialPayload.core) {
            const serverCoreSnapshot = normalizeCoreState(initialPayload.core, true);
            persisted.core = existingCoreSnapshot
                ? mergeCoreSnapshots(serverCoreSnapshot, existingCoreSnapshot)
                : serverCoreSnapshot;
        } else if (existingCoreSnapshot) {
            persisted.core = existingCoreSnapshot;
        }
        projectStateMap[currentProjectKey] = persisted;
        legacyEditorState = persisted;
        writeJsonToLocalStorage(LEGACY_EDITOR_STATE_STORAGE_KEY, persisted);
        writeJsonToLocalStorage(PROJECT_STATE_STORAGE_KEY, projectStateMap);
    }
} catch(e){}

function normalizeScenarioName(value) {
    if (value === null || value === undefined) return '';
    return String(value).replace(/\s+/g, ' ').trim();
}

function scenarioNameKey(value) {
    const normalized = normalizeScenarioName(value);
    return normalized ? normalized.toLowerCase() : '';
}

function ensureUniqueScenarioName(desiredName, scenarios, selfIndex) {
    const base = normalizeScenarioName(desiredName) || 'Scenario';
    const existing = new Set();
    try {
        (scenarios || []).forEach((sc, idx) => {
            if (!sc || typeof sc !== 'object') return;
            if (typeof selfIndex === 'number' && idx === selfIndex) return;
            const key = scenarioNameKey(sc.name);
            if (key) existing.add(key);
        });
    } catch (e) {}
    // Also treat locally-deleted (tombstoned) names as reserved so newly-created
    // scenarios don't immediately get pruned on refresh.
    try {
        if (deletedScenarioNameKeys && deletedScenarioNameKeys.size) {
            deletedScenarioNameKeys.forEach(k => { if (k) existing.add(k); });
        }
    } catch (e) {}
    if (!existing.has(scenarioNameKey(base))) return base;
    for (let n = 2; n < 1000; n++) {
        const candidate = `${base} (${n})`;
        if (!existing.has(scenarioNameKey(candidate))) return candidate;
    }
    return `${base} (${Date.now()})`;
}

function generateScenarioSid() {
    // Stable-ish unique id for client-side selection and snapshot merging.
    // Use a longer random suffix to keep collisions extremely unlikely.
    return 'scen_' + Date.now().toString(36) + '_' + Math.random().toString(36).slice(2, 10);
}

function defaultScenario(name) {
    return {
        _sid: generateScenarioSid(),
        name: name || `Scenario ${document.querySelectorAll('.scenario-card').length + 1}`,
        base: { filepath: '' },
        hitl: { enabled: false, interfaces: [] },
        density_count: 10,
        sections: {
            // Default: one Count-based row; weight-based nodes/density start at 0
            'Node Information': { total_nodes: 0, density: 0, items: [ { selected: 'Random', factor: 1.0, v_metric: 'Count', v_count: 5 } ] },
            'Routing': { density: 0.5, items: [] },
            'Services': { density: 0.5, items: [] },
            'Traffic': { density: 0.5, items: [] },
            'Events': { density: 0.5, items: [] },
            'Vulnerabilities': { density: 0.5, items: [] },
            'Segmentation': { density: 0.5, items: [] }
        },
        notes: ''
    };
}

function normalizeOptionalMessage(value) {
    if (typeof value !== 'string') return null;
    const trimmed = value.trim();
    if (!trimmed) return null;
    const lowered = trimmed.toLowerCase();
    if (NULLISH_TEXT_SENTINELS.has(lowered)) return null;
    return trimmed;
}

function normalizeHostInterfaceName(value) {
    if (value === null || value === undefined) return '';
    let normalized = String(value).trim();
    if (!normalized) return '';
    normalized = normalized.replace(/^hitl-/i, '').trim() || normalized;
    return normalized;
}

function normalizeHitlAttachment(value) {
    if (value === null || value === undefined) return DEFAULT_HITL_ATTACHMENT;
    let normalized = String(value).trim().toLowerCase();
    if (!normalized) return DEFAULT_HITL_ATTACHMENT;
    normalized = normalized.replace(/[\s-]+/g, '_');
    return HITL_ATTACHMENT_ALLOWED.has(normalized) ? normalized : DEFAULT_HITL_ATTACHMENT;
}

function prettyHitlAttachment(value) {
    const normalized = normalizeHitlAttachment(value);
    const match = HITL_ATTACHMENT_CHOICES.find(opt => opt.value === normalized);
    return match ? match.label : 'Existing Router';
}

function normalizeParticipantProxmoxHref(value) {
    if (value === undefined || value === null) return '';
    let trimmed = String(value).trim();
    if (!trimmed) return '';
    if (!/^https?:\/\//i.test(trimmed)) {
        trimmed = `https://${trimmed}`;
    }
    try {
        const parsed = new URL(trimmed);
        if (parsed.protocol !== 'http:' && parsed.protocol !== 'https:') {
            return '';
        }
        return parsed.toString();
    } catch (err) {
        return '';
    }
}


function hitlAttachmentAttemptOrder(preference) {
    const normalized = normalizeHitlAttachment(preference);
    switch (normalized) {
        case 'existing_router':
            return ['existing_router', 'existing_switch', 'new_router'];
        case 'existing_switch':
            return ['existing_switch', 'existing_router', 'new_router'];
        case 'new_router':
        default:
            return ['new_router', 'existing_router', 'existing_switch'];
    }
}

function ensureHitlStateForScenario(scen) {
    if (!scen || typeof scen !== 'object') return { enabled: false, interfaces: [] };
    if (!scen.hitl || typeof scen.hitl !== 'object') {
        scen.hitl = { enabled: false, interfaces: [] };
    }
    const normalizeAddrList = (value) => {
        if (Array.isArray(value)) {
            return value.map(v => (v ?? '').toString().trim()).filter(Boolean);
        }
        if (typeof value === 'string') {
            return value.split(',').map(v => v.trim()).filter(Boolean);
        }
        return [];
    };
    if (!Array.isArray(scen.hitl.interfaces)) {
        const raw = scen.hitl.interfaces;
        if (typeof raw === 'string' && raw.trim()) {
            scen.hitl.interfaces = [{ name: raw.trim() }];
        } else if (raw && typeof raw === 'object' && raw.name) {
            scen.hitl.interfaces = [{ ...raw }];
        } else {
            scen.hitl.interfaces = [];
        }
    }
    scen.hitl.interfaces = scen.hitl.interfaces.map((entry, idx) => {
        if (!entry) return null;
        if (typeof entry === 'string') {
            const name = normalizeHostInterfaceName(entry);
            return name ? { name } : null;
        }
        if (typeof entry !== 'object') return null;
        const clone = { ...entry };
        const derivedName = clone.name ?? clone.interface ?? clone.iface ?? clone.id ?? `iface-${idx + 1}`;
        clone.name = normalizeHostInterfaceName(derivedName);
        if (!clone.name) {
            return null;
        }
        if (clone.alias && !clone.description) clone.description = clone.alias;
        if (clone.display && !clone.description) clone.description = clone.display;
        if (clone.summary && !clone.description) clone.description = clone.summary;
        if (clone.ipv4 !== undefined) clone.ipv4 = normalizeAddrList(clone.ipv4);
        if (clone.ipv6 !== undefined) clone.ipv6 = normalizeAddrList(clone.ipv6);
        if (clone.proxmox_target && typeof clone.proxmox_target === 'object') {
            const target = clone.proxmox_target;
            const node = (target.node ?? '').toString().trim();
            const vmid = target.vmid;
            const ifaceId = (target.interface_id ?? target.interface ?? target.id ?? '').toString().trim();
            const macaddr = (target.macaddr ?? target.mac ?? '').toString();
            const bridge = (target.bridge ?? '').toString();
            const model = (target.model ?? '').toString();
            const vmName = (target.vm_name ?? target.name ?? '').toString();
            const label = (target.label ?? '').toString();
            clone.proxmox_target = {
                node,
                vmid,
                interface_id: ifaceId,
                macaddr,
                bridge,
                model,
                vm_name: vmName,
                label,
            };
        } else {
            delete clone.proxmox_target;
        }
        if (clone.external_vm && typeof clone.external_vm === 'object') {
            const ext = clone.external_vm;
            const vmKey = (ext.vm_key ?? ext.key ?? '').toString();
            const vmNode = (ext.vm_node ?? ext.node ?? '').toString();
            const vmName = (ext.vm_name ?? ext.name ?? '').toString();
            const status = (ext.status ?? '').toString();
            let vmid = ext.vmid ?? ext.id ?? '';
            if (typeof vmid === 'string') vmid = vmid.trim();
            const ifaceIdRaw = (ext.interface_id ?? ext.iface ?? '').toString().trim();
            const ifaceBridgeRaw = (ext.interface_bridge ?? ext.bridge ?? '').toString().trim();
            const ifaceMacRaw = (ext.interface_mac ?? ext.macaddr ?? ext.mac ?? '').toString().trim();
            const ifaceModelRaw = (ext.interface_model ?? ext.model ?? '').toString().trim();
            if (vmKey) {
                const normalized = {
                    vm_key: vmKey,
                    vm_node: vmNode,
                    vm_name: vmName,
                    vmid,
                    status,
                };
                if (ifaceIdRaw) normalized.interface_id = ifaceIdRaw;
                if (ifaceBridgeRaw) normalized.interface_bridge = ifaceBridgeRaw;
                if (ifaceMacRaw) normalized.interface_mac = ifaceMacRaw;
                if (ifaceModelRaw) normalized.interface_model = ifaceModelRaw;
                clone.external_vm = normalized;
            } else {
                delete clone.external_vm;
            }
        } else {
            delete clone.external_vm;
        }
        clone.attachment = normalizeHitlAttachment(clone.attachment);
        return clone;
    }).filter(Boolean);
    const participantUrlRaw = (scen.hitl.participant_proxmox_url ?? '').toString();
    scen.hitl.participant_proxmox_url = participantUrlRaw.trim();
    scen.hitl.enabled = !!scen.hitl.enabled;
    if (!scen.hitl.core || typeof scen.hitl.core !== 'object') {
        scen.hitl.core = {
            vm_key: '',
            vm_name: '',
            vm_node: '',
            grpc_host: 'localhost',
            grpc_port: 50051,
            ssh_host: '',
            ssh_port: 22,
            ssh_username: '',
            ssh_password: '',
            core_secret_id: null,
            validated: false,
            last_validated_at: null,
            stored_summary: null,
            last_tested_at: null,
            last_tested_status: null,
            last_tested_message: null,
            last_tested_host: null,
            last_tested_port: null,
            internal_bridge: '',
            internal_bridge_owner: '',
            last_interfaces_refresh: null,
            last_interfaces_attempt: null,
            interfaces_refresh_inflight: false,
            last_interfaces_error: null,
            remember_credentials: true,
            auto_start_daemon: false,
            adv_run_core_cleanup: true,
        };
    } else {
        const core = scen.hitl.core;
        core.vm_key = (core.vm_key ?? '').toString();
        core.vm_name = (core.vm_name ?? '').toString();
        core.vm_node = (core.vm_node ?? '').toString();
        core.grpc_host = (core.grpc_host ?? '').toString().trim();
        if (!core.grpc_host) core.grpc_host = 'localhost';
        core.ssh_host = (core.ssh_host ?? '').toString();
        const sshPort = parseInt(core.ssh_port, 10);
        core.ssh_port = Number.isFinite(sshPort) && sshPort > 0 ? sshPort : 22;
        const grpcPort = parseInt(core.grpc_port, 10);
        core.grpc_port = Number.isFinite(grpcPort) && grpcPort > 0 ? grpcPort : 50051;
        core.ssh_username = (core.ssh_username ?? '').toString();
        core.ssh_password = (core.ssh_password ?? '').toString();
        core.internal_bridge = (core.internal_bridge ?? '').toString().trim();
        core.internal_bridge_owner = (core.internal_bridge_owner ?? '').toString().trim();
        if (typeof core.last_tested_at !== 'string') core.last_tested_at = null;
        if (typeof core.last_tested_status !== 'string') core.last_tested_status = null;
        if (typeof core.last_tested_message !== 'string') core.last_tested_message = null;
        if (typeof core.last_tested_host !== 'string') core.last_tested_host = null;
        const testedPort = parseInt(core.last_tested_port, 10);
        core.last_tested_port = Number.isFinite(testedPort) && testedPort > 0 ? testedPort : null;
        if (typeof core.core_secret_id === 'string') {
            core.core_secret_id = core.core_secret_id.trim() || null;
        } else if (core.core_secret_id == null) {
            core.core_secret_id = null;
        } else {
            core.core_secret_id = null;
        }
        core.validated = core.validated === true;
        if (typeof core.last_validated_at !== 'string') core.last_validated_at = null;
        if (!core.stored_summary || typeof core.stored_summary !== 'object') {
            core.stored_summary = null;
        }
        if (typeof core.last_interfaces_refresh !== 'string') core.last_interfaces_refresh = null;
        if (typeof core.last_interfaces_attempt !== 'string') core.last_interfaces_attempt = null;
        core.interfaces_refresh_inflight = core.interfaces_refresh_inflight === true;
        if (typeof core.last_interfaces_error === 'string') {
            core.last_interfaces_error = normalizeOptionalMessage(core.last_interfaces_error);
        } else {
            core.last_interfaces_error = null;
        }
    }
    if (typeof scen.hitl.core.remember_credentials !== 'boolean') {
        scen.hitl.core.remember_credentials = true;
    }
    if (typeof scen.hitl.core.auto_start_daemon !== 'boolean') {
        scen.hitl.core.auto_start_daemon = false;
    }
    if (typeof scen.hitl.core.adv_run_core_cleanup !== 'boolean') {
        // Default to enabled unless the user explicitly disables it.
        scen.hitl.core.adv_run_core_cleanup = true;
    }
    const coreVmKeyCurrent = (scen.hitl.core?.vm_key ?? '').toString();
    const coreVmNodeCurrent = (scen.hitl.core?.vm_node ?? '').toString().trim();
    if (coreVmKeyCurrent) {
        scen.hitl.interfaces.forEach(iface => {
            if (iface && iface.external_vm && iface.external_vm.vm_key === coreVmKeyCurrent) {
                delete iface.external_vm;
            }
        });
    }
    if (coreVmNodeCurrent) {
        scen.hitl.interfaces.forEach(iface => {
            const vmNode = iface?.external_vm?.vm_node ? String(iface.external_vm.vm_node).trim() : '';
            if (vmNode && vmNode !== coreVmNodeCurrent) {
                delete iface.external_vm;
            }
        });
    }
    if (!scen.hitl.proxmox || typeof scen.hitl.proxmox !== 'object') {
        scen.hitl.proxmox = {
            url: '',
            port: 8006,
            username: '',
            verify_ssl: true,
            secret_id: null,
            validated: false,
            last_validated_at: null,
            last_message: '',
            inventory: { fetched_at: null, vms: [] },
            inventory_error: null,
            remember_credentials: true,
        };
    } else {
        const prox = scen.hitl.proxmox;
        prox.url = (prox.url ?? '').toString().trim();
        const parsedPort = parseInt(prox.port, 10);
        prox.port = Number.isFinite(parsedPort) && parsedPort > 0 ? parsedPort : 8006;
        prox.username = (prox.username ?? '').toString().trim();
        if ('password' in prox) {
            delete prox.password;
        }
        prox.verify_ssl = prox.verify_ssl === false ? false : true;
        if (typeof prox.secret_id === 'string') {
            const trimmedSecret = prox.secret_id.trim();
            prox.secret_id = trimmedSecret || null;
        } else {
            prox.secret_id = null;
        }
        prox.validated = prox.validated === true;
        prox.last_validated_at = prox.last_validated_at || null;
        prox.last_message = (prox.last_message ?? '').toString();
        prox.inventory_error = prox.inventory_error ? prox.inventory_error.toString() : null;
        if (!prox.inventory || typeof prox.inventory !== 'object') {
            prox.inventory = { fetched_at: null, vms: [] };
        } else {
            const inv = prox.inventory;
            inv.fetched_at = inv.fetched_at || null;
            const vms = Array.isArray(inv.vms) ? inv.vms : [];
            inv.vms = vms.map(vm => {
                if (!vm || typeof vm !== 'object') return null;
                const node = (vm.node ?? vm.host ?? '').toString();
                const vmid = vm.vmid;
                const name = (vm.name ?? '').toString();
                const status = (vm.status ?? '').toString();
                const interfaces = Array.isArray(vm.interfaces) ? vm.interfaces : [];
                const safeIfaces = interfaces.map(iface => {
                    if (!iface || typeof iface !== 'object') return null;
                    const id = (iface.id ?? '').toString();
                    const macaddr = (iface.macaddr ?? iface.mac ?? '').toString();
                    const bridge = (iface.bridge ?? '').toString();
                    const model = (iface.model ?? '').toString();
                    const tag = (iface.tag ?? '').toString();
                    const raw = (iface.raw ?? '').toString();
                    if (!id) return null;
                    return { id, macaddr, bridge, model, tag, raw };
                }).filter(Boolean);
                if (!node || vmid === undefined || safeIfaces.length === 0) {
                    return {
                        node,
                        vmid,
                        name,
                        status,
                        interfaces: safeIfaces,
                    };
                }
                return {
                    node,
                    vmid,
                    name,
                    status,
                    interfaces: safeIfaces,
                };
            }).filter(Boolean);
        }
    }
    if (typeof scen.hitl.proxmox.remember_credentials !== 'boolean') {
        scen.hitl.proxmox.remember_credentials = true;
    }
    applyDefaultProxmoxFields(scen.hitl.proxmox);
    return scen.hitl;
}

function _structuredCloneSafe(value) {
    if (value === null || typeof value !== 'object') return null;
    if (typeof structuredClone === 'function') {
        try { return structuredClone(value); } catch (err) { /* fallback */ }
    }
    try {
        return JSON.parse(JSON.stringify(value));
    } catch (err) {
        return null;
    }
}

function _normalizeScenarioLookupKey(raw) {
    if (raw === undefined || raw === null) return '';
    return String(raw).trim().toLowerCase();
}

function _scenarioMatchKey(raw) {
    if (raw === undefined || raw === null) return '';
    // Punctuation-insensitive match key to avoid name mismatches like "Scenario_1b" vs "Scenario 1b".
    return String(raw).trim().toLowerCase().replace(/[^a-z0-9]+/g, '');
}

function _hitlInterfaceKey(entry, fallbackIndex = null) {
    if (entry && typeof entry === 'object') {
        const nameCandidate = entry.name ?? entry.interface ?? entry.id;
        if (nameCandidate !== undefined && nameCandidate !== null) {
            const normalized = String(nameCandidate).trim().toLowerCase();
            if (normalized) return normalized;
        }
    }
    if (fallbackIndex === null || fallbackIndex === undefined) return '';
    return `idx:${fallbackIndex}`;
}

function mergePersistedHitlState(targetScenario, persistedScenario) {
    if (!targetScenario || !persistedScenario) return;
    const targetHitl = ensureHitlStateForScenario(targetScenario);
    const persistedClone = _structuredCloneSafe(persistedScenario);
    if (!persistedClone) return;
    const sourceHitl = ensureHitlStateForScenario(persistedClone);
    if (sourceHitl.proxmox && typeof sourceHitl.proxmox === 'object') {
        const targetProx = targetHitl.proxmox || {};
        const mergedProx = { ...targetProx, ...sourceHitl.proxmox };
        const targetInv = targetProx.inventory;
        const sourceInv = sourceHitl.proxmox.inventory;
        if (targetInv && Array.isArray(targetInv.vms) && targetInv.vms.length) {
            mergedProx.inventory = targetInv;
        } else if (sourceInv) {
            mergedProx.inventory = sourceInv;
        }
        targetHitl.proxmox = mergedProx;
    }
    if (sourceHitl.core && typeof sourceHitl.core === 'object') {
        const targetCore = targetHitl.core || {};
        const volatileFields = {
            interfaces_refresh_inflight: targetCore.interfaces_refresh_inflight,
            last_interfaces_error: targetCore.last_interfaces_error,
            last_interfaces_attempt: targetCore.last_interfaces_attempt,
            last_interfaces_refresh: targetCore.last_interfaces_refresh,
        };
        const mergedCore = { ...targetCore, ...sourceHitl.core };
        Object.entries(volatileFields).forEach(([key, value]) => {
            if (value !== undefined) {
                mergedCore[key] = value;
            }
        });
        targetHitl.core = mergedCore;
    }
    if (Array.isArray(sourceHitl.interfaces) && sourceHitl.interfaces.length) {
        if (!Array.isArray(targetHitl.interfaces)) {
            targetHitl.interfaces = [];
        }
        const targetInterfaces = targetHitl.interfaces;
        const targetLookup = new Map();
        targetInterfaces.forEach((entry, idx) => {
            const key = _hitlInterfaceKey(entry, idx);
            if (key) targetLookup.set(key, entry);
        });
        sourceHitl.interfaces.forEach((entry, idx) => {
            if (!entry || typeof entry !== 'object') return;
            const cloneEntry = _structuredCloneSafe(entry) || { ...entry };
            const key = _hitlInterfaceKey(cloneEntry, idx);
            let targetEntry = key ? targetLookup.get(key) : null;
            if (!targetEntry) {
                const insertIdx = targetInterfaces.length;
                targetInterfaces.push(cloneEntry);
                const insertKey = key || _hitlInterfaceKey(cloneEntry, insertIdx) || `idx:${insertIdx}`;
                targetLookup.set(insertKey, cloneEntry);
                return;
            }
            if (cloneEntry.attachment !== undefined) {
                targetEntry.attachment = cloneEntry.attachment;
            }
            if (Array.isArray(cloneEntry.ipv4) && (!Array.isArray(targetEntry.ipv4) || !targetEntry.ipv4.length)) {
                targetEntry.ipv4 = cloneEntry.ipv4.slice();
            }
            if (Array.isArray(cloneEntry.ipv6) && (!Array.isArray(targetEntry.ipv6) || !targetEntry.ipv6.length)) {
                targetEntry.ipv6 = cloneEntry.ipv6.slice();
            }
            if (cloneEntry.mac && !targetEntry.mac) {
                targetEntry.mac = cloneEntry.mac;
            }
            if (cloneEntry.proxmox_target && !targetEntry.proxmox_target) {
                targetEntry.proxmox_target = cloneEntry.proxmox_target;
            }
            if (cloneEntry.external_vm && typeof cloneEntry.external_vm === 'object') {
                const externalClone = _structuredCloneSafe(cloneEntry.external_vm) || { ...cloneEntry.external_vm };
                targetEntry.external_vm = externalClone;
            }
        });
    }
    if (typeof sourceHitl.participant_proxmox_url === 'string') {
        targetHitl.participant_proxmox_url = sourceHitl.participant_proxmox_url;
    }
    if (sourceHitl.enabled && !targetHitl.enabled) {
        targetHitl.enabled = true;
    }
}

function mergePersistedHitlStateIntoScenarios(currentScenarios, persistedScenarios) {
    if (!Array.isArray(currentScenarios) || !Array.isArray(persistedScenarios)) return;
    const lookup = {
        bySid: new Map(),
        byBase: new Map(),
        byName: new Map(),
        byIndex: new Map(),
    };
    persistedScenarios.forEach((scen, idx) => {
        if (!scen || typeof scen !== 'object') return;
        lookup.byIndex.set(idx, scen);
        if (scen._sid) lookup.bySid.set(String(scen._sid), scen);
        if (scen.base && typeof scen.base === 'object' && scen.base.filepath) {
            const baseKey = _normalizeScenarioLookupKey(scen.base.filepath);
            if (baseKey) lookup.byBase.set(baseKey, scen);
        }
        const nameKey = _normalizeScenarioLookupKey(scen.name);
        if (nameKey && !lookup.byName.has(nameKey)) {
            lookup.byName.set(nameKey, scen);
        }
    });

    currentScenarios.forEach((scen, idx) => {
        if (!scen || typeof scen !== 'object') return;
        const sid = scen._sid ? String(scen._sid) : '';
        const baseKey = scen.base && typeof scen.base === 'object' && scen.base.filepath
            ? _normalizeScenarioLookupKey(scen.base.filepath)
            : '';
        const nameKey = _normalizeScenarioLookupKey(scen.name);
        let persistedMatch = null;
        if (sid && lookup.bySid.has(sid)) {
            persistedMatch = lookup.bySid.get(sid);
        } else if (baseKey && lookup.byBase.has(baseKey)) {
            persistedMatch = lookup.byBase.get(baseKey);
        } else if (nameKey && lookup.byName.has(nameKey)) {
            persistedMatch = lookup.byName.get(nameKey);
        } else if (lookup.byIndex.has(idx)) {
            persistedMatch = lookup.byIndex.get(idx);
        }
        if (!persistedMatch) return;
        if (!scen._sid && persistedMatch._sid) {
            scen._sid = persistedMatch._sid;
        }
        mergePersistedHitlState(scen, persistedMatch);
    });
}

function shouldRememberProxmox(hitlState) {
    if (!hitlState || !hitlState.proxmox) return true;
    return hitlState.proxmox.remember_credentials !== false;
}

const PROXMOX_DEFAULTS_STORAGE_KEY = 'coretg_proxmox_defaults';

function normalizeProxmoxDefaults(raw) {
    if (!raw || typeof raw !== 'object') return {};
    const result = {};
    if (typeof raw.url === 'string' && raw.url.trim()) {
        result.url = raw.url.trim();
    }
    const portVal = parseInt(raw.port, 10);
    if (Number.isFinite(portVal) && portVal >= 1 && portVal <= 65535) {
        result.port = portVal;
    }
    if (typeof raw.username === 'string' && raw.username.trim()) {
        result.username = raw.username.trim();
    }
    if (typeof raw.verify_ssl === 'boolean') {
        result.verify_ssl = raw.verify_ssl;
    }
    return result;
}

function getSavedProxmoxDefaults() {
    try {
        const raw = JSON.parse(localStorage.getItem(PROXMOX_DEFAULTS_STORAGE_KEY) || 'null');
        return normalizeProxmoxDefaults(raw);
    } catch (err) {
        return {};
    }
}

function persistSavedProxmoxDefaults(partial) {
    if (!partial || typeof partial !== 'object') return;
    const current = getSavedProxmoxDefaults();
    const merged = { ...current };
    if (typeof partial.url === 'string' && partial.url.trim()) {
        merged.url = partial.url.trim();
    }
    if (partial.port !== undefined) {
        const portVal = parseInt(partial.port, 10);
        if (Number.isFinite(portVal) && portVal >= 1 && portVal <= 65535) {
            merged.port = portVal;
        }
    }
    if (typeof partial.username === 'string' && partial.username.trim()) {
        merged.username = partial.username.trim();
    }
    if (typeof partial.verify_ssl === 'boolean') {
        merged.verify_ssl = partial.verify_ssl;
    }
    const normalized = normalizeProxmoxDefaults(merged);
    try {
        localStorage.setItem(PROXMOX_DEFAULTS_STORAGE_KEY, JSON.stringify(normalized));
    } catch (err) {
        console.warn('Failed to persist Proxmox defaults', err);
    }
}

function applyDefaultProxmoxFields(target) {
    if (!target || typeof target !== 'object') return;
    const defaults = getSavedProxmoxDefaults();
    if (!defaults || Object.keys(defaults).length === 0) return;
    if (!target.url && defaults.url) {
        target.url = defaults.url;
    }
    if ((!target.port || target.port === 8006) && defaults.port) {
        target.port = defaults.port;
    }
    if (!target.username && defaults.username) {
        target.username = defaults.username;
    }
    if (typeof target.verify_ssl !== 'boolean' && typeof defaults.verify_ssl === 'boolean') {
        target.verify_ssl = defaults.verify_ssl;
    }
}

function shouldRememberCore(hitlState) {
    if (!hitlState || !hitlState.core) return true;
    return hitlState.core.remember_credentials !== false;
}

const proxmoxSecretCache = new Map();

async function fetchStoredProxmoxCredentials(secretId) {
    if (!IS_ADMIN_USER || IS_BUILDER_VIEW) return null;
    if (!secretId) return null;
    if (proxmoxSecretCache.has(secretId)) {
        return proxmoxSecretCache.get(secretId);
    }
    const resp = await fetch('/api/proxmox/credentials/get', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        credentials: 'same-origin',
        body: JSON.stringify({ secret_id: secretId }),
    });
    let data = null;
    try {
        data = await resp.json();
    } catch (err) {
        data = null;
    }
    if (!resp.ok || !data || data.success === false) {
        const message = (data && data.error) ? data.error : `HTTP ${resp.status}`;
        throw new Error(message);
    }
    const creds = data.credentials || null;
    proxmoxSecretCache.set(secretId, creds);
    return creds;
}

const coreSecretCache = new Map();

async function fetchStoredCoreCredentials(secretId) {
    if (!IS_ADMIN_USER || IS_BUILDER_VIEW) return null;
    if (!secretId) return null;
    if (coreSecretCache.has(secretId)) {
        return coreSecretCache.get(secretId);
    }
    const resp = await fetch('/api/core/credentials/get', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        credentials: 'same-origin',
        body: JSON.stringify({ core_secret_id: secretId }),
    });
    let data = null;
    try {
        data = await resp.json();
    } catch (err) {
        data = null;
    }
    if (!resp.ok || !data || data.success === false) {
        const message = (data && data.error) ? data.error : `HTTP ${resp.status}`;
        throw new Error(message);
    }
    const creds = data.credentials || null;
    coreSecretCache.set(secretId, creds);
    return creds;
}

function describeConfigHitlGate({ coreVmVerified }) {
    if (!coreVmVerified) return 'CORE VM has to be selected/verified';
    return '';
}

function _hideDisposeTooltip(el) {
    if (!el || !window.bootstrap || !bootstrap.Tooltip) return;
    try {
        const inst = bootstrap.Tooltip.getInstance(el);
        if (inst) {
            try { inst.hide(); } catch (e) {}
            try { inst.dispose(); } catch (e) {}
        }
    } catch (e) {}
}

function _ensureHoverOnlyTooltip(el, title) {
    if (!el) return;
    // Ensure hover-only so tooltips don't stick due to focus.
    el.setAttribute('data-bs-toggle', 'tooltip');
    el.setAttribute('data-bs-trigger', 'hover');
    el.setAttribute('data-bs-placement', 'top');
    if (title !== undefined) {
        el.setAttribute('data-bs-title', title);
    }
    if (window.bootstrap && bootstrap.Tooltip) {
        _hideDisposeTooltip(el);
        try { new bootstrap.Tooltip(el, { trigger: 'hover', container: 'body' }); } catch (e) {}
    }
    // Defensive: if the element loses hover/focus, force-hide.
    if (!el.dataset._ttBound) {
        el.addEventListener('mouseleave', () => _hideDisposeTooltip(el));
        el.addEventListener('blur', () => _hideDisposeTooltip(el));
        el.dataset._ttBound = '1';
    }
}

function updateHitlEntryButtons({ coreVmVerified }) {
    const configBtn = document.getElementById('configHitlBtn');
    const configWrap = document.getElementById('configHitlBtnWrap');
    const proxyConfigBtn = document.getElementById('scenarioNameConfigHitlBtn');
    const proxyConfigWrap = proxyConfigBtn ? proxyConfigBtn.parentElement : null;
    if (configBtn) {
        const ready = !!coreVmVerified;
        configBtn.disabled = !ready;
        const hint = ready
            ? 'Configure HITL interfaces and participant VMs (Steps 3 & 4).'
            : describeConfigHitlGate({ coreVmVerified }) || 'CORE VM has to be selected/verified';
        // Keep title for non-disabled contexts; bootstrap tooltip will use data-bs-title.
        configBtn.setAttribute('title', hint);
        configBtn.dataset.hitlReady = ready ? '1' : '0';
        configBtn.dataset.hitlHint = hint;

        // Enable tooltip even when the button is disabled by applying it to the wrapper.
        if (configWrap) {
            try {
                if (!ready) {
                    _ensureHoverOnlyTooltip(configWrap, hint);
                } else {
                    _hideDisposeTooltip(configWrap);
                    configWrap.removeAttribute('data-bs-toggle');
                    configWrap.removeAttribute('data-bs-trigger');
                    configWrap.removeAttribute('data-bs-placement');
                    configWrap.removeAttribute('data-bs-title');
                }
            } catch (e) {}
        }

        // Keep the scenario-name proxy button in sync too.
        if (proxyConfigBtn) {
            proxyConfigBtn.disabled = !ready;
            proxyConfigBtn.setAttribute('title', hint);
            if (proxyConfigWrap) {
                try {
                    if (!ready) {
                        _ensureHoverOnlyTooltip(proxyConfigWrap, hint);
                    } else {
                        _hideDisposeTooltip(proxyConfigWrap);
                        proxyConfigWrap.removeAttribute('data-bs-toggle');
                        proxyConfigWrap.removeAttribute('data-bs-trigger');
                        proxyConfigWrap.removeAttribute('data-bs-placement');
                        proxyConfigWrap.removeAttribute('data-bs-title');
                    }
                } catch (e) {}
            }
        }
    }
}

function updateProxmoxSummary(sidx) {
    try {
        const scenario = state.scenarios?.[sidx];
        if (!scenario) return;
        const hitl = ensureHitlStateForScenario(scenario);
        const prox = hitl.proxmox || { url: '', port: 8006, username: '' };
        const proxPort = prox.port ?? 8006;
        const proxHasCreds = IS_BUILDER_VIEW
            ? !!(prox.url || prox.secret_id)
            : !!(prox.url && prox.username);
        const proxValidated = !!(prox.validated && prox.secret_id);
        const normalizeHost = (raw) => {
            if (!raw && raw !== 0) return '';
            let text = String(raw).trim().toLowerCase();
            if (text.startsWith('[') && text.endsWith(']')) text = text.slice(1, -1);
            if (text.startsWith('::ffff:') && /^::ffff:\d+\.\d+\.\d+\.\d+$/.test(text)) {
                text = text.replace('::ffff:', '');
            }
            return text;
        };
        const core = hitl.core || {};
        const coreVmKey = (core.vm_key || '').toString();
        const coreHost = (core.grpc_host || '').toString().trim();
        const corePort = Number.isFinite(Number(core.grpc_port)) && Number(core.grpc_port) > 0 ? Number(core.grpc_port) : 50051;
        const coreSshHostRaw = (core.ssh_host || '').toString().trim();
        const coreSshHost = coreSshHostRaw || coreHost;
        const coreSshPort = Number.isFinite(Number(core.ssh_port)) && Number(core.ssh_port) > 0 ? Number(core.ssh_port) : 22;
        const coreUser = (core.ssh_username || '').toString().trim();
        const coreSecretId = typeof core.core_secret_id === 'string' ? core.core_secret_id.trim() : '';
        const coreHasSecret = !!coreSecretId;
        const corePasswordRaw = (core.ssh_password || '').toString();
        const corePasswordAvailable = !!corePasswordRaw || coreHasSecret;
        const vmKeyParts = coreVmKey ? coreVmKey.split('::') : [];
        const vmKeyNodePart = (vmKeyParts[0] || '').trim();
        const vmKeyIdPart = (vmKeyParts[1] || '').trim();
        const cachedVmInterfaceCount = Number.isFinite(Number(core.cached_vm_interface_count))
            ? Number(core.cached_vm_interface_count)
            : null;
        const liveSelectedVm = (() => {
            const inventory = hitl.proxmox?.inventory;
            const vms = inventory && Array.isArray(inventory.vms) ? inventory.vms : [];
            return vms.find(vm => `${vm.node ?? ''}::${vm.vmid ?? ''}` === coreVmKey) || null;
        })();
        const fallbackCoreVm = (!liveSelectedVm && coreVmKey)
            ? {
                name: core.vm_name || '',
                node: core.vm_node || vmKeyNodePart || '',
                status: core.cached_vm_status || '',
                vmid: vmKeyIdPart || '',
                interface_count_hint: cachedVmInterfaceCount,
            }
            : null;
        const resolvedCoreVm = liveSelectedVm
            ? { ...liveSelectedVm, cached: false }
            : (fallbackCoreVm ? { ...fallbackCoreVm, cached: true } : null);
        const resolvedVmInterfaceCount = (() => {
            if (resolvedCoreVm && Array.isArray(resolvedCoreVm.interfaces)) {
                return resolvedCoreVm.interfaces.length;
            }
            if (resolvedCoreVm && Number.isFinite(resolvedCoreVm.interface_count_hint)) {
                return Number(resolvedCoreVm.interface_count_hint);
            }
            if (cachedVmInterfaceCount !== null) {
                return cachedVmInterfaceCount;
            }
            return null;
        })();
        const interfaceCountKnown = resolvedVmInterfaceCount !== null;
        const coreVmHasInterfaces = !coreVmKey || !interfaceCountKnown || resolvedVmInterfaceCount >= 1;
        const coreVmSupportsHitl = !coreVmKey || !interfaceCountKnown || resolvedVmInterfaceCount >= 2;
        const coreInputsComplete = IS_BUILDER_VIEW
            ? !!(coreVmKey && coreHost && corePort && coreSshHost && coreSshPort && coreHasSecret)
            : !!(coreVmKey && coreHost && corePort && coreSshHost && coreSshPort && coreUser && corePasswordAvailable);
        const coreTestSuccess = core.last_tested_status === 'success';
        const coreTestMatches = coreTestSuccess
            && !!core.last_tested_host
            && normalizeHost(core.last_tested_host) === normalizeHost(coreHost)
            && Number(core.last_tested_port) === Number(corePort);
        const coreConnectionReady = proxValidated && coreInputsComplete && coreVmHasInterfaces && coreTestMatches;
        const coreReady = coreConnectionReady && coreVmSupportsHitl;
        const coreHitlBlocked = coreConnectionReady && !coreVmSupportsHitl;
        const coreTestable = proxValidated && coreInputsComplete && coreVmHasInterfaces;
    const coreVmVerified = !!(core && core.validated === true && coreHasSecret && !!coreVmKey);
    const hitlAuthReady = proxValidated && coreHasSecret && !!coreVmKey;

        const summaryEl = document.querySelector(`[data-proxmox-summary="${sidx}"]`);
        if (summaryEl) {
            const detailParts = [];
            if (proxHasCreds) {
                if (prox.last_message) {
                    detailParts.push(prox.last_message);
                } else if (proxValidated && prox.last_validated_at) {
                    try {
                        const dt = new Date(prox.last_validated_at);
                        if (!Number.isNaN(dt.getTime())) {
                            detailParts.push(`Last checked ${dt.toLocaleString()}`);
                        }
                    } catch (e) { /* ignore */ }
                }
                detailParts.push(prox.verify_ssl === false ? 'SSL verify off' : 'SSL verify on');
            }
            if (IS_BUILDER_VIEW && proxValidated) {
                const stampRaw = prox.last_validated_at || prox.stored_at || null;
                let stamp = '';
                if (stampRaw) {
                    try {
                        const dt = new Date(stampRaw);
                        if (!Number.isNaN(dt.getTime())) {
                            stamp = dt.toLocaleString();
                        }
                    } catch (e) { /* ignore */ }
                }
                detailParts.push(stamp ? `Validated by admin (${stamp})` : 'Validated by admin');
                detailParts.push('Username/password not set in builder view');
            }
            const proxSummary = proxHasCreds
                ? (IS_BUILDER_VIEW
                    ? (proxValidated
                        ? (prox.url ? `Proxmox validated for ${prox.url}:${proxPort}` : 'Proxmox validated')
                        : (prox.url ? `Proxmox assigned for ${prox.url}:${proxPort}` : 'Proxmox assigned'))
                    : (proxValidated
                        ? `Proxmox validated for ${prox.username} @ ${prox.url}:${proxPort}`
                        : `Proxmox pending validation for ${prox.username} @ ${prox.url}:${proxPort}`))
                : 'Proxmox resource not assigned.';
            const detailsText = detailParts.length ? ` • ${detailParts.join(' • ')}` : '';
            summaryEl.textContent = `${proxSummary}${detailsText}`;
            summaryEl.classList.remove('text-success', 'text-warning', 'text-muted', 'text-danger');
            if (proxValidated) summaryEl.classList.add('text-success');
            else if (proxHasCreds) summaryEl.classList.add('text-warning');
            else summaryEl.classList.add('text-muted');
        }

        const assignBtn = document.querySelector(`[data-proxmox-assign][data-scen-idx="${sidx}"]`);
        if (assignBtn) {
            assignBtn.textContent = prox.secret_id ? 'Update Proxmox Resource' : 'Assign Proxmox Resource';
        }
        const proxClearBtn = document.querySelector(`[data-proxmox-clear][data-scen-idx="${sidx}"]`);
        if (proxClearBtn) {
            const hasAny = !!(prox.secret_id || proxHasCreds);
            proxClearBtn.disabled = !hasAny;
        }
        const inventoryStatusEl = document.querySelector(`[data-proxmox-inventory-status="${sidx}"]`);
        if (inventoryStatusEl) {
            const loading = proxInventoryFetchInFlight.has(sidx);
            let statusText = '';
            if (!proxHasCreds) {
                statusText = 'Assign credentials to load VM inventory.';
            } else if (!proxValidated) {
                statusText = 'Validate credentials to load VM inventory.';
            } else if (loading) {
                statusText = 'Fetching Proxmox VM inventory…';
            } else {
                const inv = prox.inventory && typeof prox.inventory === 'object' ? prox.inventory : { vms: [] };
                const vms = Array.isArray(inv.vms) ? inv.vms : [];
                if (vms.length) {
                    const fetchedAt = inv.fetched_at ? (() => {
                        try { return new Date(inv.fetched_at).toLocaleString(); } catch (err) { return null; }
                    })() : null;
                    statusText = `Loaded ${vms.length} VM${vms.length === 1 ? '' : 's'}${fetchedAt ? ` • Last fetched ${fetchedAt}` : ''}`;
                } else if (prox.inventory_error) {
                    statusText = `Inventory error: ${prox.inventory_error}`;
                } else {
                    statusText = 'No VMs reported. Refresh to retry.';
                }
            }
            inventoryStatusEl.textContent = statusText;
            inventoryStatusEl.classList.toggle('text-danger', !!prox.inventory_error);
        }
        const refreshBtn = document.querySelector(`[data-proxmox-refresh][data-scen-idx="${sidx}"]`);
        if (refreshBtn) {
            const loading = proxInventoryFetchInFlight.has(sidx);
            const canRefresh = proxValidated && !loading && !IS_BUILDER_VIEW;
            refreshBtn.disabled = !canRefresh;
            refreshBtn.textContent = loading ? 'Refreshing VMs' : 'Refresh VM List';
            if (IS_BUILDER_VIEW) {
                refreshBtn.title = 'Builder view is read-only. Ask an admin to refresh Proxmox inventory.';
            }
        }
        const refreshBadge = document.querySelector(`[data-proxmox-refresh-badge="${sidx}"]`);
        if (refreshBadge) {
            const loading = proxInventoryFetchInFlight.has(sidx);
            refreshBadge.style.display = loading ? '' : 'none';
            refreshBadge.textContent = 'Refreshing vm list';
        }
        const coreStatusEl = document.querySelector(`[data-hitl-core-status="${sidx}"]`);
        if (coreStatusEl) {
            let statusText = '';
            let className = 'text-muted';
            if (!proxValidated) {
                statusText = 'Validate Proxmox credentials to choose a CORE VM.';
            } else if (!coreVmKey) {
                statusText = 'Select a CORE VM to configure connection details.';
            } else if (!coreVmHasInterfaces) {
                const count = resolvedVmInterfaceCount || 0;
                const plural = count === 1 ? '' : 's';
                statusText = `Selected CORE VM exposes ${count} network interface${plural}. Add at least one interface to enable CORE connectivity.`;
                className = 'text-danger';
            } else if (!coreInputsComplete) {
                statusText = IS_BUILDER_VIEW
                    ? 'CORE credentials are not stored for this scenario in builder view. Ask an admin to verify and store them.'
                    : 'Enter gRPC and SSH connection details, including credentials.';
                className = 'text-warning';
            } else if (!coreVmSupportsHitl) {
                if (coreHitlBlocked) {
                    statusText = 'CORE connection verified. Add a second interface before enabling HITL mappings in Step 3.';
                } else {
                    statusText = 'Selected CORE VM exposes only one interface. Add a second interface before enabling HITL mappings in Step 3.';
                }
                className = 'text-warning';
            } else if (coreReady) {
                const testedAt = core.last_tested_at ? (() => {
                    try { return new Date(core.last_tested_at).toLocaleString(); } catch (err) { return null; }
                })() : null;
                const storedAt = core.last_validated_at ? (() => {
                    try { return new Date(core.last_validated_at).toLocaleString(); } catch (err) { return null; }
                })() : null;
                const storedNote = storedAt
                    ? (IS_BUILDER_VIEW ? ` • Credentials stored by admin ${storedAt}` : ` • Credentials stored ${storedAt}`)
                    : (IS_BUILDER_VIEW ? ' • Credentials stored by admin' : '');
                const builderSuffix = IS_BUILDER_VIEW ? ' • SSH user/password not set in builder view' : '';
                statusText = `CORE connection verified${testedAt ? ` • Last tested ${testedAt}` : ''}${storedNote}${builderSuffix}`;
                className = 'text-success';
            } else if (coreHasSecret && coreTestSuccess) {
                statusText = 'Stored CORE credentials available. Re-test if connection details changed.';
                className = 'text-warning';
            } else if (core.last_tested_status === 'failure') {
                statusText = core.last_tested_message ? `Last test failed: ${core.last_tested_message}` : 'CORE connection test failed.';
                className = 'text-danger';
            } else if (core.last_tested_status === 'success') {
                statusText = 'CORE connection test succeeded for a different endpoint. Update details or re-test.';
                className = 'text-warning';
            } else {
                statusText = IS_BUILDER_VIEW
                    ? 'CORE connection must be verified by an admin.'
                    : 'Test the CORE connection to continue.';
                className = 'text-warning';
            }
            coreStatusEl.textContent = statusText;
            coreStatusEl.classList.remove('text-success', 'text-warning', 'text-muted', 'text-danger');
            coreStatusEl.classList.add(className);
        }
        const testBtn = document.querySelector(`[data-hitl-core-test][data-scen-idx="${sidx}"]`);
        if (testBtn) {
            testBtn.disabled = IS_BUILDER_VIEW || !coreTestable;
            if (IS_BUILDER_VIEW) {
                testBtn.title = 'Builder view is read-only. Ask an admin to validate CORE.';
            }
        }
        const coreClearBtn = document.querySelector(`[data-hitl-core-clear][data-scen-idx="${sidx}"]`);
        if (coreClearBtn) {
            coreClearBtn.disabled = IS_BUILDER_VIEW || !(coreVmKey || coreHost || coreUser || corePasswordRaw || coreSshHostRaw || coreHasSecret);
            if (IS_BUILDER_VIEW) {
                coreClearBtn.title = 'Builder view is read-only. Ask an admin to clear CORE credentials.';
            }
        }

        // Scenario-name "Clear" for Config HITL (only exists for the active scenario).
        if (sidx === activeIdx) {
            const hitlClearBtn = document.getElementById('scenarioNameHitlClearBtn');
            if (hitlClearBtn) {
                const hitlEnabled = !!hitl.enabled;
                const hitlHasValues = (
                    (Array.isArray(hitl.interfaces) && hitl.interfaces.length > 0)
                    || (((hitl.participant_proxmox_url || '').toString().trim()).length > 0)
                    || !!hitl.bridge_validated
                    || (((core.internal_bridge || '').toString().trim()).length > 0)
                    || (((core.internal_bridge_owner || '').toString().trim()).length > 0)
                );
                hitlClearBtn.disabled = (!hitlEnabled) || (!hitlHasValues);
            }
        }
        const summaryDetailEl = document.querySelector(`[data-hitl-core-summary="${sidx}"]`);
        if (summaryDetailEl) {
            const selectedVm = resolvedCoreVm;
            const sanitize = (value) => {
                return String(value ?? '').replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&#39;');
            };
            if (!coreVmKey || !selectedVm) {
                summaryDetailEl.innerHTML = '';
            } else {
                const name = sanitize(selectedVm.name ? String(selectedVm.name) : `VM ${selectedVm.vmid}`);
                const node = sanitize(selectedVm.node ? String(selectedVm.node) : '—');
                const status = selectedVm.status ? sanitize(String(selectedVm.status)) : null;
                const vmid = selectedVm.vmid !== undefined && selectedVm.vmid !== null ? sanitize(String(selectedVm.vmid)) : '—';
                const ifaceCount = Array.isArray(selectedVm.interfaces) ? selectedVm.interfaces.length : 0;
                const ifaceInfo = ifaceCount ? `${ifaceCount} interface${ifaceCount === 1 ? '' : 's'}` : 'No interfaces reported';
                const ifaceLabel = sanitize(ifaceInfo);
                summaryDetailEl.innerHTML = `
                    <div class="border rounded p-3 bg-light small">
                        <div class="d-flex justify-content-between align-items-center mb-2">
                            <span class="fw-semibold">${name}</span>
                            ${status ? `<span class="badge text-bg-secondary text-uppercase">${status}</span>` : ''}
                        </div>
                        <dl class="row mb-0">
                            <dt class="col-5 text-muted">Node</dt><dd class="col-7">${node}</dd>
                            <dt class="col-5 text-muted">VM ID</dt><dd class="col-7">${vmid}</dd>
                            <dt class="col-5 text-muted">Interfaces</dt><dd class="col-7">${ifaceLabel}</dd>
                        </dl>
                    </div>`;
            }
        }
        const step3Enabled = hitl.enabled && hitlAuthReady;
        const gateNotice = document.querySelector(`[data-hitl-interface-gate="${sidx}"]`);
        if (gateNotice) {
            const shouldHide = step3Enabled && coreReady;
            gateNotice.classList.toggle('d-none', shouldHide);
            gateNotice.classList.remove('alert-info', 'alert-warning', 'alert-danger');
            let gateText = 'Complete steps 1 and 2 to map this interface.';
            if (!hitlAuthReady) {
                gateNotice.classList.add('alert-warning');
                if (!proxValidated) gateText = 'Validate Proxmox credentials (Step 1) to unlock HITL interface mappings.';
                else if (!coreHasSecret) gateText = 'Store CORE credentials (Step 2) to unlock HITL interface mappings.';
                else if (!coreVmKey) gateText = 'Select a CORE VM in Step 2 to unlock HITL interface mappings.';
                else gateText = 'Authenticate Steps 1 and 2 to manage HITL interface mappings.';
            } else if (!step3Enabled) {
                gateNotice.classList.add('alert-info');
                gateText = 'Enable Hardware in the Loop to manage HITL interface mappings.';
            } else if (!coreVmKey) {
                gateNotice.classList.add('alert-info');
            } else if (!coreVmHasInterfaces) {
                gateNotice.classList.add('alert-danger');
                gateText = 'Selected CORE VM must expose at least one interface before mapping HITL interfaces.';
            } else if (!coreVmSupportsHitl) {
                gateNotice.classList.add('alert-warning');
                gateText = 'Selected CORE VM exposes only one interface. HITL cannot be used until a second interface is added.';
            } else {
                gateNotice.classList.add('alert-info');
            }
            gateNotice.textContent = gateText;
        }
        const availableSelect = document.querySelector(`[data-hitl-available][data-scen-idx="${sidx}"]`);
        if (availableSelect) {
            availableSelect.disabled = !(coreReady && step3Enabled);
        }
        try { bindHostInterfacesToScenarioCache(sidx); } catch (e) {}
        const hostInterfaces = getEffectiveHostInterfacesForScenario(sidx);
        const selectedNames = new Set((Array.isArray(hitl.interfaces) ? hitl.interfaces : []).map(entry => (entry && entry.name) ? String(entry.name) : '').filter(Boolean));
        const selectableInterfaces = hostInterfaces.filter(entry => {
            if (!entry || !entry.name || selectedNames.has(entry.name)) return false;
            const bridge = (entry.bridge || (entry.proxmox && entry.proxmox.bridge) || (entry.proxmox && entry.proxmox.raw && entry.proxmox.raw.bridge) || '').toString().trim().toLowerCase();
            return bridge !== 'vmbr0';
        });
        const availableCount = selectableInterfaces.length;
        document.querySelectorAll(`[data-hitl-add][data-scen-idx="${sidx}"]`).forEach(btn => {
            btn.disabled = !(coreReady && step3Enabled) || availableCount === 0;
        });
        document.querySelectorAll(`[data-hitl-attach][data-scen-idx="${sidx}"]`).forEach(selectEl => {
            selectEl.disabled = !(coreReady && step3Enabled);
        });
    } catch (e) {
        console.warn('updateProxmoxSummary failed', e);
    }
}

async function fetchProxmoxInventory(sidx, options = {}) {
    const force = !!options.force;
    if (Number.isNaN(sidx) || sidx === null || sidx === undefined) return null;
    const scenario = state.scenarios?.[sidx];
    if (!scenario) return null;
    const hitlState = ensureHitlStateForScenario(scenario);
    const prox = hitlState.proxmox || {};
    const hasSecret = !!prox.secret_id;
    const isValidated = !!(prox.validated && prox.secret_id);
    if (!hasSecret || !isValidated) {
        return null;
    }
    const existingInv = prox.inventory && Array.isArray(prox.inventory.vms) ? prox.inventory.vms : [];
    if (existingInv.length && prox.inventory?.fetched_at && !force) {
        proxInventoryFetchInFlight.delete(sidx);
        if (proxInventoryFetchInFlight.size === 0) {
            toggleEditorBusy(false);
        }
        toggleExternalIfxModalBusy(proxInventoryFetchInFlight.size > 0);
        return prox.inventory;
    }
    if (proxInventoryFetchInFlight.has(sidx)) {
        return null;
    }
    proxInventoryFetchInFlight.add(sidx);
    toggleEditorBusy(true);
    toggleExternalIfxModalBusy(true);
    updateProxmoxSummary(sidx);
    let shouldRerender = false;
    try {
        logInfo(`Fetching Proxmox VM inventory for scenario ${sidx}`);
        const resp = await fetch('/api/proxmox/vms', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            credentials: 'same-origin',
            body: JSON.stringify({ secret_id: prox.secret_id }),
        });
        let data = null;
        try { data = await resp.json(); } catch (err) { data = null; }
        if (!resp.ok || !data || data.success === false) {
            const message = (data && data.error) ? data.error : `Failed to load VM inventory (HTTP ${resp.status})`;
            throw new Error(message);
        }
        const inventory = data.inventory || {};
        const cleanedInventory = {
            fetched_at: inventory.fetched_at || new Date().toISOString(),
            vms: Array.isArray(inventory.vms) ? inventory.vms : [],
        };
        hitlState.proxmox.inventory = cleanedInventory;
        hitlState.proxmox.inventory_error = null;
        persistEditorState();
        const hidden = document.getElementById('scenarios_json');
        if (hidden) hidden.value = JSON.stringify({ scenarios: state.scenarios, active_index: activeIdx });
        const vmCount = cleanedInventory.vms.length;
        try { showToast(`Loaded ${vmCount} Proxmox VM${vmCount === 1 ? '' : 's'}`, { autohide: true, delay: 2500 }); } catch (e) {}
        shouldRerender = true;
        return cleanedInventory;
    } catch (err) {
        const message = err instanceof Error ? err.message : 'Failed to load Proxmox VM inventory';
        hitlState.proxmox.inventory_error = message;
        hitlState.proxmox.inventory = { fetched_at: null, vms: [] };
        persistEditorState();
        const hidden = document.getElementById('scenarios_json');
        if (hidden) hidden.value = JSON.stringify({ scenarios: state.scenarios, active_index: activeIdx });
        logError(message);
        try { showToast(message, { autohide: false }); } catch (e) {}
        shouldRerender = true;
        return null;
    } finally {
        proxInventoryFetchInFlight.delete(sidx);
        if (proxInventoryFetchInFlight.size === 0) {
            toggleEditorBusy(false);
        }
        toggleExternalIfxModalBusy(proxInventoryFetchInFlight.size > 0);
        updateProxmoxSummary(sidx);
        if (shouldRerender) {
            renderMain();
        }
    }
}

const HITL_PREVIEW_CACHE = new WeakMap();

const _sha256K = new Uint32Array([
    0x428a2f98,0x71374491,0xb5c0fbcf,0xe9b5dba5,0x3956c25b,0x59f111f1,0x923f82a4,0xab1c5ed5,
    0xd807aa98,0x12835b01,0x243185be,0x550c7dc3,0x72be5d74,0x80deb1fe,0x9bdc06a7,0xc19bf174,
    0xe49b69c1,0xefbe4786,0x0fc19dc6,0x240ca1cc,0x2de92c6f,0x4a7484aa,0x5cb0a9dc,0x76f988da,
    0x983e5152,0xa831c66d,0xb00327c8,0xbf597fc7,0xc6e00bf3,0xd5a79147,0x06ca6351,0x14292967,
    0x27b70a85,0x2e1b2138,0x4d2c6dfc,0x53380d13,0x650a7354,0x766a0abb,0x81c2c92e,0x92722c85,
    0xa2bfe8a1,0xa81a664b,0xc24b8b70,0xc76c51a3,0xd192e819,0xd6990624,0xf40e3585,0x106aa070,
    0x19a4c116,0x1e376c08,0x2748774c,0x34b0bcb5,0x391c0cb3,0x4ed8aa4a,0x5b9cca4f,0x682e6ff3,
    0x748f82ee,0x78a5636f,0x84c87814,0x8cc70208,0x90befffa,0xa4506ceb,0xbef9a3f7,0xc67178f2,
]);

const _sha256Init = new Uint32Array([
    0x6a09e667,0xbb67ae85,0x3c6ef372,0xa54ff53a,0x510e527f,0x9b05688c,0x1f83d9ab,0x5be0cd19,
]);

function _utf8ToBytes(str){
    if(typeof TextEncoder !== 'undefined'){
        return new TextEncoder().encode(str);
    }
    const bytes = [];
    for(let i=0;i<str.length;i++){
        let code = str.charCodeAt(i);
        if(code < 0x80){
            bytes.push(code);
        } else if(code < 0x800){
            bytes.push(0xc0 | (code >> 6));
            bytes.push(0x80 | (code & 0x3f));
        } else if(code < 0xd800 || code >= 0xe000){
            bytes.push(0xe0 | (code >> 12));
            bytes.push(0x80 | ((code >> 6) & 0x3f));
            bytes.push(0x80 | (code & 0x3f));
        } else {
            i++;
            code = 0x10000 + (((code & 0x3ff) << 10) | (str.charCodeAt(i) & 0x3ff));
            bytes.push(0xf0 | (code >> 18));
            bytes.push(0x80 | ((code >> 12) & 0x3f));
            bytes.push(0x80 | ((code >> 6) & 0x3f));
            bytes.push(0x80 | (code & 0x3f));
        }
    }
    return new Uint8Array(bytes);
}

function _sha256Bytes(message){
    const msg = message instanceof Uint8Array ? message : new Uint8Array(message || []);
    const l = msg.length;
    const bitLenHi = Math.floor((l >>> 29));
    const bitLenLo = (l << 3) >>> 0;
    const paddedLen = ((l + 9 + 63) >> 6) << 6;
    const padded = new Uint8Array(paddedLen);
    padded.set(msg);
    padded[l] = 0x80;
    const view = new DataView(padded.buffer);
    view.setUint32(paddedLen - 8, bitLenHi >>> 0, false);
    view.setUint32(paddedLen - 4, bitLenLo >>> 0, false);
    const w = new Uint32Array(64);
    const H = new Uint32Array(_sha256Init);
    for(let offset=0; offset<paddedLen; offset+=64){
        for(let i=0;i<16;i++){
            w[i] = view.getUint32(offset + (i<<2), false);
        }
        for(let i=16;i<64;i++){
            const s0 = ((w[i-15] >>> 7) | (w[i-15] << 25)) ^ ((w[i-15] >>> 18) | (w[i-15] << 14)) ^ (w[i-15] >>> 3);
            const s1 = ((w[i-2] >>> 17) | (w[i-2] << 15)) ^ ((w[i-2] >>> 19) | (w[i-2] << 13)) ^ (w[i-2] >>> 10);
            w[i] = (((w[i-16] + s0) >>> 0) + ((w[i-7] + s1) >>> 0)) >>> 0;
        }
        let a=H[0],b=H[1],c=H[2],d=H[3],e=H[4],f=H[5],g=H[6],h=H[7];
        for(let i=0;i<64;i++){
            const S1 = ((e>>>6)|(e<<26)) ^ ((e>>>11)|(e<<21)) ^ ((e>>>25)|(e<<7));
            const ch = (e & f) ^ ((~e) & g);
            const temp1 = (h + S1 + ch + _sha256K[i] + w[i]) >>> 0;
            const S0 = ((a>>>2)|(a<<30)) ^ ((a>>>13)|(a<<19)) ^ ((a>>>22)|(a<<10));
            const maj = (a & b) ^ (a & c) ^ (b & c);
            const temp2 = (S0 + maj) >>> 0;
            h = g;
            g = f;
            f = e;
            e = (d + temp1) >>> 0;
            d = c;
            c = b;
            b = a;
            a = (temp1 + temp2) >>> 0;
        }
        H[0] = (H[0] + a) >>> 0;
        H[1] = (H[1] + b) >>> 0;
        H[2] = (H[2] + c) >>> 0;
        H[3] = (H[3] + d) >>> 0;
        H[4] = (H[4] + e) >>> 0;
        H[5] = (H[5] + f) >>> 0;
        H[6] = (H[6] + g) >>> 0;
        H[7] = (H[7] + h) >>> 0;
    }
    const out = new Uint8Array(32);
    const outView = new DataView(out.buffer);
    for(let i=0;i<8;i++){
        outView.setUint32(i<<2, H[i], false);
    }
    return out;
}

function makeDeterministicRng(seed) {
    const base = _sha256Bytes(_utf8ToBytes(String(seed || '')));
    let counter = 0;
    const counterBytes = new Uint8Array(8);
    const counterView = new DataView(counterBytes.buffer);
    return () => {
        counterView.setUint32(0, counter >>> 0, true);
        counterView.setUint32(4, Math.floor(counter / 0x100000000) >>> 0, true);
        counter += 1;
        const combined = new Uint8Array(base.length + counterBytes.length);
        combined.set(base, 0);
        combined.set(counterBytes, base.length);
        const digest = _sha256Bytes(combined);
        let value = 0n;
        for(let i=0;i<8;i++){
            value = (value << 8n) | BigInt(digest[i]);
        }
        return Number(value) / 18446744073709551616;
    };
}

function intToIpv4(value) {
    const num = (Number(value) >>> 0);
    const part1 = (num >>> 24) & 0xff;
    const part2 = (num >>> 16) & 0xff;
    const part3 = (num >>> 8) & 0xff;
    const part4 = num & 0xff;
    return `${part1}.${part2}.${part3}.${part4}`;
}

function slugifyHitlName(rawValue, fallback) {
    let value = '';
    if (typeof rawValue === 'string') {
        value = rawValue.trim().toLowerCase();
    } else if (rawValue !== null && rawValue !== undefined) {
        value = String(rawValue).trim().toLowerCase();
    }
    if (!value) {
        value = (fallback || '').toString().trim().toLowerCase();
    }
    const cleaned = [];
    for (const ch of value) {
        if (/^[a-z0-9]$/.test(ch)) {
            cleaned.push(ch);
        } else if (ch === '-' || ch === '_') {
            cleaned.push(ch);
        } else {
            cleaned.push('-');
        }
    }
    let slug = cleaned.join('').replace(/^[-_]+|[-_]+$/g, '');
    if (!slug) {
        slug = ((fallback || '').toString().trim().toLowerCase()).replace(/^[-_]+|[-_]+$/g, '') || 'iface';
    }
    if (slug.length > 48) slug = slug.slice(0, 48);
    return slug;
}

function computeHitlPreviewLinkIps(scenarioKey, ifaceName, ordinal, prefixLen = 24) {
    try {
        const sanitizedPrefix = Number.isFinite(prefixLen) ? Math.min(Math.max(Math.trunc(prefixLen), 0), 32) : 24;
        const baseNetworkInt = (10 << 24) | (254 << 16); // 10.254.0.0
        const addressSpaceSize = 1 << 16; // /16 block span
        const hostBlock = sanitizedPrefix >= 32 ? 1 : (1 << Math.max(0, 32 - sanitizedPrefix));
        if (hostBlock < 8) {
                const pwdInput = document.querySelector(`[data-hitl-core-field="ssh_password"][data-scen-idx="${sidx}"]`);
                if (pwdInput) pwdInput.removeAttribute('placeholder');
            // Need at least 3 usable hosts (existing router, new router, RJ45)
            return null;
        }
        const subnetSpan = Math.max(0, sanitizedPrefix - 16);
        const totalSubnets = Math.max(1, Math.pow(2, subnetSpan));
        const seed = `${scenarioKey || '__default__'}|${ifaceName || ordinal}|${ordinal}|hitl-link`;
        const rng = makeDeterministicRng(seed);
        const subnetIndex = Math.floor(rng() * totalSubnets) % totalSubnets;
        let networkAddressInt = (baseNetworkInt + (subnetIndex * hostBlock)) >>> 0;
        const maxAddressInt = (baseNetworkInt + addressSpaceSize - 1) >>> 0;
        if (networkAddressInt > maxAddressInt) {
            networkAddressInt = (baseNetworkInt + (networkAddressInt % addressSpaceSize)) >>> 0;
        }
        let broadcastInt = (networkAddressInt + hostBlock - 1) >>> 0;
        if (broadcastInt > maxAddressInt) {
            broadcastInt = (baseNetworkInt + (broadcastInt % addressSpaceSize)) >>> 0;
        }
        const hostInts = [];
        for (let addr = (networkAddressInt + 1) >>> 0; addr < broadcastInt; addr = (addr + 1) >>> 0) {
            hostInts.push(addr >>> 0);
        }
        if (hostInts.length < 3) {
            return null;
        }
        const netmaskInt = sanitizedPrefix === 0 ? 0 : ((0xffffffff << (32 - sanitizedPrefix)) >>> 0);
        const pool = hostInts.slice();
        const selections = [];
        for (let i = 0; i < 3; i++) {
            if (!pool.length) break;
            const choiceIdx = Math.floor(rng() * pool.length) % pool.length;
            selections.push(pool.splice(choiceIdx, 1)[0]);
        }
        if (selections.length < 3) {
            return null;
        }
        return {
            network: intToIpv4(networkAddressInt),
            network_cidr: `${intToIpv4(networkAddressInt)}/${sanitizedPrefix}`,
            prefix_len: sanitizedPrefix,
            netmask: intToIpv4(netmaskInt),
            broadcast_ip4: intToIpv4(broadcastInt),
            existing_router_ip4: intToIpv4(selections[0]),
            new_router_ip4: intToIpv4(selections[1]),
            rj45_ip4: intToIpv4(selections[2]),
        };
    } catch (err) {
        console.warn('HITL: failed to compute preview link IPs', err);
        return null;
    }
}

function deriveHitlLinkMeta(iface, ordinal, totalCount, scenarioKey) {
    if (!iface || typeof iface !== 'object') {
        return {};
    }
    const previewRouter = iface.preview_router || iface.previewRouter || null;
    const previewMetadata = (previewRouter && previewRouter.metadata) || {};
    const result = {
        network: iface.link_network || iface.linkNetwork || null,
        networkCidr: iface.link_network_cidr || iface.linkNetworkCidr || null,
        prefixLen: Number.isFinite(iface.prefix_len) ? Number(iface.prefix_len) : null,
        netmask: iface.netmask || null,
        existingRouterIp4: iface.existing_router_ip4 || null,
        newRouterIp4: iface.new_router_ip4 || null,
        rj45Ip4: iface.rj45_ip4 || null,
        broadcastIp4: iface.broadcast_ip4 || null,
    };
    if (!result.network && previewMetadata.link_network) result.network = previewMetadata.link_network;
    if (!result.networkCidr && previewMetadata.link_network) result.networkCidr = previewMetadata.link_network;
    if (!result.prefixLen && Number.isFinite(previewMetadata.prefix_len)) result.prefixLen = Number(previewMetadata.prefix_len);
    if (!result.netmask && previewMetadata.netmask) result.netmask = previewMetadata.netmask;
    if (!result.existingRouterIp4 && previewMetadata.existing_router_ip4) result.existingRouterIp4 = previewMetadata.existing_router_ip4;
    if (!result.newRouterIp4 && previewMetadata.new_router_ip4) result.newRouterIp4 = previewMetadata.new_router_ip4;
    if (!result.rj45Ip4 && previewMetadata.rj45_ip4) result.rj45Ip4 = previewMetadata.rj45_ip4;
    if (!result.broadcastIp4 && previewMetadata.broadcast_ip4) result.broadcastIp4 = previewMetadata.broadcast_ip4;
    if (previewRouter && typeof previewRouter.ip4 === 'string' && !result.newRouterIp4) {
        result.newRouterIp4 = previewRouter.ip4;
    }
    if (result.newRouterIp4 && typeof result.newRouterIp4 === 'string' && result.newRouterIp4.includes('/')) {
        const parts = result.newRouterIp4.split('/', 2);
        result.newRouterIp4 = parts[0];
        if (!result.prefixLen && parts[1]) {
            const parsed = parseInt(parts[1], 10);
            if (!Number.isNaN(parsed)) {
                result.prefixLen = parsed;
            }
        }
    }
    if (!result.networkCidr && result.network && Number.isFinite(result.prefixLen)) {
        result.networkCidr = `${result.network}/${result.prefixLen}`;
    }
    const needsFallback = !result.networkCidr || !result.newRouterIp4 || !result.rj45Ip4 || !result.existingRouterIp4;
    if (needsFallback) {
        const fallback = computeHitlPreviewLinkIps(scenarioKey, iface.name || `iface-${ordinal + 1}`, ordinal);
        if (fallback) {
            result.network = result.network || fallback.network;
            result.networkCidr = result.networkCidr || fallback.network_cidr || fallback.network;
            result.prefixLen = result.prefixLen || fallback.prefix_len;
            result.netmask = result.netmask || fallback.netmask;
            result.existingRouterIp4 = result.existingRouterIp4 || fallback.existing_router_ip4;
            result.newRouterIp4 = result.newRouterIp4 || fallback.new_router_ip4;
            result.rj45Ip4 = result.rj45Ip4 || fallback.rj45_ip4;
            result.broadcastIp4 = result.broadcastIp4 || fallback.broadcast_ip4;
        }
    }
    if (result.network && Number.isFinite(result.prefixLen) && !result.netmask) {
        const prefix = Math.min(Math.max(Number(result.prefixLen), 0), 32);
        const maskInt = prefix === 0 ? 0 : ((0xffffffff << (32 - prefix)) >>> 0);
        result.netmask = intToIpv4(maskInt);
    }
    if (result.network && Number.isFinite(result.prefixLen) && !result.networkCidr) {
        result.networkCidr = `${result.network}/${result.prefixLen}`;
    }
    return result;
}

function deriveHitlPreviewArtifacts(full) {
    if (!full || typeof full !== 'object') return null;
    if (HITL_PREVIEW_CACHE.has(full)) {
        return HITL_PREVIEW_CACHE.get(full) || null;
    }
    const scenario = Array.isArray(state?.scenarios) ? state.scenarios[activeIdx] : null;
    if (!scenario) {
        HITL_PREVIEW_CACHE.set(full, null);
        return null;
    }
    const hitlState = ensureHitlStateForScenario(scenario);
    if (!hitlState.enabled) {
        HITL_PREVIEW_CACHE.set(full, null);
        return null;
    }
    const scenarioName = (scenario && typeof scenario.name === 'string') ? scenario.name : '';
    const scenarioSeed = scenarioName && scenarioName.trim() ? scenarioName.trim() : '__preview__';
    const rawInterfaces = (hitlState.interfaces || []).filter(entry => entry && typeof entry === 'object' && entry.name);
    if (!rawInterfaces.length) {
        HITL_PREVIEW_CACHE.set(full, null);
        return null;
    }
    const normalizeList = (value) => {
        if (Array.isArray(value)) {
            return value.map(v => (v ?? '').toString().trim()).filter(Boolean);
        }
        if (typeof value === 'string') {
            return value.split(',').map(v => v.trim()).filter(Boolean);
        }
        return [];
    };
    const totalInterfaces = rawInterfaces.length;
    const hitlScenarioKey = (typeof hitlState.scenario_key === 'string' && hitlState.scenario_key.trim())
        ? hitlState.scenario_key.trim()
        : scenarioSeed;
    const interfaces = rawInterfaces.map((entry, idx) => {
        const clone = { ...entry };
        clone.name = (clone.name || '').toString();
        clone.alias = clone.alias ?? clone.description ?? clone.display;
        clone.ipv4 = normalizeList(clone.ipv4);
        clone.ipv6 = normalizeList(clone.ipv6);
        clone.attachment = normalizeHitlAttachment(clone.attachment);
        const fallbackSlug = `iface-${idx + 1}`;
        const slug = slugifyHitlName(clone.name, fallbackSlug);
        clone.slug = slug;
        clone.ordinal = idx;
        const linkMeta = deriveHitlLinkMeta(clone, idx, totalInterfaces, hitlScenarioKey) || {};
        clone.hitl_link_meta = linkMeta;
        if (linkMeta.rj45Ip4 && !clone.rj45_ip4) {
            clone.rj45_ip4 = linkMeta.rj45Ip4;
        }
        if (linkMeta.newRouterIp4 && !clone.new_router_ip4) {
            clone.new_router_ip4 = linkMeta.newRouterIp4;
        }
        if (linkMeta.existingRouterIp4 && !clone.existing_router_ip4) {
            clone.existing_router_ip4 = linkMeta.existingRouterIp4;
        }
        if (linkMeta.networkCidr && !clone.link_network_cidr) {
            clone.link_network_cidr = linkMeta.networkCidr;
        }
        if (linkMeta.netmask && !clone.netmask) {
            clone.netmask = linkMeta.netmask;
        }
        return clone;
    });
    const normalizeName = (raw, idx) => {
        let base = (raw || `iface-${idx}`).toString().trim().toLowerCase();
        base = base.replace(/[^a-z0-9_-]+/g, '-').replace(/-+/g, '-').replace(/^-|-$/g, '');
        if (!base) base = `iface-${idx}`;
        if (base.length > 48) base = base.slice(0, 48);
        return base;
    };
    const existingIds = new Set();
    const noteExisting = val => {
        if (val === undefined || val === null) return;
        existingIds.add(String(val));
    };
    (full.routers || []).forEach(r => noteExisting(r?.node_id ?? r?.id));
    (full.hosts || []).forEach(h => noteExisting(h?.node_id ?? h?.id));
    (full.switches_detail || []).forEach(sw => noteExisting(sw?.switch_id ?? sw?.id));
    const basePreview = full.base_bridge_preview || {};
    noteExisting(basePreview?.bridge_router_id);
    noteExisting(basePreview?.internal_peer_router_id);
    const routerPeers = Array.isArray(full.routers)
        ? full.routers.filter(r => r && r.node_id !== undefined && r.node_id !== null)
        : [];
    routerPeers.sort((a, b) => {
        const aid = Number(a?.node_id ?? a?.id ?? 0);
        const bid = Number(b?.node_id ?? b?.id ?? 0);
        return aid - bid;
    });
    const routerPeerMap = new Map();
    routerPeers.forEach(peer => {
        const peerId = peer?.node_id ?? peer?.id;
        if(peerId !== undefined && peerId !== null){
            routerPeerMap.set(String(peerId), peer);
        }
    });
    const hostPeers = Array.isArray(full.hosts)
        ? full.hosts.filter(h => h && h.node_id !== undefined && h.node_id !== null)
        : [];
    hostPeers.sort((a, b) => {
        const aid = Number(a?.node_id ?? a?.id ?? 0);
        const bid = Number(b?.node_id ?? b?.id ?? 0);
        return aid - bid;
    });
    const existingSubnets = Array.isArray(full.switches_detail)
        ? full.switches_detail.filter(sw => sw && sw.switch_id !== undefined && sw.switch_id !== null).sort((a, b) => {
            const aid = Number(a?.switch_id ?? a?.id ?? 0);
            const bid = Number(b?.switch_id ?? b?.id ?? 0);
            return aid - bid;
        })
        : [];
    const hitlSwitchLookup = new Map();
    existingSubnets.forEach(detail => {
        if (!detail || typeof detail !== 'object') return;
        const meta = (detail.metadata && typeof detail.metadata === 'object') ? detail.metadata : {};
        const slugKey = meta.hitl_slug || meta.hitl_switch_slug || meta.hitl_interface_slug;
        if (slugKey) {
            hitlSwitchLookup.set(`slug:${String(slugKey)}`, detail);
        }
        const ifaceName = meta.hitl_interface_name || meta.interface_name || detail.interface_name;
        if (ifaceName) {
            hitlSwitchLookup.set(`name:${String(ifaceName).toLowerCase().trim()}`, detail);
        }
    });
    const nodes = [];
    const links = [];
    const makeUniqueId = (base) => {
        let candidate = base;
        let suffix = 2;
        while (existingIds.has(String(candidate))) {
            candidate = `${base}-${suffix}`;
            suffix += 1;
        }
        existingIds.add(String(candidate));
        return candidate;
    };
    const includedRouterNodeIds = new Set();
    const includedSwitchNodeIds = new Set();
    const routerOverlayMap = new Map();
    const switchOverlayMap = new Map();
    const routerSwitchInterfaceMap = new Map();

    const registerRouterOverlayNode = (node) => {
        if(!node) return;
        const key = String(node.id ?? node.node_id);
        if(!key) return;
        routerOverlayMap.set(key, node);
    };

    const getOrCreateRouterOverlayNode = (routerId, fallbackLabel = null) => {
        if(routerId === null || routerId === undefined) return null;
        const key = String(routerId);
        if(routerOverlayMap.has(key)){
            return routerOverlayMap.get(key);
        }
        let node = nodes.find(existing => String(existing.id ?? existing.node_id) === key);
        if(!node){
            const basePeer = routerPeerMap.get(key);
            const label = fallbackLabel || basePeer?.name || `Router ${routerId}`;
            node = {
                id: routerId,
                node_id: routerId,
                type: 'router',
                label,
                name: label,
                isHitlRouter: true,
            };
            nodes.push(node);
            includedRouterNodeIds.add(routerId);
        }
        registerRouterOverlayNode(node);
        return node;
    };

    const registerSwitchOverlayNode = (node) => {
        if(!node) return;
        const key = String(node.switch_id ?? node.id);
        if(!key) return;
        switchOverlayMap.set(key, node);
    };

    const registerRouterSwitchInterface = (routerId, entry) => {
        if(routerId === null || routerId === undefined) return;
        const key = String(routerId);
        const list = routerSwitchInterfaceMap.get(key) || [];
        list.push(entry);
        routerSwitchInterfaceMap.set(key, list);
    };
    interfaces.forEach((iface, idx) => {
        const linkMeta = iface.hitl_link_meta || deriveHitlLinkMeta(iface, idx, totalInterfaces, hitlScenarioKey) || {};
        const previewRouterMeta = iface.preview_router || iface.previewRouter || null;
        const baseName = normalizeName(iface.name, idx);
        const attachmentPref = normalizeHitlAttachment(iface.attachment);
        const nodeId = makeUniqueId(baseName);
        const alias = iface.alias;
        const labelParts = [];
        if (iface.name) labelParts.push(iface.name);
        if (alias && alias !== iface.name) {
            labelParts.push(alias);
        } else if (iface.mac) {
            labelParts.push(iface.mac);
        }
        const nodeLabel = labelParts.filter(Boolean).join(' · ') || iface.name || `HITL ${idx + 1}`;
        const hitlNode = {
            id: nodeId,
            type: 'rj45',
            label: nodeLabel,
            name: nodeLabel,
            isHitl: true,
            hitlInterface: iface,
            attachment: attachmentPref,
        };
        if (linkMeta && linkMeta.rj45Ip4) {
            hitlNode.ip4 = linkMeta.rj45Ip4;
        } else if (Array.isArray(iface.ipv4) && iface.ipv4.length) {
            hitlNode.ip4 = iface.ipv4[0];
        }
        if (linkMeta && (linkMeta.networkCidr || linkMeta.network)) {
            hitlNode.linkNetwork = linkMeta.networkCidr || linkMeta.network;
        }
        if (linkMeta && Number.isFinite(linkMeta.prefixLen)) {
            hitlNode.prefixLen = Number(linkMeta.prefixLen);
        }
        if (linkMeta && linkMeta.newRouterIp4) {
            hitlNode.peerRouterIp4 = linkMeta.newRouterIp4;
        }
        if (linkMeta && linkMeta.existingRouterIp4) {
            hitlNode.existingRouterIp4 = linkMeta.existingRouterIp4;
        }
        if (linkMeta && linkMeta.netmask) {
            hitlNode.netmask = linkMeta.netmask;
        }
        if (linkMeta && linkMeta.broadcastIp4) {
            hitlNode.broadcastIp4 = linkMeta.broadcastIp4;
        }
        hitlNode.hitlLinkMeta = linkMeta;
        nodes.push(hitlNode);
        const rng = makeDeterministicRng(`${scenarioSeed}|${iface.name}|${idx}|${interfaces.length}`);
        const attempts = hitlAttachmentAttemptOrder(attachmentPref);
        let targetId = null;
        let assignment = null;
        let linkKind = 'hitl-peer';
        let uplinkRouterId = null;
        const pickRouterPeer = () => {
            if (!routerPeers.length) return null;
            const peer = routerPeers[Math.floor(rng() * routerPeers.length)];
            const peerId = peer?.node_id ?? peer?.id;
            return (peerId !== undefined && peerId !== null) ? peerId : null;
        };
        const pickSwitchPeer = () => {
            if (!existingSubnets.length) return null;
            const subnet = existingSubnets[Math.floor(rng() * existingSubnets.length)];
            const candidateId = subnet?.switch_id ?? subnet?.id;
            return (candidateId !== undefined && candidateId !== null) ? candidateId : null;
        };
        const createNewRouter = () => {
            const matchPreviewRouter = () => {
                if (previewRouterMeta && (previewRouterMeta.node_id ?? previewRouterMeta.nodeId ?? previewRouterMeta.id) !== undefined) {
                    return previewRouterMeta;
                }
                return routerPeers.find(peer => {
                    if (!peer) return false;
                    const meta = peer.metadata || peer.meta || peer.details || null;
                    if (!meta || meta.hitl_preview !== true) return false;
                    if (iface.slug && typeof meta.hitl_slug === 'string' && meta.hitl_slug === iface.slug) return true;
                    const ifaceNameLower = (iface.name || '').toString().trim().toLowerCase();
                    if (ifaceNameLower && typeof meta.hitl_interface_name === 'string' && meta.hitl_interface_name.trim().toLowerCase() === ifaceNameLower) {
                        return true;
                    }
                    if (Number.isFinite(meta.ordinal) && meta.ordinal === idx) return true;
                    return false;
                }) || null;
            };

            const previewRouter = matchPreviewRouter();
            if (previewRouter) {
                const routerId = previewRouter.node_id ?? previewRouter.nodeId ?? previewRouter.id;
                if (routerId !== undefined && routerId !== null) {
                    noteExisting(routerId);
                    const routerLabel = previewRouter.name || `HITL Router ${idx + 1}`;
                    const meta = previewRouter.metadata || previewRouter.meta || {};
                    if (meta && meta.uplink_router_node_id !== undefined && meta.uplink_router_node_id !== null) {
                        uplinkRouterId = meta.uplink_router_node_id;
                    } else if (meta && meta.uplinkRouterId !== undefined && meta.uplinkRouterId !== null) {
                        uplinkRouterId = meta.uplinkRouterId;
                    }
                    const prefixCandidate = Number.isFinite(linkMeta?.prefixLen) ? Number(linkMeta.prefixLen) : Number.isFinite(meta?.prefix_len) ? Number(meta.prefix_len) : null;
                    const routerNode = getOrCreateRouterOverlayNode(routerId, routerLabel);
                    if (routerNode) {
                        const assignIfMissing = (key, value) => {
                            if (value === undefined || value === null) return;
                            if (routerNode[key] === undefined || routerNode[key] === null) {
                                routerNode[key] = value;
                            }
                        };
                        assignIfMissing('label', routerLabel);
                        assignIfMissing('name', routerLabel);
                        routerNode.isHitlRouter = true;
                        routerNode.attachment = routerNode.attachment || attachmentPref;
                        routerNode.previewRouter = routerNode.previewRouter || previewRouter;
                        routerNode.hitlInterface = routerNode.hitlInterface || iface;
                        if (linkMeta && !routerNode.hitlLinkMeta) {
                            routerNode.hitlLinkMeta = linkMeta;
                        }
                        if (meta && meta.new_router_ip4) {
                            const value = prefixCandidate && !String(meta.new_router_ip4).includes('/')
                                ? `${meta.new_router_ip4}/${prefixCandidate}`
                                : meta.new_router_ip4;
                            assignIfMissing('ip4', value);
                        } else if (linkMeta && linkMeta.newRouterIp4) {
                            const value = prefixCandidate && !String(linkMeta.newRouterIp4).includes('/')
                                ? `${linkMeta.newRouterIp4}/${prefixCandidate}`
                                : linkMeta.newRouterIp4;
                            assignIfMissing('ip4', value);
                        } else if (typeof previewRouter.ip4 === 'string') {
                            assignIfMissing('ip4', previewRouter.ip4);
                        }
                        if (meta && meta.existing_router_ip4) {
                            assignIfMissing('peerRouterIp4', meta.existing_router_ip4);
                        } else if (linkMeta && linkMeta.existingRouterIp4) {
                            assignIfMissing('peerRouterIp4', linkMeta.existingRouterIp4);
                        }
                        if (linkMeta && (linkMeta.networkCidr || linkMeta.network)) {
                            assignIfMissing('linkNetwork', linkMeta.networkCidr || linkMeta.network);
                        } else if (meta && meta.link_network) {
                            assignIfMissing('linkNetwork', meta.link_network);
                        }
                        if (Number.isFinite(prefixCandidate)) {
                            assignIfMissing('prefixLen', prefixCandidate);
                        }
                        if (uplinkRouterId !== null && (routerNode.uplinkRouterId === undefined || routerNode.uplinkRouterId === null)) {
                            routerNode.uplinkRouterId = uplinkRouterId;
                        }
                        registerRouterOverlayNode(routerNode);
                    }
                    if (!routerPeers.some(peer => String(peer?.node_id ?? peer?.id) === String(routerId))) {
                        routerPeers.push(previewRouter);
                    }
                    routerPeerMap.set(String(routerId), previewRouter);
                    return routerId;
                }
            }

            const routerId = makeUniqueId(`hitl-router-${baseName}`);
            const routerLabel = `HITL Router ${idx + 1}`;
            const routerNode = getOrCreateRouterOverlayNode(routerId, routerLabel);
            if (routerNode) {
                const assignIfMissing = (key, value) => {
                    if (value === undefined || value === null) return;
                    if (routerNode[key] === undefined || routerNode[key] === null) {
                        routerNode[key] = value;
                    }
                };
                assignIfMissing('label', routerLabel);
                assignIfMissing('name', routerLabel);
                routerNode.isHitlRouter = true;
                routerNode.hitlInterface = routerNode.hitlInterface || iface;
                routerNode.attachment = routerNode.attachment || attachmentPref;
                if (linkMeta && !routerNode.hitlLinkMeta) {
                    routerNode.hitlLinkMeta = linkMeta;
                }
                if (linkMeta && linkMeta.newRouterIp4) {
                    const withPrefix = Number.isFinite(linkMeta.prefixLen) && !String(linkMeta.newRouterIp4).includes('/')
                        ? `${linkMeta.newRouterIp4}/${linkMeta.prefixLen}`
                        : linkMeta.newRouterIp4;
                    assignIfMissing('ip4', withPrefix);
                }
                if (linkMeta && (linkMeta.networkCidr || linkMeta.network)) {
                    assignIfMissing('linkNetwork', linkMeta.networkCidr || linkMeta.network);
                }
                if (linkMeta && Number.isFinite(linkMeta.prefixLen)) {
                    assignIfMissing('prefixLen', Number(linkMeta.prefixLen));
                }
                if (linkMeta && linkMeta.existingRouterIp4) {
                    assignIfMissing('peerRouterIp4', linkMeta.existingRouterIp4);
                }
                registerRouterOverlayNode(routerNode);
            }
            const routerCandidates = routerPeers.length ? routerPeers.slice() : [];
            if (routerCandidates.length) {
                const chosen = routerCandidates[Math.floor(rng() * routerCandidates.length) % routerCandidates.length];
                const chosenId = chosen?.node_id ?? chosen?.id;
                if (chosenId !== undefined && chosenId !== null) {
                    uplinkRouterId = chosenId;
                    if (routerNode && (routerNode.uplinkRouterId === undefined || routerNode.uplinkRouterId === null)) {
                        routerNode.uplinkRouterId = chosenId;
                    }
                    noteExisting(chosenId);
                    links.push({ sourceId: routerId, targetId: chosenId, kind: 'hitl-router-uplink', attachment: attachmentPref, assignment: 'uplink_router', linkMeta });
                }
            }
            routerPeers.push({ node_id: routerId, id: routerId, name: routerLabel, type: 'router', isHitlRouter: true });
            routerPeerMap.set(String(routerId), { node_id: routerId, id: routerId, name: routerLabel, type: 'router', isHitlRouter: true });
            noteExisting(routerId);
            return routerId;
        };
        const createNewSwitch = () => {
            const previewSwitchMetaRaw = iface.preview_switch || iface.previewSwitch || null;
            const previewSwitchId = previewSwitchMetaRaw && (previewSwitchMetaRaw.node_id ?? previewSwitchMetaRaw.nodeId ?? previewSwitchMetaRaw.id);
            if (previewSwitchMetaRaw && previewSwitchId !== undefined && previewSwitchId !== null) {
                const switchId = previewSwitchId;
                const switchLabel = previewSwitchMetaRaw.name || `HITL Switch ${idx + 1}`;
                noteExisting(switchId);
                let switchNode = switchOverlayMap.get(String(switchId));
                if (!switchNode) {
                    switchNode = {
                        id: switchId,
                        switch_id: switchId,
                        type: 'switch',
                        label: switchLabel,
                        name: switchLabel,
                        isHitlSwitch: true,
                        hitlInterface: iface,
                        attachment: attachmentPref,
                        previewSwitch: previewSwitchMetaRaw,
                    };
                    nodes.push(switchNode);
                    includedSwitchNodeIds.add(switchId);
                    registerSwitchOverlayNode(switchNode);
                } else {
                    if (!switchNode.label) switchNode.label = switchLabel;
                    if (!switchNode.name) switchNode.name = switchLabel;
                    switchNode.isHitlSwitch = true;
                    switchNode.hitlInterface = switchNode.hitlInterface || iface;
                    switchNode.attachment = switchNode.attachment || attachmentPref;
                    switchNode.previewSwitch = switchNode.previewSwitch || previewSwitchMetaRaw;
                    registerSwitchOverlayNode(switchNode);
                }
                if (linkMeta && !switchNode.hitlLinkMeta) {
                    switchNode.hitlLinkMeta = linkMeta;
                }
                if (!existingSubnets.some(sw => String(sw?.switch_id ?? sw?.id) === String(switchId))) {
                    existingSubnets.push({ switch_id: switchId, id: switchId, name: switchLabel, isHitlSwitch: true });
                }
                const hintedRouterId = iface.targetRouterId ?? previewSwitchMetaRaw.router_id ?? previewSwitchMetaRaw.routerId ?? null;
                if (hintedRouterId !== null && hintedRouterId !== undefined) {
                    uplinkRouterId = hintedRouterId;
                    if (switchNode.router_id === undefined || switchNode.router_id === null) {
                        switchNode.router_id = hintedRouterId;
                    }
                    if (switchNode.uplinkRouterId === undefined || switchNode.uplinkRouterId === null) {
                        switchNode.uplinkRouterId = hintedRouterId;
                    }
                }
                return switchId;
            }
            const slugKey = iface.slug ? `slug:${iface.slug}` : null;
            const nameKey = iface.name ? `name:${String(iface.name).toLowerCase().trim()}` : null;
            const matchedDetail = (slugKey && hitlSwitchLookup.get(slugKey)) || (nameKey && hitlSwitchLookup.get(nameKey)) || null;
            let switchId;
            let switchLabel;
            if (matchedDetail && matchedDetail.switch_id !== undefined && matchedDetail.switch_id !== null) {
                switchId = matchedDetail.switch_id;
                const meta = (matchedDetail.metadata && typeof matchedDetail.metadata === 'object') ? matchedDetail.metadata : {};
                switchLabel = matchedDetail.name || matchedDetail.label || meta.name || `sw-${switchId}`;
            } else {
                switchId = makeUniqueId(`hitl-switch-${baseName}`);
                switchLabel = `HITL Switch ${idx + 1}`;
            }
            let switchNode = switchOverlayMap.get(String(switchId));
            if (!switchNode) {
                switchNode = {
                    id: switchId,
                    switch_id: switchId,
                    type: 'switch',
                    label: switchLabel,
                    name: switchLabel,
                    isHitlSwitch: true,
                    hitlInterface: iface,
                    attachment: attachmentPref,
                };
                nodes.push(switchNode);
                includedSwitchNodeIds.add(switchId);
            } else {
                if (!switchNode.label) switchNode.label = switchLabel;
                if (!switchNode.name) switchNode.name = switchLabel;
                switchNode.isHitlSwitch = true;
                switchNode.hitlInterface = switchNode.hitlInterface || iface;
                switchNode.attachment = switchNode.attachment || attachmentPref;
            }
            registerSwitchOverlayNode(switchNode);
            const assignSwitchIfMissing = (key, value) => {
                if (value === undefined || value === null) return;
                if (switchNode[key] === undefined || switchNode[key] === null) {
                    switchNode[key] = value;
                }
            };
            if (matchedDetail) {
                assignSwitchIfMissing('router_id', matchedDetail.router_id ?? (matchedDetail.metadata && matchedDetail.metadata.target_router_id));
                assignSwitchIfMissing('uplinkRouterId', matchedDetail.router_id ?? (matchedDetail.metadata && matchedDetail.metadata.target_router_id));
                assignSwitchIfMissing('switch_ip', matchedDetail.switch_ip);
                assignSwitchIfMissing('router_ip', matchedDetail.router_ip);
                assignSwitchIfMissing('link_network_cidr', matchedDetail.rsw_subnet);
                assignSwitchIfMissing('link_network', matchedDetail.rsw_subnet || matchedDetail.lan_subnet);
                if (matchedDetail.host_if_ips && matchedDetail.host_if_ips.rj45 && (!switchNode.host_if_ips || !switchNode.host_if_ips.rj45)) {
                    switchNode.host_if_ips = switchNode.host_if_ips || {};
                    switchNode.host_if_ips.rj45 = matchedDetail.host_if_ips.rj45;
                }
            }
            if (linkMeta) {
                switchNode.hitlLinkMeta = switchNode.hitlLinkMeta || linkMeta;
                assignSwitchIfMissing('switch_ip', linkMeta.rj45Ip4 || null);
                assignSwitchIfMissing('router_ip', linkMeta.newRouterIp4 || null);
                assignSwitchIfMissing('link_network_cidr', linkMeta.networkCidr || null);
                assignSwitchIfMissing('link_network', linkMeta.network || null);
            }
            let routerLinkEstablished = false;
            const routerCandidates = routerPeers.length ? routerPeers.slice() : [];
            if (routerCandidates.length) {
                const chosen = routerCandidates[Math.floor(rng() * routerCandidates.length) % routerCandidates.length];
                const chosenId = chosen?.node_id ?? chosen?.id;
                if (chosenId !== undefined && chosenId !== null) {
                    uplinkRouterId = chosenId;
                    assignSwitchIfMissing('router_id', chosenId);
                    switchNode.uplinkRouterId = switchNode.uplinkRouterId ?? chosenId;
                    noteExisting(chosenId);
                    links.push({ sourceId: switchId, targetId: chosenId, kind: 'hitl-switch-uplink', attachment: attachmentPref, assignment: 'uplink_switch' });
                    routerLinkEstablished = true;
                }
            }
            if (!routerLinkEstablished) {
                const fallbackRouterId = createNewRouter();
                if (fallbackRouterId !== null && fallbackRouterId !== undefined) {
                    uplinkRouterId = fallbackRouterId;
                    assignSwitchIfMissing('router_id', fallbackRouterId);
                    switchNode.uplinkRouterId = fallbackRouterId;
                    noteExisting(fallbackRouterId);
                    links.push({ sourceId: switchId, targetId: fallbackRouterId, kind: 'hitl-switch-uplink', attachment: attachmentPref, assignment: 'uplink_switch' });
                    routerLinkEstablished = true;
                }
            }
            if (!matchedDetail) {
                existingSubnets.push({ switch_id: switchId, id: switchId, name: switchLabel, isHitlSwitch: true });
            }
            noteExisting(switchId);
            return switchId;
        };
        for (const attempt of attempts) {
            if (attempt === 'existing_router') {
                const candidate = pickRouterPeer();
                if (candidate !== null) {
                    targetId = candidate;
                    assignment = 'existing_router';
                    linkKind = 'hitl-router';
                    noteExisting(candidate);
                    uplinkRouterId = candidate;
                    break;
                }
            } else if (attempt === 'existing_switch') {
                const candidate = pickSwitchPeer();
                if (candidate !== null) {
                    targetId = candidate;
                    assignment = 'existing_switch';
                    linkKind = 'hitl-switch';
                    noteExisting(candidate);
                    break;
                }
            } else if (attempt === 'new_router') {
                const newRouterId = createNewRouter();
                if (newRouterId !== null) {
                    targetId = newRouterId;
                    assignment = 'new_router';
                    linkKind = 'hitl-router';
                    break;
                }
            }
        }
        if (targetId === null) {
            const fallbackRouter = pickRouterPeer();
            if (fallbackRouter !== null) {
                targetId = fallbackRouter;
                assignment = assignment ?? 'existing_router';
                linkKind = 'hitl-router';
                noteExisting(fallbackRouter);
                uplinkRouterId = fallbackRouter;
            }
        }
        if (targetId === null && hostPeers.length) {
            const peer = hostPeers[Math.floor(rng() * hostPeers.length)];
            const peerId = peer?.node_id ?? peer?.id;
            if (peerId !== undefined && peerId !== null) {
                targetId = peerId;
                assignment = assignment ?? 'existing_host';
                linkKind = 'hitl-host';
                noteExisting(peerId);
            }
        }
        if (targetId === null) {
            const networkId = makeUniqueId(`hitl-net-${baseName}`);
            const networkLabel = `HITL Network ${idx + 1}`;
            nodes.push({
                id: networkId,
                type: 'network',
                label: networkLabel,
                name: networkLabel,
                isHitlNetwork: true,
                hitlInterface: iface,
                attachment: attachmentPref,
            });
            targetId = networkId;
            assignment = assignment ?? 'network';
            linkKind = 'hitl-network';
        }
        if (targetId !== null) {
            hitlNode.peerNodeId = targetId;
            hitlNode.assignment = assignment || attachmentPref;
            if (uplinkRouterId !== null) {
                hitlNode.uplinkRouterId = uplinkRouterId;
            }
            links.push({
                sourceId: nodeId,
                targetId,
                kind: linkKind,
                attachment: attachmentPref,
                assignment: assignment || attachmentPref,
                linkMeta,
            });
        }
    });
    routerSwitchInterfaceMap.forEach((entries, key) => {
        const routerNode = getOrCreateRouterOverlayNode(key);
        if (routerNode) {
            routerNode.hitlSwitchInterfaces = entries;
        }
    });
    const result = nodes.length ? { nodes, links, interfaces, hitlState } : null;
    HITL_PREVIEW_CACHE.set(full, result);
    return result;
}

function normalizeBaseUpload(meta) {
    if (!meta || typeof meta !== 'object') return null;
    const safe = {};
    if (typeof meta.path === 'string') safe.path = meta.path;
    if (typeof meta.display_name === 'string') safe.display_name = meta.display_name;
    if (Object.prototype.hasOwnProperty.call(meta, 'valid')) safe.valid = !!meta.valid;
    return Object.keys(safe).length ? safe : null;
}

const ROUTER_NODE_TYPES = new Set(['router', 'prouter', 'mdr', 'core-router', 'gateway']);
const SWITCH_NODE_TYPES = new Set(['switch', 'lanswitch', 'l3switch', 'bridge', 'core-switch']);
const DOCKER_NODE_TYPES = new Set(['docker']);
const HOST_NODE_TYPES = new Set(['host', 'pc', 'server', 'workstation', 'client', 'desktop', 'lxc', 'xterm', 'generic', 'terminal', 'laptop']);
const NETWORK_NODE_TYPES = new Set(['network', 'lan', 'wan']);
const WIRELESS_NODE_TYPES = new Set(['wireless', 'wirelesslan', 'wireless-lan', 'wlan', 'wifi']);
const RJ45_NODE_TYPES = new Set(['rj45']);
const HUB_NODE_TYPES = new Set(['hub', 'ethernet', 'tap']);

const NODE_TYPE_STYLE_PRESETS = {
    router: { label: 'Router', color: '#ff7043', radius: 11 },
    switch: { label: 'Switch', color: '#17a2b8', radius: 8 },
    // Distinguish Docker-role hosts vs non-docker hosts in Preview graph.
    host: { label: 'Host (non-docker)', color: 'var(--bs-warning-bg-subtle)', radius: 5 },
    docker: { label: 'Host (Docker)', color: 'var(--bs-warning)', radius: 6 },
    network: { label: 'Network', color: '#6c757d', radius: 7 },
    hub: { label: 'Hub', color: '#7952b3', radius: 6 },
    rj45: { label: 'RJ45', color: '#20c997', radius: 6, shape: 'square' },
    wireless: { label: 'Wireless', color: '#0dcaf0', radius: 6 },
    wlan: { label: 'WLAN', color: '#0dcaf0', radius: 6 },
    tap: { label: 'TAP', color: '#6f42c1', radius: 6 },
};

function canonicalNodeType(raw) {
    if (raw === null || raw === undefined) return 'host';
    const key = String(raw).trim().toLowerCase();
    if (!key) return 'host';
    if (ROUTER_NODE_TYPES.has(key)) return 'router';
    if (SWITCH_NODE_TYPES.has(key)) return 'switch';
    if (RJ45_NODE_TYPES.has(key)) return 'rj45';
    if (WIRELESS_NODE_TYPES.has(key)) return 'wireless';
    if (NETWORK_NODE_TYPES.has(key)) return 'network';
    if (HUB_NODE_TYPES.has(key)) return 'hub';
    if (DOCKER_NODE_TYPES.has(key)) return 'docker';
    if (HOST_NODE_TYPES.has(key)) return 'host';
    return key;
}

function formatNodeTypeLabel(key) {
    if (!key) return 'Node';
    return key.replace(/[-_]/g, ' ').replace(/\b\w/g, c => c.toUpperCase());
}

function nodeStyleForType(rawType) {
    const key = canonicalNodeType(rawType);
    const preset = NODE_TYPE_STYLE_PRESETS[key];
    if (preset) {
        const radius = Number.isFinite(preset.radius) ? preset.radius : 6;
        const shape = preset.shape || 'circle';
        return { ...preset, radius, shape };
    }
    return {
        label: formatNodeTypeLabel(key),
        color: '#adb5bd',
        radius: 6,
        shape: 'circle',
    };
}

function coerceBool(value) {
    if (typeof value === 'boolean') return value;
    if (typeof value === 'number') return value !== 0;
    if (typeof value === 'string') {
        const val = value.trim().toLowerCase();
        return ['1', 'true', 'yes', 'on', 'y'].includes(val);
    }
    return false;
}

function toPositiveInt(value, fallback) {
    if (typeof value === 'number' && Number.isFinite(value) && value > 0) {
        return Math.round(value);
    }
    if (typeof value === 'string') {
        const trimmed = value.trim();
        if (trimmed) {
            const parsed = parseInt(trimmed, 10);
            if (!Number.isNaN(parsed) && parsed > 0) {
                return parsed;
            }
        }
    }
    return fallback;
}

function normalizeCoreState(raw, includePassword = true) {
    const serverDefaults = (initialPayload && typeof initialPayload.core === 'object') ? initialPayload.core : {};
    const defaults = {
        host: (typeof serverDefaults.host === 'string' && serverDefaults.host.trim()) ? serverDefaults.host.trim() : 'localhost',
        port: toPositiveInt(serverDefaults.port, 50051),
        ssh_enabled: true,
        ssh_host: (typeof serverDefaults.ssh_host === 'string' && serverDefaults.ssh_host.trim()) ? serverDefaults.ssh_host.trim() : '',
        ssh_port: toPositiveInt(serverDefaults.ssh_port, 22),
        ssh_username: (typeof serverDefaults.ssh_username === 'string') ? serverDefaults.ssh_username : '',
        auto_start_daemon: !!serverDefaults.auto_start_daemon,
    };
    const serverDefaultVenv = (typeof serverDefaults.venv_bin === 'string' && serverDefaults.venv_bin.trim()) ? serverDefaults.venv_bin.trim() : '';
    const defaultVenvBin = serverDefaultVenv || CORE_DEFAULT_VENV_BIN;
    if (!defaults.ssh_host) defaults.ssh_host = defaults.host;
    const source = (raw && typeof raw === 'object') ? raw : {};
    const out = {
        host: defaults.host,
        port: defaults.port,
        ssh_enabled: true,
        ssh_host: defaults.ssh_host,
        ssh_port: defaults.ssh_port,
        ssh_username: defaults.ssh_username,
        venv_bin: defaultVenvBin,
        auto_start_daemon: defaults.auto_start_daemon,
    };
    if ('host' in source && String(source.host).trim()) {
        out.host = String(source.host).trim();
    }
    out.port = toPositiveInt(source.port, out.port);
    out.ssh_enabled = true;
    if ('ssh_host' in source && String(source.ssh_host).trim()) {
        out.ssh_host = String(source.ssh_host).trim();
    }
    if (!out.ssh_host) {
        out.ssh_host = out.host;
    }
    out.ssh_port = toPositiveInt(source.ssh_port, out.ssh_port);
    if ('ssh_username' in source) {
        out.ssh_username = String(source.ssh_username || '');
    }
    if (includePassword) {
        if ('ssh_password' in source) {
            out.ssh_password = source.ssh_password === null ? '' : String(source.ssh_password);
        } else if (source && typeof source.ssh === 'object' && source.ssh && 'password' in source.ssh) {
            out.ssh_password = String(source.ssh.password || '');
        } else {
            out.ssh_password = '';
        }
    }
    if (!out.ssh_port || !Number.isFinite(out.ssh_port)) {
        out.ssh_port = 22;
    }
    const venvSource = (source.venv_bin ?? source.core_venv_bin);
    if (typeof venvSource === 'string' && venvSource.trim()) {
        out.venv_bin = venvSource.trim();
    }
    if (!out.venv_bin) {
        out.venv_bin = defaultVenvBin;
    }
    out.auto_start_daemon = !!(source.auto_start_daemon ?? out.auto_start_daemon);
    return out;
}

function sanitizeCoreForPersist(coreState) {
    return normalizeCoreState(coreState, false);
}

function mergeCoreSnapshots(primary, secondary) {
    const merged = { ...(primary || {}) };
    if (!secondary || typeof secondary !== 'object') {
        return merged;
    }
    Object.keys(secondary).forEach((key) => {
        const value = secondary[key];
        if (value === undefined) return;
        if (typeof value === 'string') {
            if (!value.trim() && key !== 'ssh_password') return;
            merged[key] = value;
            return;
        }
        if (typeof value === 'number') {
            if (!Number.isFinite(value)) return;
            merged[key] = value;
            return;
        }
        if (typeof value === 'boolean') {
            merged[key] = value;
            return;
        }
        if (value && typeof value === 'object') {
            merged[key] = Array.isArray(value) ? value.slice() : { ...value };
            return;
        }
        merged[key] = value;
    });
    return merged;
}

function restoreCorePasswordFromSession(coreState) {
    const cfg = normalizeCoreState(coreState, true);
    try {
        const stored = sessionStorage.getItem('coretg_core_pw');
        if (stored !== null) {
            cfg.ssh_password = stored;
        }
    } catch (e) {
        /* ignore */
    }
    return cfg;
}

function storeCorePasswordInSession() {
    try {
        const pw = state?.core?.ssh_password ?? '';
        if (pw) {
            sessionStorage.setItem('coretg_core_pw', pw);
        } else {
            sessionStorage.removeItem('coretg_core_pw');
        }
    } catch (e) {
        /* ignore */
    }
}

function getCoreConfig(includePassword = true) {
    const normalized = normalizeCoreState(state?.core || {}, includePassword);
    if (!includePassword && 'ssh_password' in normalized) {
        delete normalized.ssh_password;
    }
    return normalized;
}

function syncGlobalCoreConnection(coreState, testedHost = null, testedPort = null) {
    if (!coreState || typeof coreState !== 'object') return;
    const host = (coreState.grpc_host || '').toString().trim() || 'localhost';
    const portRaw = Number(coreState.grpc_port);
    const port = Number.isFinite(portRaw) && portRaw > 0 ? Number(portRaw) : 50051;
    const sshHostCandidate = (coreState.ssh_host || '').toString().trim();
    const sshHost = sshHostCandidate || host;
    const sshPortRaw = Number(coreState.ssh_port);
    const sshPort = Number.isFinite(sshPortRaw) && sshPortRaw > 0 ? Number(sshPortRaw) : 22;
    const sshUser = (coreState.ssh_username || '').toString();
    const venvBin = (coreState.venv_bin || '').toString().trim();
    const normalized = normalizeCoreState({
        host,
        port,
        ssh_host: sshHost,
        ssh_port: sshPort,
        ssh_username: sshUser,
        venv_bin: venvBin,
        ssh_password: '',
    }, true);
    normalized.ssh_password = '';
    state.core = normalized;
    state.core_ok = true;
    const testedPortNumber = Number(testedPort);
    state.core_tested_host = (testedHost || host || '').toString();
    state.core_tested_port = Number.isFinite(testedPortNumber) && testedPortNumber > 0 ? Number(testedPortNumber) : port;
    try {
        refreshExecuteRemoteToggleState();
    } catch (err) { /* ignore until modal initialized */ }
}

function markGlobalCoreDisconnected() {
    state.core_ok = false;
    state.core_tested_host = null;
    state.core_tested_port = null;
    try {
        refreshExecuteRemoteToggleState();
    } catch (err) { /* ignore until modal initialized */ }
}

function getActiveScenarioContext() {
    const scenarios = Array.isArray(state?.scenarios) ? state.scenarios : [];
    const idx = Number.isInteger(activeIdx) && activeIdx >= 0 && activeIdx < scenarios.length ? activeIdx : null;
    const scenario = (idx !== null) ? scenarios[idx] : null;
    const name = (scenario && typeof scenario.name === 'string') ? scenario.name.trim() : '';
    return { idx, scenario, name };
}

function getActiveScenarioName() {
    return (getActiveScenarioContext().name || '').trim();
}

function buildScenarioAwareUrl(baseUrl, scenarioName = null) {
    if (!baseUrl || typeof baseUrl !== 'string') return baseUrl;
    const sourceName = scenarioName !== null ? scenarioName : getActiveScenarioName();
    const trimmed = (sourceName || '').trim();
    if (!trimmed) return baseUrl;
    try {
        const isAbsolute = /^https?:/i.test(baseUrl);
        const url = new URL(baseUrl, window.location.origin);
        url.searchParams.set('scenario', trimmed);
        return isAbsolute ? url.toString() : `${url.pathname}${url.search}${url.hash}`;
    } catch (e) {
        const sep = baseUrl.includes('?') ? '&' : '?';
        return `${baseUrl}${sep}scenario=${encodeURIComponent(trimmed)}`;
    }
}

function updateActiveScenarioQueryParam() {
    try {
        const { name } = getActiveScenarioContext();
        const trimmed = (name || '').trim();
        const url = new URL(window.location.href);
        const current = (url.searchParams.get('scenario') || '').trim();
        if (trimmed) {
            if (current === trimmed) {
                return;
            }
            url.searchParams.set('scenario', trimmed);
        } else {
            if (!current) {
                return;
            }
            url.searchParams.delete('scenario');
        }
        window.history.replaceState({}, '', url.toString());
        try {
            if (typeof window !== 'undefined' && typeof window.CORETG_PATCH_SCENARIO_NAV === 'function') {
                window.CORETG_PATCH_SCENARIO_NAV(trimmed);
            }
        } catch (e) {
            /* ignore */
        }
    } catch (err) {
        /* ignore */
    }
}

function scheduleScenarioRedirect(baseUrl, options = {}) {
    const delay = Number(options.delay) || 0;
    const scenarioName = typeof options.scenarioName === 'string' ? options.scenarioName : null;
    const targetUrl = buildScenarioAwareUrl(baseUrl, scenarioName) || baseUrl;
    const navigate = () => { window.location.href = targetUrl; };
    if (delay > 0) { setTimeout(navigate, delay); } else { navigate(); }
}

function cloneScenarioCoreFromScenario(scenario, includePassword = true) {
    if (!scenario) return null;
    const hitlState = ensureHitlStateForScenario(scenario);
    if (!hitlState || typeof hitlState !== 'object' || !hitlState.core || typeof hitlState.core !== 'object') {
        return null;
    }
    let clone;
    try {
        clone = JSON.parse(JSON.stringify(hitlState.core));
    } catch (err) {
        clone = { ...hitlState.core };
    }
    if (!includePassword) {
        delete clone.ssh_password;
    }
    return clone;
}

function cloneScenarioCoreByIndex(idx, includePassword = true) {
    if (!Number.isInteger(idx)) return null;
    const scenarios = Array.isArray(state?.scenarios) ? state.scenarios : [];
    if (idx < 0 || idx >= scenarios.length) return null;
    return cloneScenarioCoreFromScenario(scenarios[idx], includePassword);
}

function cloneActiveScenarioCore(includePassword = true) {
    const { scenario } = getActiveScenarioContext();
    return cloneScenarioCoreFromScenario(scenario, includePassword);
}

function formatBytes(value) {
    const num = Number(value);
    if (!Number.isFinite(num) || num <= 0) {
        return '0 B';
    }
    const units = ['B', 'KiB', 'MiB', 'GiB', 'TiB'];
    let idx = 0;
    let current = num;
    while (current >= 1024 && idx < units.length - 1) {
        current /= 1024;
        idx += 1;
    }
    const precision = current >= 10 || idx === 0 ? 0 : 1;
    return `${current.toFixed(precision)} ${units[idx]}`;
}

function appendScenarioContextToFormData(form, options = {}) {
    const { includeCore = true, scenarioIndex = null } = options;
    const { idx: activeIdx, name: activeName } = getActiveScenarioContext();
    const idx = Number.isInteger(scenarioIndex) ? scenarioIndex : activeIdx;
    const scenarios = Array.isArray(state?.scenarios) ? state.scenarios : [];
    const scenario = Number.isInteger(idx) && idx >= 0 && idx < scenarios.length ? scenarios[idx] : null;
    const name = scenario && typeof scenario.name === 'string' ? scenario.name : activeName;
    if (Number.isInteger(idx)) {
        form.append('scenario_index', String(idx));
    }
    if (name) {
        form.append('scenario_name', name);
        form.append('scenario', name);
    }
    if (includeCore) {
        const scenarioCore = cloneScenarioCoreFromScenario(scenario, true);
        if (scenarioCore) {
            form.append('hitl_core_json', JSON.stringify(scenarioCore));
        }
    }
}

function enrichPayloadWithScenarioContext(payload, options = {}) {
    const {
        includeCore = true,
        scenarioIndex = null,
        scenarioOverride = null,
    } = options;
    const scenarios = Array.isArray(state?.scenarios) ? state.scenarios : [];
    let idx = Number.isInteger(scenarioIndex) ? scenarioIndex : null;
    let scenario = scenarioOverride;
    if (!scenario) {
        if (idx !== null && idx >= 0 && idx < scenarios.length) {
            scenario = scenarios[idx];
        } else {
            const { idx: activeIdx, scenario: activeScenario } = getActiveScenarioContext();
            idx = activeIdx;
            scenario = activeScenario;
        }
    }
    if (Number.isInteger(idx)) {
        payload.scenario_index = idx;
    }
    const scenarioName = scenario && typeof scenario.name === 'string' ? scenario.name : '';
    if (scenarioName) {
        payload.scenario = scenarioName;
        payload.scenario_name = scenarioName;
    }
    if (includeCore) {
        const scenarioCore = cloneScenarioCoreFromScenario(scenario, true);
        if (scenarioCore) {
            payload.hitl_core = scenarioCore;
        }
    }
    return payload;
}

function enableAutoStartDaemonPreference() {
    let changed = false;
    if (!state.core) {
        state.core = normalizeCoreState({ auto_start_daemon: true }, true);
        changed = true;
    } else if (!state.core.auto_start_daemon) {
        state.core.auto_start_daemon = true;
        changed = true;
    }
    const { scenario } = getActiveScenarioContext();
    if (scenario) {
        const hitlState = ensureHitlStateForScenario(scenario);
        if (hitlState?.core && hitlState.core.auto_start_daemon !== true) {
            hitlState.core.auto_start_daemon = true;
            changed = true;
        }
    }
    if (changed) {
        try {
            persistEditorState();
            const hidden = document.getElementById('scenarios_json');
            if (hidden) {
                hidden.value = JSON.stringify({ scenarios: state.scenarios, active_index: activeIdx });
            }
        } catch (err) {
            console.warn('Failed to persist auto-start preference', err);
        }
    }
    return true;
}

let persistedActiveIdx = 0;
if (USE_LOCAL_EDITOR_STATE) {
    // Restore persisted editor state (scenarios and last saved xml) and active index from localStorage
    persistedState = projectStateMap[currentProjectKey];
    if (!persistedState && currentProjectKey !== DEFAULT_PROJECT_KEY) {
        persistedState = projectStateMap[DEFAULT_PROJECT_KEY];
    }
    if (!persistedState && scenarioQueryToken) {
        try {
            const matchingKey = Object.keys(projectStateMap || {}).find(key => {
                const entry = projectStateMap[key];
                if (!entry || typeof entry !== 'object') return false;
                const entryScenario = typeof entry.scenario_query === 'string' ? entry.scenario_query.trim() : '';
                return entryScenario && entryScenario === scenarioQueryToken;
            });
            if (matchingKey) {
                persistedState = projectStateMap[matchingKey];
                currentProjectKey = matchingKey;
            }
        } catch (err) {}
    }
    if (!persistedState) {
        const signatureFallback = resolveScenarioQueryHintFromSource(serverEditorSnapshot || initialPayload) || scenarioQueryToken;
        if (signatureFallback) {
            try {
                const signatureKey = `${DEFAULT_PROJECT_KEY}::${signatureFallback.toLowerCase()}`;
                if (projectStateMap[signatureKey]) {
                    currentProjectKey = signatureKey;
                    persistedState = projectStateMap[signatureKey];
                }
            } catch (err) {}
        }
    }
    if (!persistedState) {
        if (serverEditorSnapshot) {
            try {
                persistedState = JSON.parse(JSON.stringify(serverEditorSnapshot));
            } catch (err) {
                persistedState = serverEditorSnapshot;
            }
        }
    }
    const serverSnapshotHasScenarios = Array.isArray(serverEditorSnapshot?.scenarios) && serverEditorSnapshot.scenarios.length > 0;
    const persistedMissingScenarios = (
        !persistedState ||
        !Array.isArray(persistedState.scenarios) ||
        !persistedState.scenarios.length
    );
    if (persistedMissingScenarios && serverSnapshotHasScenarios) {
        try {
            const snapshotClone = JSON.parse(JSON.stringify(serverEditorSnapshot));
            if (snapshotClone) {
                persistedState = snapshotClone;
            }
        } catch (err) {
            persistedState = serverEditorSnapshot;
        }
    }
    if (!persistedState) {
        persistedState = legacyEditorState;
    }

    // Safety net: if the selected key resolves to a minimal snapshot (often 1 scenario)
    // but localStorage contains a richer snapshot, prefer the richer one.
    // This prevents view-mode switches from making scenarios appear to "disappear".
    try {
        const persistedCount = Array.isArray(persistedState?.scenarios) ? persistedState.scenarios.length : 0;
        const serverCount = Array.isArray(initialPayload?.scenarios) ? initialPayload.scenarios.length : 0;
        const wantsRecovery = (!serverResultPath && (persistedCount <= 1) && (serverCount <= 1));
        if (wantsRecovery) {
            const best = pickBestLocalSnapshotByScenarioCount(projectStateMap);
            if (best.snapshot && best.count > persistedCount && best.key) {
                persistedState = best.snapshot;
                currentProjectKey = best.key;
            }
        }
    } catch (err) {}

    // If the URL explicitly asks for a scenario name (e.g. after clicking tabs), do NOT
    // allow a filtered server payload/editor_snapshot to shrink the local scenario list.
    // Instead, pick the richest local snapshot that contains that scenario and use it.
    try {
        const url = new URL(window.location.href);
        const requestedScenarioName = (url.searchParams.get('scenario') || '').trim();
        if (requestedScenarioName) {
            let bestKey = '';
            let bestSnapshot = null;
            let bestCount = 0;
            let bestIdx = 0;
            Object.keys(projectStateMap || {}).forEach((key) => {
                const entry = projectStateMap[key];
                if (!entry || typeof entry !== 'object') return;
                const scenarios = Array.isArray(entry.scenarios) ? entry.scenarios : null;
                if (!scenarios || !scenarios.length) return;
                const idx = scenarios.findIndex(s => ((s && typeof s.name === 'string') ? s.name.trim() : '') === requestedScenarioName);
                if (idx < 0) return;
                const count = scenarios.length;
                if (count > bestCount) {
                    bestCount = count;
                    bestKey = key;
                    bestSnapshot = entry;
                    bestIdx = idx;
                }
            });

            const currentCount = Array.isArray(persistedState?.scenarios) ? persistedState.scenarios.length : 0;
            if (bestSnapshot && bestKey && bestCount >= currentCount && bestCount > 0) {
                persistedState = bestSnapshot;
                currentProjectKey = bestKey;
                activeIdxMap[currentProjectKey] = bestIdx;
                try { writeJsonToLocalStorage(PROJECT_ACTIVE_IDX_STORAGE_KEY, activeIdxMap); } catch (_) {}
                try { localStorage.setItem('coretg_active_idx', String(bestIdx || 0)); } catch (_) {}
                persistedActiveIdx = bestIdx;
            }
        }
    } catch (err) {}

    persistedState = scrubSnapshotTransientErrors(persistedState);
    const activeIdxCandidateRaw = activeIdxMap[currentProjectKey];
    if (activeIdxCandidateRaw !== undefined) {
        const parsedIdx = parseInt(activeIdxCandidateRaw, 10);
        if (!isNaN(parsedIdx)) persistedActiveIdx = parsedIdx;
    } else {
        try { const v = parseInt(localStorage.getItem('coretg_active_idx')||'0',10); if(!isNaN(v)) persistedActiveIdx = v; } catch(e){}
    }
} else {
    // Non-admin / builder view: rely on server-side snapshot persistence.
    persistedState = serverEditorSnapshot;
    try {
        const idx = (serverEditorSnapshot && serverEditorSnapshot.active_index !== undefined)
            ? parseInt(serverEditorSnapshot.active_index, 10)
            : 0;
        if (!isNaN(idx)) persistedActiveIdx = idx;
    } catch (e) {}
}

// Base state is from server payload or default
let state = initialPayload ?? { scenarios: [ defaultScenario('Scenario 1') ], result_path: null };
// Host interface cache: prefer a non-empty server payload; otherwise fall back to persisted cache.
// This prevents a page refresh from wiping out interface-derived summary fields (e.g., CORE VM Bridge)
// when the server renders an empty `host_interfaces: []`.
{
    const serverHostInterfaces = Array.isArray(initialPayload?.host_interfaces) ? initialPayload.host_interfaces : null;
    const persistedHostInterfaces = (USE_LOCAL_EDITOR_STATE && Array.isArray(persistedState?.host_interfaces)) ? persistedState.host_interfaces : null;
    const currentHostInterfaces = Array.isArray(state.host_interfaces) ? state.host_interfaces : null;

    if (serverHostInterfaces && serverHostInterfaces.length) {
        state.host_interfaces = serverHostInterfaces;
    } else if (persistedHostInterfaces && persistedHostInterfaces.length) {
        state.host_interfaces = persistedHostInterfaces;
    } else if (currentHostInterfaces) {
        state.host_interfaces = currentHostInterfaces;
    } else if (serverHostInterfaces) {
        state.host_interfaces = serverHostInterfaces;
    } else {
        state.host_interfaces = [];
    }
}
const persistedHostMeta = USE_LOCAL_EDITOR_STATE ? persistedState : null;
state.host_interfaces_source = (initialPayload?.host_interfaces_source ?? null) || (persistedHostMeta?.host_interfaces_source ?? null) || state.host_interfaces_source || null;
state.host_interfaces_metadata = (initialPayload?.host_interfaces_metadata ?? null) || (persistedHostMeta?.host_interfaces_metadata ?? null) || state.host_interfaces_metadata || null;
state.host_interfaces_fetched_at = (initialPayload?.host_interfaces_fetched_at ?? null) || (persistedHostMeta?.host_interfaces_fetched_at ?? null) || state.host_interfaces_fetched_at || null;
// If server provided a concrete result_path (save/load/run), the server scenarios are authoritative for the
// catalog/source-of-truth list, but we still want locally-edited fields to survive refresh in admin view.
const serverHasResult = !!(initialPayload && initialPayload.result_path);

// Builder/participant view: merge server snapshot values into the server-provided
// scenario list so field edits survive refresh (even if a saved XML/result_path exists).
if (!USE_LOCAL_EDITOR_STATE && serverEditorSnapshot && typeof serverEditorSnapshot === 'object') {
    try {
        const snapScenarios = Array.isArray(serverEditorSnapshot.scenarios) ? serverEditorSnapshot.scenarios : [];
        const serverScenarios = Array.isArray(state.scenarios) ? state.scenarios : [];
        if (!serverScenarios.length && snapScenarios.length) {
            state.scenarios = snapScenarios;
        } else if (serverScenarios.length && snapScenarios.length) {
            const snapByKey = new Map();
            snapScenarios.forEach((snapScen) => {
                if (!snapScen || typeof snapScen !== 'object') return;
                const k = _scenarioMatchKey(snapScen.name);
                if (k && !snapByKey.has(k)) snapByKey.set(k, snapScen);
            });
            state.scenarios = serverScenarios.map((serverScen) => {
                if (!serverScen || typeof serverScen !== 'object') return serverScen;
                const k = _scenarioMatchKey(serverScen.name);
                const snapScen = k ? snapByKey.get(k) : null;
                if (!snapScen || typeof snapScen !== 'object') return serverScen;
                const out = { ...serverScen, ...snapScen };
                out.name = (serverScen.name || snapScen.name || '').toString();
                out.base = { ...(serverScen.base && typeof serverScen.base === 'object' ? serverScen.base : {}), ...(snapScen.base && typeof snapScen.base === 'object' ? snapScen.base : {}) };
                out.hitl = { ...(serverScen.hitl && typeof serverScen.hitl === 'object' ? serverScen.hitl : {}), ...(snapScen.hitl && typeof snapScen.hitl === 'object' ? snapScen.hitl : {}) };
                out.sections = { ...(serverScen.sections && typeof serverScen.sections === 'object' ? serverScen.sections : {}), ...(snapScen.sections && typeof snapScen.sections === 'object' ? snapScen.sections : {}) };
                return out;
            });
        }

        // Prefer snapshot result_path/base_upload when the server hasn't provided one.
        if (!state.result_path && serverEditorSnapshot.result_path) {
            state.result_path = serverEditorSnapshot.result_path;
        }
        const snapBase = normalizeBaseUpload(serverEditorSnapshot.base_upload);
        if (snapBase && (!state.base_upload || !state.base_upload.path)) {
            state.base_upload = { ...snapBase };
        }
    } catch (e) {}
}
const serverScenarioBases = Array.isArray(initialPayload?.scenarios)
    ? initialPayload.scenarios.map(s => {
        if (!s || typeof s !== 'object' || !s.base || typeof s.base !== 'object') return undefined;
        const meta = {};
        if (typeof s.base.filepath === 'string') meta.filepath = s.base.filepath;
        if (typeof s.base.display_name === 'string') meta.display_name = s.base.display_name;
        return Object.keys(meta).length ? meta : undefined;
    })
    : [];
if (USE_LOCAL_EDITOR_STATE && persistedState && Array.isArray(persistedState.scenarios) && persistedState.scenarios.length) {
    // Admin UX: prefer the server-rendered scenario list (catalog-driven) so scenarios like
    // "Scenario 1b" appear consistently. Then append any local-only scenarios so unsaved
    // work in localStorage isn't lost.
    if (!state.result_path && persistedState.result_path) state.result_path = persistedState.result_path;

    try {
        const serverScenarios = Array.isArray(state.scenarios) ? state.scenarios : [];
        const localScenarios = Array.isArray(persistedState.scenarios) ? persistedState.scenarios : [];

        // Build a lookup of local scenarios by match key so we can restore values
        // without letting localStorage hide server/catalog scenarios.
        const localByKey = new Map();
        localScenarios.forEach((localScen) => {
            if (!localScen || typeof localScen !== 'object') return;
            const k = _scenarioMatchKey(localScen.name);
            if (!k) return;
            if (!localByKey.has(k)) {
                localByKey.set(k, localScen);
            }
        });

        const mergeHitlPreservingAdminHints = (serverHitl, localHitl) => {
            const serverObj = (serverHitl && typeof serverHitl === 'object') ? serverHitl : {};
            const localObj = (localHitl && typeof localHitl === 'object') ? localHitl : {};

            // Start by allowing local edits to overlay, but then re-apply server authority
            // for admin-managed fields so stale localStorage cannot wipe them.
            const merged = { ...serverObj, ...localObj };

            const serverCore = (serverObj.core && typeof serverObj.core === 'object') ? serverObj.core : {};
            const localCore = (localObj.core && typeof localObj.core === 'object') ? localObj.core : {};
            const coreMerged = { ...serverCore, ...localCore };
            const serverProx = (serverObj.proxmox && typeof serverObj.proxmox === 'object') ? serverObj.proxmox : {};
            const localProx = (localObj.proxmox && typeof localObj.proxmox === 'object') ? localObj.proxmox : {};
            const proxMerged = { ...serverProx, ...localProx };

            // Server-authoritative CORE fields (managed/verified by admin).
            const coreServerKeys = [
                'core_secret_id',
                'validated',
                'last_validated_at',
                'stored_summary',
                'last_tested_at',
                'last_tested_status',
                'last_tested_message',
                'last_tested_host',
                'last_tested_port',
                'vm_key',
                'vm_name',
                'vm_node',
                'grpc_host',
                'grpc_port',
                'ssh_host',
                'ssh_port',
                // Persist last-known CORE VM interface enumeration across reloads.
                'cached_host_interfaces',
                'cached_host_interfaces_vm_key',
                'cached_host_interfaces_source',
                'cached_host_interfaces_metadata',
                'cached_host_interfaces_fetched_at',
                'cached_vm_interface_count',
                'cached_vm_status',
            ];
            coreServerKeys.forEach((k) => {
                if (Object.prototype.hasOwnProperty.call(serverCore, k)) {
                    coreMerged[k] = serverCore[k];
                }
            });

            // Server-authoritative Proxmox fields (managed/verified by admin).
            const proxServerKeys = [
                'secret_id',
                'validated',
                'last_validated_at',
                'stored_at',
                'last_message',
                'url',
                'port',
                'verify_ssl',
                'inventory',
                'inventory_error',
            ];
            proxServerKeys.forEach((k) => {
                if (Object.prototype.hasOwnProperty.call(serverProx, k)) {
                    proxMerged[k] = serverProx[k];
                }
            });

            merged.core = coreMerged;
            merged.proxmox = proxMerged;

            // HITL config is admin-managed; keep server as source-of-truth.
            if (Object.prototype.hasOwnProperty.call(serverObj, 'enabled')) {
                merged.enabled = !!serverObj.enabled;
            }
            if (Object.prototype.hasOwnProperty.call(serverObj, 'interfaces')) {
                merged.interfaces = Array.isArray(serverObj.interfaces) ? serverObj.interfaces : [];
            }
            // Participant URL hints should not disappear.
            ['participant_proxmox_url', 'participant_ui_url', 'participant_url', 'participant'].forEach((k) => {
                if (Object.prototype.hasOwnProperty.call(serverObj, k)) {
                    merged[k] = serverObj[k];
                }
            });

            return merged;
        };

        const mergedServerScenarios = serverScenarios.map((serverScen) => {
            if (!serverScen || typeof serverScen !== 'object') return serverScen;
            const k = _scenarioMatchKey(serverScen.name);
            const localScen = k ? localByKey.get(k) : null;
            if (!localScen || typeof localScen !== 'object') return serverScen;

            // Prefer local values for user-edited fields, but keep any new server-provided
            // structure/fields around by shallow-merging.
            const out = { ...serverScen, ...localScen };
            out.name = (serverScen.name || localScen.name || '').toString();
            out.base = { ...(serverScen.base && typeof serverScen.base === 'object' ? serverScen.base : {}), ...(localScen.base && typeof localScen.base === 'object' ? localScen.base : {}) };
            out.hitl = mergeHitlPreservingAdminHints(
                (serverScen.hitl && typeof serverScen.hitl === 'object') ? serverScen.hitl : {},
                (localScen.hitl && typeof localScen.hitl === 'object') ? localScen.hitl : {},
            );
            out.sections = { ...(serverScen.sections && typeof serverScen.sections === 'object' ? serverScen.sections : {}), ...(localScen.sections && typeof localScen.sections === 'object' ? localScen.sections : {}) };
            return out;
        });

        const serverKeys = new Set(
            mergedServerScenarios
                .map((scen) => _scenarioMatchKey(scen && typeof scen === 'object' ? scen.name : ''))
                .filter(Boolean)
        );

        // Append any local-only scenarios.
        localScenarios.forEach((localScen) => {
            const k = _scenarioMatchKey(localScen && typeof localScen === 'object' ? localScen.name : '');
            if (!k || serverKeys.has(k)) return;
            mergedServerScenarios.push(localScen);
            serverKeys.add(k);
        });

        state.scenarios = mergedServerScenarios;
    } catch (err) {}
}

if (USE_LOCAL_EDITOR_STATE && persistedState && Array.isArray(persistedState.scenarios) && Array.isArray(state.scenarios)) {
    mergePersistedHitlStateIntoScenarios(state.scenarios, persistedState.scenarios);
}
const serverBaseUpload = normalizeBaseUpload(initialPayload?.base_upload);
const persistedBaseUpload = USE_LOCAL_EDITOR_STATE ? normalizeBaseUpload(persistedState?.base_upload) : null;
if (USE_LOCAL_EDITOR_STATE && !serverHasResult && persistedBaseUpload && (!state.base_upload || !state.base_upload.path)) {
    if (state.scenarios?.[0] && state.scenarios[0].base && (state.scenarios[0].base.filepath || state.scenarios[0].base.display_name)) {
        state.base_upload = { ...persistedBaseUpload };
    }
}
if (serverBaseUpload) {
    state.base_upload = { ...serverBaseUpload };
}
if (state.base_upload && state.scenarios?.[0]) {
    const scenBase = (typeof state.scenarios[0].base === 'object' && state.scenarios[0].base) ? state.scenarios[0].base : (state.scenarios[0].base = {});
    if (!scenBase.filepath && state.base_upload.path) {
        scenBase.filepath = state.base_upload.path;
    }
    if (!scenBase.display_name) {
        if (state.base_upload.display_name) scenBase.display_name = state.base_upload.display_name;
        else if (scenBase.filepath) scenBase.display_name = scenBase.filepath.split(/[/\\]/).pop() || '';
    }
}
if (state.base_upload) {
    if (!state.base_upload.display_name) {
        const fallback = state.scenarios?.[0]?.base?.display_name || (state.base_upload.path ? state.base_upload.path.split(/[/\\]/).pop() : '');
        if (fallback) state.base_upload.display_name = fallback;
    }
    if (!state.base_upload.path && state.scenarios?.[0]?.base?.filepath) {
        state.base_upload.path = state.scenarios[0].base.filepath;
    }
}

function getScenarioByIndex(idx) {
    const scenarios = Array.isArray(state?.scenarios) ? state.scenarios : [];
    if (!Number.isInteger(idx) || idx < 0 || idx >= scenarios.length) {
        return null;
    }
    return scenarios[idx];
}

function resolveScenarioQueryHint() {
    try {
        const token = (scenarioQueryToken || '').trim();
        if (token) return token;
        const signature = deriveScenarioSignature(state);
        if (signature) {
            scenarioQueryToken = signature;
            return signature;
        }
    } catch (err) {
        /* ignore */
    }
    return (scenarioQueryToken || '').trim();
}

const resolveScenarioQueryHintFromSnapshot = resolveScenarioQueryHintFromSource;

(state.scenarios || []).forEach(ensureHitlStateForScenario);
// Clear any stale in-flight flags persisted from a previous session/tab so UI doesn't show a busy state on load
try {
    (state.scenarios || []).forEach((scen) => {
        if (!scen || typeof scen !== 'object') return;
        const hitl = scen.hitl && typeof scen.hitl === 'object' ? scen.hitl : null;
        const core = hitl && typeof hitl.core === 'object' ? hitl.core : null;
        if (core && core.interfaces_refresh_inflight === true) {
            core.interfaces_refresh_inflight = false;
        }
    });
} catch (e) { /* ignore */ }

// Preview workflow state (in-memory only; persisted history handled separately)
let serverSnapshotPendingPayload = null;
let serverSnapshotTimerId = null;
let serverSnapshotDisabled = false;

function scrubHitlForServerSnapshot(snapshotPayload) {
    if (!snapshotPayload || typeof snapshotPayload !== 'object') return;
    const scenarios = Array.isArray(snapshotPayload.scenarios) ? snapshotPayload.scenarios : [];
    scenarios.forEach((scen) => {
        if (!scen || typeof scen !== 'object') return;
        const hitl = (scen.hitl && typeof scen.hitl === 'object') ? scen.hitl : null;
        if (!hitl) return;

        const prox = (hitl.proxmox && typeof hitl.proxmox === 'object') ? hitl.proxmox : null;
        const proxValidated = !!(prox && prox.validated && prox.secret_id);
        if (!proxValidated) {
            delete hitl.proxmox;
        } else {
            // Ensure no secret material is ever sent in snapshots.
            if (prox && 'password' in prox) delete prox.password;
        }

        const core = (hitl.core && typeof hitl.core === 'object') ? hitl.core : null;
        const coreValidated = !!(core && core.validated && (core.core_secret_id || core.secret_id));
        if (!coreValidated) {
            delete hitl.core;
        } else {
            if (core && core.ssh_password) delete core.ssh_password;
        }

        const bridgeValidated = !!hitl.bridge_validated;
        if (!bridgeValidated) {
            hitl.enabled = false;
            delete hitl.interfaces;
            delete hitl.participant_proxmox_url;
            delete hitl.participant_ui_url;
            delete hitl.participant_url;
            if (core && typeof core === 'object') {
                delete core.internal_bridge;
                delete core.internal_bridge_owner;
            }
        }
    });
}

async function transmitEditorSnapshotToServer(payload) {
    if (!payload || serverSnapshotDisabled) return;
    try {
        const resp = await fetch('/api/editor_snapshot', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            credentials: 'same-origin',
            body: JSON.stringify(payload),
        });
        if (resp.status === 401) {
            serverSnapshotDisabled = true;
            return { ok: false, error: 'Authentication required' };
        }
        let data = null;
        try {
            data = await resp.clone().json();
        } catch (e) {
            data = null;
        }
        if (!resp.ok) {
            const detail = (data && typeof data.error === 'string' && data.error.trim())
                ? data.error.trim()
                : await resp.text().catch(() => '');
            return { ok: false, error: (detail || `HTTP ${resp.status}`) };
        }
        if (data && typeof data === 'object' && data.success === false) {
            const err = (typeof data.error === 'string' && data.error.trim()) ? data.error.trim() : 'Snapshot rejected';
            return { ok: false, error: err };
        }
        return { ok: true };
    } catch (err) {
        const message = (err && err.message) ? err.message : 'Failed to persist editor snapshot on server';
        console.warn('Failed to persist editor snapshot on server', err);
        return { ok: false, error: message };
    }
}

function scheduleServerSnapshotPersist(snapshot) {
    if (!snapshot || typeof snapshot !== 'object') {
        return;
    }
    if (serverSnapshotDisabled) {
        return;
    }
    try {
        serverSnapshotPendingPayload = JSON.parse(JSON.stringify(snapshot));
    } catch (err) {
        console.warn('Unable to serialize editor snapshot for server persistence', err);
        return;
    }
    try {
        scrubHitlForServerSnapshot(serverSnapshotPendingPayload);
    } catch (err) {
        /* ignore */
    }
    if (serverSnapshotTimerId) {
        window.clearTimeout(serverSnapshotTimerId);
    }
    serverSnapshotTimerId = window.setTimeout(() => {
        const payload = serverSnapshotPendingPayload;
        serverSnapshotPendingPayload = null;
        serverSnapshotTimerId = null;
        if (!payload) {
            return;
        }
        transmitEditorSnapshotToServer(payload);
    }, 900);
}

async function flushServerSnapshotPersistNow() {
    if (serverSnapshotDisabled) return { ok: false, error: 'Authentication required' };
    const payload = serverSnapshotPendingPayload;
    if (!payload) return { ok: true, skipped: true };
    serverSnapshotPendingPayload = null;
    if (serverSnapshotTimerId) {
        window.clearTimeout(serverSnapshotTimerId);
        serverSnapshotTimerId = null;
    }
    try {
        return await transmitEditorSnapshotToServer(payload);
    } catch (err) {
        const message = (err && err.message) ? err.message : 'Snapshot persist failed';
        return { ok: false, error: message };
    }
}

let previewState = {
    fullPreview: null,
    fullPreviewHistory: [],
    xmlSaved: !!(state.result_path),
    dirty: false,
    coreTested: false
};
const FULL_PREVIEW_ARTIFACT_VERSION = 2;

function safeClone(value){
    if(value === null || typeof value !== 'object') return value;
    try { return structuredClone(value); }
    catch(e){
        try { return JSON.parse(JSON.stringify(value)); }
        catch(err){ return value; }
    }
}

function summarizeSegRule(rule){
    if(!rule) return '';
    const type = rule.type || rule.action || '';
    if(type === 'nat'){
        const mode = rule.mode ? `${rule.mode} ` : '';
        const internal = rule.internal || rule.internal_subnet || '';
        const external = rule.external || rule.external_subnet || '';
        return `${mode}${internal}${(internal && external)?' -> ':''}${external}`.trim();
    }
    if(type === 'host_block'){
        const src = rule.src || rule.source || '';
        const dst = rule.dst || rule.destination || '';
        return `${src} X ${dst}`.trim();
    }
    if(type === 'custom'){
        return rule.description || 'custom';
    }
    if(type){
        const src = rule.src || rule.source;
        const dst = rule.dst || rule.destination;
        if(src || dst){
            return `${type}: ${src || '*'} -> ${dst || '*'}`;
        }
        return type;
    }
    return '';
}

function buildSegmentationArtifacts(full){
    const seg = (full && full.segmentation_preview) || {};
    const rawRules = Array.isArray(seg.rules) ? seg.rules : [];
    const meta = safeClone(seg);
    if(meta && typeof meta === 'object') delete meta.rules;
    if(!rawRules.length){
        return {
            rows: [],
            tableRows: [],
            table_rows: [],
            json: {
                rules_count: 0,
                types_summary: {},
                rules: [],
                metadata: meta || null
            }
        };
    }
    const summaries = [];
    const tableRows = [];
    const typeCounts = {};
    for(const rawEntry of rawRules){
        const entry = safeClone(rawEntry);
        if(!entry || typeof entry !== 'object') continue;
        const rule = ('rule' in entry && entry.rule) ? safeClone(entry.rule) : safeClone(entry);
        if(!rule || typeof rule !== 'object') continue;
        const nodeId = (entry.node_id !== undefined) ? entry.node_id : (rule.node_id !== undefined ? rule.node_id : null);
        const typeRaw = (rule.type !== undefined && rule.type !== null) ? rule.type : rule.action;
        const type = (typeRaw !== undefined && typeRaw !== null) ? String(typeRaw) : null;
        const summary = summarizeSegRule(rule);
        const src = (rule.src !== undefined && rule.src !== null) ? rule.src : rule.source;
        const dst = (rule.dst !== undefined && rule.dst !== null) ? rule.dst : rule.destination;
        const internal = (rule.internal !== undefined && rule.internal !== null) ? rule.internal : rule.internal_subnet;
        const external = (rule.external !== undefined && rule.external !== null) ? rule.external : rule.external_subnet;
        const proto = (rule.proto !== undefined && rule.proto !== null) ? rule.proto : rule.protocol;
        const port = (rule.port !== undefined) ? rule.port : null;
        const scriptPath = typeof entry.script === 'string' ? entry.script : (typeof rule.script === 'string' ? rule.script : null);
        const scriptName = scriptPath ? scriptPath.split('/').pop() : null;
        const tableRow = {
            node_id: nodeId,
            type,
            summary,
            src: src ?? null,
            dst: dst ?? null,
            subnet: rule.subnet ?? null,
            internal: internal ?? null,
            external: external ?? null,
            proto: proto ?? null,
            port,
            script_path: scriptPath || null,
            script_name: scriptName || null,
            detail: rule
        };
        tableRows.push(tableRow);
        summaries.push({ node_id: nodeId, type, summary });
        const key = type || 'unknown';
        typeCounts[key] = (typeCounts[key] || 0) + 1;
    }
    return {
        rows: summaries,
        tableRows,
        table_rows: tableRows,
        json: {
            rules_count: tableRows.length,
            types_summary: typeCounts,
            rules: tableRows.map(row => ({ node_id: row.node_id, type: row.type, summary: row.summary, detail: safeClone(row.detail) })),
            metadata: meta || null
        }
    };
}

function buildFullPreviewArtifacts(full){
    if(!full) return { segmentation: buildSegmentationArtifacts(full) };
    if(full.__displayArtifactsVersion === FULL_PREVIEW_ARTIFACT_VERSION && full.__displayArtifacts){
        return full.__displayArtifacts;
    }
    let artifacts = null;
    if(full.display_artifacts_version === FULL_PREVIEW_ARTIFACT_VERSION && full.display_artifacts){
        artifacts = safeClone(full.display_artifacts);
    }
    if(!artifacts || !artifacts.segmentation){
        artifacts = { segmentation: buildSegmentationArtifacts(full) };
    } else {
        const seg = artifacts.segmentation;
        if(!seg.tableRows || !seg.table_rows || !Array.isArray(seg.rows)){
            artifacts.segmentation = buildSegmentationArtifacts(full);
        }
    }
    artifacts.__version = FULL_PREVIEW_ARTIFACT_VERSION;
    try {
        Object.defineProperty(full, '__displayArtifacts', { value: artifacts, enumerable: false, configurable: true, writable: true });
        Object.defineProperty(full, '__displayArtifactsVersion', { value: FULL_PREVIEW_ARTIFACT_VERSION, enumerable: false, configurable: true, writable: true });
    } catch(e){
        full.__displayArtifacts = artifacts;
        full.__displayArtifactsVersion = FULL_PREVIEW_ARTIFACT_VERSION;
    }
    return artifacts;
}
// Core settings: prefer server-provided if present; otherwise restore from persisted
// ---------------- Plan Workflow State -----------------
// (Legacy alias cleanup left intentionally blank. Using previewState below.)

// ---------- Full Preview History Persistence ----------
function loadFullPreviewHistory(){
    try { previewState.fullPreviewHistory = JSON.parse(localStorage.getItem('coretg_full_preview_history')||'[]'); } catch(e){ previewState.fullPreviewHistory = []; }
    if(!Array.isArray(previewState.fullPreviewHistory)) previewState.fullPreviewHistory = [];
}
function saveFullPreviewHistory(){
    try { localStorage.setItem('coretg_full_preview_history', JSON.stringify(previewState.fullPreviewHistory.slice(-25))); } catch(e){}
}
loadFullPreviewHistory();

// Run progress modal state (hoisted early to avoid TDZ issues)
let runProgressModalInst = null;
let runProgressEvtSrc = null;
let runProgressRunId = null;

function setupPreviewModalExecute(modalEl, modalInstance){
    if(!modalEl) return;
    const execBtn = modalEl.querySelector('#previewModalExecuteBtn');
    if(!execBtn) return;
    if(execBtn.dataset.enhanced === '1') return;
    execBtn.dataset.enhanced = '1';
    execBtn.addEventListener('click', async () => {
        if(execBtn.disabled) return;
        execBtn.disabled = true;
        execBtn.classList.add('disabled');
        let modalHidden = false;
        const forceHideModal = () => {
            try { modalInstance?.hide(); } catch(e){}
            if(modalEl){
                modalEl.classList.remove('show');
                modalEl.setAttribute('aria-hidden','true');
                modalEl.style.display = 'none';
            }
            // Remove any lingering backdrop only if no other modals remain visible
            const openModals = document.querySelectorAll('.modal.show');
            if(openModals.length === 0){
                document.querySelectorAll('.modal-backdrop').forEach(b => {
                    try { b.remove(); } catch(e){}
                });
                document.body.classList.remove('modal-open');
                document.body.style.removeProperty('paddingRight');
                document.body.style.removeProperty('overflow');
            }
        };
        const restoreModal = () => {
            try {
                if(modalInstance){
                    modalInstance.show();
                } else if(modalEl){
                    modalEl.style.display = 'block';
                    modalEl.classList.add('show');
                    document.body.classList.add('modal-open');
                }
            } catch(e){}
        };
        const hideModalForConfirm = async () => {
            if(modalHidden) return;
            forceHideModal();
            modalHidden = true;
            await new Promise(resolve => requestAnimationFrame(() => resolve()));
        };
        const restoreModalIfHidden = () => {
            if(!modalHidden) return;
            modalHidden = false;
            restoreModal();
        };
        const waitForPaint = async () => {
            await new Promise(resolve => requestAnimationFrame(() => resolve()));
        };
        try {
            const execInfo = detectLocalEmulation();
            const confirmMsg = 'Execute this scenario now? This will start a CORE session.';
            const { idx: scenarioIdx } = getActiveScenarioContext();
            await hideModalForConfirm();
            const confirmResult = await promptExecuteConfirmation({
                message: confirmMsg,
                scenarioIndex: scenarioIdx,
                alertMessage: '',
                alertTone: 'info',
                keepOpenOnConfirm: true,
            });
            const updateRemoteRepo = !!confirmResult?.updateRemote;
            if(!confirmResult?.confirmed){
                restoreModalIfHidden();
                execBtn.disabled = false;
                execBtn.classList.remove('disabled');
                return;
            }
            await waitForPaint();
            await new Promise(resolve => setTimeout(resolve, 0));
            showExecuteProgressPanel(
                execInfo.shouldFake ? 'Local emulation run' : 'Preparing CORE run…',
                execInfo.shouldFake
                    ? 'CORE connection unavailable; running locally.'
                    : (IS_BUILDER_VIEW ? 'Remote CORE backend managed by admin.' : `CORE ${execInfo.host}:${execInfo.port}`)
            );
            try {
                const showBtn = document.getElementById('dockShowBtn');
                if(showBtn && !showBtn.classList.contains('d-none')) showBtn.click();
            } catch(e){}

            let launchFailed = false;
            const result = await runSyncWithModal({
                showProgressModal: false,
                skipConfirm: true,
                scenarioIndex: scenarioIdx,
                updateRemoteRepo,
                confirmResult,
                advanced: confirmResult?.advanced,
                onRunId: (runId) => {
                    bindExecuteProgressToRun(runId);
                },
                onTick: (data) => {
                    if(data && !data.done){
                        setExecuteProgressStatus('Running CLI…', 'Streaming logs…');
                    }
                },
                onComplete: (data) => {
                    if(data?.returncode === 0){
                        completeExecuteProgressPanel(true, 'Scenario started', 'Redirecting to reports…');
                        try {
                            setTimeout(()=>{
                                if(executeConfirmModalEl && window.bootstrap){
                                    bootstrap.Modal.getOrCreateInstance(executeConfirmModalEl).hide();
                                }
                            }, 200);
                        } catch(e){}
                        try {
                            scheduleScenarioRedirect("{{ url_for('reports_page') }}", { delay: 500 });
                        } catch(e){}
                    } else {
                        completeExecuteProgressPanel(false, 'Finished with errors', 'Check logs for details.');
                    }
                    try {
                        if(data?.returncode !== 0){
                            restoreModal();
                        }
                    } catch(e){}
                },
                onError: (err) => {
                    const detail = (err && err.message) ? err.message : 'Unable to launch CLI';
                    completeExecuteProgressPanel(false, 'Failed to start', detail);
                    launchFailed = true;
                    restoreModal();
                },
            });
            if(result === false){
                if(!launchFailed){
                    completeExecuteProgressPanel(false, 'Failed to start', 'Request aborted');
                    restoreModal();
                }
                return;
            }
        } catch(err){
            console.error('Preview execute failed', err);
            closeRunProgress();
            restoreModal();
        } finally {
            execBtn.disabled = false;
            execBtn.classList.remove('disabled');
        }
    });
}

function updatePlanButtons(){
    const previewBtn = document.getElementById('planPreviewBtn');
    const statusBadge = document.getElementById('planStatusBadge');
    const hint = document.getElementById('planHint');
    const genBtn = document.getElementById('runSyncBtn');
    const xmlPathVal = (state.result_path || '').trim();
    previewState.xmlSaved = !!xmlPathVal;
    const canPreview = previewState.xmlSaved || previewState.dirty;
    if(previewBtn) previewBtn.disabled = !canPreview;
    if(genBtn) genBtn.disabled = !canPreview;
    if(hint){
    if(!previewState.xmlSaved) hint.textContent = 'Save XML to enable planning.';
    else hint.textContent = previewState.fullPreview ? 'Full preview ready.' : 'Generate a full preview.';
    }
    if(statusBadge){
    statusBadge.className = 'badge ' + (previewState.fullPreview ? 'text-bg-info' : 'text-bg-secondary');
    statusBadge.textContent = previewState.fullPreview ? 'Preview' : 'No Preview';
    }
}


function showPlanSummary(summary){
    const pre = document.getElementById('planPreviewJson');
    if(!pre) return;
    pre.classList.remove('d-none');
    try{ pre.textContent = JSON.stringify(summary, null, 2); }catch(e){ pre.textContent='(error displaying plan)'; }
}

async function computePlanPreview(){
    // Deprecated lightweight preview replaced by full preview; delegate
    return computeFullPlanPreview();
}

// Approval functions removed

function onCoreTestedSuccess(){ previewState.coreTested = true; updatePlanButtons(); }

// Hook into existing CORE test result update
const originalUpdateCoreStatus = window.updateCoreStatus; // if defined later, we patch after definition
window.updateCoreStatus = function(success, msg){
    if(typeof originalUpdateCoreStatus === 'function') originalUpdateCoreStatus(success, msg);
    if(success) onCoreTestedSuccess();
};

document.addEventListener('DOMContentLoaded', () => {
    document.getElementById('planPreviewBtn')?.addEventListener('click', computePlanPreview);
    // Scenarios header Preview tab: save XML, then navigate to /scenarios/preview.
    document.getElementById('scenariosPreviewTabLink')?.addEventListener('click', async (ev)=>{
        try {
            ev.preventDefault();
            if (IS_BUILDER_VIEW) {
                // Builder view: show a preview of the current configuration without saving.
                try { await computeFullPlanPreview(); } catch(e) { /* ignore */ }
                return;
            }
            if (typeof window.coretgSaveAllAndGoPreview !== 'function') {
                alert('Save helper unavailable; refresh and try again.');
                return;
            }
            await window.coretgSaveAllAndGoPreview();
        } catch(e){
            try { ev.preventDefault(); } catch(_e){}
        }
    });

    // Shared Scenarios Preview button: save XML, then navigate to /scenarios/preview.
    document.getElementById('scenariosExecuteBtn')?.addEventListener('click', (ev)=>{
        try {
            ev.preventDefault();
            document.getElementById('scenariosPreviewTabLink')?.click();
        } catch(e){}
    });

    // Allow other tabs (Preview / Full Preview) to delegate execution here.
    try {
        const url = new URL(window.location.href);
        const params = url.searchParams;
        const autoExecute = (params.get('auto_execute') || '') === '1';
        const xmlPathFromUrl = (params.get('xml_path') || '').trim();
        if (xmlPathFromUrl && xmlPathFromUrl.endsWith('.xml')) {
            try {
                if (!state.result_path || String(state.result_path).trim() !== xmlPathFromUrl) {
                    state.result_path = xmlPathFromUrl;
                    try { updateDownloadButtonState(); } catch (e) {}
                    try { persistEditorState(); } catch (e) {}
                    try { refreshXmlDockPreview({ force: true, preferSavedPath: true }); } catch (e) {}
                }
            } catch (e) {}
        }
        if (autoExecute) {
            // Auto-execute comes from the Preview tab's Execute button.
            // The shared bottom-bar button is now "Preview", so we must call the actual
            // execution entrypoint.
            setTimeout(() => {
                try {
                    if (typeof runSyncWithModal === 'function') {
                        runSyncWithModal({ showProgressModal: true, skipConfirm: false });
                        return;
                    }
                } catch (e) {}
                try { alert('Execute unavailable: runSyncWithModal not found.'); } catch (e) {}
            }, 250);
            // Prevent repeated execution prompts on reload/back.
            params.delete('auto_execute');
            params.delete('xml_path');
            const qs = params.toString();
            const newUrl = url.pathname + (qs ? ('?' + qs) : '') + url.hash;
            window.history.replaceState({}, '', newUrl);
        }
    } catch (e) {}
    try { updatePlanButtons(); } catch(e){}
});

async function computeFullPlanPreview(){
    let newXmlPath = (state.result_path || '').trim();
    if (!IS_BUILDER_VIEW) {
        if(!newXmlPath){
            try { await autoSaveXml(); } catch(e){ alert('Auto-save failed: '+e); return; }
        }
        newXmlPath = (state.result_path || '').trim();
        if(!newXmlPath){ alert('XML path still unavailable after save.'); return; }
    }
    const btn = document.getElementById('planPreviewBtn');
    const pre = document.getElementById('planPreviewJson');
    if (btn) {
        btn.disabled = true;
        btn.dataset.prevLabel = btn.textContent;
        btn.textContent = 'Full preview...';
    }
    if (pre) {
        pre.classList.remove('d-none');
        pre.textContent = 'Computing full preview...';
    }
    try {
    // Collect routing row host-per-switch overrides (min/max)
    let r2sHostsMinList = [];
    let r2sHostsMaxList = [];
    try {
        const scen = state.scenarios[0];
        if (scen && scen.sections && scen.sections['Routing']) {
            (scen.sections['Routing'].items || []).forEach(it => {
                    if (id) {
                        const escapedId = (window.CSS && typeof window.CSS.escape === 'function') ? window.CSS.escape(id) : id;
                        const lbl = coreConnectionForm.querySelector(`label[for="${escapedId}"]`);
                }
            });
        }
                    coreState.core_secret_id = null;
                    coreState.validated = false;
                    coreState.last_validated_at = null;
                    coreState.stored_summary = null;
    } catch(e) { /* ignore */ }
    const baseBody = IS_BUILDER_VIEW
        ? { scenarios: state.scenarios, r2s_hosts_min_list: r2sHostsMinList, r2s_hosts_max_list: r2sHostsMaxList, core: getCoreConfig(true) }
        : { xml_path: newXmlPath, r2s_hosts_min_list: r2sHostsMinList, r2s_hosts_max_list: r2sHostsMaxList, core: getCoreConfig(true) };
    const body = enrichPayloadWithScenarioContext(baseBody);
        const res = await fetch('/api/plan/preview_full', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(body) });
        const data = await res.json();
        try {
            if(window.logLine){ window.logLine('INFO', 'Preview: response received; parsing plan summary'); }
        } catch(e){}
    if(!data.ok){
            if (pre) pre.textContent='Full preview failed: '+(data.error||'');
            previewState.fullPreview=null;
            document.getElementById('fullPreviewStructured')?.classList.add('d-none');
        }
        else {
            previewState.fullPreview = data.full_preview;
            buildFullPreviewArtifacts(previewState.fullPreview);
            if (pre) pre.textContent = JSON.stringify(previewState.fullPreview, null, 2);
            renderFullPreviewStructured();
            // Emit detailed calculation logs into dock
            try {
                const fp = previewState.fullPreview || {};
                // Traffic breakdown
                try {
                    if(fp.traffic_summary){
                        const ts = fp.traffic_summary;
                        const flows = ts.total_flows || ts.flows || 'n/a';
                        window.logLine && window.logLine('INFO', `[preview.plan.traffic] flows=${flows}`);
                    }
                } catch(e){}
            } catch(e){ /* ignore logging issues */ }
            try { showFullPreviewModal(previewState.fullPreview); } catch(e){ console.warn('Modal render failed', e); }
            // Append to history
            try {
                const fp = previewState.fullPreview;
                previewState.fullPreviewHistory.push({
                    ts: Date.now(),
                    seed: fp.seed,
                    seed_generated: fp.seed_generated,
                    stats: {
                        routers: (fp.routers||[]).length,
                        hosts: (fp.hosts||[]).length,
                        switches: (fp.switches||[]).length,
                        r2r_edges: (fp.r2r_edges_preview||[]).length,
                        seg_rules: (fp.segmentation_preview && fp.segmentation_preview.rules ? fp.segmentation_preview.rules.length : 0)
                    },
                    preview: fp
                });
                saveFullPreviewHistory();
            } catch(e){}
        }
    } catch(e){
        if (pre) pre.textContent='Error: '+e;
        previewState.fullPreview=null;
    }
    if (btn) {
        btn.disabled = false;
        btn.textContent = btn.dataset.prevLabel || 'Full Preview';
    }
}

function renderFullPreviewStructured(){
    const wrap = document.getElementById('fullPreviewStructured');
    if(!wrap) return;
    const full = previewState.fullPreview;
    if(!full){ wrap.classList.add('d-none'); return; }
    wrap.classList.remove('d-none');
    const tabsEl = document.getElementById('fullPreviewSectionTabs');
    const contentEl = document.getElementById('fullPreviewSectionContent');
    if(!tabsEl || !contentEl) return;
    const sections = [
        { id:'overview', label:'Overview' },
        { id:'routers', label:`Routers (${(full.routers||[]).length})` },
        { id:'hosts', label:`Hosts (${(full.hosts||[]).length})` },
        { id:'switches', label:`Switches (${(full.switches||[]).length})` },
        { id:'subnets', label:'Subnets' },
        { id:'r2r', label:`R2R Edges (${(full.r2r_edges_preview||[]).length})` },
        { id:'seg', label:`Seg Rules (${(full.segmentation_preview && full.segmentation_preview.rules ? full.segmentation_preview.rules.length : 0)})` },
        { id:'services_bd', label:'Services Plan' },
        { id:'vuln_bd', label:'Vuln Plan' },
        { id:'seg_bd', label:'Seg Plan' },
        { id:'router_bd', label:'Router Plan' },
        { id:'traffic_bd', label:'Traffic Plan' },
        { id:'history', label:'History' },
    ];
    // Build tabs
    tabsEl.innerHTML = '';
    sections.forEach((s, idx) => {
        const b = document.createElement('button');
        b.type='button'; b.className='btn btn-outline-primary' + (idx===0?' active':'');
        b.textContent = s.label;
        b.dataset.section = s.id;
        b.onclick = () => { tabsEl.querySelectorAll('button').forEach(x=>x.classList.remove('active')); b.classList.add('active'); renderSectionContent(s.id); };
        tabsEl.appendChild(b);
    });
    function esc(x){ return (''+x).replace(/[&<>]/g,c=>({'&':'&amp;','<':'&lt;','>':'&gt;'}[c])); }
    function renderSectionContent(id){
        if(id==='overview'){
            const stats = [
                ['Routers', (full.routers||[]).length],
                ['Hosts', (full.hosts||[]).length],
                ['Switches', (full.switches||[]).length],
                ['R2R Edges', (full.r2r_edges_preview||[]).length],
                ['Avg R2R Deg', full.r2r_stats_preview && full.r2r_stats_preview.avg],
                ['Seg Rules', full.segmentation_preview && full.segmentation_preview.rules ? full.segmentation_preview.rules.length : 0],
                ['P2P /24', (full.ptp_subnets||[]).length],
                ['Router-Sw /24', (full.router_switch_subnets||[]).length],
                ['LAN /24', (full.lan_subnets||[]).length],
                // Seed removed from UI summary
            ];
            contentEl.innerHTML = '<div class="row g-2">' + stats.map(s=>`<div class="col-auto"><span class="badge text-bg-secondary">${esc(s[0])}: ${esc(s[1]??'-')}</span></div>`).join('') + '</div>';
            return;
        }
        if(id==='routers'){
            contentEl.innerHTML = tableFromObjects(full.routers || [], ['node_id','name','ip4']); return;
        }
        if(id==='hosts'){
            contentEl.innerHTML = tableFromObjects(full.hosts || [], ['node_id','name','role','ip4']); return;
        }
        if(id==='switches'){
            const rows = full.switches_detail || [];
            contentEl.innerHTML = tableFromObjects(rows, ['switch_id','router_id','hosts','rsw_subnet','lan_subnet']); return;
        }
        if(id==='subnets'){
            const p2p = (full.ptp_subnets||[]).map(s=>`<li>${esc(s)}</li>`).join('');
            const rs = (full.router_switch_subnets||[]).map(s=>`<li>${esc(s)}</li>`).join('');
            const lan = (full.lan_subnets||[]).map(s=>`<li>${esc(s)}</li>`).join('');
            contentEl.innerHTML = `<div class="row small g-3"><div class="col"><h6 class="fw-bold">Host P2P (/24)</h6><ul class="mb-0">${p2p||'<li>(none)</li>'}</ul></div><div class="col"><h6 class="fw-bold">Router-Switch (/24)</h6><ul class="mb-0">${rs||'<li>(none)</li>'}</ul></div><div class="col"><h6 class="fw-bold">LAN (/24)</h6><ul class="mb-0">${lan||'<li>(none)</li>'}</ul></div></div>`; return;
        }
        if(id==='r2r'){
            const edges = full.r2r_edges_preview || [];
            const deg = full.r2r_degree_preview || {};
            const degList = Object.entries(deg).map(([k,v])=>`r${k}:${v}`).join(', ');
            const spark = Object.values(deg).join(' ');
            const edgesSample = edges.slice(0,200).map(e=>`(${e[0]}-${e[1]})`).join(' ');
            contentEl.innerHTML = `<div><div class="mb-2"><strong>Degree Stats:</strong> ${esc(JSON.stringify(full.r2r_stats_preview||{}))}</div><div class="mb-2"><strong>Degrees:</strong> ${esc(degList||'(none)')}</div><div class="mb-2"><strong>Edges (${edges.length}):</strong> ${esc(edgesSample||'(none)')} ${edges.length>200?'...':''}</div><div><strong>Spark:</strong> ${esc(spark)}</div></div>`; return;
        }
        if(id==='seg'){
            const artifacts = buildFullPreviewArtifacts(full);
            const segRows = (artifacts && artifacts.segmentation && artifacts.segmentation.rows) || [];
            contentEl.innerHTML = tableFromObjects(segRows, ['node_id','type','summary']);
            return;
        }
        if(id==='router_bd'){
            const rp = (full.router_plan)||{};
            contentEl.innerHTML = `<pre class="small mb-0">${esc(JSON.stringify(rp,null,2))}</pre>`; return;
        }
        if(id==='services_bd'){
            const sp = (full.services_plan)||{};
            contentEl.innerHTML = `<pre class="small mb-0">${esc(JSON.stringify(sp,null,2))}</pre>`; return;
        }
        if(id==='vuln_bd'){
            const vp = (full.vulnerabilities_plan)||{};
            contentEl.innerHTML = `<pre class="small mb-0">${esc(JSON.stringify(vp,null,2))}</pre>`; return;
        }
        if(id==='seg_bd'){
            const sb = (full.segmentation_preview)||{};
            contentEl.innerHTML = `<pre class="small mb-0">${esc(JSON.stringify(sb,null,2))}</pre>`; return;
        }
        if(id==='traffic_bd'){
            const tp = (full.traffic_summary)||{};
            contentEl.innerHTML = `<pre class="small mb-0">${esc(JSON.stringify(tp,null,2))}</pre>`; return;
        }
        if(id==='history'){
            renderPreviewHistory(contentEl, full);
            return;
        }
        contentEl.textContent='Unknown section';
    }
    function tableFromObjects(arr, cols){
        if(!arr.length) return '<div class="text-muted fst-italic">(none)</div>';
        const head = '<thead><tr>' + cols.map(c=>`<th>${esc(c)}</th>`).join('') + '</tr></thead>';
        const body = '<tbody>' + arr.map(o=>'<tr>'+cols.map(c=>`<td>${esc((o[c]!==undefined && o[c]!==null)? (Array.isArray(o[c])? o[c].join(','): o[c]): '')}</td>`).join('')+'</tr>').join('') + '</tbody>';
        return `<div class="table-responsive"><table class="table table-sm table-bordered mb-0">${head}${body}</table></div>`;
    }
    // Initial load
    renderSectionContent('overview');
    // Wire toggle button
    const toggleBtn = document.getElementById('toggleRawFullPreviewBtn');
    if(toggleBtn){
        toggleBtn.onclick = () => {
            const raw = document.getElementById('planPreviewJson');
            const struct = document.getElementById('fullPreviewStructured');
            if(raw.classList.contains('d-none')){ raw.classList.remove('d-none'); toggleBtn.textContent='Structured'; }
            else { raw.classList.add('d-none'); toggleBtn.textContent='Raw JSON'; }
        };
    }
    // Seed copy button removed
}

function renderPreviewHistory(contentEl, currentFull){
    loadFullPreviewHistory();
    if(!previewState.fullPreviewHistory.length){ contentEl.innerHTML = '<div class="text-muted fst-italic">No previous full previews</div>'; return; }
    function esc(x){ return (''+x).replace(/[&<>]/g,c=>({'&':'&amp;','<':'&lt;','>':'&gt;'}[c])); }
    const rows = previewState.fullPreviewHistory.slice().reverse().map((rec,idx) => {
        const dt = new Date(rec.ts).toLocaleTimeString();
        const diffBtn = `<button class="btn btn-sm btn-outline-primary" data-action="diff" data-seed="${esc(rec.seed)}">Diff</button>`;
        return `<tr><td>${idx+1}</td><td>${esc(rec.seed)}</td><td>${esc(rec.stats.routers)}/${esc(rec.stats.hosts)}/${esc(rec.stats.switches)}</td><td>${esc(rec.stats.r2r_edges)}</td><td>${esc(rec.stats.seg_rules)}</td><td>${dt}</td><td class="text-nowrap">${diffBtn}</td></tr>`;
    }).join('');
    contentEl.innerHTML = `<div class="table-responsive"><table class="table table-sm table-bordered mb-2"><thead><tr><th>#</th><th>Seed</th><th>R/H/S</th><th>R2R</th><th>Seg</th><th>Time</th><th></th></tr></thead><tbody>${rows}</tbody></table></div><div id="previewDiffOutput" class="small"></div>`;
    // Seed load buttons removed
    contentEl.querySelectorAll('button[data-action="diff"]').forEach(btn => {
        btn.addEventListener('click', () => { const seed = btn.getAttribute('data-seed'); const rec = previewState.fullPreviewHistory.find(r=> String(r.seed)===seed); if(!rec){ return; } const diffHtml = buildPreviewDiff(rec.preview, currentFull); document.getElementById('previewDiffOutput').innerHTML = diffHtml; });
    });
}

function buildPreviewDiff(a,b){
    const metrics = [
        ['Routers', (a.routers||[]).length, (b.routers||[]).length],
        ['Hosts', (a.hosts||[]).length, (b.hosts||[]).length],
        ['Switches', (a.switches||[]).length, (b.switches||[]).length],
        ['R2R Edges', (a.r2r_edges_preview||[]).length, (b.r2r_edges_preview||[]).length],
        ['Seg Rules', (a.segmentation_preview && a.segmentation_preview.rules ? a.segmentation_preview.rules.length : 0), (b.segmentation_preview && b.segmentation_preview.rules ? b.segmentation_preview.rules.length : 0)]
    ];
    function esc(x){ return (''+x).replace(/[&<>]/g,c=>({'&':'&amp;','<':'&lt;','>':'&gt;'}[c])); }
    const rows = metrics.map(m => { const delta = m[2]-m[1]; const cls = delta===0?'text-secondary':(delta>0?'text-success':'text-danger'); return `<tr><td>${esc(m[0])}</td><td>${esc(m[1])}</td><td>${esc(m[2])}</td><td class="${cls}">${delta>0?'+':''}${esc(delta)}</td></tr>`; }).join('');
    return `<div class="card border-info"><div class="card-header py-1 small">Diff vs current preview</div><div class="card-body p-2"><div class="table-responsive"><table class="table table-sm table-bordered mb-0"><thead><tr><th>Metric</th><th>Old</th><th>Current</th><th>Δ</th></tr></thead><tbody>${rows}</tbody></table></div></div></div>`;
}

// ---------- Full Preview Modal Rendering ----------
function showFullPreviewModal(full){
    if(!full) return;
    const modalEl = document.getElementById('fullPreviewModal');
    if(!modalEl) return;
    document.getElementById('fpModalSeed').textContent = `seed=${full.seed}`;
    // Counts
    const countsEl = document.getElementById('fpCounts');
    const stats = [
        ['Routers',(full.routers||[]).length],
        ['Hosts',(full.hosts||[]).length],
        ['Switches',(full.switches||[]).length],
        ['R2R Edges',(full.r2r_edges_preview||[]).length],
        ['Seg Rules', (full.segmentation_preview && full.segmentation_preview.rules ? full.segmentation_preview.rules.length:0)],
        ['P2P /24',(full.ptp_subnets||[]).length],
        ['R-Sw /24',(full.router_switch_subnets||[]).length],
        ['LAN /24',(full.lan_subnets||[]).length],
    ];
    countsEl.innerHTML = '<div class="row g-1">' + stats.map(s=>`<div class="col-auto"><span class="badge text-bg-secondary">${s[0]}: ${s[1]}</span></div>`).join('') + '</div>';
    // Policies & segmentation
    function setJson(id, obj){ const el=document.getElementById(id); if(el) el.textContent = JSON.stringify(obj||{}, null, 2); }
    setJson('fpR2RPolicy', full.r2r_policy_preview);
    setJson('fpR2SPolicy', full.r2s_policy_preview);
    // Render segmentation plan using shared artifacts so modal and structured views match
    (function(){
        const segEl = document.getElementById('fpSegmentation');
        if(!segEl) return;
        const typesEl = document.getElementById('fpSegmentationTypes');
        const runtimeWrap = document.getElementById('fpSegmentationRuntimeWrap');
        const runtimeEl = document.getElementById('fpSegmentationRuntime');
        const hashEl = document.getElementById('fpSegmentationHash');
        const artifacts = buildFullPreviewArtifacts(full) || {};
        const segArtifacts = artifacts.segmentation || null;
        const segJson = segArtifacts && segArtifacts.json;
        const hasRules = !!(segJson && typeof segJson === 'object' && segJson.rules_count > 0);
        if(hasRules){
            try {
                segEl.textContent = JSON.stringify(segJson, null, 2);
            } catch(e){
                segEl.textContent = '[error rendering segmentation plan JSON]';
            }
        } else {
            segEl.textContent = '(no segmentation plan rules)';
        }
        if(typesEl){
            typesEl.innerHTML = '';
            const typesSummary = hasRules ? (segJson.types_summary || {}) : {};
            const entries = Object.entries(typesSummary).filter(([, count]) => count !== undefined && count !== null);
            if(entries.length){
                typesEl.hidden = false;
                entries.forEach(([type, count]) => {
                    const badge = document.createElement('span');
                    badge.className = 'badge text-bg-light border me-1';
                    badge.textContent = `${type}: ${count}`;
                    typesEl.appendChild(badge);
                });
            } else {
                typesEl.hidden = true;
            }
        }
        const segPreview = (full && full.segmentation_preview) || {};
        const runtimeSummary = segPreview && segPreview.runtime_summary;
        if(runtimeWrap){
            if(runtimeSummary){
                runtimeWrap.hidden = false;
                if(runtimeEl){
                    try {
                        runtimeEl.textContent = JSON.stringify(runtimeSummary, null, 2);
                    } catch(e){
                        runtimeEl.textContent = '[error rendering runtime segmentation summary]';
                    }
                }
            } else {
                runtimeWrap.hidden = true;
                if(runtimeEl){ runtimeEl.textContent = ''; }
            }
        }
        if(hashEl){
            const hashVal = segPreview && segPreview.scripts_hash_sha256;
            if(hashVal){
                hashEl.hidden = false;
                hashEl.textContent = `Scripts Hash (SHA-256): ${hashVal}`;
            } else {
                hashEl.hidden = true;
                hashEl.textContent = '';
            }
        }
    })();
    // Breakdown plans
    try { setJson('fpRouterPlan', full.router_plan); } catch(e){}
    try { setJson('fpServicesPlan', full.services_plan); } catch(e){}
    try { setJson('fpVulnPlan', full.vulnerabilities_plan); } catch(e){}
    try { setJson('fpTrafficPlan', full.traffic_summary || full.traffic_plan || {}); } catch(e){}
    // Tables
    function tableHtml(arr, cols){ if(!arr||!arr.length) return '<div class="text-muted small">(none)</div>'; const head='<thead><tr>'+cols.map(c=>`<th>${c}</th>`).join('')+'</tr></thead>'; const body='<tbody>'+arr.map(o=>'<tr>'+cols.map(c=>`<td>${(o[c]!==undefined&&o[c]!==null)? (Array.isArray(o[c])? o[c].join(','): o[c]): ''}</td>`).join('')+'</tr>').join('')+'</tbody>'; return `<div class="table-responsive"><table class="table table-sm table-bordered mb-0">${head}${body}</table></div>`; }
    function summarizeRouterInterfaces(full){
        const routers = full.routers || [];
        if(!routers.length) return [];
        const r2rLinks = full.r2r_links_preview || [];
        const switches = full.switches_detail || [];
        const r2rMap = {};
        r2rLinks.forEach(link => {
            const routersList = link.routers || [];
            if(routersList.length < 2) return;
            const subnet = link.subnet || '';
            const [ra, rb] = routersList;
            const entryA = `r${rb.id ?? '?'}: ${(ra.ip || '-')}${subnet ? ` [${subnet}]` : ''}`;
            const entryB = `r${ra.id ?? '?'}: ${(rb.ip || '-')}${subnet ? ` [${subnet}]` : ''}`;
            if(ra && ra.id !== undefined){
                const listA = r2rMap[ra.id] || (r2rMap[ra.id] = []);
                listA.push(entryA);
            }
            if(rb && rb.id !== undefined){
                const listB = r2rMap[rb.id] || (r2rMap[rb.id] = []);
                listB.push(entryB);
            }
        });
        const switchMap = {};
        switches.forEach(sw => {
            if(sw.router_id === undefined) return;
            const label = `sw-${sw.switch_id ?? '?'}: ${(sw.router_ip || '-')}${sw.rsw_subnet ? ` [${sw.rsw_subnet}]` : ''}`;
            const list = switchMap[sw.router_id] || (switchMap[sw.router_id] = []);
            list.push(label);
        });
        return routers.map(r => {
            const r2rList = (r2rMap[r.node_id] || []).slice().sort();
            const swList = (switchMap[r.node_id] || []).slice().sort();
            return {
                'ID': r.node_id,
                'Name': r.name || `r${r.node_id}`,
                'Primary IP': r.ip4 || '-',
                'R2R Interfaces': r2rList.length ? r2rList.join('; ') : '-',
                'Switch Links': swList.length ? swList.join('; ') : '-',
            };
        });
    }
    const routersWrap = document.getElementById('fpRoutersWrap'); if(routersWrap) routersWrap.innerHTML = tableHtml(summarizeRouterInterfaces(full),['ID','Name','Primary IP','R2R Interfaces','Switch Links']);
    const hostsWrap = document.getElementById('fpHostsWrap'); if(hostsWrap) hostsWrap.innerHTML = tableHtml(full.hosts,['node_id','name','role','ip4']);
    const switchesWrap = document.getElementById('fpSwitchesWrap'); if(switchesWrap) switchesWrap.innerHTML = tableHtml(full.switches_detail,['switch_id','router_id','hosts','rsw_subnet','lan_subnet']);
    // Graph
    buildFullPreviewModalGraph(full);
    setupPreviewCollapsers();
    try { buildNodeSectionsTable(full); } catch(e){ console.warn('Node sections table failed', e); }
        // Removed history, role distribution, service distribution
    // Approval & drift removed
    document.getElementById('fpExportJsonBtn')?.addEventListener('click', ()=>{ try { const blob=new Blob([JSON.stringify(full,null,2)],{type:'application/json'}); const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download='full_preview_seed_'+(full.seed||'na')+'.json'; document.body.appendChild(a); a.click(); a.remove(); setTimeout(()=>URL.revokeObjectURL(a.href),4000);} catch(e){} });
    // Open standalone full preview page via POST (original GET caused 405 Method Not Allowed)
    document.getElementById('fpOpenStandaloneBtn')?.addEventListener('click', ()=>{
        const xmlPath = state.result_path || '';
        if(!xmlPath.endsWith('.xml')){ alert('Save XML first to open standalone preview.'); return; }
        const scen = state.scenarios && state.scenarios[activeIdx] ? state.scenarios[activeIdx].name : '';
        const form = document.createElement('form');
        form.method='POST';
        form.action='/plan/full_preview_page';
        form.target='_blank';
        const inXml = document.createElement('input'); inXml.type='hidden'; inXml.name='xml_path'; inXml.value=xmlPath; form.appendChild(inXml);
        if(scen){ const inSc = document.createElement('input'); inSc.type='hidden'; inSc.name='scenario'; inSc.value=scen; form.appendChild(inSc); }
        if(full && full.seed){ const inSeed=document.createElement('input'); inSeed.type='hidden'; inSeed.name='seed'; inSeed.value=full.seed; form.appendChild(inSeed); }
        document.body.appendChild(form);
        form.submit();
        setTimeout(()=>{ try { form.remove(); } catch(e){} }, 1000);
    });
    (new bootstrap.Modal(modalEl)).show();
}

// Removed history and distribution functions

// Drift function removed

function normalizeVulnerabilitiesByNode(source){
    const out = {};
    if(!source) return out;
    Object.entries(source).forEach(([key, value])=>{
        if(key === '__density_pool__') return;
        if(Array.isArray(value)){
            out[String(key)] = value;
            const numericKey = Number(key);
            if(Number.isFinite(numericKey)){
                out[numericKey] = value;
            }
        }
    });
    return out;
}

function buildFullPreviewModalGraph(full){
    const labelToggle = document.getElementById('fpGraphLabelsToggle');
    const labelStateKey = 'coretg_graph_labels_state';
    if(labelToggle && !labelToggle.dataset.initialized){
        try {
            const saved = sessionStorage.getItem(labelStateKey);
            if(saved){
                labelToggle.checked = saved === 'on';
                labelToggle.dataset.graphLabelsState = saved;
            }
        } catch(e){}
        labelToggle.dataset.initialized = '1';
    }
    const shouldShowLabels = !!(labelToggle && labelToggle.checked);
    if(labelToggle){
        labelToggle.dataset.graphLabelsState = shouldShowLabels ? 'on' : 'off';
    }
    if(!window.d3){ const g=document.getElementById('fpGraphLoading'); if(g) g.textContent='d3 not loaded'; return; }
    const container = d3.select('#fpGraph');
    container.selectAll('*').remove();
    const w = container.node().clientWidth || 800; const h = container.node().clientHeight || 480;
    const svg = container.append('svg').attr('width', w).attr('height', h).style('cursor','grab');
    const zoomLayer = svg.append('g').attr('class','zoom-layer');
    let currentTransform = d3.zoomIdentity;
    const zoom = d3.zoom().scaleExtent([0.2,4]).on('zoom', (ev)=>{
        currentTransform = ev.transform; zoomLayer.attr('transform', currentTransform);
    });
    svg.call(zoom).on('dblclick.zoom', null);
        const vulnerabilitiesByNode = normalizeVulnerabilitiesByNode(full.vulnerabilities_by_node);
    const nodes=[];
    const nodeById = new Map();
    const hitlPreview = deriveHitlPreviewArtifacts(full);
        const baseCluster = full.base_bridge_preview && full.base_bridge_preview.attached ? (full.base_bridge_preview.target_cluster || null) : null;
        const baseClusterNodeMap = new Map();
        const baseBridgeInfo = full.base_bridge_preview && full.base_bridge_preview.attached ? full.base_bridge_preview : null;
        const legend = svg.append('g').attr('class','legend').attr('transform','translate(8,8)');
        let legendOffset = 0;
        const legendTypesSeen = new Set();
        let legendSpacingAdded = false;

        const ensureLegendEntry = (canonicalType) => {
            if(!canonicalType || legendTypesSeen.has(canonicalType)) return;
            legendTypesSeen.add(canonicalType);
            const style = nodeStyleForType(canonicalType);
            const radius = Math.max(4, Math.min((style.radius ?? 6), 12));
            const entry = legend.append('g').attr('transform', `translate(0,${legendOffset})`);
            if (style.shape === 'square') {
                const side = radius * 2;
                entry.append('rect')
                    .attr('x', 0)
                    .attr('y', 0)
                    .attr('width', side)
                    .attr('height', side)
                    .attr('fill', style.color)
                    .attr('stroke', '#333')
                    .attr('stroke-width', 1);
            } else {
                entry.append('circle')
                    .attr('r', radius)
                    .attr('cx', radius)
                    .attr('cy', radius)
                    .attr('fill', style.color)
                    .attr('stroke', '#333')
                    .attr('stroke-width', 1);
            }
            entry.append('text')
                .text(style.label)
                .attr('x', radius * 2 + 6)
                .attr('y', radius + 4)
                .attr('font-size', '11px');
            legendOffset += Math.max(radius * 2 + 6, 20);
        };

        // Always include host-vs-docker distinction in the legend.
        ensureLegendEntry('host');
        ensureLegendEntry('docker');

        const registerLegendForNodes = (list) => {
            if(!Array.isArray(list)) return;
            list.forEach(node => {
                if(!node) return;
                const canonical = canonicalNodeType(node.type ?? node.kind ?? node.role);
                if(node.type !== canonical) node.type = canonical;
                ensureLegendEntry(canonical);
            });
        };

        const addLegendSpacing = () => {
            if(!legendSpacingAdded && legendTypesSeen.size > 0){
                legendOffset += 6;
                legendSpacingAdded = true;
            }
        };
        function resolveBaseNodeType(meta){
            if(!meta || typeof meta !== 'object') return 'host';
            const raw = meta.type ?? meta.model ?? meta.kind ?? meta.role ?? '';
            return canonicalNodeType(raw);
        }
        const addNode = (node)=>{
            if(node==null || node.id===undefined || node.id===null) return;
            const key = String(node.id);
            const canonicalType = canonicalNodeType(node.type ?? node.kind ?? node.role);
            const normalized = { ...node, type: canonicalType };
            if(nodeById.has(key)){
                Object.assign(nodeById.get(key), normalized);
                return;
            }
            nodeById.set(key, normalized);
            nodes.push(normalized);
        };
        const bridgeRouterIdNum = baseBridgeInfo ? Number(baseBridgeInfo.bridge_router_id) : null;
        (full.routers||[]).forEach(r=>{
            if(r==null || r.node_id===undefined || r.node_id===null) return;
            const routerIdNum = Number(r.node_id);
            const isBridgeRouter = Number.isFinite(bridgeRouterIdNum) && routerIdNum === bridgeRouterIdNum;
            addNode({id:r.node_id, label:r.name, type:'router', ip4: r.ip4 || '', isBaseBridge: isBridgeRouter});
        });
        (full.hosts||[]).forEach(hn=>{
            if(hn==null) return;
            const hostId = hn.node_id;
            if(hostId===undefined || hostId===null) return;
            const keyStr = String(hostId);
            const assignment = Array.isArray(hn.vulnerabilities) ? hn.vulnerabilities : vulnerabilitiesByNode[keyStr] || vulnerabilitiesByNode[hostId] || [];
            const vulnList = Array.isArray(assignment) ? assignment : [];
            const hasVuln = vulnList.length > 0;
            const roleRaw = (hn && (hn.role || hn.kind || hn.type)) ? String(hn.role || hn.kind || hn.type) : '';
            const isDockerRole = roleRaw.trim().toLowerCase() === 'docker';
            addNode({id:hostId, label:hn.name, type: (isDockerRole ? 'docker' : 'host'), role: roleRaw, ip4: hn.ip4 || '', hasVuln: hasVuln, vulnerabilities: vulnList});
        });
        (full.switches_detail||[]).forEach(sw=>{
            if(sw==null) return;
            const switchId = sw.switch_id;
            if(switchId===undefined || switchId===null) return;
            addNode({id:switchId, label:'sw-'+switchId, type:'switch'});
        });
    const bridgePeerIdNum = baseBridgeInfo ? Number(baseBridgeInfo.internal_peer_router_id) : null;
        const baseBridgeKeys = new Set();
        if(Number.isFinite(bridgeRouterIdNum) && Number.isFinite(bridgePeerIdNum)){
            baseBridgeKeys.add(`${Math.min(bridgeRouterIdNum, bridgePeerIdNum)}-${Math.max(bridgeRouterIdNum, bridgePeerIdNum)}`);
        }

        const linkDescriptors=[];
        (full.r2r_edges_preview||[]).forEach(e=>{
            if(!Array.isArray(e) || e.length<2) return;
            const [a,b] = e;
            if(a===undefined || a===null || b===undefined || b===null) return;
            const key = `${Math.min(Number(a), Number(b))}-${Math.max(Number(a), Number(b))}`;
            const kind = baseBridgeKeys.has(key) ? 'base-bridge' : 'r2r';
            linkDescriptors.push({sourceId:a, targetId:b, kind});
        });
        (full.switches_detail||[]).forEach(sw=>{
            if(sw==null) return;
            const switchId = sw.switch_id;
            const routerId = sw.router_id;
            if(switchId===undefined || switchId===null || routerId===undefined || routerId===null) return;
            (sw.hosts||[]).forEach(hid=>{
                if(hid===undefined || hid===null) return;
                linkDescriptors.push({sourceId:switchId, targetId:hid, kind:'sw-host'});
            });
            linkDescriptors.push({sourceId:routerId, targetId:switchId, kind:'r-sw'});
        });
        const hr = full.host_router_map || {};
        Object.entries(hr).forEach(([hid,rid])=>{
            if(hid===undefined || hid===null) return;
            const hIdNum = Number.isFinite(Number(hid)) ? Number(hid) : parseInt(hid, 10);
            const hostId = Number.isFinite(hIdNum) ? hIdNum : hid;
            if(hostId===undefined || hostId===null) return;
            const hasSwitchLink = linkDescriptors.find(l=>l.kind==='sw-host' && String(l.targetId)===String(hostId));
            if(hasSwitchLink) return;
            const routerCandidate = (typeof rid === 'number' && Number.isFinite(rid)) ? rid : parseInt(rid,10);
            const routerId = Number.isFinite(routerCandidate) ? routerCandidate : rid;
            if(routerId===undefined || routerId===null) return;
            linkDescriptors.push({sourceId:routerId, targetId:hostId, kind:'r-host'});
        });

        const ensureNodeForLink = (id, role)=>{
            if(id===undefined || id===null || (typeof id==='number' && Number.isNaN(id))) return;
            const key = String(id);
            if(nodeById.has(key)) return;
            const type = role==='router'? 'router' : role==='switch'? 'switch' : 'host';
            const labelBase = role==='router'? `router-${key}` : role==='switch'? `sw-${key}` : `host-${key}`;
            const fallback = { id, label: labelBase, type };
            if(type==='host'){
                fallback.hasVuln = false;
                fallback.vulnerabilities = [];
            }
            addNode(fallback);
        };
        linkDescriptors.forEach(link=>{
            if(!link) return;
            if(link.kind==='r2r'){
                ensureNodeForLink(link.sourceId, 'router');
                ensureNodeForLink(link.targetId, 'router');
            } else if(link.kind==='r-sw'){
                ensureNodeForLink(link.sourceId, 'router');
                ensureNodeForLink(link.targetId, 'switch');
            } else if(link.kind==='sw-host'){
                ensureNodeForLink(link.sourceId, 'switch');
                ensureNodeForLink(link.targetId, 'host');
            } else if(link.kind==='r-host'){
                ensureNodeForLink(link.sourceId, 'router');
                ensureNodeForLink(link.targetId, 'host');
            }
        });

        if(hitlPreview && Array.isArray(hitlPreview.nodes)){
            hitlPreview.nodes.forEach(node => {
                if(!node) return;
                const sourceId = node.id ?? node.node_id ?? null;
                if(sourceId !== null){
                    const key = String(sourceId);
                    if(nodeById.has(key)){
                        const existing = nodeById.get(key);
                        const mergeFieldWhenMissing = (field) => {
                            if(Object.prototype.hasOwnProperty.call(node, field)){
                                const value = node[field];
                                if(value !== undefined && value !== null && (existing[field] === undefined || existing[field] === null)){
                                    existing[field] = value;
                                }
                            }
                        };
                        mergeFieldWhenMissing('type');
                        mergeFieldWhenMissing('label');
                        mergeFieldWhenMissing('name');
                        mergeFieldWhenMissing('ip4');
                        mergeFieldWhenMissing('linkNetwork');
                        mergeFieldWhenMissing('prefixLen');
                        mergeFieldWhenMissing('netmask');
                        mergeFieldWhenMissing('peerRouterIp4');
                        mergeFieldWhenMissing('existingRouterIp4');
                        mergeFieldWhenMissing('broadcastIp4');
                        mergeFieldWhenMissing('attachment');
                        mergeFieldWhenMissing('assignment');
                        mergeFieldWhenMissing('hitlAttachment');
                        mergeFieldWhenMissing('hitlAssignment');
                        mergeFieldWhenMissing('hitlUplinkRouterId');
                        mergeFieldWhenMissing('uplinkRouterId');
                        if(node.hitlInterface && !existing.hitlInterface){
                            existing.hitlInterface = node.hitlInterface;
                        }
                        if(node.hitlLinkMeta && !existing.hitlLinkMeta){
                            existing.hitlLinkMeta = node.hitlLinkMeta;
                        }
                        if(Array.isArray(node.hitlSwitchInterfaces) && node.hitlSwitchInterfaces.length){
                            if(!Array.isArray(existing.hitlSwitchInterfaces)){
                                existing.hitlSwitchInterfaces = node.hitlSwitchInterfaces.slice();
                            } else {
                                const seenKeys = new Set(existing.hitlSwitchInterfaces.map(entry => {
                                    if(!entry) return '';
                                    return entry.switch_id !== undefined && entry.switch_id !== null
                                        ? String(entry.switch_id)
                                        : JSON.stringify(entry);
                                }));
                                node.hitlSwitchInterfaces.forEach(entry => {
                                    if(!entry) return;
                                    const keyEntry = entry.switch_id !== undefined && entry.switch_id !== null
                                        ? String(entry.switch_id)
                                        : JSON.stringify(entry);
                                    if(!seenKeys.has(keyEntry)){
                                        existing.hitlSwitchInterfaces.push(entry);
                                        seenKeys.add(keyEntry);
                                    }
                                });
                            }
                        }
                        if(node.isHitlRouter){
                            existing.isHitlRouter = true;
                        }
                        if(node.isHitl){
                            existing.isHitl = true;
                        }
                        if(node.hitlAttachment && !existing.hitlAttachment){
                            existing.hitlAttachment = node.hitlAttachment;
                        }
                        if(node.hitlAssignment && !existing.hitlAssignment){
                            existing.hitlAssignment = node.hitlAssignment;
                        }
                        if(node.hitlUplinkRouterId && !existing.hitlUplinkRouterId){
                            existing.hitlUplinkRouterId = node.hitlUplinkRouterId;
                        }
                        existing._hasHitlOverlay = true;
                        return;
                    }
                }
                const canonical = canonicalNodeType(node.type ?? node.kind ?? node.role);
                const clone = { ...node, type: canonical };
                const key = sourceId !== null ? String(sourceId) : (clone.id !== undefined && clone.id !== null ? String(clone.id) : null);
                if(key !== null){
                    nodeById.set(key, clone);
                }
                nodes.push(clone);
            });
        }

        const filteredLinks = linkDescriptors.filter(link=>{
            if(!link) return false;
            return nodeById.has(String(link.sourceId)) && nodeById.has(String(link.targetId));
        });

        if(hitlPreview && Array.isArray(hitlPreview.links)){
            hitlPreview.links.forEach(link=>{
                if(!link) return;
                if(!nodeById.has(String(link.sourceId)) || !nodeById.has(String(link.targetId))) return;
                filteredLinks.push({
                    sourceId: link.sourceId,
                    targetId: link.targetId,
                    kind: link.kind || 'hitl',
                    attachment: link.attachment || null,
                    assignment: link.assignment || null,
                });
            });
        }

        if(baseCluster && Array.isArray(baseCluster.nodes)){
            baseCluster.nodes.forEach((baseNodeMeta, idx)=>{
                if(!baseNodeMeta) return;
                const originalId = baseNodeMeta.id !== undefined && baseNodeMeta.id !== null ? String(baseNodeMeta.id) : `base-${idx}`;
                if(baseClusterNodeMap.has(originalId)) return;
                const nodeId = `base-cluster-${originalId}`;
                baseClusterNodeMap.set(originalId, nodeId);
                const clusterLabel = baseNodeMeta.name || `Base ${originalId}`;
                const clusterNode = {
                    id: nodeId,
                    name: clusterLabel,
                    label: clusterLabel,
                    type: resolveBaseNodeType(baseNodeMeta),
                    isBaseCluster: true,
                    isBase: true,
                    baseOriginal: baseNodeMeta,
                };
                if(baseNodeMeta.position && Number.isFinite(Number(baseNodeMeta.position.x)) && Number.isFinite(Number(baseNodeMeta.position.y))){
                    clusterNode._layout = { x: Number(baseNodeMeta.position.x), y: Number(baseNodeMeta.position.y) };
                }
                addNode(clusterNode);
            });
        }
        let baseAnchorId = null;
        const baseTargetMeta = full.base_bridge_preview && full.base_bridge_preview.attached ? (full.base_bridge_preview.target || null) : null;
        if(baseClusterNodeMap.size > 0){
            const targetKey = baseTargetMeta && baseTargetMeta.id !== undefined && baseTargetMeta.id !== null ? String(baseTargetMeta.id) : null;
            if(targetKey && baseClusterNodeMap.has(targetKey)){
                baseAnchorId = baseClusterNodeMap.get(targetKey);
            } else {
                baseAnchorId = baseClusterNodeMap.values().next().value;
            }
        } else if(baseTargetMeta){
            baseAnchorId = `base-target-${baseTargetMeta.id || 'base'}`;
            if(!nodeById.has(baseAnchorId)){
                const anchorLabel = baseTargetMeta.name || 'Base Scenario';
                const anchorNode = {
                    id: baseAnchorId,
                    name: anchorLabel,
                    label: anchorLabel,
                    type: resolveBaseNodeType(baseTargetMeta),
                    isBaseExternal: true,
                    isBase: true,
                    baseTarget: baseTargetMeta,
                };
                if(baseTargetMeta.position && Number.isFinite(Number(baseTargetMeta.position.x)) && Number.isFinite(Number(baseTargetMeta.position.y))){
                    anchorNode._layout = { x: Number(baseTargetMeta.position.x), y: Number(baseTargetMeta.position.y) };
                }
                addNode(anchorNode);
            }
        }
        if(baseCluster && Array.isArray(baseCluster.edges)){
            baseCluster.edges.forEach(edge=>{
                if(!Array.isArray(edge) || edge.length < 2) return;
                const aRaw = edge[0];
                const bRaw = edge[1];
                const keyA = aRaw !== undefined && aRaw !== null ? String(aRaw) : null;
                const keyB = bRaw !== undefined && bRaw !== null ? String(bRaw) : null;
                if(!keyA || !keyB) return;
                const mappedA = baseClusterNodeMap.get(keyA);
                const mappedB = baseClusterNodeMap.get(keyB);
                if(!mappedA || !mappedB) return;
                filteredLinks.push({ sourceId: mappedA, targetId: mappedB, kind: 'base-cluster' });
            });
        }
        const bridgeRouterId = baseBridgeInfo ? baseBridgeInfo.bridge_router_id : null;
        if(baseAnchorId && bridgeRouterId !== null){
            filteredLinks.push({ sourceId: bridgeRouterId, targetId: baseAnchorId, kind: 'base-external' });
        }

        if(nodes.length === 0){
            svg.remove();
            container.append('div').attr('class','text-muted small p-2').text('No nodes to display');
            document.getElementById('fpGraphLoading')?.remove();
            return;
        }

        registerLegendForNodes(nodes);
        addLegendSpacing();

        const layoutPositions = full.layout_positions;
        const layoutMaps = (layoutPositions && !layoutPositions.error && typeof layoutPositions === 'object')
            ? {
                    routers: layoutPositions.routers || {},
                    switches: layoutPositions.switches || {},
                    hosts: layoutPositions.hosts || {},
                }
            : null;
        function layoutCoordForNode(node){
            if(!layoutMaps) return null;
            let table = null;
            if(node.type==='router') table = layoutMaps.routers;
            else if(node.type==='switch') table = layoutMaps.switches;
            else if(node.isBase){
                if(node._layout) return node._layout;
                return null;
            }
            else table = layoutMaps.hosts;
            if(!table) return null;
            const key = String(node.id);
            const raw = table[key] || table[node.id];
            if(!raw) return null;
            const x = Number(raw.x);
            const y = Number(raw.y);
            if(Number.isFinite(x) && Number.isFinite(y)) return {x, y};
            return null;
        }
        const layoutCoords = [];
        if(layoutMaps){
            nodes.forEach(n=>{
                let pos = layoutCoordForNode(n);
                if(!pos && n.isBase && n._layout){
                    pos = n._layout;
                }
                if(pos){
                    n._layout = pos;
                    layoutCoords.push(pos);
                }
            });
        }
        const margin = 40;
        const innerWidth = Math.max(w - margin*2, 200);
        const innerHeight = Math.max(h - margin*2, 200);
        let usingLayout = layoutCoords.length > 0;
        const originalPositions = new Map();
    function applyRowJitter(list){
            const buckets = new Map();
            list.forEach(node=>{
                if(!Number.isFinite(node.y)) return;
        if(node.isBase) return;
                const base = node._layout ? node._layout.y : node.y;
                if(!Number.isFinite(base)) return;
                const key = Math.round(base * 1000);
                const bucket = buckets.get(key);
                if(bucket){
                    bucket.push(node);
                } else {
                    buckets.set(key, [node]);
                }
            });
            buckets.forEach(group=>{
                if(group.length <= 1) return;
                group.sort((a,b)=> String(a.id).localeCompare(String(b.id)));
                const mid = (group.length - 1) / 2;
                const spacing = 8;
                group.forEach((node, idx)=>{
                    node.y += (idx - mid) * spacing;
                });
            });
        }
        let scale = 1;
        let offsetX = margin;
        let offsetY = margin;
        if(usingLayout && layoutCoords.length){
            let minX = layoutCoords[0].x, maxX = layoutCoords[0].x;
            let minY = layoutCoords[0].y, maxY = layoutCoords[0].y;
            layoutCoords.forEach(c=>{ if(c.x<minX) minX=c.x; if(c.x>maxX) maxX=c.x; if(c.y<minY) minY=c.y; if(c.y>maxY) maxY=c.y; });
            const spanX = Math.max(1, maxX - minX);
            const spanY = Math.max(1, maxY - minY);
            scale = Math.min(innerWidth/spanX, innerHeight/spanY);
            if(!Number.isFinite(scale) || scale <= 0){
                scale = 1;
                usingLayout = false;
            } else {
                offsetX = margin + (innerWidth - spanX * scale) / 2 - minX * scale;
                offsetY = margin + (innerHeight - spanY * scale) / 2 - minY * scale;
            }
        }

        if(usingLayout){
            nodes.forEach(n=>{
                if(n._layout){
                    n.x = offsetX + n._layout.x * scale;
                    n.y = offsetY + n._layout.y * scale;
                } else {
                    n.x = w/2 + Math.random()*40 - 20;
                    n.y = h/2 + Math.random()*40 - 20;
                }
            });
            applyRowJitter(nodes);
            nodes.forEach(n=>{
                n.layoutX = n.x;
                n.layoutY = n.y;
                if(Number.isFinite(n.x) && Number.isFinite(n.y)){
                    originalPositions.set(n.id, { x: n.x, y: n.y });
                }
            });
        } else {
            nodes.forEach(n=>{
                n.x = w/2 + Math.random()*80 - 40;
                n.y = h/2 + Math.random()*80 - 40;
                n.layoutX = undefined;
                n.layoutY = undefined;
            });
        }

        const simLinks = filteredLinks.map(l=>({...l, source:l.sourceId, target:l.targetId}));

        // Build per-node interface/IP hints for hover tooltips.
        function buildIfaceHints(preview){
            const map = new Map();
            const add = (id, line) => {
                if(id === undefined || id === null || line == null) return;
                const key = String(id);
                const txt = String(line).trim();
                if(!txt) return;
                if(!map.has(key)) map.set(key, []);
                const arr = map.get(key);
                if(arr.length >= 20) return;
                if(!arr.includes(txt)) arr.push(txt);
            };

            // Router-router links with explicit IPs (preferred)
            try {
                (preview.r2r_links_preview || []).forEach(link => {
                    const routers = link && link.routers ? link.routers : null;
                    if(!Array.isArray(routers) || routers.length !== 2) return;
                    const a = routers[0];
                    const b = routers[1];
                    const aId = a && a.id !== undefined ? a.id : null;
                    const bId = b && b.id !== undefined ? b.id : null;
                    if(aId === null || bId === null) return;
                    if(a.ip) add(aId, `to r${bId}: ${a.ip}`);
                    if(b.ip) add(bId, `to r${aId}: ${b.ip}`);
                });
            } catch(e){}

            // Router<->switch and host<->switch interface IPs
            try {
                (preview.switches_detail || []).forEach(sw => {
                    if(!sw) return;
                    const sid = sw.switch_id;
                    const rid = sw.router_id;
                    if(sw.router_ip) add(rid, `to sw${sid}: ${sw.router_ip}`);
                    const hostIps = (sw.host_if_ips && typeof sw.host_if_ips === 'object') ? sw.host_if_ips : {};
                    (sw.hosts || []).forEach(hid => {
                        const ip = hostIps[String(hid)] || hostIps[hid];
                        if(ip) add(hid, `to sw${sid}: ${ip}`);
                    });
                });
            } catch(e){}

            return map;
        }

        const ifaceHints = buildIfaceHints(full);

        function nodeTitle(d){
            const label = d.label || d.name || String(d.id);
            const lines = [`${label} (${d.type || 'node'})`];
            const ip4 = (d.ip4 || '').trim();
            if(ip4) lines.push(`IP: ${ip4}`);
            const extras = ifaceHints.get(String(d.id)) || [];
            // HITL overlays: include any explicit peer/existing router IP hints
            if(d.peerRouterIp4) extras.unshift(`peer: ${d.peerRouterIp4}`);
            if(d.existingRouterIp4) extras.unshift(`uplink: ${d.existingRouterIp4}`);
            if(extras.length){
                lines.push('Interfaces:');
                extras.slice(0, 12).forEach(x => lines.push(`- ${x}`));
            } else {
                lines.push('Interfaces: -');
            }
            return lines.join('\n');
        }

        const isHitlLink = (kind) => typeof kind === 'string' && kind.startsWith('hitl');
        const link = zoomLayer.selectAll('line').data(simLinks).enter().append('line')
            .attr('stroke', l=> {
                if(l.kind === 'base-bridge' || l.kind === 'base-external' || l.kind === 'base-cluster') return '#6f42c1';
                if(l.kind==='r2r') return '#0d6efd';
                if(isHitlLink(l.kind)) return '#20c997';
                return (l.kind==='r-sw'? '#198754':'#999');
            })
            .attr('stroke-width', l=> {
                if(l.kind === 'base-cluster') return 3;
                if(l.kind === 'base-bridge' || l.kind === 'base-external') return 4;
                if(isHitlLink(l.kind)) return 2.4;
                return l.kind==='r2r'? 2:1.2;
            })
            .attr('stroke-linecap', l=> (l.kind === 'base-bridge' || l.kind === 'base-external' || l.kind === 'base-cluster') ? 'round' : null)
            .attr('stroke-dasharray', l=> {
                if(l.kind==='r-host') return '3,3';
                if(isHitlLink(l.kind)) return '5,4';
                return null;
            })
            .attr('opacity', .9);
    const node = zoomLayer.selectAll('g').data(nodes).enter().append('g');
        // Native SVG tooltip on hover
        node.insert('title', ':first-child').text(d => nodeTitle(d));
        const vulnerabilityColor = '#28a745';
        const isHostLike = (t) => t === 'host' || t === 'docker';
        const hasVulnerableHosts = nodes.some(n => isHostLike(n.type) && n.hasVuln);
        const normalNode = node.filter(d => !(isHostLike(d.type) && d.hasVuln));
        normalNode.each(function(d){
            const nodeGroup = d3.select(this);
            const style = nodeStyleForType(d.type);
            if (style.shape === 'square') {
                const side = (Number.isFinite(style.radius) ? style.radius : 6) * 2;
                nodeGroup.append('rect')
                    .attr('x', -side / 2)
                    .attr('y', -side / 2)
                    .attr('width', side)
                    .attr('height', side)
                    .attr('rx', 2)
                    .attr('ry', 2)
                    .attr('fill', style.color)
                    .attr('stroke', (d.isBase || d.isBaseBridge) ? '#6f42c1' : '#333')
                    .attr('stroke-width', d.isBaseBridge ? 3 : d.isBase ? 2 : 1.1);
            } else {
                const radius = Number.isFinite(style.radius) ? style.radius : 6;
                nodeGroup.append('circle')
                    .attr('r', radius)
                    .attr('fill', style.color)
                    .attr('stroke', (d.isBase || d.isBaseBridge) ? '#6f42c1' : '#333')
                    .attr('stroke-width', d.isBaseBridge ? 3 : d.isBase ? 2 : 1.1);
            }
        });
        const vulnNode = node.filter(d => isHostLike(d.type) && d.hasVuln);
        const vulnSymbol = d3.symbol().type(d3.symbolStar).size(170);
        vulnNode.append('path')
            .attr('d', vulnSymbol)
            .attr('fill', vulnerabilityColor)
            .attr('stroke', '#333')
            .attr('stroke-width', 1.1);
        const labelGroups = node.append('g').attr('class', 'node-label-wrapper');

        const computeLabelWidth = (d) => {
            const text = d.label || d.name || String(d.id);
            return Math.max(24, (String(text).length * 6 + 6));
        };

        labelGroups.append('rect')
            .attr('class', 'node-label-bg')
            .attr('x', d => -computeLabelWidth(d) / 2)
            .attr('y', 10)
            .attr('width', d => computeLabelWidth(d))
            .attr('height', 16)
            .attr('rx', 3)
            .attr('ry', 3)
            .attr('fill', '#fff')
            .attr('stroke', '#bbb')
            .attr('stroke-width', 0.8)
            .attr('opacity', 0.88);

        labelGroups.append('text')
            .attr('class', 'node-label-text')
            .attr('text-anchor', 'middle')
            .attr('x', 0)
            .attr('y', 21)
            .attr('font-size', '10px')
            .attr('fill', '#000')
            .text(d => d.label || d.name || String(d.id));

        const simulation = d3.forceSimulation(nodes)
            .force('link', d3.forceLink(simLinks).id(d=>d.id).distance(l=> {
                if(l.kind === 'base-cluster') return 60;
                if(l.kind === 'base-bridge' || l.kind === 'base-external') return 95;
                return l.kind==='r2r'? 80 : (l.kind==='r-sw'? 60 : 40);
            }).strength(l => l.kind === 'base-cluster' ? 0.9 : (l.kind === 'base-bridge' || l.kind === 'base-external' ? 0.7 : 0.6)))
            .force('charge', d3.forceManyBody().strength(d => d.isBase ? -160 : -220))
            .force('center', d3.forceCenter(w/2,h/2))
            .force('layoutX', d3.forceX(d => Number.isFinite(d.layoutX) ? d.layoutX : w/2).strength(usingLayout ? 0.2 : 0.04))
            .force('layoutY', d3.forceY(d => Number.isFinite(d.layoutY) ? d.layoutY : h/2).strength(usingLayout ? 0.2 : 0.04));

        simulation.alpha(1).alphaTarget(0.03).restart();

        link.data(simLinks, d=>`${d.source}-${d.target}`);

        simulation.on('tick', ()=>{
            link.attr('x1', d=>d.source.x).attr('y1', d=>d.source.y).attr('x2', d=>d.target.x).attr('y2', d=>d.target.y);
            node.attr('transform', d=>`translate(${d.x},${d.y})`);
        });

        node.call(d3.drag().on('start', dragstarted).on('drag', dragged).on('end', dragended));

        let sim = simulation;

        let resetStaticPositions = null;
        if(usingLayout){
            resetStaticPositions = () => {
                nodes.forEach(n => {
                    const orig = originalPositions.get(n.id);
                    if(orig){
                        n.layoutX = orig.x;
                        n.layoutY = orig.y;
                        n.x = orig.x;
                        n.y = orig.y;
                        n.vx = 0;
                        n.vy = 0;
                        n.fx = null;
                        n.fy = null;
                    }
                });
                simulation.alpha(0.55).restart();
            };
        }
    // Legend
    const hasBaseBridge = baseBridgeInfo && baseBridgeInfo.attached;
    if(hasBaseBridge){
        const g=legend.append('g').attr('transform',`translate(0,${legendOffset})`);
        g.append('line').attr('x1',0).attr('y1',8).attr('x2',24).attr('y2',8).attr('stroke','#6f42c1').attr('stroke-width',4).attr('stroke-linecap','round');
        g.append('text').text('Bridge to Base Scenario').attr('x',28).attr('y',12).attr('font-size','11px');
        legendOffset += 20;
    }
    if(hasVulnerableHosts){
        const g=legend.append('g').attr('transform',`translate(0,${legendOffset})`);
        const vulnLegendSymbol = d3.symbol().type(d3.symbolStar).size(80);
        g.append('path')
            .attr('d', vulnLegendSymbol)
            .attr('transform','translate(8,8)')
            .attr('fill', vulnerabilityColor)
            .attr('stroke','#333')
            .attr('stroke-width',1);
        g.append('text').text('Host (vulnerable)').attr('x', 20).attr('y', 12).attr('font-size','11px');
        legendOffset += 20;
    }
    // Node labels rendered conditionally (toggle in UI)
    // Build section lookups
    const servicesByNode = full.services_preview || {}; // node_id -> [services]
    const vulnByNode = vulnerabilitiesByNode; // node_id -> [vulns]
    const segRules = (full.segmentation_preview && full.segmentation_preview.rules) || [];
    const segCnt = {}; segRules.forEach(r=>{ segCnt[r.node_id] = (segCnt[r.node_id]||0)+1; });
    const traffic = full.traffic_summary || {};
    const tSend = {}; const tRecv = {};
    try { (traffic.flows || traffic || []).forEach(f=>{ const s=f.src_id??f.src; const d=f.dst_id??f.dst; if(s!==undefined) tSend[s]=(tSend[s]||0)+1; if(d!==undefined) tRecv[d]=(tRecv[d]||0)+1; }); } catch(e){}
    // Hover tooltips use native SVG <title> (see nodeTitle)
    function dragstarted(event,d){
        try { event.sourceEvent?.stopPropagation?.(); } catch(e){}
        if(sim && !event.active) sim.alphaTarget(.35).restart();
        d.fx=d.x; d.fy=d.y;
    }
    function dragged(event,d){ d.fx=event.x; d.fy=event.y; }
    function dragended(event,d){
        if(sim && !event.active) sim.alphaTarget(0.03);
        d.fx=d.x; d.fy=d.y;
        d.layoutX = d.x;
        d.layoutY = d.y;
    }
    document.getElementById('fpGraphLoading')?.remove();
    const resetBtn = document.getElementById('fpGraphResetBtn');
    if(resetBtn){
        resetBtn.addEventListener('click', ()=>{
            if(sim){
                sim.alpha(1).restart();
                nodes.forEach(n=>{ n.fx=null; n.fy=null; });
            }
            if(resetStaticPositions){
                resetStaticPositions();
            }
            svg.transition().duration(250).call(zoom.transform, d3.zoomIdentity);
        });
    }
    // Removed zoom hint tooltip
    svg.on('mousedown', ()=> svg.style('cursor','grabbing'));
    window.addEventListener('mouseup', ()=> svg.style('cursor','grab'));
    document.getElementById('fpGraphPngBtn')?.addEventListener('click', ()=>{ try { const serializer=new XMLSerializer(); const svgStr=serializer.serializeToString(svg.node()); const canvas=document.createElement('canvas'); canvas.width=w*2; canvas.height=h*2; const ctx=canvas.getContext('2d'); const img=new Image(); img.onload=function(){ ctx.fillStyle='#fff'; ctx.fillRect(0,0,canvas.width,canvas.height); ctx.drawImage(img,0,0,canvas.width,canvas.height); canvas.toBlob(b=>{ const a=document.createElement('a'); a.href=URL.createObjectURL(b); a.download='full_preview_graph_'+(full.seed||'na')+'.png'; document.body.appendChild(a); a.click(); a.remove(); setTimeout(()=>URL.revokeObjectURL(a.href),4000); }); }; img.src='data:image/svg+xml;base64,'+btoa(unescape(encodeURIComponent(svgStr))); } catch(e){ console.error('PNG export failed', e); } });

    container.node().dispatchEvent(new CustomEvent('coretg-graph-ready', {
        bubbles: true,
        detail: {
            target: '#fpGraph',
            showLabels: shouldShowLabels,
            svg: container.select('svg').node()
        }
    }));

    if(labelToggle && !labelToggle.dataset.bound){
        labelToggle.dataset.bound = '1';
        labelToggle.addEventListener('change', ()=>{
            const wrap = document.getElementById('fpGraph');
            const show = !!labelToggle.checked;
            labelToggle.dataset.graphLabelsState = show ? 'on' : 'off';
            try { sessionStorage.setItem(labelStateKey, show ? 'on' : 'off'); } catch(e){}
            if(wrap){
                wrap.dataset.showLabels = show ? 'on' : 'off';
                d3.select(wrap).selectAll('.node-label-wrapper').style('display', show ? null : 'none');
            }
            labelToggle.dispatchEvent(new CustomEvent('coretg-graph-label-toggle', {
                bubbles: true,
                detail: { target: '#fpGraph', show }
            }));
        });
    }

    if(labelToggle && labelToggle.dataset.bound && container.node()){
        container.node().dataset.showLabels = shouldShowLabels ? 'on' : 'off';
        container.selectAll('.node-label-wrapper').style('display', shouldShowLabels ? null : 'none');
        try { sessionStorage.setItem(labelStateKey, shouldShowLabels ? 'on' : 'off'); } catch(e){}
    }
}

function buildNodeSectionsTable(full){
    const wrap = document.getElementById('fpNodeSectionsWrap'); if(!wrap) return;
    const servicesByNode = full.services_preview || {};
    const vulnByNode = normalizeVulnerabilitiesByNode(full.vulnerabilities_by_node);
    const segRules = (full.segmentation_preview && full.segmentation_preview.rules) || [];
    const segCnt = {}; segRules.forEach(r=>{ segCnt[r.node_id]=(segCnt[r.node_id]||0)+1; });
    const traffic = full.traffic_summary || {};
    const tSend = {}; const tRecv = {};
    try { (traffic.flows || traffic || []).forEach(f=>{ const s=f.src_id??f.src; const d=f.dst_id??f.dst; if(s!==undefined) tSend[s]=(tSend[s]||0)+1; if(d!==undefined) tRecv[d]=(tRecv[d]||0)+1; }); } catch(e){}
    const all = [];
    const seenIds = new Set();
    const pushNode = (entry) => {
        if(!entry || entry.id === undefined || entry.id === null) return;
        const key = String(entry.id);
        if(seenIds.has(key)) return;
        seenIds.add(key);
        all.push(entry);
    };
    (full.routers||[]).forEach(r=> pushNode({id:r.node_id, name:r.name, type:'router'}));
    (full.hosts||[]).forEach(h=> pushNode({id:h.node_id, name:h.name, type:h.role||'host'}));
    (full.switches_detail||[]).forEach(sw=> pushNode({id:sw.switch_id, name:'sw-'+sw.switch_id, type:'switch'}));
    const hitlPreview = deriveHitlPreviewArtifacts(full);
    if(hitlPreview && Array.isArray(hitlPreview.nodes)){
        hitlPreview.nodes.forEach(node=>{
            if(!node) return;
            const canonical = canonicalNodeType(node.type || (node.isHitl ? 'rj45' : node.isHitlNetwork ? 'network' : 'host'));
            pushNode({
                id: node.id,
                name: node.label || node.name || String(node.id),
                type: canonical,
                hitlAttachment: node.attachment || (node.hitlInterface && node.hitlInterface.attachment) || null,
                hitlAssignment: node.assignment || null,
                hitlPeer: node.peerNodeId || null,
            });
        });
    }
    if(!all.length){ wrap.innerHTML='<div class="text-muted small">No nodes</div>'; return; }
    const rows = all.map(n=>{
        const svc=(servicesByNode[n.id]||[]).join(',');
        const vul=(vulnByNode[n.id]||[]).join(',');
        const sc=segCnt[n.id]||0; const ts=tSend[n.id]||0; const tr=tRecv[n.id]||0;
        let attachmentDisplay = '-';
        if(n.hitlAttachment){
            const baseLabel = prettyHitlAttachment(n.hitlAttachment);
            let assignmentLabel = '';
            if(n.hitlAssignment){
                if(HITL_ATTACHMENT_ALLOWED.has(n.hitlAssignment)){
                    assignmentLabel = prettyHitlAttachment(n.hitlAssignment);
                } else if(n.hitlAssignment === 'existing_host'){
                    assignmentLabel = 'Existing Host';
                } else if(n.hitlAssignment === 'network'){
                    assignmentLabel = 'Isolated Network';
                } else {
                    assignmentLabel = n.hitlAssignment.replace(/_/g, ' ');
                }
            }
            attachmentDisplay = assignmentLabel && assignmentLabel !== baseLabel
                ? `${baseLabel} → ${assignmentLabel}`
                : baseLabel;
        }
        return `<tr><td>${n.id}</td><td>${n.name ?? '-'}</td><td>${n.type || '-'}</td><td>${attachmentDisplay}</td><td>${svc}</td><td>${vul}</td><td>${sc}</td><td>${ts}</td><td>${tr}</td></tr>`;
    }).join('');
    wrap.innerHTML = `<div class='table-responsive'><table class='table table-sm table-bordered mb-0'><thead><tr><th>ID</th><th>Name</th><th>Type</th><th>HITL Attachment</th><th>Services</th><th>Vulns</th><th>Seg Rules</th><th>Traffic S</th><th>Traffic R</th></tr></thead><tbody>${rows}</tbody></table></div>`;
}

// Execute button in Full Preview modal
document.addEventListener('DOMContentLoaded', ()=>{
    const execBtn = document.getElementById('fpExecuteBtn');
    if(execBtn && !execBtn.dataset.boundExecute){
        execBtn.dataset.boundExecute = '1';
        let executing = false;
        const originalLabel = execBtn.textContent;
        const modalEl = document.getElementById('fullPreviewModal');
        let modalHidden = false;
        let allowPreviewRestore = true;
        if(modalEl && !modalEl.dataset.executeVisibilityBound){
            modalEl.addEventListener('shown.bs.modal', () => { modalHidden = false; });
            modalEl.addEventListener('hidden.bs.modal', () => { modalHidden = true; });
            modalEl.dataset.executeVisibilityBound = '1';
        }
        const resolveModalInstance = () => {
            if(!modalEl || !window.bootstrap) return null;
            try {
                return bootstrap.Modal.getInstance(modalEl) || new bootstrap.Modal(modalEl);
            } catch(e){
                console.error('Failed to resolve full preview modal instance', e);
                return null;
            }
        };
        execBtn.addEventListener('click', async ()=>{
            if(executing) return;
            if(!IS_BUILDER_VIEW && (!state.result_path || !state.result_path.endsWith('.xml'))){
                alert('Save XML before executing.');
                return;
            }
            const execInfo = detectLocalEmulation();
            const confirmMsg = 'Execute this scenario now? This will start a CORE session.';
            const { idx: scenarioIdx } = getActiveScenarioContext();
            const modalInstance = resolveModalInstance();
            allowPreviewRestore = true;
            const hideModalForConfirm = async () => {
                try { modalInstance?.hide(); } catch(e){}
                if(modalEl){
                    modalEl.classList.remove('show');
                    modalEl.setAttribute('aria-hidden','true');
                    modalEl.style.display = 'none';
                }
                const openModals = document.querySelectorAll('.modal.show');
                if(openModals.length === 0){
                    document.querySelectorAll('.modal-backdrop').forEach(b => { try { b.remove(); } catch(e){} });
                    document.body.classList.remove('modal-open');
                    document.body.style.removeProperty('paddingRight');
                    document.body.style.removeProperty('overflow');
                }
                modalHidden = true;
                await new Promise(resolve => requestAnimationFrame(() => resolve()));
            };
            const restoreModalIfHidden = () => {
                if(!modalHidden || !allowPreviewRestore) return;
                modalHidden = false;
                try {
                    if(modalInstance){
                        modalInstance.show();
                    } else if(modalEl){
                        modalEl.style.display = 'block';
                        modalEl.classList.add('show');
                        document.body.classList.add('modal-open');
                    }
                } catch(e){}
            };
            await hideModalForConfirm();
            allowPreviewRestore = false;
            const confirmResult = await promptExecuteConfirmation({
                message: confirmMsg,
                scenarioIndex: scenarioIdx,
                alertMessage: '',
                alertTone: 'info',
                keepOpenOnConfirm: true,
            });
            const updateRemoteRepo = !!confirmResult?.updateRemote;
            if(!confirmResult?.confirmed){
                return;
            }
            const forceHideModal = () => {
                try { modalInstance?.hide(); } catch(e){}
                if(modalEl){
                    modalEl.classList.remove('show');
                    modalEl.setAttribute('aria-hidden','true');
                    modalEl.style.display = 'none';
                }
                const openModals = document.querySelectorAll('.modal.show');
                if(openModals.length === 0){
                    document.querySelectorAll('.modal-backdrop').forEach(b => { try { b.remove(); } catch(e){} });
                    document.body.classList.remove('modal-open');
                    document.body.style.removeProperty('paddingRight');
                    document.body.style.removeProperty('overflow');
                }
                modalHidden = true;
            };
            const restoreModal = () => {
                if(!allowPreviewRestore) return;
                try {
                    if(modalInstance){
                        modalInstance.show();
                    } else if(modalEl){
                        modalEl.style.display = 'block';
                        modalEl.classList.add('show');
                        document.body.classList.add('modal-open');
                    }
                } catch(e){}
                modalHidden = false;
            };
            const waitForPaint = async () => {
                await new Promise(resolve => requestAnimationFrame(() => resolve()));
            };
            executing = true;
            execBtn.disabled = true;
            execBtn.classList.add('disabled');
            if(originalLabel){ execBtn.textContent = 'Executing…'; }
            let launchFailed = false;
            try {
                forceHideModal();
                await waitForPaint();
                showExecuteProgressPanel(
                    execInfo.shouldFake ? 'Local emulation run' : 'Preparing CORE run…',
                    execInfo.shouldFake
                        ? 'CORE connection unavailable; running locally.'
                        : (IS_BUILDER_VIEW ? 'Remote CORE backend managed by admin.' : `CORE ${execInfo.host}:${execInfo.port}`)
                );
                // Ensure dock visible
                try { const showBtn=document.getElementById('dockShowBtn'); if(showBtn && !showBtn.classList.contains('d-none')) showBtn.click(); } catch(e){}
                appendLog('--- Execute (Full Preview) start: '+state.result_path+' ---','info');
                const result = await runSyncWithModal({
                    showProgressModal: false,
                    skipConfirm: true,
                    scenarioIndex: scenarioIdx,
                    updateRemoteRepo,
                    confirmResult,
                    advanced: confirmResult?.advanced,
                    onRunId: (runId) => {
                        bindExecuteProgressToRun(runId);
                        appendLog('Run ID: '+runId,'info');
                    },
                    onTick: (data) => {
                        if(data && !data.done){
                            setExecuteProgressStatus('Running CLI…', 'Streaming logs…');
                        }
                    },
                    onComplete: (data) => {
                        if(data?.returncode === 0){
                            completeExecuteProgressPanel(true, 'Scenario started', 'Redirecting to reports…');
                            try {
                                setTimeout(()=>{
                                    if(executeConfirmModalEl && window.bootstrap){
                                        bootstrap.Modal.getOrCreateInstance(executeConfirmModalEl).hide();
                                    }
                                }, 200);
                            } catch(e){}
                            scheduleScenarioRedirect("{{ url_for('reports_page') }}", { delay: 600 });
                        } else {
                            completeExecuteProgressPanel(false, 'Finished with errors', 'Check logs for details.');
                            restoreModal();
                        }
                    },
                    onError: (err) => {
                        launchFailed = true;
                        const detail = (err && err.message) ? err.message : 'Unable to launch CLI';
                        completeExecuteProgressPanel(false, 'Failed to start', detail);
                        restoreModal();
                    },
                });
                if(result === false){
                    if(!launchFailed){
                        completeExecuteProgressPanel(false, 'Failed to start', 'Request aborted');
                        restoreModal();
                    }
                    return;
                }
            } catch(e){
                appendLog('Execution exception: '+e,'error');
                completeExecuteProgressPanel(false, 'Failed to start', 'Unexpected error');
                restoreModal();
            }
            finally {
                execBtn.disabled = false;
                execBtn.classList.remove('disabled');
                if(originalLabel){ execBtn.textContent = originalLabel; }
                executing = false;
            }
        });
    }
});

// Seed clear button
document.addEventListener('DOMContentLoaded', () => {
  const scb = document.getElementById('seedClearBtn');
    // seed clear button removed
});

// ------------- Auto-Save Support for Planning -------------
async function autoSaveXml(){
    if (IS_BUILDER_VIEW) {
        try { showToast('Builder view is read-only.', { autohide: true, delay: 2500 }); } catch (_) {}
        return Promise.reject(new Error('Builder view is read-only'));
    }
    return new Promise((resolve, reject) => {
        try {
            const scenariosJsonInput = document.getElementById('scenarios_json');
            if(!scenariosJsonInput){ reject('Editor form missing'); return; }
            try { scenariosJsonInput.value = JSON.stringify({ scenarios: state.scenarios, active_index: activeIdx }); } catch(e){ reject('Serialize failed'); return; }
            const latestCoreConfig = getCoreConfig(true);
            const coreJsonInput = document.getElementById('core_json');
            if (coreJsonInput) {
                coreJsonInput.value = JSON.stringify(latestCoreConfig);
            }
            const scenarioQueryHint = resolveScenarioQueryHint();
            const projectKeyHint = currentProjectKey || DEFAULT_PROJECT_KEY;
            const priorPassword = state?.core?.ssh_password || '';
            const applyCoreUpdate = (corePayload) => {
                if (!corePayload) return;
                state.core = normalizeCoreState(corePayload, true);
                if (priorPassword && !state.core.ssh_password) {
                    state.core.ssh_password = priorPassword;
                }
                storeCorePasswordInSession();
            };
            const applyResultPath = (resultPath) => {
                if (!resultPath) return;
                const previousProjectKey = currentProjectKey;
                const previousSnapshot = USE_LOCAL_EDITOR_STATE
                    ? { ...(projectStateMap[previousProjectKey] || legacyEditorState || {}) }
                    : {};
                state.result_path = resultPath;
                try { updateDownloadButtonState(); } catch (err) {}
                try {
                    const projectKeyProbe = {
                        project_key_hint: resultPath,
                        result_path: resultPath,
                        scenarios: state.scenarios || [],
                        base_upload: state.base_upload || null,
                        scenario_query: resolveScenarioQueryHint() || null,
                    };
                    const derivedKey = deriveProjectKey(projectKeyProbe, previousProjectKey || DEFAULT_PROJECT_KEY);
                    currentProjectKey = derivedKey || previousProjectKey || DEFAULT_PROJECT_KEY;
                } catch (keyErr) {
                    console.warn('Failed to derive project key from result_path', keyErr);
                    if (!currentProjectKey) {
                        currentProjectKey = previousProjectKey || DEFAULT_PROJECT_KEY;
                    }
                }
                try {
                    if (USE_LOCAL_EDITOR_STATE) {
                        const persisted = { ...previousSnapshot };
                        persisted.result_path = state.result_path;
                        persisted.project_key_hint = state.result_path;
                        projectStateMap[currentProjectKey] = persisted;
                        legacyEditorState = persisted;
                        writeJsonToLocalStorage(LEGACY_EDITOR_STATE_STORAGE_KEY, persisted);
                        writeJsonToLocalStorage(PROJECT_STATE_STORAGE_KEY, projectStateMap);
                    }
                } catch(err) {}
                // Persist again so the new result_path becomes the active project key
                persistEditorState();
            };
            const finalizeSuccess = () => {
                previewState.xmlSaved = true;
                try { updatePlanButtons(); } catch(err) {}
                // Keep the dock's XML Preview in sync for all save paths (auto-save + modal saves).
                try { refreshXmlDockPreview({ force: true, preferSavedPath: true }); } catch (e) {}
                resolve();
            };
            const legacySave = () => {
                const formData = new FormData();
                formData.append('scenarios_json', scenariosJsonInput.value);
                if (coreJsonInput) {
                    formData.append('core_json', coreJsonInput.value);
                }
                formData.append('project_key_hint', projectKeyHint);
                formData.append('scenario_query', scenarioQueryHint || '');
                return fetch('/save_xml', { method:'POST', body: formData, credentials: 'same-origin' })
                    .then(r=>r.text())
                    .then(html => {
                        try {
                            const parser = new DOMParser();
                            const doc = parser.parseFromString(html, 'text/html');
                            const payloadScript = doc.querySelector('#payload-data');
                            if(payloadScript){
                                const newPayload = JSON.parse(payloadScript.textContent || 'null');
                                if(newPayload){
                                    if (newPayload.core) {
                                        applyCoreUpdate(newPayload.core);
                                    }
                                    if(newPayload.result_path){
                                        applyResultPath(newPayload.result_path);
                                        finalizeSuccess();
                                        return;
                                    }
                                }
                            }
                            reject(new Error('Could not detect saved XML path in response'));
                        } catch(e){ reject(e); }
                    })
                    .catch(err => reject(err));
            };
            const apiSave = () => {
                return fetch('/save_xml_api', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    credentials: 'same-origin',
                    body: JSON.stringify({
                        scenarios: state.scenarios,
                        active_index: activeIdx,
                        core: latestCoreConfig,
                        project_key_hint: projectKeyHint,
                        scenario_query: scenarioQueryHint,
                    }),
                }).then(async resp => {
                    let data = null;
                    try { data = await resp.json(); } catch(_) {}
                    if (!resp.ok || !data || data.ok === false) {
                        const errMsg = (data && (data.error || data.message)) || `HTTP ${resp.status}`;
                        throw new Error(errMsg);
                    }
                    if (data.core) {
                        applyCoreUpdate(data.core);
                    }
                    if (data.result_path) {
                        applyResultPath(data.result_path);
                    }
                    finalizeSuccess();
                });
            };
            apiSave().catch(err => {
                console.warn('save_xml_api failed, falling back to legacy save_xml', err);
                legacySave();
            });
        } catch(e){ reject(e); }
    });
}

document.addEventListener('DOMContentLoaded', () => {
    const hitlSnapshotForScenarioIndex = (sidx) => {
        try {
            const scen = Number.isInteger(sidx) ? (state && Array.isArray(state.scenarios) ? state.scenarios[sidx] : null) : null;
            const hitl = (scen && typeof scen === 'object') ? (scen.hitl || null) : null;
            return JSON.stringify(hitl || null);
        } catch (e) {
            return '';
        }
    };

    const scenarioNameForIndex = (sidx) => {
        try {
            const scen = Number.isInteger(sidx) ? (state && Array.isArray(state.scenarios) ? state.scenarios[sidx] : null) : null;
            const name = scen && typeof scen === 'object' ? String(scen.name || '').trim() : '';
            return name;
        } catch (e) {
            return '';
        }
    };

    const bindHitlSnapshotToModal = (modalId) => {
        try {
            const modalEl = document.getElementById(modalId);
            if (!modalEl) return;
            if (modalEl.dataset.hitlSnapshotBound === '1') return;
            const capture = () => {
                try {
                    const { idx } = getActiveScenarioContext();
                    modalEl.dataset.hitlSnapshot = hitlSnapshotForScenarioIndex(idx);
                } catch (e) {}
            };
            if (window.bootstrap) {
                modalEl.addEventListener('show.bs.modal', capture);
            }
            // Fallback: if bootstrap events aren't available, capture on first interaction.
            modalEl.addEventListener('click', () => {
                try {
                    if (!modalEl.dataset.hitlSnapshot) capture();
                } catch (e) {}
            }, { capture: true });
            modalEl.dataset.hitlSnapshotBound = '1';
        } catch (e) {}
    };
    bindHitlSnapshotToModal('coreVmModal');
    bindHitlSnapshotToModal('externalIfxModal');

    const bindModalSaveButton = (buttonId, options = {}) => {
        const btn = document.getElementById(buttonId);
        if (!btn || btn.dataset.modalSaveBound === '1') return;
        const busyHtml = '<span class="spinner-border spinner-border-sm me-2" role="status" aria-hidden="true"></span>Saving…';
        const doFallbackSubmit = () => {
            const editorForm = document.getElementById('editorForm');
            if (!editorForm) return Promise.reject(new Error('Editor form not found'));
            return new Promise((resolve) => {
                try {
                    if (typeof editorForm.requestSubmit === 'function') {
                        editorForm.requestSubmit();
                    } else {
                        editorForm.submit();
                    }
                    resolve();
                } catch (err) {
                    console.warn('Fallback submit failed', err);
                    resolve();
                }
            });
        };
        const runSave = async () => {
            if (typeof autoSaveXml === 'function') {
                await autoSaveXml();
            } else {
                await doFallbackSubmit();
            }
        };
        const closeParentModal = () => {
            try {
                const modalEl = btn.closest('.modal');
                if (modalEl && window.bootstrap) {
                    const instance = window.bootstrap.Modal.getOrCreateInstance(modalEl);
                    instance.hide();
                } else if (modalEl) {
                    modalEl.classList.remove('show');
                    modalEl.setAttribute('aria-hidden', 'true');
                    modalEl.style.display = 'none';
                }
            } catch (err) {
                console.warn('Failed to close modal after save', err);
            }
        };
        btn.addEventListener('click', async () => {
            if (btn.disabled) return;
            const originalHtml = btn.innerHTML;

            // VM / Access: warn if HITL settings were changed since modal open.
            try {
                if ((buttonId === 'coreVmModalSaveBtn' || buttonId === 'externalIfxModalSaveBtn')
                    && (typeof SCENARIOS_ACTIVE_TAB === 'string' && SCENARIOS_ACTIVE_TAB === 'connection-setup')) {
                    const modalEl = btn.closest('.modal');
                    if (modalEl) {
                        const before = String(modalEl.dataset.hitlSnapshot || '');
                        const nowSnap = (() => {
                            try {
                                const { idx } = getActiveScenarioContext();
                                return hitlSnapshotForScenarioIndex(idx);
                            } catch (e) {
                                return '';
                            }
                        })();
                        if (before && nowSnap && before !== nowSnap) {
                            let scenarioName = '';
                            try {
                                const { idx } = getActiveScenarioContext();
                                scenarioName = scenarioNameForIndex(idx);
                            } catch (e) {}
                            const msg = scenarioName
                                ? ('These VM / Access (HITL) changes will invalidate Flag Sequencing for scenario "' + scenarioName + '".\n\nYou may need to re-run Generate on the Flag Sequencing page.\n\nContinue?')
                                : 'These VM / Access (HITL) changes will invalidate Flag Sequencing for this project.\n\nYou may need to re-run Generate on the Flag Sequencing page.\n\nContinue?';
                            const proceed = window.confirm(msg);
                            if (!proceed) return;
                        }
                    }
                }
            } catch (e) {}

            // CORE VM select modal: verify first; only close on success.
            if (buttonId === 'coreVmModalSaveBtn') {
                try {
                    btn.disabled = true;
                    btn.innerHTML = '<span class="spinner-border spinner-border-sm me-2" role="status" aria-hidden="true"></span>Verifying…';
                    const verifyRes = await verifyScenarioCoreSetup(activeIdx, { triggerButton: null });
                    if (!verifyRes || verifyRes.ok !== true) {
                        // Keep the modal open unless user presses Cancel.
                        return;
                    }
                    btn.innerHTML = '<span class="spinner-border spinner-border-sm me-2" role="status" aria-hidden="true"></span>Saving…';
                    await runSave();
                    closeParentModal();
                } catch (err) {
                    const message = err && err.message ? err.message : (typeof err === 'string' ? err : 'Verify & Save failed');
                    console.warn(`Modal verify/save failed: ${message}`);
                    // Toasts are intentionally disabled on this page; fall back to an alert.
                    try { alert(`Verify & Save failed: ${message}`); } catch (_) {}
                } finally {
                    btn.disabled = false;
                    btn.innerHTML = originalHtml;
                }
                return;
            }

            // Config HITL modal: validate + apply + confirm; only close on success.
            if (buttonId === 'externalIfxModalSaveBtn') {
                try {
                    // If HITL is disabled, just save the disabled setting.
                    try {
                        const modalEl = document.getElementById('externalIfxModal');
                        const toggle = modalEl ? modalEl.querySelector(`[data-hitl-toggle][data-scen-idx="${activeIdx}"]`) : null;
                        const enabled = toggle ? !!toggle.checked : !!(state?.scenarios?.[activeIdx]?.hitl?.enabled);
                        if (!enabled) {
                            btn.disabled = true;
                            btn.innerHTML = '<span class="spinner-border spinner-border-sm me-2" role="status" aria-hidden="true"></span>Saving…';
                            await runSave();
                            closeParentModal();
                            return;
                        }
                    } catch (e) {}

                    btn.disabled = true;
                    btn.innerHTML = '<span class="spinner-border spinner-border-sm me-2" role="status" aria-hidden="true"></span>Validating…';
                    const validateRes = await verifyScenarioHitlBridge(activeIdx, { triggerButton: null });
                    if (!validateRes || validateRes.ok !== true) {
                        // Keep the modal open unless user presses Cancel.
                        return;
                    }

                    btn.innerHTML = '<span class="spinner-border spinner-border-sm me-2" role="status" aria-hidden="true"></span>Applying…';
                    const applyRes = await handleExternalIfxApply({ confirmUser: false, setBusy: false, autoSave: false });
                    if (!applyRes || applyRes.ok !== true) {
                        return;
                    }

                    btn.innerHTML = '<span class="spinner-border spinner-border-sm me-2" role="status" aria-hidden="true"></span>Confirming…';
                    const confirmRes = await verifyScenarioHitlBridge(activeIdx, { triggerButton: null });
                    if (!confirmRes || confirmRes.ok !== true) {
                        return;
                    }

                    btn.innerHTML = '<span class="spinner-border spinner-border-sm me-2" role="status" aria-hidden="true"></span>Saving…';
                    await runSave();
                    closeParentModal();
                } catch (err) {
                    const message = err && err.message ? err.message : (typeof err === 'string' ? err : 'Validate & Save failed');
                    console.warn(`Modal verify/save failed: ${message}`);
                    // Toasts are intentionally disabled on this page; fall back to an alert.
                    try { alert(`Validate & Save failed: ${message}`); } catch (_) {}
                } finally {
                    btn.disabled = false;
                    btn.innerHTML = originalHtml;
                    try { syncExternalIfxModalSaveLabel(); } catch (_) {}
                }
                return;
            }

            btn.disabled = true;
            btn.innerHTML = busyHtml;
            try {
                await runSave();
                if (typeof showToast === 'function') {
                    showToast('Scenario saved.', { autohide: true, delay: 2200 });
                }
                closeParentModal();
            } catch (err) {
                const message = err && err.message ? err.message : (typeof err === 'string' ? err : 'Save failed');
                console.warn(`Modal save failed: ${message}`);
                if (typeof showToast === 'function') {
                    showToast(`Scenario save failed: ${message}`, { autohide: false });
                } else {
                    alert(`Scenario save failed: ${message}`);
                }
            } finally {
                btn.disabled = false;
                btn.innerHTML = originalHtml;
            }
        });
        btn.dataset.modalSaveBound = '1';
    };
    bindModalSaveButton('coreVmModalSaveBtn');
    bindModalSaveButton('externalIfxModalSaveBtn');
});

state.core = restoreCorePasswordFromSession(state.core);
if (USE_LOCAL_EDITOR_STATE && persistedState && persistedState.core) {
    const persistedCore = normalizeCoreState(persistedState.core, false);
    state.core = {
        ...state.core,
        ...persistedCore,
    };
    state.core = restoreCorePasswordFromSession(state.core);
}
if (!state.core) {
    state.core = restoreCorePasswordFromSession({});
}
if (USE_LOCAL_EDITOR_STATE && persistedState) {
    if (persistedState.core_ok !== undefined) state.core_ok = persistedState.core_ok;
    if (persistedState.core_tested_host !== undefined) state.core_tested_host = persistedState.core_tested_host;
    if (persistedState.core_tested_port !== undefined) state.core_tested_port = persistedState.core_tested_port;
}
let activeIdx = Math.min(Math.max(0, persistedActiveIdx), (state.scenarios.length||1)-1);

// Prevent stale local project snapshots from resurrecting scenarios that were
// previously deleted (identified by stable _sid).
try { ensureScenarioIds(); } catch (e) {}
try { pruneDeletedScenariosInState(); } catch (e) {}

function persistEditorState(){
    try {
        const baseUploadMeta = normalizeBaseUpload(state.base_upload) || (state.scenarios?.[0]?.base?.filepath || state.scenarios?.[0]?.base?.display_name ? {
            path: state.scenarios?.[0]?.base?.filepath || '',
            display_name: state.scenarios?.[0]?.base?.display_name || (state.scenarios?.[0]?.base?.filepath ? state.scenarios[0].base.filepath.split(/[/\\]/).pop() || '' : '')
        } : null);
        const coreForPersist = sanitizeCoreForPersist(state.core);
        const scenariosForSnapshot = cloneScenariosForSnapshot(state.scenarios || []);
        const snapshot = {
            scenarios: scenariosForSnapshot,
            result_path: state.result_path || null,
            core: coreForPersist || null,
            core_ok: !!state.core_ok,
            core_tested_host: state.core_tested_host || null,
            core_tested_port: state.core_tested_port || null,
            base_upload: baseUploadMeta,
            host_interfaces: Array.isArray(state.host_interfaces) ? state.host_interfaces : [],
            host_interfaces_source: state.host_interfaces_source || null,
            host_interfaces_metadata: state.host_interfaces_metadata || null,
            host_interfaces_fetched_at: state.host_interfaces_fetched_at || null,
        };
        snapshot.active_index = Number.isInteger(activeIdx) ? activeIdx : 0;
        const scenarioSignature = deriveScenarioSignature({ scenarios: scenariosForSnapshot });
        const trimmedScenarioToken = (scenarioQueryToken || '').trim();
        const nextScenarioQuery = trimmedScenarioToken || scenarioSignature || '';
        snapshot.scenario_query = nextScenarioQuery || null;
        if (!trimmedScenarioToken && nextScenarioQuery) {
            scenarioQueryToken = nextScenarioQuery;
        }
        const stableProjectHint = (() => {
            if (currentProjectKey && currentProjectKey !== DEFAULT_PROJECT_KEY) return currentProjectKey;
            if (snapshot.project_key_hint) return snapshot.project_key_hint;
            if (nextScenarioQuery) return nextScenarioQuery;
            if (snapshot.result_path) return snapshot.result_path;
            if (snapshot.base_upload && snapshot.base_upload.path) return snapshot.base_upload.path;
            return null;
        })();
        snapshot.project_key_hint = stableProjectHint;
        scrubSnapshotTransientErrors(snapshot);

        // Always persist a sanitized snapshot on the server so refresh/back doesn't lose
        // newly-created state for users who don't use local persistence (e.g. builder view).
        try { scheduleServerSnapshotPersist(snapshot); } catch (_) {}
        try { storeCorePasswordInSession(); } catch (_) {}

        // Local persistence is admin-only (and disabled in builder view).
        if (!ALLOW_LOCAL_EDITOR_PERSISTENCE) return;

        writeJsonToLocalStorage(LEGACY_EDITOR_STATE_STORAGE_KEY, snapshot);
        const nextProjectKey = deriveProjectKey(snapshot, currentProjectKey || DEFAULT_PROJECT_KEY);
        currentProjectKey = nextProjectKey || DEFAULT_PROJECT_KEY;
        projectStateMap[currentProjectKey] = snapshot;
        writeJsonToLocalStorage(PROJECT_STATE_STORAGE_KEY, projectStateMap);
        activeIdxMap[currentProjectKey] = activeIdx || 0;
        writeJsonToLocalStorage(PROJECT_ACTIVE_IDX_STORAGE_KEY, activeIdxMap);
        try { localStorage.setItem(LAST_PROJECT_KEY_STORAGE_KEY, currentProjectKey); } catch (err) {}
        localStorage.setItem('coretg_active_idx', String(activeIdx||0));
    } catch(e){}
}
// Persist initial merged state so it survives cross-page navigation immediately
persistEditorState();

// On refresh/navigation, flush any pending server snapshot so edits aren't lost.
try {
    window.addEventListener('pagehide', () => { try { flushServerSnapshotPersistNow(); } catch (_) {} }, { capture: true });
    window.addEventListener('beforeunload', () => { try { flushServerSnapshotPersistNow(); } catch (_) {} }, { capture: true });
} catch (e) {}

const dropdownsBySection = {
    'Node Information': ['Server','Workstation','PC','Docker','Random'],
    // Added 'Random' entry so user can explicitly request a random routing protocol.
    'Routing': ['RIP','RIPNG','BGP','OSPFv2','OSPFv3','Random'],
    'Services': ['SSH','HTTP','DHCPClient','Random'],
    'Traffic': ['Random','TCP','UDP','CUSTOM'],
    'Events': ['Script Path'],
    'Vulnerabilities': ['Category','Specific','Random'],
    'Segmentation': ['Random','Firewall','NAT','CUSTOM']
};

const proxInventoryFetchInFlight = new Set();
// Feature flag: disable automatic CORE VM interface refresh; require explicit user action
const HOST_INTERFACES_AUTO_REFRESH_ENABLED = false;
// Feature flag: disable automatic Proxmox VM inventory refresh; rely on user action
const PROXMOX_INVENTORY_AUTO_REFRESH_ENABLED = false;
const HOST_INTERFACES_REFRESH_COOLDOWN_MS = 10_000;
const HOST_INTERFACES_REQUEST_TIMEOUT_MS = 15_000;
const HOST_INTERFACES_MAX_AUTO_RETRIES = 5;
const hostInterfacesRetryTimers = new Map();
const hostInterfacesRetryCounters = new Map();
const HITL_MODAL_AUTO_REFRESH_STALE_MS = 30_000;

function isNetworkFetchError(err) {
    if (!err || typeof err !== 'object') return false;
    if (err.name === 'TypeError' && typeof err.message === 'string' && /fetch/i.test(err.message)) return true;
    if (err.message && typeof err.message === 'string' && err.message.includes('Failed to fetch')) return true;
    return false;
}

function isHitlAuthenticationReady(hitlState) {
    if (!hitlState || typeof hitlState !== 'object') return false;
    const proxState = hitlState.proxmox && typeof hitlState.proxmox === 'object' ? hitlState.proxmox : {};
    const coreState = hitlState.core && typeof hitlState.core === 'object' ? hitlState.core : {};
    const proxValidated = !!(proxState.validated && proxState.secret_id);
    const coreSecretId = typeof coreState.core_secret_id === 'string' ? coreState.core_secret_id.trim() : '';
    const vmKey = (coreState.vm_key || '').toString();
    return proxValidated && !!coreSecretId && !!vmKey;
}

function setHitlStatus(sidx, message, tone = 'info') {
    const statusEl = document.querySelector(`[data-hitl-status="${sidx}"]`);
    if (!statusEl) return;
    statusEl.textContent = message;
    const toneClasses = ['text-danger', 'text-warning', 'text-success', 'text-muted'];
    toneClasses.forEach(cls => statusEl.classList.remove(cls));
    switch (tone) {
        case 'error':
            statusEl.classList.add('text-danger');
            break;
        case 'warning':
            statusEl.classList.add('text-warning');
            break;
        case 'success':
            statusEl.classList.add('text-success');
            break;
        case 'neutral':
            statusEl.classList.add('text-muted');
            break;
        default:
            statusEl.classList.add('text-muted');
            break;
    }
}

async function refreshHostInterfacesForScenario(sidx, options = {}) {
    const {
        reason = 'manual',
        silent = false,
        setStatus = null,
        timeoutMs = null,
    } = options;
    const scenario = Number.isInteger(sidx) ? state.scenarios?.[sidx] : null;
    const retryKey = String(sidx);
    if (hostInterfacesRetryTimers.has(retryKey)) {
        clearTimeout(hostInterfacesRetryTimers.get(retryKey));
        hostInterfacesRetryTimers.delete(retryKey);
    }
    const statusFn = typeof setStatus === 'function'
        ? setStatus
        : (message, tone) => setHitlStatus(sidx, message, tone);
    if (!scenario) {
        statusFn('Scenario unavailable for refresh.', 'error');
        return { ok: false, reason: 'no-scenario' };
    }
    const hitlState = ensureHitlStateForScenario(scenario);
    const proxState = hitlState.proxmox && typeof hitlState.proxmox === 'object' ? hitlState.proxmox : {};
    const proxValidated = !!(proxState.validated && proxState.secret_id);
    if (!proxValidated) {
        statusFn('Validate Proxmox credentials in Step 1 before refreshing interfaces.', 'error');
        if (!silent) {
            try { showToast('Validate Proxmox credentials to unlock HITL steps.', { autohide: true, delay: 2800 }); } catch (e) {}
        }
        return { ok: false, reason: 'no-proxmox' };
    }
    const coreState = hitlState.core || (hitlState.core = {});
    const coreSecretId = typeof coreState.core_secret_id === 'string' ? coreState.core_secret_id.trim() : '';
    if (!coreSecretId) {
        statusFn('Store CORE credentials to enumerate interfaces.', 'error');
        if (!silent) {
            try { showToast('Configure CORE credentials to refresh interfaces.', { autohide: true, delay: 2500 }); } catch (e) {}
        }
        return { ok: false, reason: 'no-secret' };
    }
    const nowIso = new Date().toISOString();
    coreState.last_interfaces_attempt = nowIso;
    if (coreState.interfaces_refresh_inflight) {
        statusFn('Interface refresh already in progress.', 'warning');
        return { ok: false, reason: 'busy' };
    }
    const vmKey = (coreState.vm_key || '').toString();
    const coreVmMeta = {
        vm_key: vmKey,
        vm_name: coreState.vm_name || '',
        vm_node: '',
        vmid: '',
    };
    if (vmKey) {
        const [nodePart, vmidPart] = vmKey.split('::');
        coreVmMeta.vm_node = (nodePart || '').trim();
        coreVmMeta.vmid = vmidPart && vmidPart.trim() ? vmidPart.trim() : '';
    }
    const proxInventory = hitlState.proxmox && hitlState.proxmox.inventory && Array.isArray(hitlState.proxmox.inventory.vms)
        ? hitlState.proxmox.inventory.vms
        : [];
    const targetVm = proxInventory.find(vm => `${vm.node ?? ''}::${vm.vmid ?? ''}` === vmKey);
    if (targetVm) {
        coreVmMeta.vm_name = targetVm.name ? String(targetVm.name) : coreVmMeta.vm_name;
        if (!coreVmMeta.vm_node && targetVm.node) coreVmMeta.vm_node = String(targetVm.node);
        if (!coreVmMeta.vmid && targetVm.vmid !== undefined && targetVm.vmid !== null) coreVmMeta.vmid = String(targetVm.vmid);
        if (Array.isArray(targetVm.interfaces)) {
            coreVmMeta.interfaces = targetVm.interfaces;
        }
    }
    coreState.interfaces_refresh_inflight = true;
    coreState.last_interfaces_error = null;
    persistEditorState();
    try { window.requestAnimationFrame(() => renderMain()); } catch (err) {}
    statusFn(reason === 'auto' ? 'Enumerating host interfaces…' : 'Refreshing interface list…', 'neutral');
    const controller = (typeof AbortController === 'function') ? new AbortController() : null;
    const requestTimeoutMs = Number.isFinite(timeoutMs) && timeoutMs > 0 ? timeoutMs : HOST_INTERFACES_REQUEST_TIMEOUT_MS;
    let timeoutId = null;
    let timedOut = false;
    try {
        const payload = {
            core_secret_id: coreSecretId,
            include_down: true,
            core_vm: coreVmMeta,
            scenario_index: sidx,
            scenario_name: scenario?.name || '',
        };
        const fetchOptions = {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Accept': 'application/json',
            },
            credentials: 'same-origin',
            body: JSON.stringify(payload),
        };
        if (controller) {
            fetchOptions.signal = controller.signal;
        }
        const fetchPromise = fetch('/api/host_interfaces', fetchOptions);
        const shouldTimeout = requestTimeoutMs > 0;
        let resp;
        if (shouldTimeout) {
            const timeoutPromise = new Promise((_, reject) => {
                timeoutId = window.setTimeout(() => {
                    timedOut = true;
                    if (controller) {
                        try { controller.abort(); } catch (err) { /* ignore */ }
                    }
                    reject(new Error('RequestTimedOut'));
                }, requestTimeoutMs);
            });
            resp = await Promise.race([fetchPromise, timeoutPromise]);
        } else {
            resp = await fetchPromise;
        }
        if (timeoutId !== null) {
            try { window.clearTimeout(timeoutId); } catch (err) { /* ignore */ }
            timeoutId = null;
        }
        if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
        const contentType = resp.headers.get('content-type') || '';
        let data;
        if (contentType.toLowerCase().includes('application/json')) {
            data = await resp.json();
        } else {
            const text = await resp.text();
            const snippet = text ? text.trim().slice(0, 240) : 'Empty response body';
            throw new Error(`Non-JSON response from host interface endpoint: ${snippet}`);
        }
        if (!data || data.success === false) {
            const errMsg = data && data.error ? data.error : 'Interface enumeration failed';
            throw new Error(errMsg);
        }
        const interfaces = Array.isArray(data.interfaces) ? data.interfaces : [];
        state.host_interfaces = interfaces;
        state.host_interfaces_vm_key = (coreState.vm_key || '').toString();
        state.host_interfaces_source = data.source || 'core_vm';
        state.host_interfaces_metadata = data.metadata || null;
        const fetchedAt = data.fetched_at || new Date().toISOString();
        state.host_interfaces_fetched_at = fetchedAt;
        coreState.last_interfaces_refresh = fetchedAt;
        coreState.last_interfaces_error = null;

        // Persist per-scenario cache so interfaces survive reloads until VM is changed/cleared.
        coreState.cached_host_interfaces = interfaces;
        coreState.cached_host_interfaces_vm_key = (coreState.vm_key || '').toString();
        coreState.cached_host_interfaces_source = state.host_interfaces_source;
        coreState.cached_host_interfaces_metadata = state.host_interfaces_metadata;
        coreState.cached_host_interfaces_fetched_at = fetchedAt;
        persistEditorState();
        hostInterfacesRetryCounters.delete(retryKey);
        const hidden = document.getElementById('scenarios_json');
        if (hidden) hidden.value = JSON.stringify({ scenarios: state.scenarios, active_index: activeIdx });
        renderMain();
        statusFn('Interfaces refreshed from CORE VM', 'success');
        if (!silent) {
            try { showToast('CORE interfaces refreshed', { autohide: true, delay: 2200 }); } catch (e) {}
        }
        return { ok: true, data };
    } catch (err) {
        const requestTimedOut = timedOut || (err && (err.name === 'AbortError' || err.code === 20 || err.message === 'RequestTimedOut'));
        const networkFailure = requestTimedOut || isNetworkFetchError(err);
        const timeoutSeconds = Math.max(1, Math.round((requestTimeoutMs || HOST_INTERFACES_REQUEST_TIMEOUT_MS) / 1000));
        const message = requestTimedOut
            ? `Interface refresh timed out after ${timeoutSeconds} seconds. Verify CORE connectivity and try again.`
            : (networkFailure
                ? 'Unable to reach the server while refreshing interfaces. Will retry shortly.'
                : (err?.message ? String(err.message) : 'Refresh failed. Check server logs.'));
        if (networkFailure) {
            logWarn(`Host interface refresh temporarily unavailable: ${err}`);
        } else {
            logError(`Failed to refresh host interfaces: ${err}`);
        }
        coreState.last_interfaces_error = message;
        statusFn(message, 'error');
        persistEditorState();
        try { renderMain(); } catch (e) {}
        const autoEligible = (reason === 'auto' || reason === 'retry');
        if (networkFailure && autoEligible) {
            const attempts = (hostInterfacesRetryCounters.get(retryKey) || 0) + 1;
            hostInterfacesRetryCounters.set(retryKey, attempts);
            if (attempts <= HOST_INTERFACES_MAX_AUTO_RETRIES) {
                const backoffMs = Math.min(60_000, 2_000 * Math.pow(2, attempts - 1));
                const timerId = window.setTimeout(() => {
                    hostInterfacesRetryTimers.delete(retryKey);
                    refreshHostInterfacesForScenario(sidx, {
                        reason: 'retry',
                        silent: true,
                        setStatus: (msg, tone) => setHitlStatus(sidx, msg, tone),
                    }).catch(err2 => console.warn('Auto retry refresh host interfaces failed', err2));
                }, backoffMs);
                hostInterfacesRetryTimers.set(retryKey, timerId);
            } else {
                logWarn(`Max auto retries reached for host interface refresh on scenario ${retryKey}`);
            }
        }
        return { ok: false, reason: 'error', error: err };
    } finally {
        if (timeoutId !== null) {
            try { window.clearTimeout(timeoutId); } catch (err) { /* ignore */ }
        }
        coreState.interfaces_refresh_inflight = false;
        persistEditorState();
        try { window.requestAnimationFrame(() => renderMain()); } catch (err) {}
    }
}

function maybeAutoRefreshHitlInterfacesOnModalOpen(sidx) {
    // (helper declarations live above; keep function order stable)
    const scenario = Number.isInteger(sidx) ? state.scenarios?.[sidx] : null;
    if (!scenario) return;
    const hitlState = ensureHitlStateForScenario(scenario);
    if (!isHitlAuthenticationReady(hitlState)) return;
    const coreState = hitlState.core || {};
    if (coreState.interfaces_refresh_inflight) return;
    try { bindHostInterfacesToScenarioCache(sidx); } catch (e) {}
    const hostInterfaces = getEffectiveHostInterfacesForScenario(sidx);
    const lastRefreshMs = Date.parse(coreState.last_interfaces_refresh || '');
    const hasError = !!coreState.last_interfaces_error;
    const shouldRefresh = (() => {
        if (!hostInterfaces.length) return true;
        if (hasError) return true;
        if (Number.isNaN(lastRefreshMs)) return true;
        return (Date.now() - lastRefreshMs) > HITL_MODAL_AUTO_REFRESH_STALE_MS;
    })();
    if (!shouldRefresh) return;
    refreshHostInterfacesForScenario(sidx, {
        reason: 'modal-open',
        silent: true,
        setStatus: (message, tone) => setHitlStatus(sidx, message, tone),
    }).catch(err => console.warn('HITL modal auto-refresh failed', err));
}

function getEffectiveHostInterfacesForScenario(sidx) {
    const scenario = Number.isInteger(sidx) ? state.scenarios?.[sidx] : null;
    const hitlState = scenario ? ensureHitlStateForScenario(scenario) : null;
    const coreState = hitlState && hitlState.core && typeof hitlState.core === 'object' ? hitlState.core : {};
    const vmKey = (coreState.vm_key || '').toString();
    const currentVmKey = (state.host_interfaces_vm_key || '').toString();
    const current = Array.isArray(state.host_interfaces) ? state.host_interfaces : [];
    if (current.length && vmKey && currentVmKey === vmKey) {
        return current;
    }
    const cached = Array.isArray(coreState.cached_host_interfaces) ? coreState.cached_host_interfaces : [];
    const cachedVmKey = (coreState.cached_host_interfaces_vm_key || '').toString();
    if (cached.length && vmKey && cachedVmKey === vmKey) {
        return cached;
    }
    return current;
}

function bindHostInterfacesToScenarioCache(sidx) {
    const scenario = Number.isInteger(sidx) ? state.scenarios?.[sidx] : null;
    if (!scenario) return;
    const hitlState = ensureHitlStateForScenario(scenario);
    const coreState = (hitlState.core && typeof hitlState.core === 'object') ? hitlState.core : {};
    const vmKey = (coreState.vm_key || '').toString();
    if (!vmKey) return;
    const cached = Array.isArray(coreState.cached_host_interfaces) ? coreState.cached_host_interfaces : [];
    const cachedVmKey = (coreState.cached_host_interfaces_vm_key || '').toString();
    if (!cached.length || cachedVmKey !== vmKey) return;
    const currentVmKey = (state.host_interfaces_vm_key || '').toString();
    const current = Array.isArray(state.host_interfaces) ? state.host_interfaces : [];
    if (current.length && currentVmKey === vmKey) return;
    state.host_interfaces = cached;
    state.host_interfaces_vm_key = vmKey;
    state.host_interfaces_source = (coreState.cached_host_interfaces_source ?? state.host_interfaces_source ?? null);
    state.host_interfaces_metadata = (coreState.cached_host_interfaces_metadata ?? state.host_interfaces_metadata ?? null);
    state.host_interfaces_fetched_at = (coreState.cached_host_interfaces_fetched_at ?? state.host_interfaces_fetched_at ?? null);
}

function scheduleAutoRefreshHostInterfaces(sidx) {
    if (!HOST_INTERFACES_AUTO_REFRESH_ENABLED) return;
    const scenario = Number.isInteger(sidx) ? state.scenarios?.[sidx] : null;
    if (!scenario) return;
    const hitlState = ensureHitlStateForScenario(scenario);
    if (!hitlState.enabled) return;
    if (!isHitlAuthenticationReady(hitlState)) return;
    const coreState = hitlState.core || (hitlState.core = {});
    try { bindHostInterfacesToScenarioCache(sidx); } catch (e) {}
    const hostInterfaces = getEffectiveHostInterfacesForScenario(sidx);
    if (hostInterfaces.length) return;
    if (coreState.interfaces_refresh_inflight) return;
    const coreSecretId = typeof coreState.core_secret_id === 'string' ? coreState.core_secret_id.trim() : '';
    if (!coreSecretId) return;
    if (!(coreState.vm_key || '').toString()) return;
    const lastAttemptMs = Date.parse(coreState.last_interfaces_attempt || '');
    if (!Number.isNaN(lastAttemptMs) && (Date.now() - lastAttemptMs) < HOST_INTERFACES_REFRESH_COOLDOWN_MS) {
        return;
    }
    window.setTimeout(() => {
        refreshHostInterfacesForScenario(sidx, {
            reason: 'auto',
            silent: true,
            setStatus: (message, tone) => setHitlStatus(sidx, message, tone),
        }).catch(err => console.warn('Auto refresh host interfaces failed', err));
    }, 150);
}

function describeTimestampRelative(isoString) {
    if (!isoString || typeof isoString !== 'string') return null;
    const epoch = Date.parse(isoString);
    if (Number.isNaN(epoch)) return null;
    try {
        const deltaMs = Date.now() - epoch;
        if (Math.abs(deltaMs) < 90_000) return 'just now';
        return new Date(epoch).toLocaleString();
    } catch (err) {
        return null;
    }
}

function updateHitlStatusForScenario(sidx) {
    const scenario = Number.isInteger(sidx) ? state.scenarios?.[sidx] : null;
    if (!scenario) return;
    const hitlState = ensureHitlStateForScenario(scenario);
    if (!hitlState.enabled) {
        if (isHitlAuthenticationReady(hitlState)) {
            setHitlStatus(sidx, 'Enable Hardware in the Loop to manage interface mappings.', 'neutral');
        } else {
            setHitlStatus(sidx, 'Validate Steps 1 and 2 before enabling Hardware in the Loop.', 'warning');
        }
        return;
    }
    if (!isHitlAuthenticationReady(hitlState)) {
        setHitlStatus(sidx, 'Validate Proxmox credentials and store CORE credentials to manage HITL interfaces.', 'warning');
        return;
    }
    const coreState = hitlState.core || {};
    try { bindHostInterfacesToScenarioCache(sidx); } catch (e) {}
    const hostInterfaces = getEffectiveHostInterfacesForScenario(sidx);
    const hasInterfaces = hostInterfaces.length > 0;
    const refreshBusy = coreState.interfaces_refresh_inflight === true;
    const lastAttemptStr = coreState.last_interfaces_attempt;
    const lastRefreshStr = coreState.last_interfaces_refresh;
    const lastError = coreState.last_interfaces_error;
    if (refreshBusy) {
        setHitlStatus(sidx, 'Enumerating host interfaces…', 'neutral');
        return;
    }
    if (lastError) {
        const attemptLabel = describeTimestampRelative(lastAttemptStr);
        const message = attemptLabel ? `${lastError} • Last attempt ${attemptLabel}` : lastError;
        setHitlStatus(sidx, message, 'error');
        return;
    }
    if (hasInterfaces) {
        const refreshLabel = describeTimestampRelative(lastRefreshStr) || 'recently';
        setHitlStatus(sidx, `Interfaces loaded from CORE VM ${refreshLabel}.`, 'success');
        return;
    }
    const attemptLabel = describeTimestampRelative(lastAttemptStr);
    if (attemptLabel) {
        setHitlStatus(sidx, `No interfaces detected yet • Last attempt ${attemptLabel}`, 'warning');
    } else {
        setHitlStatus(sidx, 'Select Refresh to enumerate interfaces from the CORE VM.', 'neutral');
    }
}

function updateParticipantProxmoxNavLink() {
    const wrapper = document.getElementById('navParticipantLinkWrap');
    const link = document.getElementById('navParticipantLink');
    if (!wrapper || !link) return;
    const scenario = state.scenarios?.[activeIdx];

    // Server can inject the participant URL for the currently loaded `?scenario=` even before
    // the editor state is fully hydrated. Use it as a fallback ONLY when it matches the loaded
    // scenario query, so switching scenarios in the editor doesn't accidentally inherit it.
    const serverInitial = normalizeParticipantProxmoxHref(link.getAttribute('data-initial-participant-url') || '');
    let serverInitialApplicable = false;
    try {
        const params = new URLSearchParams(window.location.search || '');
        const queryScenario = (params.get('scenario') || '').trim();
        const queryKey = _scenarioMatchKey(queryScenario);
        if (!link.dataset.serverInitialScenarioKey) {
            link.dataset.serverInitialScenarioKey = queryKey;
        }
        const isInitialScenario = !!queryKey && link.dataset.serverInitialScenarioKey === queryKey;
        if (isInitialScenario && queryScenario && scenario && _scenarioMatchKey(queryScenario) === _scenarioMatchKey(scenario.name || '')) {
            serverInitialApplicable = true;
        }
    } catch (e) {
        serverInitialApplicable = false;
    }

    if (!scenario) {
        wrapper.classList.add('d-none');
        link.href = '#';
        link.setAttribute('aria-disabled', 'true');
        link.dataset.participantUiHref = '';
        window.CORETG_PARTICIPANT_UI_HREF = '';
        return;
    }

    const hitlState = ensureHitlStateForScenario(scenario);
    const stateHref = normalizeParticipantProxmoxHref(hitlState.participant_proxmox_url || '');
    const href = stateHref || (serverInitialApplicable ? serverInitial : '');

    if (!href) {
        wrapper.classList.add('d-none');
        link.setAttribute('aria-disabled', 'true');
        link.setAttribute('title', 'Participant-UI unavailable');
        link.dataset.participantUiHref = '';
        window.CORETG_PARTICIPANT_UI_HREF = '';
        return;
    }

    wrapper.classList.remove('d-none');
    link.removeAttribute('aria-disabled');
    link.setAttribute('title', `Participant-UI (${href})`);
    link.dataset.participantUiHref = href;
    window.CORETG_PARTICIPANT_UI_HREF = href;
}

function updateDownloadButtonState() {
    const dlBtn = document.getElementById('downloadXmlBtn');
    if (!dlBtn) return;
    const rp = state.result_path || '';
    if (rp && rp.endsWith('.xml')) {
        dlBtn.removeAttribute('disabled');
        dlBtn.classList.remove('pe-none');
        dlBtn.setAttribute('title', '');
    } else {
        dlBtn.setAttribute('disabled', 'disabled');
        dlBtn.classList.add('pe-none');
        dlBtn.setAttribute('title', 'Save XML first');
    }
}

function render() {
    updateActiveScenarioQueryParam();
    renderSidebar();
    renderMain();
    updateParticipantProxmoxNavLink();
    // Ensure H/S bounds visibility reflects initial r2s_mode values
    updateHsBoundsVisibility();
    // Ensure routing policy preview replaces the default "(pending)" label.
    setTimeout(validateRoutingEdges, 0);
    // Enable/disable Download XML button based on saved xml path
    updateDownloadButtonState();
    // Sync Base Scenario UI with persisted metadata (independent of active scenario)
    const scen0 = state.scenarios?.[0] || {};
    const scen0Base = (typeof scen0.base === 'object' && scen0.base) ? scen0.base : {};
    const metaBase = (state.base_upload && typeof state.base_upload === 'object') ? state.base_upload : (initialPayload?.base_upload && typeof initialPayload.base_upload === 'object' ? initialPayload.base_upload : {});
    const basePath = metaBase.path || scen0Base.filepath || '';
    const baseDisplayName = metaBase.display_name || scen0Base.display_name || (basePath ? basePath.split(/[/\\]/).pop() : '');
    const baseValid = typeof metaBase.valid === 'boolean' ? metaBase.valid : true;

    const baseIn = document.getElementById('baseFileInput');
    if (baseIn) {
        const current = baseIn.value || '';
        const target = baseDisplayName || '';
        if (current !== target) baseIn.value = target;
    }
    const baseBadge = document.getElementById('baseValidityBadge');
    if (baseBadge) {
        if (basePath) {
            baseBadge.textContent = baseValid ? 'VALID' : 'INVALID';
            baseBadge.classList.remove('d-none', 'text-bg-success', 'text-bg-danger');
            baseBadge.classList.add(baseValid ? 'text-bg-success' : 'text-bg-danger');
        } else {
            baseBadge.classList.add('d-none');
            baseBadge.classList.remove('text-bg-success', 'text-bg-danger');
        }
    }
    const baseDetailsLink = document.getElementById('baseDetailsLink');
    if (baseDetailsLink) {
        if (basePath) {
            const baseUrl = baseDetailsLink.dataset.baseUrl || baseDetailsLink.getAttribute('href') || '';
            if (baseUrl) {
                baseDetailsLink.href = `${baseUrl}${encodeURIComponent(basePath)}`;
            }
            baseDetailsLink.classList.remove('d-none');
        } else {
            baseDetailsLink.classList.add('d-none');
        }
    }
    const baseRemoveForm = document.getElementById('baseRemoveForm');
    if (baseRemoveForm) {
        if (basePath) baseRemoveForm.classList.remove('d-none');
        else baseRemoveForm.classList.add('d-none');
    }
}

function toggleEditorBusy(isBusy) {
    const root = document.getElementById('editorRoot');
    if (root) {
        root.classList.toggle('opacity-50', !!isBusy);
        if (isBusy) {
            root.setAttribute('aria-busy', 'true');
        } else {
            root.removeAttribute('aria-busy');
        }
    }
    document.querySelectorAll('#editorRoot button, #editorRoot input, #editorRoot select, #editorRoot textarea').forEach(el => {
        if (el.closest('#proxmoxAssignModal')) return;
        if (el.closest('#coreConnectionModal')) return;
        if (isBusy) {
            el.setAttribute('data-busy-disabled', el.disabled ? '1' : '0');
            el.disabled = true;
        } else if (el.hasAttribute('data-busy-disabled')) {
            const wasDisabled = el.getAttribute('data-busy-disabled') === '1';
            el.disabled = wasDisabled;
            el.removeAttribute('data-busy-disabled');
        }
    });
}

function toggleExternalIfxModalBusy(isBusy) {
    const modal = document.getElementById('externalIfxModal');
    if (!modal) return;
    const busy = !!isBusy;
    const notice = document.getElementById('externalIfxBusyNotice');
    if (busy) {
        modal.setAttribute('aria-busy', 'true');
        if (notice) {
            notice.textContent = 'Refreshing Proxmox interfaces…';
            notice.classList.remove('d-none');
        }
    } else {
        modal.removeAttribute('aria-busy');
        if (notice) {
            notice.classList.add('d-none');
            notice.textContent = '';
        }
    }
    modal.querySelectorAll('button, input, select, textarea').forEach(el => {
        if (el.matches('[data-bs-dismiss="modal"]')) return;
        if (busy) {
            if (!el.hasAttribute('data-ifx-busy-disabled')) {
                el.setAttribute('data-ifx-busy-disabled', el.disabled ? '1' : '0');
            }
            el.disabled = true;
        } else if (el.hasAttribute('data-ifx-busy-disabled')) {
            const wasDisabled = el.getAttribute('data-ifx-busy-disabled') === '1';
            el.disabled = wasDisabled;
            el.removeAttribute('data-ifx-busy-disabled');
        }
    });
}

let externalIfxStatusTimer = null;

function clearExternalIfxStatus() {
    const notice = document.getElementById('externalIfxBusyNotice');
    if (!notice) return;
    notice.classList.add('d-none');
    notice.classList.remove('alert-info', 'alert-success', 'alert-warning', 'alert-danger');
    notice.textContent = '';
    notice.removeAttribute('aria-busy');
    if (externalIfxStatusTimer) {
        clearTimeout(externalIfxStatusTimer);
        externalIfxStatusTimer = null;
    }
}

function updateExternalIfxStatus(message, variant = 'info', { busy = false, autoHideMs = 0 } = {}) {
    const notice = document.getElementById('externalIfxBusyNotice');
    if (!notice) return;
    const variants = ['info', 'success', 'warning', 'danger'];
    if (externalIfxStatusTimer) {
        clearTimeout(externalIfxStatusTimer);
        externalIfxStatusTimer = null;
    }
    notice.classList.remove('alert-info', 'alert-success', 'alert-warning', 'alert-danger');
    if (!message) {
        clearExternalIfxStatus();
        return;
    }
    if (!variants.includes(variant)) variant = 'info';
    notice.classList.remove('d-none');
    notice.classList.add(`alert-${variant}`);
    notice.textContent = message;
    notice.setAttribute('role', 'status');
    notice.setAttribute('aria-live', variant === 'danger' ? 'assertive' : 'polite');
    notice.setAttribute('aria-busy', busy ? 'true' : 'false');
    if (autoHideMs > 0) {
        externalIfxStatusTimer = window.setTimeout(() => {
            clearExternalIfxStatus();
        }, autoHideMs);
    }
}

function setExternalIfxApplyBusy(isBusy, label = 'Applying…') {
    const btn = document.getElementById('externalIfxApplyBtn');
    if (!btn) return;
    if (!btn.dataset.defaultHtml) {
        btn.dataset.defaultHtml = btn.innerHTML || btn.textContent || 'Apply';
    }
    if (isBusy) {
        btn.disabled = true;
        btn.innerHTML = `<span class="spinner-border spinner-border-sm me-2" role="status" aria-hidden="true"></span>${label}`;
    } else {
        btn.disabled = false;
        const fallback = btn.dataset.defaultHtml || 'Apply';
        btn.innerHTML = fallback;
    }
}

async function handleExternalIfxApply(options = {}) {
    const { confirmUser = true, setBusy = true, autoSave = true } = options || {};
    const bridgeName = computeInternalBridgeName();
    logInfo(`External IFX apply initiated for bridge ${bridgeName}`);
    if (confirmUser) {
        const message = `This will create a new internal bridge named "${bridgeName}" and use it to connect the CORE VM with the selected VM.\n\nDo you want to continue?`;
        if (!window.confirm(message)) {
            logInfo('External IFX apply cancelled by user');
            return { ok: false, cancelled: true, message: 'Cancelled' };
        }
    }
    if (setBusy) {
        setExternalIfxApplyBusy(true);
    }
    updateExternalIfxStatus(`Applying bridge "${bridgeName}"…`, 'info', { busy: true });
    try {
        const { idx, scenario, name: scenarioName } = getActiveScenarioContext();
        if (idx === null || !scenario) {
            const failureMessage = 'Unable to determine the active scenario. Please select a scenario and try again.';
            logWarn('External IFX apply failed: active scenario not found');
            updateExternalIfxStatus(failureMessage, 'danger');
            try { showToast('Unable to determine active scenario for Apply.', { autohide: true, delay: 2500 }); } catch (e) {}
            return { ok: false, message: failureMessage };
        }

        logInfo(`External IFX apply context resolved for scenario ${idx} (${scenarioName || 'unnamed'})`);

        const hitlState = ensureHitlStateForScenario(scenario);
        const coreState = hitlState.core || (hitlState.core = {});
        const proxState = hitlState.proxmox || {};
        const pickFirst = (...candidates) => {
            for (let idxCandidate = 0; idxCandidate < candidates.length; idxCandidate += 1) {
                const candidate = candidates[idxCandidate];
                if (candidate === null || candidate === undefined) continue;
                const text = String(candidate).trim();
                if (text) return text;
            }
            return '';
        };
        try { bindHostInterfacesToScenarioCache(idx); } catch (e) {}
        const hostInterfaces = getEffectiveHostInterfacesForScenario(idx);
        const hostInfoLookup = new Map(
            hostInterfaces
                .filter(item => item && typeof item === 'object' && item.name)
                .map(item => [item.name, item])
        );
        const proxInventoryList = proxState && proxState.inventory && Array.isArray(proxState.inventory.vms)
            ? proxState.inventory.vms
            : [];
        const findVmRecord = (nodeVal, vmidVal) => {
            if (!nodeVal || !vmidVal) return null;
            const nodeKey = String(nodeVal).trim();
            const vmidKey = String(vmidVal).trim();
            if (!nodeKey || !vmidKey) return null;
            for (let vmIdx = 0; vmIdx < proxInventoryList.length; vmIdx += 1) {
                const vmEntry = proxInventoryList[vmIdx];
                if (!vmEntry || typeof vmEntry !== 'object') continue;
                const vmNode = vmEntry.node !== undefined && vmEntry.node !== null ? String(vmEntry.node).trim() : '';
                const vmId = vmEntry.vmid !== undefined && vmEntry.vmid !== null ? String(vmEntry.vmid).trim() : '';
                if (vmNode && vmId && vmNode === nodeKey && vmId === vmidKey) {
                    return vmEntry;
                }
            }
            return null;
        };

        const buildHitlApplyPayload = (rawHitl) => {
            const clean = {
                enabled: !!rawHitl.enabled,
                participant_proxmox_url: (rawHitl.participant_proxmox_url || '').toString().trim(),
                interfaces: [],
                core: {},
                proxmox: {},
            };
            const missingCore = [];
            const ifaceList = Array.isArray(rawHitl.interfaces) ? rawHitl.interfaces : [];
            for (let i = 0; i < ifaceList.length; i += 1) {
                const entry = ifaceList[i];
                if (!entry || typeof entry !== 'object') {
                    continue;
                }
                const sanitized = {
                    name: entry.name || '',
                    attachment: entry.attachment || '',
                };
                const hostInfo = hostInfoLookup.get(sanitized.name) || null;
                let proxTargetClean = null;
                const proxTarget = entry.proxmox_target;
                if (proxTarget && typeof proxTarget === 'object') {
                    proxTargetClean = {
                        node: pickFirst(proxTarget.node, proxTarget.vm_node, proxTarget.raw && proxTarget.raw.node),
                        vmid: pickFirst(proxTarget.vmid, proxTarget.vm_id, proxTarget.raw && proxTarget.raw.vmid, proxTarget.raw && proxTarget.raw.vm_id),
                        interface_id: pickFirst(
                            proxTarget.interface_id,
                            proxTarget.id,
                            proxTarget.adapter,
                            proxTarget.raw && proxTarget.raw.interface_id,
                            proxTarget.raw && proxTarget.raw.id,
                            proxTarget.raw && proxTarget.raw.adapter
                        ),
                    };
                    if (proxTarget.vm_name || proxTarget.label) {
                        proxTargetClean.vm_name = proxTarget.vm_name ?? proxTarget.label ?? '';
                    }
                    if (proxTarget.macaddr) proxTargetClean.macaddr = proxTarget.macaddr;
                    if (proxTarget.bridge) proxTargetClean.bridge = proxTarget.bridge;
                    if (proxTarget.model) proxTargetClean.model = proxTarget.model;
                }
                if (!proxTargetClean && hostInfo && hostInfo.proxmox && typeof hostInfo.proxmox === 'object') {
                    const hostProx = hostInfo.proxmox;
                    proxTargetClean = {
                        node: pickFirst(hostProx.vm_node, hostProx.node, hostProx.raw && hostProx.raw.node),
                        vmid: pickFirst(hostProx.vmid, hostProx.vm_id, hostProx.raw && hostProx.raw.vmid, hostProx.raw && hostProx.raw.vm_id),
                        interface_id: pickFirst(hostProx.id, hostProx.interface_id, hostProx.adapter, hostProx.raw && hostProx.raw.interface_id, hostProx.raw && hostProx.raw.id, hostProx.raw && hostProx.raw.adapter),
                    };
                    const vmName = pickFirst(hostProx.vm_name, hostProx.raw && hostProx.raw.vm_name, hostProx.raw && hostProx.raw.name);
                    if (vmName) proxTargetClean.vm_name = vmName;
                    if (hostProx.macaddr) proxTargetClean.macaddr = String(hostProx.macaddr).trim();
                    if (hostProx.bridge) proxTargetClean.bridge = String(hostProx.bridge).trim();
                    if (hostProx.model) proxTargetClean.model = String(hostProx.model).trim();
                }
                if (proxTargetClean) {
                    if (!proxTargetClean.interface_id && hostInfo && hostInfo.mac) {
                        const macKey = String(hostInfo.mac).trim().toLowerCase();
                        const nodeVal = proxTargetClean.node || (hostInfo.proxmox && pickFirst(hostInfo.proxmox.vm_node, hostInfo.proxmox.node));
                        const vmidVal = proxTargetClean.vmid || (hostInfo.proxmox && pickFirst(hostInfo.proxmox.vmid, hostInfo.proxmox.vm_id));
                        const vmRecord = findVmRecord(nodeVal, vmidVal);
                        if (vmRecord && Array.isArray(vmRecord.interfaces)) {
                            for (let ifaceIdx = 0; ifaceIdx < vmRecord.interfaces.length; ifaceIdx += 1) {
                                const vmIface = vmRecord.interfaces[ifaceIdx];
                                if (!vmIface || typeof vmIface !== 'object') continue;
                                const ifaceMac = vmIface.macaddr ? String(vmIface.macaddr).trim().toLowerCase() : '';
                                if (ifaceMac && ifaceMac === macKey) {
                                    proxTargetClean.interface_id = pickFirst(vmIface.id, vmIface.interface_id, vmIface.name);
                                    if (!proxTargetClean.bridge && vmIface.bridge) proxTargetClean.bridge = String(vmIface.bridge).trim();
                                    if (!proxTargetClean.model && vmIface.model) proxTargetClean.model = String(vmIface.model).trim();
                                    break;
                                }
                            }
                        }
                    }
                    if (!proxTargetClean.interface_id && proxTargetClean.macaddr) {
                        const macKey = String(proxTargetClean.macaddr).trim().toLowerCase();
                        const vmRecord = findVmRecord(proxTargetClean.node, proxTargetClean.vmid);
                        if (vmRecord && Array.isArray(vmRecord.interfaces)) {
                            for (let ifaceIdx = 0; ifaceIdx < vmRecord.interfaces.length; ifaceIdx += 1) {
                                const vmIface = vmRecord.interfaces[ifaceIdx];
                                if (!vmIface || typeof vmIface !== 'object') continue;
                                const ifaceMac = vmIface.macaddr ? String(vmIface.macaddr).trim().toLowerCase() : '';
                                if (ifaceMac && ifaceMac === macKey) {
                                    proxTargetClean.interface_id = pickFirst(vmIface.id, vmIface.interface_id, vmIface.name);
                                    if (!proxTargetClean.bridge && vmIface.bridge) proxTargetClean.bridge = String(vmIface.bridge).trim();
                                    if (!proxTargetClean.model && vmIface.model) proxTargetClean.model = String(vmIface.model).trim();
                                    break;
                                }
                            }
                        }
                    }
                    sanitized.proxmox_target = proxTargetClean;
                }
                const external = entry.external_vm;
                if (external && typeof external === 'object') {
                    const ext = {
                        vm_key: external.vm_key ?? '',
                        vmid: external.vmid ?? '',
                        interface_id: external.interface_id ?? '',
                    };
                    if (external.vm_node) ext.vm_node = external.vm_node;
                    if (external.vm_name) ext.vm_name = external.vm_name;
                    sanitized.external_vm = ext;
                    const hasCoreSelection = proxTargetClean && proxTargetClean.interface_id;
                    const hasExternalSelection = (ext.vm_key && String(ext.vm_key).trim()) ||
                        (ext.vmid && String(ext.vmid).trim()) ||
                        (ext.vm_name && String(ext.vm_name).trim());
                    if (hasExternalSelection && !hasCoreSelection) {
                        missingCore.push(sanitized.name || `Interface ${i + 1}`);
                    }
                }
                clean.interfaces.push(sanitized);
            }
            const coreRaw = rawHitl.core;
            if (coreRaw && typeof coreRaw === 'object') {
                clean.core = {
                    vm_key: coreRaw.vm_key ?? '',
                    vm_name: coreRaw.vm_name ?? '',
                    vm_node: coreRaw.vm_node ?? '',
                    internal_bridge: coreRaw.internal_bridge ?? '',
                    internal_bridge_owner: coreRaw.internal_bridge_owner ?? '',
                };
            }
            const proxRaw = rawHitl.proxmox;
            if (proxRaw && typeof proxRaw === 'object') {
                clean.proxmox = {
                    secret_id: proxRaw.secret_id ?? proxRaw.secretId ?? null,
                };
            }
            return { clean, missingCore };
        };

        const { clean: sanitizedHitl, missingCore } = buildHitlApplyPayload(hitlState);
        const ifaceCount = Array.isArray(sanitizedHitl.interfaces) ? sanitizedHitl.interfaces.length : 0;
        const extSelections = sanitizedHitl.interfaces.filter(iface => iface?.external_vm && (iface.external_vm.vm_key || iface.external_vm.vmid || iface.external_vm.vm_name)).length;
        const proxSelections = sanitizedHitl.interfaces.filter(iface => iface?.proxmox_target && iface.proxmox_target.interface_id).length;
        logInfo(`External IFX apply payload prepared (interfaces=${ifaceCount}, externalMapped=${extSelections}, coreAdapters=${proxSelections})`);
        if (missingCore.length) {
            const detailMessage = missingCore.length === 1
                ? `${missingCore[0]} needs a Proxmox adapter (for example, net0) selected in Step 3 before applying the bridge.`
                : `Select a Proxmox adapter (for example, net0) in Step 3 for: ${missingCore.join(', ')}.`;
            logWarn(`External IFX apply blocked: no Proxmox adapter chosen for ${missingCore.join(', ')}`);
            updateExternalIfxStatus(detailMessage, 'warning', { busy: false });
            try { showToast(detailMessage, { autohide: false }); } catch (e) {}
            try { delete hitlState.bridge_validated; } catch (e) {}
            try { persistEditorState(); } catch (e) {}
            try { updateProxmoxSummary(idx); } catch (e) {}
            try { renderMain(); } catch (e) {}
            return { ok: false, message: detailMessage };
        }
        const requestPayload = {
            bridge_name: bridgeName,
            scenario_index: idx,
            scenario_name: scenarioName,
            bridge_owner: window.CORETG_USERNAME || '',
            hitl: sanitizedHitl,
        };
        enrichPayloadWithScenarioContext(requestPayload, { includeCore: false });

        logInfo(`External IFX apply dispatching to /api/hitl/apply_bridge for scenario ${idx}`);

        const resp = await fetch('/api/hitl/apply_bridge', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            credentials: 'same-origin',
            body: JSON.stringify(requestPayload),
        });

        let data = null;
        try { data = await resp.json(); } catch (err) { data = null; }

        logInfo(`External IFX apply response received HTTP ${resp.status}`);

        if (!resp.ok || !data || data.success === false) {
            const errMessage = (data && (data.error || data.message)) ? (data.error || data.message) : `Bridge apply failed (HTTP ${resp.status})`;
            logError(`External IFX apply failed: ${errMessage}`);
            updateExternalIfxStatus(errMessage, 'danger');
            try { showToast(errMessage, { autohide: false }); } catch (e) {}
            try { delete hitlState.bridge_validated; } catch (e) {}
            try { persistEditorState(); } catch (e) {}
            try { updateProxmoxSummary(idx); } catch (e) {}
            try { renderMain(); } catch (e) {}
            return { ok: false, message: errMessage, data };
        }

        const appliedBridgeName = data.bridge_name || bridgeName;
        coreState.internal_bridge = appliedBridgeName;
        try { hitlState.bridge_validated = true; } catch (e) {}
        const responseOwner = (data.bridge_owner || requestPayload.bridge_owner || '').toString();
        coreState.internal_bridge_owner = responseOwner;
        window.requestAnimationFrame(() => {
            try { updateProxmoxSummary(idx); } catch (rafErr) { console.warn('Failed to update Proxmox summary', rafErr); }
        });
        window.setTimeout(() => {
            try { persistEditorState(); } catch (persistErr) { console.warn('Failed to persist editor state', persistErr); }
            try {
                const hidden = document.getElementById('scenarios_json');
                if (hidden) hidden.value = JSON.stringify({ scenarios: state.scenarios, active_index: activeIdx });
            } catch (hiddenErr) { console.warn('Failed refreshing hidden scenarios_json', hiddenErr); }
        }, 0);

        const successMessage = data.message || `Bridge "${appliedBridgeName}" applied successfully.`;
        logInfo(`External IFX apply confirmed for scenario ${idx} with bridge ${appliedBridgeName}`);
        updateExternalIfxStatus(successMessage, 'success', { busy: false, autoHideMs: 3000 });
        try { showToast(`${successMessage} Scenario saved.`, { autohide: true, delay: 2500 }); } catch (e) {}
        if (Array.isArray(data.warnings) && data.warnings.length) {
            const warningText = data.warnings.join('\n');
            logWarn(`External IFX apply warnings: ${warningText}`);
            updateExternalIfxStatus(`${successMessage}\n${warningText}`, 'warning');
            try { showToast(warningText, { autohide: false }); } catch (e) {}
        }
        if (autoSave) window.setTimeout(() => {
            const fallbackSubmit = () => {
                const editorForm = document.getElementById('editorForm');
                try {
                    if (editorForm && typeof editorForm.requestSubmit === 'function') {
                        editorForm.requestSubmit();
                    } else if (editorForm) {
                        editorForm.submit();
                    }
                } catch (submitErr) {
                    console.warn('Failed to auto-save scenario after External IFX apply (fallback submit)', submitErr);
                }
            };
            if (typeof autoSaveXml !== 'function') {
                fallbackSubmit();
                return;
            }
            (async () => {
                try {
                    await autoSaveXml();
                    logInfo('Scenario auto-saved after External IFX apply');
                } catch (saveErr) {
                    const warningMessage = 'Bridge applied but auto-save failed. Save XML manually.';
                    logWarn(`${warningMessage}: ${saveErr}`);
                    updateExternalIfxStatus(warningMessage, 'warning');
                    try { showToast(warningMessage, { autohide: false }); } catch (toastErr) { console.warn('Toast failed', toastErr); }
                    fallbackSubmit();
                }
            })();
        }, 300);

        return { ok: true, message: successMessage, data };
    } catch (err) {
        try {
            const detail = err && err.stack ? err.stack : (err && err.toString ? err.toString() : 'unknown error');
            logError(`External IFX apply threw unexpected error: ${detail}`);
        } catch (_) {}
        const errMessage = err instanceof Error ? err.message : 'Failed to apply external IFX configuration.';
        logError(`External IFX apply failed: ${errMessage}`);
        updateExternalIfxStatus(errMessage, 'danger');
        try { showToast(errMessage, { autohide: false }); } catch (e) {}
        return { ok: false, message: errMessage };
    } finally {
        if (setBusy) {
            setExternalIfxApplyBusy(false);
        }
    }
}

async function verifyScenarioCoreSetup(sidx, options = {}) {
    const { triggerButton = null } = options;
    if (Number.isNaN(sidx) || !state.scenarios?.[sidx]) {
        return { ok: false, message: 'Scenario unavailable' };
    }
    if (IS_BUILDER_VIEW) {
        try { showToast('Builder view is read-only.', { autohide: true, delay: 2500 }); } catch (_) {}
        return { ok: false, message: 'Builder view is read-only' };
    }

    const scenario = state.scenarios[sidx];
    const hitlState = ensureHitlStateForScenario(scenario);
    const prox = hitlState.proxmox || (hitlState.proxmox = {});
    const core = hitlState.core || (hitlState.core = {});

    const verifyModal = (() => {
        const modalEl = document.getElementById('verifySetupModal');
        if (!modalEl || !window.bootstrap) return null;
        const get = (id) => document.getElementById(id);
        return {
            modalEl,
            instance: bootstrap.Modal.getInstance(modalEl) || new bootstrap.Modal(modalEl, { backdrop: true, keyboard: true }),
            titleEl: get('verifySetupTitle'),
            statusEl: get('verifySetupStatus'),
            metaEl: get('verifySetupMeta'),
            spinnerEl: get('verifySetupSpinner'),
            badgeEl: get('verifySetupResultBadge'),
            logEl: get('verifySetupLog'),
            finalAlertEl: get('verifySetupFinalAlert'),
        };
    })();

    const verifyResetUi = ({ title }) => {
        if (!verifyModal) return;
        if (verifyModal.titleEl) verifyModal.titleEl.textContent = title || 'Verify';
        if (verifyModal.statusEl) {
            verifyModal.statusEl.textContent = 'Preparing…';
            verifyModal.statusEl.classList.remove('text-success', 'text-warning', 'text-danger');
        }
        if (verifyModal.metaEl) verifyModal.metaEl.textContent = '';
        if (verifyModal.spinnerEl) verifyModal.spinnerEl.classList.remove('d-none');
        if (verifyModal.badgeEl) {
            verifyModal.badgeEl.textContent = 'Running';
            verifyModal.badgeEl.classList.remove('text-bg-success', 'text-bg-danger', 'text-bg-warning');
            verifyModal.badgeEl.classList.add('text-bg-secondary');
        }
        if (verifyModal.logEl) verifyModal.logEl.textContent = '';
        if (verifyModal.finalAlertEl) {
            verifyModal.finalAlertEl.classList.add('d-none');
            verifyModal.finalAlertEl.classList.remove('alert-success', 'alert-danger', 'alert-warning', 'alert-info');
            verifyModal.finalAlertEl.textContent = '';
        }
        verifyModal.instance.show();
    };

    const verifyLog = (line) => {
        if (!verifyModal?.logEl) return;
        const next = (verifyModal.logEl.textContent || '') + (verifyModal.logEl.textContent ? '\n' : '') + String(line);
        verifyModal.logEl.textContent = next;
        verifyModal.logEl.scrollTop = verifyModal.logEl.scrollHeight;
    };

    const verifySetStatus = (statusText, metaText = '') => {
        if (!verifyModal) return;
        if (verifyModal.statusEl) verifyModal.statusEl.textContent = statusText || '';
        if (verifyModal.metaEl) verifyModal.metaEl.textContent = metaText || '';
    };

    const verifyFinish = ({ ok, message, tone = null }) => {
        if (!verifyModal) return;
        if (verifyModal.spinnerEl) verifyModal.spinnerEl.classList.add('d-none');
        if (verifyModal.badgeEl) {
            verifyModal.badgeEl.classList.remove('text-bg-secondary', 'text-bg-success', 'text-bg-danger', 'text-bg-warning');
            if (ok) {
                verifyModal.badgeEl.textContent = 'SUCCESS';
                verifyModal.badgeEl.classList.add('text-bg-success');
            } else {
                verifyModal.badgeEl.textContent = 'FAILURE';
                verifyModal.badgeEl.classList.add('text-bg-danger');
            }
        }
        if (verifyModal.finalAlertEl) {
            verifyModal.finalAlertEl.classList.remove('d-none');
            verifyModal.finalAlertEl.classList.remove('alert-success', 'alert-danger', 'alert-warning', 'alert-info');
            const resolvedTone = tone || (ok ? 'success' : 'danger');
            verifyModal.finalAlertEl.classList.add(`alert-${resolvedTone}`);
            verifyModal.finalAlertEl.textContent = message || (ok ? 'Verification succeeded.' : 'Verification failed.');
        }
        if (verifyModal.statusEl) {
            verifyModal.statusEl.classList.remove('text-success', 'text-warning', 'text-danger');
            verifyModal.statusEl.classList.add(ok ? 'text-success' : 'text-danger');
            verifyModal.statusEl.textContent = ok ? 'Verification succeeded' : 'Verification failed';
        }
    };

    const btn = triggerButton;
    const originalLabel = btn?.textContent;
    if (btn) {
        btn.disabled = true;
        btn.textContent = 'Verifying…';
    }

    const restore = () => {
        if (btn) {
            btn.disabled = false;
            if (originalLabel !== undefined) btn.textContent = originalLabel;
        }
    };

    try {
        verifyResetUi({ title: 'Verify CORE Setup' });
        verifySetStatus('Checking prerequisites…');
        verifyLog(`Scenario ${sidx + 1}: checking Proxmox + CORE settings`);

        const markCoreVerifyFailed = (message) => {
            try {
                core.validated = false;
                persistEditorState();
                const hidden = document.getElementById('scenarios_json');
                if (hidden) hidden.value = JSON.stringify({ scenarios: state.scenarios, active_index: activeIdx });
                updateProxmoxSummary(sidx);
                renderMain();
            } catch (e) {}
            try {
                if (message) {
                    showToast(message, { autohide: false });
                }
            } catch (e) {}
        };

        // Step 1: Proxmox must be validated & stored.
        const proxHasStored = !!(prox.validated && prox.secret_id);
        if (!proxHasStored) {
            const msg = 'Validate Proxmox credentials (Step 1) before verifying CORE.';
            verifyLog(`FAILED: ${msg}`);
            verifyFinish({ ok: false, message: msg });
            markCoreVerifyFailed(msg);
            return { ok: false, message: msg };
        }

        // Step 2: CORE connection validation requires a selected VM and connection details.
        const vmKey = (core.vm_key || '').toString().trim();
        if (!vmKey) {
            const msg = 'Select a CORE VM (Step 2) before verifying CORE.';
            verifyLog(`FAILED: ${msg}`);
            verifyFinish({ ok: false, message: msg });
            markCoreVerifyFailed(msg);
            return { ok: false, message: msg };
        }

        // Confirm the selected VM exists in the current Proxmox inventory (and has interfaces).
        try {
            verifySetStatus('Checking selected CORE VM…');
            const ensureInventory = async () => {
                const inv = prox.inventory && typeof prox.inventory === 'object' ? prox.inventory : null;
                const vms = inv && Array.isArray(inv.vms) ? inv.vms : [];
                if (vms.length) return vms;
                verifyLog('Proxmox inventory not loaded; fetching now…');
                verifySetStatus('Loading Proxmox inventory…');
                const fetched = await fetchProxmoxInventory(sidx, { force: false });
                const vms2 = fetched && Array.isArray(fetched.vms) ? fetched.vms : [];
                return vms2;
            };
            const vms = await ensureInventory();
            const selectedVm = vms.find(vm => `${vm?.node ?? ''}::${vm?.vmid ?? ''}` === vmKey) || null;
            if (!selectedVm) {
                const msg = 'Selected CORE VM is not present in the current Proxmox inventory. Refresh the VM list and re-select the VM.';
                verifyLog(`FAILED: ${msg}`);
                verifyFinish({ ok: false, message: msg });
                markCoreVerifyFailed(msg);
                return { ok: false, message: msg };
            }
            const ifaceCount = Array.isArray(selectedVm.interfaces) ? selectedVm.interfaces.length : null;
            if (ifaceCount !== null && ifaceCount < 1) {
                const msg = 'Selected CORE VM reports zero interfaces in Proxmox. Add at least one interface and refresh the VM list.';
                verifyLog(`FAILED: ${msg}`);
                verifyFinish({ ok: false, message: msg });
                markCoreVerifyFailed(msg);
                return { ok: false, message: msg };
            }
            verifyLog(`Selected CORE VM present in inventory: ${selectedVm.name || selectedVm.vmid || vmKey}`);
        } catch (err) {
            const msg = err instanceof Error ? err.message : 'Unable to confirm CORE VM in Proxmox inventory.';
            verifyLog(`FAILED: ${msg}`);
            verifyFinish({ ok: false, message: msg });
            markCoreVerifyFailed(msg);
            return { ok: false, message: msg };
        }

        const coreHost = (core.grpc_host || '').toString().trim();
        const corePort = Number.isFinite(Number(core.grpc_port)) && Number(core.grpc_port) > 0 ? Number(core.grpc_port) : 50051;
        const coreSshHost = ((core.ssh_host || '').toString().trim() || coreHost);
        const coreSshPort = Number.isFinite(Number(core.ssh_port)) && Number(core.ssh_port) > 0 ? Number(core.ssh_port) : 22;
        const coreUser = (core.ssh_username || '').toString().trim();
        const hasSecret = typeof core.core_secret_id === 'string' && core.core_secret_id.trim();
        const hasPassword = !!(core.ssh_password || hasSecret);

        if (!coreHost || !coreUser || !hasPassword || !coreSshHost || !corePort || !coreSshPort) {
            const msg = 'Complete Step 2 connection details (gRPC host/port, SSH host/port, SSH user, and password) before verifying.';
            verifyLog(`FAILED: ${msg}`);
            verifyFinish({ ok: false, message: msg });
            markCoreVerifyFailed(msg);
            return { ok: false, message: msg };
        }

        verifySetStatus('Validating CORE connection…', `/test_core → ${coreHost}:${corePort}`);
        const autoStartDaemon = !!(core.auto_start_daemon);
        const installCustomServices = !!(core.install_custom_services);
        const advFixDockerDaemon = !!(core.adv_fix_docker_daemon);
        const advRunCoreCleanup = !!(core.adv_run_core_cleanup);
        const advCheckCoreVersion = !!(core.adv_check_core_version);
        const advRestartCoreDaemon = !!(core.adv_restart_core_daemon);
        const advAutoKillSessions = !!(core.adv_auto_kill_sessions);
        const enabledFlags = [];
        if (autoStartDaemon) enabledFlags.push('Auto-start core-daemon');
        if (installCustomServices) enabledFlags.push('Install custom services');
        if (advFixDockerDaemon) enabledFlags.push('Advanced: Fix Docker daemon');
        if (advRunCoreCleanup) enabledFlags.push('Advanced: Run core-cleanup');
        if (advCheckCoreVersion) enabledFlags.push('Advanced: Check CORE version');
        if (advRestartCoreDaemon) enabledFlags.push('Advanced: Restart core-daemon');
        if (advAutoKillSessions) enabledFlags.push('Advanced: Auto-kill sessions');
        verifyLog(`Calling /test_core for ${coreHost}:${corePort}`);
        verifyLog(`Using last dialog options: ${enabledFlags.length ? enabledFlags.join(' | ') : 'none'}`);
        const result = await validateCoreConnection(sidx, {
            triggerButton: null,
            workingLabel: 'Verifying…',
            statusEl: verifyModal?.statusEl || null,
            rememberCredentials: shouldRememberCore(hitlState),
            closeModalOnSuccess: false,
            suppressToasts: true,
            showSummaryOnSuccess: false,
            autoStartDaemon,
            installCustomServices,
            advFixDockerDaemon,
            advRunCoreCleanup,
            advCheckCoreVersion,
            advRestartCoreDaemon,
            advAutoKillSessions,
        });

        if (result && result.ok) {
            // Ensure the CORE VM host interface catalog is loaded and consistent.
            try {
                verifySetStatus('Loading CORE VM interfaces…');
                const refreshRes = await refreshHostInterfacesForScenario(sidx, {
                    reason: 'core_verify',
                    silent: true,
                    timeoutMs: HOST_INTERFACES_REQUEST_TIMEOUT_MS,
                    setStatus: (message, tone) => {
                        try { verifyLog(`[interfaces] ${message}`); } catch (_) {}
                    },
                });
                if (!refreshRes || !refreshRes.ok) {
                    const msg = (refreshRes && refreshRes.message) ? refreshRes.message : 'Failed to load CORE VM interfaces.';
                    verifyLog(`FAILED: ${msg}`);
                    verifyFinish({ ok: false, message: msg });
                    markCoreVerifyFailed(msg);
                    return { ok: false, message: msg };
                }
                try { bindHostInterfacesToScenarioCache(sidx); } catch (e) {}
                const catalog = getEffectiveHostInterfacesForScenario(sidx);
                if (!Array.isArray(catalog) || catalog.length < 1) {
                    const msg = 'CORE VM interface catalog is empty. Refresh interfaces and retry verification.';
                    verifyLog(`FAILED: ${msg}`);
                    verifyFinish({ ok: false, message: msg });
                    markCoreVerifyFailed(msg);
                    return { ok: false, message: msg };
                }

                // If Step 3 already has selected interfaces, confirm they still exist.
                const selected = Array.isArray(hitlState.interfaces) ? hitlState.interfaces : [];
                const selectedNames = selected
                    .map(entry => (entry && entry.name) ? String(entry.name).trim() : '')
                    .filter(Boolean);
                if (selectedNames.length) {
                    const catalogNames = new Set(catalog.map(item => (item && item.name) ? String(item.name).trim() : '').filter(Boolean));
                    const missing = selectedNames.filter(name => !catalogNames.has(name));
                    if (missing.length) {
                        const msg = `One or more selected HITL interfaces no longer exist on the CORE VM: ${missing.join(', ')}`;
                        verifyLog(`FAILED: ${msg}`);
                        verifyFinish({ ok: false, message: msg });
                        markCoreVerifyFailed(msg);
                        return { ok: false, message: msg };
                    }
                }
            } catch (err) {
                const msg = err instanceof Error ? err.message : 'Failed while validating CORE VM interface catalog.';
                verifyLog(`FAILED: ${msg}`);
                verifyFinish({ ok: false, message: msg });
                markCoreVerifyFailed(msg);
                return { ok: false, message: msg };
            }

            let hasAdvancedFailures = false;
            try {
                const advObj = result.data && result.data.advanced_checks;
                if (advObj && typeof advObj === 'object') {
                    hasAdvancedFailures = Object.values(advObj).some((entry) => {
                        return entry && typeof entry === 'object' && entry.enabled && entry.ok === false;
                    });
                }
            } catch (e) {}
            const msg = (result.data && (result.data.message || result.data.core_message))
                ? (result.data.message || result.data.core_message)
                : 'CORE connection verified.';
            verifyLog(`SUCCESS: ${msg}`);
            if (hasAdvancedFailures) {
                verifyLog('Completed with warnings (advanced checks failed).');
                verifyFinish({ ok: true, message: `${msg} (with warnings)`, tone: 'warning' });
            } else {
                verifyFinish({ ok: true, message: msg });
            }
            return result;
        }

        const failMsg = (result && result.message) ? result.message : 'CORE verification failed.';
        verifyLog(`FAILED: ${failMsg}`);
        verifyFinish({ ok: false, message: failMsg });
        markCoreVerifyFailed(failMsg);
        return result;
    } finally {
        restore();
    }
}

async function clearScenarioCoreVmSelection(sidx, options = {}) {
    const { triggerButton = null } = options;
    if (Number.isNaN(sidx) || !state.scenarios?.[sidx]) {
        return { ok: false, message: 'Scenario unavailable' };
    }
    if (IS_BUILDER_VIEW || !IS_ADMIN_USER) {
        try { showToast('Admin access required.', { autohide: true, delay: 2500 }); } catch (_) {}
        return { ok: false, message: 'Admin access required' };
    }

    const btn = triggerButton;
    const originalLabel = btn?.textContent;
    if (btn) {
        btn.disabled = true;
        btn.textContent = 'Clearing…';
    }

    const restore = () => {
        if (btn) {
            btn.disabled = false;
            if (originalLabel !== undefined) btn.textContent = originalLabel;
        }
    };

    try {
        const scenario = state.scenarios[sidx];
        const hitl = ensureHitlStateForScenario(scenario);
        const core = hitl.core || (hitl.core = {});
        const oldVmKey = (core.vm_key || '').toString();

        // Clear Step 2 selection.
        delete core.vm_key;
        delete core.vm_name;
        delete core.vm_node;
        delete core.vmid;

        // Clear connection + verification fields shown in the Step 2 table.
        core.grpc_host = '';
        core.grpc_port = 50051;
        core.venv_bin = '';
        core.ssh_host = '';
        core.ssh_port = 22;
        core.ssh_username = '';
        core.ssh_password = '';
        core.core_secret_id = null;
        core.validated = false;
        core.last_validated_at = null;
        core.stored_summary = null;
        core.last_tested_at = null;
        core.last_tested_status = null;
        core.last_tested_message = null;
        core.last_tested_host = null;
        core.last_tested_port = null;

        delete core.cached_vm_interface_count;
        delete core.cached_vm_status;
        delete core.cached_host_interfaces;
        delete core.cached_host_interfaces_vm_key;
        delete core.cached_host_interfaces_source;
        delete core.cached_host_interfaces_metadata;
        delete core.cached_host_interfaces_fetched_at;
        delete hitl.bridge_validated;

        if (oldVmKey && (state.host_interfaces_vm_key || '').toString() === oldVmKey) {
            state.host_interfaces = [];
            state.host_interfaces_vm_key = '';
            state.host_interfaces_source = null;
            state.host_interfaces_metadata = null;
            state.host_interfaces_fetched_at = null;
        }

        // Clearing the CORE VM invalidates downstream mappings/bridge settings.
        hitl.enabled = false;
        hitl.participant_proxmox_url = '';
        if (Array.isArray(hitl.interfaces)) {
            hitl.interfaces = [];
        }
        delete core.internal_bridge;
        delete core.internal_bridge_owner;

        persistEditorState();
        try { await flushServerSnapshotPersistNow(); } catch (_) {}

        const scenarioName = (scenario.name || '').toString();
        const resp = await fetch('/api/hitl/core_vm/clear', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            credentials: 'same-origin',
            body: JSON.stringify({ scenario_index: sidx, scenario_name: scenarioName }),
        });
        let data = null;
        try { data = await resp.json(); } catch (_) { data = null; }
        if (!resp.ok || (data && data.success === false)) {
            const msg = (data && (data.error || data.message)) ? (data.error || data.message) : `Failed (HTTP ${resp.status})`;
            try { showToast(msg, { autohide: false }); } catch (_) {}
            return { ok: false, message: msg };
        }

        render();
        try { showToast('Cleared CORE VM selection and HITL mappings.', { autohide: true, delay: 2500 }); } catch (_) {}
        return { ok: true };
    } catch (err) {
        const msg = err instanceof Error ? err.message : 'Failed to clear CORE VM selection.';
        try { showToast(msg, { autohide: false }); } catch (_) {}
        return { ok: false, message: msg };
    } finally {
        restore();
    }
}

async function clearScenarioHitlConfig(sidx, options = {}) {
    const { triggerButton = null } = options;
    if (Number.isNaN(sidx) || !state.scenarios?.[sidx]) {
        return { ok: false, message: 'Scenario unavailable' };
    }
    if (IS_BUILDER_VIEW || !IS_ADMIN_USER) {
        try { showToast('Admin access required.', { autohide: true, delay: 2500 }); } catch (_) {}
        return { ok: false, message: 'Admin access required' };
    }

    const btn = triggerButton;
    const originalLabel = btn?.textContent;
    if (btn) {
        btn.disabled = true;
        btn.textContent = 'Clearing…';
    }

    const restore = () => {
        if (btn) {
            btn.disabled = false;
            if (originalLabel !== undefined) btn.textContent = originalLabel;
        }
    };

    try {
        const scenario = state.scenarios[sidx];
        const hitl = ensureHitlStateForScenario(scenario);
        const core = hitl.core || (hitl.core = {});

        // Clear Steps 3–5 config while keeping Step 2 CORE VM selection.
        hitl.enabled = false;
        hitl.participant_proxmox_url = '';
        delete hitl.bridge_validated;
        if (Array.isArray(hitl.interfaces)) {
            hitl.interfaces = [];
        }
        delete core.internal_bridge;
        delete core.internal_bridge_owner;

        persistEditorState();
        try { await flushServerSnapshotPersistNow(); } catch (_) {}

        const scenarioName = (scenario.name || '').toString();
        const resp = await fetch('/api/hitl/config/clear', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            credentials: 'same-origin',
            body: JSON.stringify({ scenario_index: sidx, scenario_name: scenarioName }),
        });
        let data = null;
        try { data = await resp.json(); } catch (_) { data = null; }
        if (!resp.ok || (data && data.success === false)) {
            const msg = (data && (data.error || data.message)) ? (data.error || data.message) : `Failed (HTTP ${resp.status})`;
            try { showToast(msg, { autohide: false }); } catch (_) {}
            return { ok: false, message: msg };
        }

        render();
        try { showToast('Cleared HITL config (interfaces/bridge).', { autohide: true, delay: 2500 }); } catch (_) {}
        return { ok: true };
    } catch (err) {
        const msg = err instanceof Error ? err.message : 'Failed to clear HITL config.';
        try { showToast(msg, { autohide: false }); } catch (_) {}
        return { ok: false, message: msg };
    } finally {
        restore();
    }
}

async function verifyScenarioHitlBridge(sidx, options = {}) {
    const { triggerButton = null } = options;
    if (Number.isNaN(sidx) || !state.scenarios?.[sidx]) {
        return { ok: false, message: 'Scenario unavailable' };
    }
    if (IS_BUILDER_VIEW) {
        try { showToast('Builder view is read-only.', { autohide: true, delay: 2500 }); } catch (_) {}
        return { ok: false, message: 'Builder view is read-only' };
    }

    const scenario = state.scenarios[sidx];
    const hitlState = ensureHitlStateForScenario(scenario);
    const coreState = hitlState.core || (hitlState.core = {});
    const proxState = hitlState.proxmox || (hitlState.proxmox = {});

    const verifyModal = (() => {
        const modalEl = document.getElementById('verifySetupModal');
        if (!modalEl || !window.bootstrap) return null;
        const get = (id) => document.getElementById(id);
        return {
            modalEl,
            instance: bootstrap.Modal.getInstance(modalEl) || new bootstrap.Modal(modalEl, { backdrop: true, keyboard: true }),
            titleEl: get('verifySetupTitle'),
            statusEl: get('verifySetupStatus'),
            metaEl: get('verifySetupMeta'),
            spinnerEl: get('verifySetupSpinner'),
            badgeEl: get('verifySetupResultBadge'),
            logEl: get('verifySetupLog'),
            finalAlertEl: get('verifySetupFinalAlert'),
        };
    })();

    const verifyResetUi = ({ title }) => {
        if (!verifyModal) return;
        if (verifyModal.titleEl) verifyModal.titleEl.textContent = title || 'Verify';
        if (verifyModal.statusEl) {
            verifyModal.statusEl.textContent = 'Preparing…';
            verifyModal.statusEl.classList.remove('text-success', 'text-warning', 'text-danger');
        }
        if (verifyModal.metaEl) verifyModal.metaEl.textContent = '';
        if (verifyModal.spinnerEl) verifyModal.spinnerEl.classList.remove('d-none');
        if (verifyModal.badgeEl) {
            verifyModal.badgeEl.textContent = 'Running';
            verifyModal.badgeEl.classList.remove('text-bg-success', 'text-bg-danger', 'text-bg-warning');
            verifyModal.badgeEl.classList.add('text-bg-secondary');
        }
        if (verifyModal.logEl) verifyModal.logEl.textContent = '';
        if (verifyModal.finalAlertEl) {
            verifyModal.finalAlertEl.classList.add('d-none');
            verifyModal.finalAlertEl.classList.remove('alert-success', 'alert-danger', 'alert-warning', 'alert-info');
            verifyModal.finalAlertEl.textContent = '';
        }
        verifyModal.instance.show();
    };

    const verifyLog = (line) => {
        if (!verifyModal?.logEl) return;
        const next = (verifyModal.logEl.textContent || '') + (verifyModal.logEl.textContent ? '\n' : '') + String(line);
        verifyModal.logEl.textContent = next;
        verifyModal.logEl.scrollTop = verifyModal.logEl.scrollHeight;
    };

    const verifySetStatus = (statusText, metaText = '') => {
        if (!verifyModal) return;
        if (verifyModal.statusEl) verifyModal.statusEl.textContent = statusText || '';
        if (verifyModal.metaEl) verifyModal.metaEl.textContent = metaText || '';
    };

    const verifyFinish = ({ ok, message }) => {
        if (!verifyModal) return;
        if (verifyModal.spinnerEl) verifyModal.spinnerEl.classList.add('d-none');
        if (verifyModal.badgeEl) {
            verifyModal.badgeEl.classList.remove('text-bg-secondary', 'text-bg-success', 'text-bg-danger');
            if (ok) {
                verifyModal.badgeEl.textContent = 'SUCCESS';
                verifyModal.badgeEl.classList.add('text-bg-success');
            } else {
                verifyModal.badgeEl.textContent = 'FAILURE';
                verifyModal.badgeEl.classList.add('text-bg-danger');
            }
        }
        if (verifyModal.finalAlertEl) {
            verifyModal.finalAlertEl.classList.remove('d-none');
            verifyModal.finalAlertEl.classList.remove('alert-success', 'alert-danger');
            verifyModal.finalAlertEl.classList.add(ok ? 'alert-success' : 'alert-danger');
            verifyModal.finalAlertEl.textContent = message || (ok ? 'Verification succeeded.' : 'Verification failed.');
        }
        if (verifyModal.statusEl) {
            verifyModal.statusEl.classList.remove('text-success', 'text-warning', 'text-danger');
            verifyModal.statusEl.classList.add(ok ? 'text-success' : 'text-danger');
            verifyModal.statusEl.textContent = ok ? 'Verification succeeded' : 'Verification failed';
        }
    };

    const btn = triggerButton;
    const originalLabel = btn?.textContent;
    if (btn) {
        btn.disabled = true;
        btn.textContent = 'Verifying…';
    }

    const restore = () => {
        if (btn) {
            btn.disabled = false;
            if (originalLabel !== undefined) btn.textContent = originalLabel;
        }
    };

    const markHitlVerifyFailed = (message) => {
        try {
            delete hitlState.bridge_validated;
            persistEditorState();
            const hidden = document.getElementById('scenarios_json');
            if (hidden) hidden.value = JSON.stringify({ scenarios: state.scenarios, active_index: activeIdx });
            updateProxmoxSummary(sidx);
            renderMain();
        } catch (e) {}
        try {
            if (message) {
                showToast(message, { autohide: false });
            }
        } catch (e) {}
    };

    try {
        verifyResetUi({ title: 'Verify HITL Bridge Setup' });
        verifySetStatus('Checking prerequisites…');
        verifyLog(`Scenario ${sidx + 1}: checking HITL prerequisites`);

        const secretId = typeof proxState.secret_id === 'string' ? proxState.secret_id.trim() : '';
        if (!secretId || !(proxState.validated && secretId)) {
            const msg = 'Validate Proxmox credentials (Step 1) before verifying HITL.';
            verifyLog(`FAILED: ${msg}`);
            verifyFinish({ ok: false, message: msg });
            markHitlVerifyFailed(msg);
            return { ok: false, message: msg };
        }
        const vmKey = (coreState.vm_key || '').toString().trim();
        if (!vmKey) {
            const msg = 'Select a CORE VM (Step 2) before verifying HITL.';
            verifyLog(`FAILED: ${msg}`);
            verifyFinish({ ok: false, message: msg });
            markHitlVerifyFailed(msg);
            return { ok: false, message: msg };
        }
        const coreHasSecret = typeof coreState.core_secret_id === 'string' && coreState.core_secret_id.trim();
        if (!coreHasSecret) {
            const msg = 'Store CORE credentials (Step 2) before verifying HITL.';
            verifyLog(`FAILED: ${msg}`);
            verifyFinish({ ok: false, message: msg });
            markHitlVerifyFailed(msg);
            return { ok: false, message: msg };
        }
        if (!hitlState.enabled) {
            const msg = 'Enable Hardware in the Loop (Step 3) before verifying HITL.';
            verifyLog(`FAILED: ${msg}`);
            verifyFinish({ ok: false, message: msg });
            markHitlVerifyFailed(msg);
            return { ok: false, message: msg };
        }
        const proxInventoryBusy = proxInventoryFetchInFlight && typeof proxInventoryFetchInFlight.has === 'function'
            ? proxInventoryFetchInFlight.has(sidx)
            : false;
        const proxInventoryError = proxState.inventory_error ? proxState.inventory_error.toString() : '';
        if (proxInventoryBusy) {
            const msg = 'Wait for the Proxmox VM inventory fetch to finish before verifying HITL.';
            verifyLog(`FAILED: ${msg}`);
            verifyFinish({ ok: false, message: msg });
            markHitlVerifyFailed(msg);
            return { ok: false, message: msg };
        }
        if (proxInventoryError) {
            const msg = `Resolve Proxmox inventory error before verifying HITL: ${proxInventoryError}`;
            verifyLog(`FAILED: ${msg}`);
            verifyFinish({ ok: false, message: msg });
            markHitlVerifyFailed(msg);
            return { ok: false, message: msg };
        }

        // Match the Config HITL dialog behavior: when the modal opens, it auto-refreshes
        // the CORE VM interface catalog if empty or stale. Do the same before we evaluate
        // Step 3 (interfaces cannot be added reliably until the catalog is loaded).
        try {
            if (isHitlAuthenticationReady(hitlState)) {
                try { bindHostInterfacesToScenarioCache(sidx); } catch (e) {}
                const hostInterfaces = getEffectiveHostInterfacesForScenario(sidx);
                const lastRefreshMs = Date.parse(coreState.last_interfaces_refresh || '');
                const hasError = !!coreState.last_interfaces_error;
                const shouldRefresh = (() => {
                    if (!hostInterfaces.length) return true;
                    if (hasError) return true;
                    if (Number.isNaN(lastRefreshMs)) return true;
                    return (Date.now() - lastRefreshMs) > HITL_MODAL_AUTO_REFRESH_STALE_MS;
                })();
                if (shouldRefresh && !coreState.interfaces_refresh_inflight) {
                    verifySetStatus('Loading CORE VM interfaces…', 'Same behavior as Config HITL dialog');
                    verifyLog('Refreshing interface list from CORE VM…');
                    const refreshRes = await refreshHostInterfacesForScenario(sidx, {
                        reason: 'verify',
                        silent: true,
                        timeoutMs: HOST_INTERFACES_REQUEST_TIMEOUT_MS,
                        setStatus: (message, tone) => {
                            // Keep the Verify modal as the primary feedback surface.
                            try { verifyLog(`[hitl] ${message}`); } catch (_) {}
                        },
                    });
                    if (refreshRes && refreshRes.ok) {
                        verifyLog('Interface list loaded.');
                    } else {
                        // Best-effort: if refresh fails, keep going — later payload building
                        // may still succeed with cached mappings.
                        verifyLog('WARN: Unable to refresh interface list right now.');
                    }
                }
            }
        } catch (err) {
            verifyLog('WARN: Interface refresh threw; continuing.');
        }

        // Re-read after the auto-refresh attempt (state normalization can happen on access).
        const hitlStateAfterRefresh = ensureHitlStateForScenario(scenario);
        const ifaces = Array.isArray(hitlStateAfterRefresh.interfaces) ? hitlStateAfterRefresh.interfaces : [];
        if (!ifaces.length) {
            const msg = 'Add at least one HITL interface (Step 3) before verifying.';
            verifyLog(`FAILED: ${msg}`);
            verifyFinish({ ok: false, message: msg });
            markHitlVerifyFailed(msg);
            return { ok: false, message: msg };
        }
        const extSelections = ifaces.filter(iface => iface?.external_vm && (iface.external_vm.vm_key || iface.external_vm.vmid || iface.external_vm.vm_name)).length;
        const extSelectionsWithIface = ifaces.filter(iface => iface?.external_vm && (iface.external_vm.vm_key || iface.external_vm.vmid || iface.external_vm.vm_name) && iface.external_vm.interface_id).length;
        if (extSelections <= 0) {
            const msg = 'Map at least one HITL interface to an external VM (Step 4) before verifying.';
            verifyLog(`FAILED: ${msg}`);
            verifyFinish({ ok: false, message: msg });
            markHitlVerifyFailed(msg);
            return { ok: false, message: msg };
        }
        if (extSelectionsWithIface <= 0) {
            const msg = 'Select an external VM interface (for example, net0) in Step 4 before verifying.';
            verifyLog(`FAILED: ${msg}`);
            verifyFinish({ ok: false, message: msg });
            markHitlVerifyFailed(msg);
            return { ok: false, message: msg };
        }
        const storedBridge = (coreState.internal_bridge || '').toString().trim();
        const bridgeName = storedBridge || computeInternalBridgeName();
        if (!bridgeName) {
            const msg = 'Unable to compute internal bridge name.';
            verifyLog(`FAILED: ${msg}`);
            verifyFinish({ ok: false, message: msg });
            markHitlVerifyFailed(msg);
            return { ok: false, message: msg };
        }

        verifySetStatus('Preparing HITL payload…');
        verifyLog(storedBridge
            ? `Using last applied bridge: ${bridgeName}`
            : `Using computed bridge: ${bridgeName}`);

        // Reuse the same sanitization logic as Apply.
        try { bindHostInterfacesToScenarioCache(sidx); } catch (e) {}
        const hostInterfaces = getEffectiveHostInterfacesForScenario(sidx);
        const hostInfoLookup = new Map(
            hostInterfaces
                .filter(item => item && typeof item === 'object' && item.name)
                .map(item => [item.name, item])
        );
        const proxInventoryList = proxState && proxState.inventory && Array.isArray(proxState.inventory.vms)
            ? proxState.inventory.vms
            : [];
        const pickFirst = (...candidates) => {
            for (let idxCandidate = 0; idxCandidate < candidates.length; idxCandidate += 1) {
                const candidate = candidates[idxCandidate];
                if (candidate === null || candidate === undefined) continue;
                const text = String(candidate).trim();
                if (text) return text;
            }
            return '';
        };
        const findVmRecord = (nodeVal, vmidVal) => {
            if (!nodeVal || !vmidVal) return null;
            const nodeKey = String(nodeVal).trim();
            const vmidKey = String(vmidVal).trim();
            if (!nodeKey || !vmidKey) return null;
            for (let vmIdx = 0; vmIdx < proxInventoryList.length; vmIdx += 1) {
                const vmEntry = proxInventoryList[vmIdx];
                if (!vmEntry || typeof vmEntry !== 'object') continue;
                const vmNode = vmEntry.node !== undefined && vmEntry.node !== null ? String(vmEntry.node).trim() : '';
                const vmId = vmEntry.vmid !== undefined && vmEntry.vmid !== null ? String(vmEntry.vmid).trim() : '';
                if (vmNode && vmId && vmNode === nodeKey && vmId === vmidKey) {
                    return vmEntry;
                }
            }
            return null;
        };

        const buildHitlApplyPayload = (rawHitl) => {
            const clean = {
                enabled: !!rawHitl.enabled,
                participant_proxmox_url: (rawHitl.participant_proxmox_url || '').toString().trim(),
                interfaces: [],
                core: {},
                proxmox: {},
            };
            const missingCore = [];
            const ifaceList = Array.isArray(rawHitl.interfaces) ? rawHitl.interfaces : [];
            for (let i = 0; i < ifaceList.length; i += 1) {
                const entry = ifaceList[i];
                if (!entry || typeof entry !== 'object') {
                    continue;
                }
                const sanitized = {
                    name: entry.name || '',
                    attachment: entry.attachment || '',
                };
                const hostInfo = hostInfoLookup.get(sanitized.name) || null;
                let proxTargetClean = null;
                const proxTarget = entry.proxmox_target;
                if (proxTarget && typeof proxTarget === 'object') {
                    proxTargetClean = {
                        node: pickFirst(proxTarget.node, proxTarget.vm_node, proxTarget.raw && proxTarget.raw.node),
                        vmid: pickFirst(proxTarget.vmid, proxTarget.vm_id, proxTarget.raw && proxTarget.raw.vmid, proxTarget.raw && proxTarget.raw.vm_id),
                        interface_id: pickFirst(
                            proxTarget.interface_id,
                            proxTarget.id,
                            proxTarget.adapter,
                            proxTarget.raw && proxTarget.raw.interface_id,
                            proxTarget.raw && proxTarget.raw.id,
                            proxTarget.raw && proxTarget.raw.adapter
                        ),
                    };
                    if (proxTarget.vm_name || proxTarget.label) {
                        proxTargetClean.vm_name = proxTarget.vm_name ?? proxTarget.label ?? '';
                    }
                    if (proxTarget.macaddr) proxTargetClean.macaddr = proxTarget.macaddr;
                    if (proxTarget.bridge) proxTargetClean.bridge = proxTarget.bridge;
                    if (proxTarget.model) proxTargetClean.model = proxTarget.model;
                }
                if (!proxTargetClean && hostInfo && hostInfo.proxmox && typeof hostInfo.proxmox === 'object') {
                    const hostProx = hostInfo.proxmox;
                    proxTargetClean = {
                        node: pickFirst(hostProx.vm_node, hostProx.node, hostProx.raw && hostProx.raw.node),
                        vmid: pickFirst(hostProx.vmid, hostProx.vm_id, hostProx.raw && hostProx.raw.vmid, hostProx.raw && hostProx.raw.vm_id),
                        interface_id: pickFirst(hostProx.id, hostProx.interface_id, hostProx.adapter, hostProx.raw && hostProx.raw.interface_id, hostProx.raw && hostProx.raw.id, hostProx.raw && hostProx.raw.adapter),
                    };
                    const vmName = pickFirst(hostProx.vm_name, hostProx.raw && hostProx.raw.vm_name, hostProx.raw && hostProx.raw.name);
                    if (vmName) proxTargetClean.vm_name = vmName;
                    if (hostProx.macaddr) proxTargetClean.macaddr = String(hostProx.macaddr).trim();
                    if (hostProx.bridge) proxTargetClean.bridge = String(hostProx.bridge).trim();
                    if (hostProx.model) proxTargetClean.model = String(hostProx.model).trim();
                }
                if (proxTargetClean) {
                    if (!proxTargetClean.interface_id && hostInfo && hostInfo.mac) {
                        const macKey = String(hostInfo.mac).trim().toLowerCase();
                        const nodeVal = proxTargetClean.node || (hostInfo.proxmox && pickFirst(hostInfo.proxmox.vm_node, hostInfo.proxmox.node));
                        const vmidVal = proxTargetClean.vmid || (hostInfo.proxmox && pickFirst(hostInfo.proxmox.vmid, hostInfo.proxmox.vm_id));
                        const vmRecord = findVmRecord(nodeVal, vmidVal);
                        if (vmRecord && Array.isArray(vmRecord.interfaces)) {
                            for (let ifaceIdx = 0; ifaceIdx < vmRecord.interfaces.length; ifaceIdx += 1) {
                                const vmIface = vmRecord.interfaces[ifaceIdx];
                                if (!vmIface || typeof vmIface !== 'object') continue;
                                const ifaceMac = vmIface.macaddr ? String(vmIface.macaddr).trim().toLowerCase() : '';
                                if (ifaceMac && ifaceMac === macKey) {
                                    proxTargetClean.interface_id = pickFirst(vmIface.id, vmIface.interface_id, vmIface.name);
                                    if (!proxTargetClean.bridge && vmIface.bridge) proxTargetClean.bridge = String(vmIface.bridge).trim();
                                    if (!proxTargetClean.model && vmIface.model) proxTargetClean.model = String(vmIface.model).trim();
                                    break;
                                }
                            }
                        }
                    }
                    if (!proxTargetClean.interface_id && proxTargetClean.macaddr) {
                        const macKey = String(proxTargetClean.macaddr).trim().toLowerCase();
                        const vmRecord = findVmRecord(proxTargetClean.node, proxTargetClean.vmid);
                        if (vmRecord && Array.isArray(vmRecord.interfaces)) {
                            for (let ifaceIdx = 0; ifaceIdx < vmRecord.interfaces.length; ifaceIdx += 1) {
                                const vmIface = vmRecord.interfaces[ifaceIdx];
                                if (!vmIface || typeof vmIface !== 'object') continue;
                                const ifaceMac = vmIface.macaddr ? String(vmIface.macaddr).trim().toLowerCase() : '';
                                if (ifaceMac && ifaceMac === macKey) {
                                    proxTargetClean.interface_id = pickFirst(vmIface.id, vmIface.interface_id, vmIface.name);
                                    if (!proxTargetClean.bridge && vmIface.bridge) proxTargetClean.bridge = String(vmIface.bridge).trim();
                                    if (!proxTargetClean.model && vmIface.model) proxTargetClean.model = String(vmIface.model).trim();
                                    break;
                                }
                            }
                        }
                    }
                    sanitized.proxmox_target = proxTargetClean;
                }
                const external = entry.external_vm;
                if (external && typeof external === 'object') {
                    const ext = {
                        vm_key: external.vm_key ?? '',
                        vmid: external.vmid ?? '',
                        interface_id: external.interface_id ?? '',
                    };
                    if (external.vm_node) ext.vm_node = external.vm_node;
                    if (external.vm_name) ext.vm_name = external.vm_name;
                    sanitized.external_vm = ext;
                    const hasCoreSelection = proxTargetClean && proxTargetClean.interface_id;
                    const hasExternalSelection = (ext.vm_key && String(ext.vm_key).trim()) ||
                        (ext.vmid && String(ext.vmid).trim()) ||
                        (ext.vm_name && String(ext.vm_name).trim());
                    if (hasExternalSelection && !hasCoreSelection) {
                        missingCore.push(sanitized.name || `Interface ${i + 1}`);
                    }
                }
                clean.interfaces.push(sanitized);
            }
            const coreRaw = rawHitl.core;
            if (coreRaw && typeof coreRaw === 'object') {
                clean.core = {
                    vm_key: coreRaw.vm_key ?? '',
                    vm_name: coreRaw.vm_name ?? '',
                    vm_node: coreRaw.vm_node ?? '',
                    internal_bridge: coreRaw.internal_bridge ?? '',
                    internal_bridge_owner: coreRaw.internal_bridge_owner ?? '',
                };
            }
            const proxRaw = rawHitl.proxmox;
            if (proxRaw && typeof proxRaw === 'object') {
                clean.proxmox = {
                    secret_id: proxRaw.secret_id ?? proxRaw.secretId ?? null,
                };
            }
            return { clean, missingCore };
        };

        const { clean: sanitizedHitl, missingCore } = buildHitlApplyPayload(hitlState);
        if (missingCore.length) {
            const detailMessage = missingCore.length === 1
                ? `${missingCore[0]} needs a Proxmox adapter (for example, net0) selected in Step 3 before verifying.`
                : `Select a Proxmox adapter (for example, net0) in Step 3 for: ${missingCore.join(', ')}.`;
            verifyLog(`FAILED: ${detailMessage}`);
            verifyFinish({ ok: false, message: detailMessage });
            markHitlVerifyFailed(detailMessage);
            return { ok: false, message: detailMessage };
        }

        // Keep payload consistent with the bridge we are verifying.
        try {
            if (!sanitizedHitl.core || typeof sanitizedHitl.core !== 'object') sanitizedHitl.core = {};
            sanitizedHitl.core.internal_bridge = bridgeName;
        } catch (e) {}

        const requestPayload = {
            bridge_name: bridgeName,
            scenario_index: sidx,
            scenario_name: (scenario?.name || '').toString(),
            hitl: sanitizedHitl,
        };

        verifySetStatus('Validating HITL bridge settings…', '/api/hitl/validate_bridge');
        verifyLog('Calling /api/hitl/validate_bridge');
        const resp = await fetch('/api/hitl/validate_bridge', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            credentials: 'same-origin',
            body: JSON.stringify(requestPayload),
        });
        let data = null;
        try { data = await resp.json(); } catch (err) { data = null; }
        if (!resp.ok || !data || data.success === false) {
            const errMessage = (data && (data.error || data.message)) ? (data.error || data.message) : `HITL verification failed (HTTP ${resp.status})`;
            verifyLog(`FAILED: ${errMessage}`);
            verifyFinish({ ok: false, message: errMessage });
            markHitlVerifyFailed(errMessage);
            return { ok: false, message: errMessage, data };
        }

        const msg = data.message || 'HITL bridge settings verified.';
        try {
            hitlState.bridge_validated = true;
            if (hitlState.core && typeof hitlState.core === 'object') {
                hitlState.core.internal_bridge = bridgeName;
            }
            persistEditorState();
        } catch (e) {}
        try {
            const changed = Array.isArray(data.changed_interfaces) ? data.changed_interfaces.length : null;
            const unchanged = Array.isArray(data.unchanged_interfaces) ? data.unchanged_interfaces.length : null;
            if (changed !== null || unchanged !== null) {
                verifyLog(`Preview: ${changed ?? 0} interface(s) would change; ${unchanged ?? 0} unchanged`);
            }
        } catch (e) {}
        verifyLog(`SUCCESS: ${msg}`);
        verifyFinish({ ok: true, message: msg });
        return { ok: true, data };
    } catch (err) {
        const message = err instanceof Error ? err.message : 'HITL verification failed';
        verifyLog(`FAILED: ${message}`);
        verifyFinish({ ok: false, message });
        markHitlVerifyFailed(message);
        return { ok: false, message };
    } finally {
        restore();
    }
}

function handleCoreFieldUpdate(inputEl, { rerender } = { rerender: false }) {
    if (!inputEl) return;
    if (IS_BUILDER_VIEW) return;
    const sidx = parseInt(inputEl.getAttribute('data-scen-idx'));
    if (Number.isNaN(sidx) || !state.scenarios?.[sidx]) return;
    const field = inputEl.getAttribute('data-hitl-core-field');
    if (!field) return;
    const hitlState = ensureHitlStateForScenario(state.scenarios[sidx]);
    const coreState = hitlState.core || (hitlState.core = {});
    let dirty = false;
    if (inputEl.type === 'checkbox') {
        const value = !!inputEl.checked;
        if (coreState[field] !== value) {
            coreState[field] = value;
            dirty = true;
        }
    } else if (field === 'grpc_port' || field === 'ssh_port') {
        const fallback = field === 'grpc_port' ? 50051 : 22;
        const parsed = parseInt(inputEl.value, 10);
        const sanitized = Number.isFinite(parsed) && parsed > 0 ? parsed : fallback;
        if (coreState[field] !== sanitized) {
            coreState[field] = sanitized;
            dirty = true;
        }
    } else if (field === 'ssh_host' || field === 'venv_bin' || field === 'ssh_username' || field === 'ssh_password') {
        const value = (inputEl.value || '').trim();
        if ((coreState[field] || '') !== value) {
            coreState[field] = value;
            dirty = true;
            if (field === 'venv_bin') {
                coreState.venv_test_status = null;
                coreState.venv_test_message = null;
                coreState.venv_test_at = null;
                coreState.venv_test_python = null;
                const modalIdxRaw = coreConnectionModal?.getAttribute('data-scen-idx');
                const modalIdx = modalIdxRaw !== null ? parseInt(modalIdxRaw, 10) : NaN;
                if (!Number.isNaN(modalIdx) && modalIdx === sidx) {
                    setCoreVenvStatusDisplay(null, null);
                }
            } else if (field in {'ssh_host':1,'ssh_username':1,'ssh_password':1}) {
                coreState.venv_test_status = null;
                coreState.venv_test_message = null;
                coreState.venv_test_at = null;
                coreState.venv_test_python = null;
            }
        }
    } else {
        const value = inputEl.value || '';
        if ((coreState[field] || '') !== value) {
            coreState[field] = value;
            dirty = true;
        }
    }
    if (dirty) {
        coreState.last_tested_status = null;
        coreState.last_tested_message = null;
        coreState.last_tested_at = null;
        coreState.last_tested_host = null;
        coreState.last_tested_port = null;
        persistEditorState();
        const hidden = document.getElementById('scenarios_json');
        if (hidden) hidden.value = JSON.stringify({ scenarios: state.scenarios, active_index: activeIdx });
    }
    updateProxmoxSummary(sidx);
    if (dirty && rerender) {
        renderMain();
    }
}

async function validateCoreConnection(sidx, options = {}) {
    const {
        triggerButton = null,
        workingLabel = 'Testing…',
        statusEl: providedStatusEl,
        hintOnStart = null,
        hintOnSuccess = null,
        hintOnFailure = null,
        successToastMessage = null,
        closeModalOnSuccess = false,
        suppressToasts = false,
        rememberCredentials = true,
        autoStartDaemon = false,
        installCustomServices = false,
        stopDuplicateDaemons = false,
        advFixDockerDaemon = false,
        advRunCoreCleanup = false,
        advCheckCoreVersion = false,
        advRestartCoreDaemon = false,
        advAutoKillSessions = false,
        _daemonConflictPrompted = false,
        showSummaryOnSuccess = false,
    } = options;
    if (Number.isNaN(sidx) || !state.scenarios?.[sidx]) {
        return { ok: false, message: 'Scenario unavailable' };
    }
    if (IS_BUILDER_VIEW) {
        // Builder view can't run live validation (no secrets). Provide useful feedback using
        // the last admin test/validation hints already merged into the scenario payload.
        const button = options.triggerButton || null;
        const originalLabel = button?.textContent;
        const restoreButton = () => {
            if (!button) return;
            button.disabled = false;
            if (originalLabel !== undefined) {
                button.textContent = originalLabel;
            }
        };
        if (button) {
            button.disabled = true;
            button.textContent = 'Please Wait';
        }

        const scenario = state.scenarios[sidx];
        const hitlState = ensureHitlStateForScenario(scenario);
        const coreState = hitlState.core || (hitlState.core = {});
        const proxState = hitlState.proxmox && typeof hitlState.proxmox === 'object' ? hitlState.proxmox : {};

        const nowIso = new Date().toISOString();
        const lastStatus = (coreState.last_tested_status ?? '').toString().trim().toLowerCase();
        const lastAt = (coreState.last_tested_at ?? '').toString().trim();
        const lastMsg = (coreState.last_tested_message ?? '').toString().trim();
        const lastValidatedAt = (coreState.last_validated_at ?? '').toString().trim();

        // When a builder presses "Test Connection", update the displayed "last tested" time.
        // This is a UI-only check (no live validation); we infer success from admin setup hints.
        const vmKey = (coreState.vm_key ?? '').toString().trim();
        const coreSecretId = (coreState.core_secret_id ?? '').toString().trim();
        const proxSecretId = (proxState.secret_id ?? '').toString().trim();
        const inferredOk = !!(vmKey && coreSecretId && proxSecretId);
        coreState.last_tested_at = nowIso;
        coreState.last_tested_status = lastStatus || (inferredOk ? 'success' : 'failure');
        coreState.last_tested_message = lastMsg || (inferredOk
            ? 'Builder check requested (no live test performed)'
            : 'Builder check requested (missing admin setup)');

        // Populate global last-test fields so Execute modal status line can reuse them.
        {
            state.core_last_test_status = (coreState.last_tested_status ?? '').toString().trim().toLowerCase();
            state.core_last_test_at = (coreState.last_tested_at ?? '').toString().trim();
            state.core_last_test_message = (coreState.last_tested_message ?? '').toString().trim();
            state.core_last_test_host = (coreState.last_tested_host ?? coreState.grpc_host ?? state.core_last_test_host ?? '').toString();
            state.core_last_test_port = coreState.last_tested_port ?? coreState.grpc_port ?? state.core_last_test_port ?? null;
        }

        const statusEl = options.statusEl ?? document.querySelector(`[data-hitl-core-status="${sidx}"]`);
        const summary = (() => {
            const atText = formatCoreTestTimestamp(coreState.last_tested_at);
            const effectiveStatus = (coreState.last_tested_status ?? '').toString().trim().toLowerCase();
            if (effectiveStatus === 'success') {
                return atText ? `Last test succeeded at ${atText}` : 'Last test succeeded';
            }
            if (effectiveStatus === 'failure') {
                const base = atText ? `Last test failed at ${atText}` : 'Last test failed';
                const msg = (coreState.last_tested_message ?? '').toString().trim();
                return msg ? `${base} (${msg})` : base;
            }
            const valText = formatCoreTestTimestamp(lastValidatedAt);
            return valText ? `Last validated by admin at ${valText}` : '';
        })();

        const message = summary
            ? `Builder view cannot run a live test. ${summary}.`
            : 'Builder view cannot run a live test. CORE credentials are managed by an admin.';

        if (statusEl) {
            statusEl.textContent = message;
            statusEl.classList.remove('text-success', 'text-warning', 'text-danger', 'text-muted');
            // Colorize based on last known test result, if available.
            const effectiveStatus = (coreState.last_tested_status ?? '').toString().trim().toLowerCase();
            if (effectiveStatus === 'success') {
                statusEl.classList.add('text-success');
            } else if (effectiveStatus === 'failure') {
                statusEl.classList.add('text-danger');
            } else {
                statusEl.classList.add(summary ? 'text-muted' : 'text-warning');
            }
        }
        if (typeof setCoreConnectionHint === 'function') {
            try { setCoreConnectionHint(message, 'info'); } catch (_) {}
        }
        if (!options.suppressToasts && typeof showToast === 'function') {
            try { showToast(message, { autohide: true, delay: 4200 }); } catch (_) {}
        }

        // Ensure the user sees the temporary "Please Wait" state.
        try { await new Promise(r => window.setTimeout(r, 350)); } catch (_) {}
        restoreButton();

        return {
            ok: (coreState.last_tested_status ?? '').toString().trim().toLowerCase() === 'success',
            message,
            builderNoLiveTest: true,
            last_tested_at: coreState.last_tested_at,
            last_tested_status: coreState.last_tested_status,
        };
    }
    const scenario = state.scenarios[sidx];
    const hitlState = ensureHitlStateForScenario(scenario);
    const coreState = hitlState.core || (hitlState.core = {});
    const vmKey = (coreState.vm_key || '').toString().trim();
    const vmNode = (coreState.vm_node || '').toString().trim();
    const body = {
        core: {
            host: coreState.grpc_host || '',
            port: coreState.grpc_port || 50051,
            ssh_host: coreState.ssh_host || coreState.grpc_host || '',
            ssh_port: coreState.ssh_port || 22,
            ssh_username: coreState.ssh_username || '',
            ssh_password: coreState.ssh_password || '',
                venv_bin: coreState.venv_bin || '',
            ssh_enabled: true,
            core_secret_id: coreState.core_secret_id || null,
            vm_key: vmKey,
            vm_node: vmNode,
            auto_start_daemon: autoStartDaemon,
            install_custom_services: installCustomServices,
            stop_duplicate_daemons: stopDuplicateDaemons,
            adv_fix_docker_daemon: advFixDockerDaemon,
            adv_run_core_cleanup: advRunCoreCleanup,
            adv_check_core_version: advCheckCoreVersion,
            adv_restart_core_daemon: advRestartCoreDaemon,
            adv_auto_kill_sessions: advAutoKillSessions,
        },
    };
    enrichPayloadWithScenarioContext(body, { scenarioIndex: sidx, scenarioOverride: scenario });
    const statusEl = providedStatusEl ?? document.querySelector(`[data-hitl-core-status="${sidx}"]`);
    const button = triggerButton;
    const originalLabel = button?.textContent;
    if (!vmKey) {
        const message = 'Select a CORE VM before testing the connection.';
        try { coreState.validated = false; } catch (e) {}
        if (statusEl) {
            statusEl.textContent = message;
            statusEl.classList.remove('text-success', 'text-warning', 'text-danger', 'text-muted');
            statusEl.classList.add('text-danger');
        }
        if (!suppressToasts) {
            try { showToast(message, { autohide: true, delay: 2600 }); } catch (e) {}
        }
        return { ok: false, message };
    }
    if (button) {
        button.disabled = true;
        button.textContent = workingLabel;
    }
    if (statusEl) {
        statusEl.textContent = workingLabel === 'Testing…' ? 'Testing CORE connection…' : 'Validating CORE connection…';
        statusEl.classList.remove('text-success', 'text-warning', 'text-danger');
        statusEl.classList.add('text-muted');
    }
    if (hintOnStart && typeof setCoreConnectionHint === 'function') {
        setCoreConnectionHint(hintOnStart, 'info');
    }
    const restoreButton = () => {
        if (button) {
            button.disabled = false;
            if (originalLabel !== undefined) {
                button.textContent = originalLabel;
            }
        }
    };
    try {
        const resp = await fetch('/test_core', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            credentials: 'same-origin',
            body: JSON.stringify(body),
        });
        let data = null;
        try { data = await resp.json(); } catch (err) { data = null; }
        const nowIso = new Date().toISOString();
        const _formatAdvancedCheckLines = (advObj) => {
            if (!advObj || typeof advObj !== 'object') return [];
            const rows = [
                { key: 'adv_check_core_version', label: 'Check CORE version (9.2.1)' },
                { key: 'adv_fix_docker_daemon', label: 'Fix Docker daemon' },
                { key: 'adv_run_core_cleanup', label: 'Run core-cleanup' },
                { key: 'adv_restart_core_daemon', label: 'Restart core-daemon' },
                { key: 'adv_auto_kill_sessions', label: 'Auto-kill running sessions' },
            ];
            const out = [];
            rows.forEach((row) => {
                const entry = advObj[row.key];
                if (!entry || typeof entry !== 'object') return;
                if (!entry.enabled) return;
                const ok = entry.ok === true;
                const msg = (entry.message || '').toString().trim();
                out.push(`Advanced: ${row.label}: ${ok ? 'OK' : 'FAILED'}${msg ? ` (${msg})` : ''}`);
            });
            return out;
        };
        if (data && data.ok) {
            const buildSummary = () => {
                const lines = [];
                lines.push('CORE connection validated.');
                const coreHost = data.host || (data.core && data.core.host) || '';
                const corePort = (data.port !== undefined && data.port !== null) ? data.port : (data.core && data.core.port);
                if (coreHost && corePort) {
                    lines.push(`gRPC: ${coreHost}:${corePort}`);
                } else if (data.remote) {
                    lines.push(`gRPC: ${data.remote}`);
                }
                if (data.forward_host && data.forward_port) {
                    lines.push(`Tunnel: ${data.forward_host}:${data.forward_port}`);
                }
                const pids = Array.isArray(data.daemon_pids) ? data.daemon_pids : [];
                if (pids.length === 1) {
                    lines.push(`core-daemon: running (PID ${pids[0]})`);
                } else if (pids.length > 1) {
                    lines.push(`core-daemon: multiple processes detected (PIDs: ${pids.join(', ')})`);
                } else {
                    lines.push('core-daemon: not checked');
                }
                if (installCustomServices) {
                    const meta = (data.install_custom_services && typeof data.install_custom_services === 'object') ? data.install_custom_services : null;
                    const modules = meta && Array.isArray(meta.modules) ? meta.modules.map(v => String(v)).filter(Boolean) : [];
                    const servicesDir = meta && meta.services_dir ? String(meta.services_dir) : '';
                    if (modules.length && servicesDir) {
                        lines.push(`Custom services: installed (${modules.join(', ')}) -> ${servicesDir}`);
                    } else if (modules.length) {
                        lines.push(`Custom services: installed (${modules.join(', ')})`);
                    } else {
                        lines.push('Custom services: installed');
                    }
                } else {
                    lines.push('Custom services: not installed');
                }
                const advLines = _formatAdvancedCheckLines(data.advanced_checks);
                if (advLines.length) {
                    lines.push(...advLines);
                }
                lines.push('Credentials: stored securely after verification.');
                return lines.join('\n');
            };

            const summary = (data.core_summary && typeof data.core_summary === 'object') ? data.core_summary : null;
            coreState.last_tested_status = 'success';
            coreState.last_tested_message = data.message
                || (data.forward_host && data.forward_port
                    ? `Tunnel ${data.forward_host}:${data.forward_port}`
                    : 'Connection successful');
            coreState.last_tested_at = nowIso;
            coreState.last_tested_host = data.host || coreState.grpc_host || '';
            coreState.last_tested_port = data.port || coreState.grpc_port || null;
            state.core_last_test_status = 'success';
            state.core_last_test_host = coreState.last_tested_host;
            state.core_last_test_port = coreState.last_tested_port;
            state.core_last_test_at = nowIso;
            const incomingSecretId = data.core_secret_id || (summary && summary.identifier) || null;
            if (rememberCredentials) {
                coreState.core_secret_id = incomingSecretId;
                coreState.validated = !!incomingSecretId;
                coreState.last_validated_at = (summary && summary.stored_at) || nowIso;
                coreState.stored_summary = summary;
            } else {
                coreState.core_secret_id = coreState.core_secret_id || null;
                if (!coreState.core_secret_id) {
                    coreState.validated = false;
                    coreState.last_validated_at = null;
                    coreState.stored_summary = null;
                }
            }
            syncGlobalCoreConnection(coreState, coreState.last_tested_host, coreState.last_tested_port);
            coreState.ssh_password = '';
            persistEditorState();
            const hidden = document.getElementById('scenarios_json');
            if (hidden) hidden.value = JSON.stringify({ scenarios: state.scenarios, active_index: activeIdx });
            const pwdInput = document.querySelector(`[data-hitl-core-field="ssh_password"][data-scen-idx="${sidx}"]`);
            if (pwdInput) {
                pwdInput.value = '';
                pwdInput.setAttribute('placeholder', 'Stored securely');
            }
            updateProxmoxSummary(sidx);
            renderMain();

            // Provide immediate, explicit feedback in the status line (e.g., Execute modal).
            if (statusEl) {
                const atText = formatCoreTestTimestamp(coreState.last_tested_at);
                const suffix = atText ? ` • ${atText}` : '';
                statusEl.textContent = `Succeeded${suffix}`;
                statusEl.classList.remove('text-warning', 'text-danger', 'text-muted');
                statusEl.classList.add('text-success');
            }

            let hasAdvancedFailures = false;
            try {
                const advObj = data && data.advanced_checks;
                if (advObj && typeof advObj === 'object') {
                    hasAdvancedFailures = Object.values(advObj).some((entry) => {
                        return entry && typeof entry === 'object' && entry.enabled && entry.ok === false;
                    });
                }
            } catch (e) {}

            if (typeof setCoreConnectionHint === 'function') {
                if (showSummaryOnSuccess) {
                    const tone = hasAdvancedFailures ? 'warning' : (rememberCredentials ? 'success' : 'warning');
                    setCoreConnectionHint(buildSummary(), tone);
                } else if (hintOnSuccess) {
                    const tone = hasAdvancedFailures ? 'warning' : (rememberCredentials ? 'success' : 'warning');
                    setCoreConnectionHint(hintOnSuccess, tone);
                } else if (hintOnStart) {
                    const tone = hasAdvancedFailures ? 'warning' : (rememberCredentials ? 'success' : 'warning');
                    setCoreConnectionHint(
                        rememberCredentials ? 'Validation successful.' : 'Validated without storing credentials. Re-enter password next time.',
                        tone,
                    );
                }
            }
            if (!suppressToasts) {
                try {
                    let toastMessage = successToastMessage || data.message || 'CORE connection verified and stored securely.';
                    if (hasAdvancedFailures) {
                        toastMessage = `${toastMessage} (with warnings)`;
                    }
                    showToast(toastMessage, { autohide: true, delay: 2500 });
                } catch (e) {}
            }
            if (closeModalOnSuccess && coreConnectionModal && window.bootstrap) {
                try { bootstrap.Modal.getInstance(coreConnectionModal)?.hide(); } catch (e) {}
            }
            return { ok: true, data };
        }

        // If the backend detected multiple core-daemon processes, offer to stop them and retry once.
        if (
            data &&
            data.daemon_conflict &&
            !_daemonConflictPrompted &&
            !stopDuplicateDaemons
        ) {
            const canStop = (data.can_stop_daemons !== false);
            const pids = Array.isArray(data.daemon_pids) ? data.daemon_pids.map(v => String(v)).filter(Boolean) : [];
            const pidText = pids.length ? pids.join(', ') : '';
            if (canStop) {
                const prompt = pidText
                    ? `Multiple core-daemon processes are running on the CORE VM (PIDs: ${pidText}).\n\nWould you like CORE TopoGen to stop them and restart core-daemon now?`
                    : 'Multiple core-daemon processes are running on the CORE VM.\n\nWould you like CORE TopoGen to stop them and restart core-daemon now?';
                let doFix = false;
                try { doFix = window.confirm(prompt); } catch (e) { doFix = false; }
                if (doFix) {
                    return await validateCoreConnection(sidx, {
                        ...options,
                        workingLabel: 'Fixing…',
                        hintOnStart: 'Stopping duplicate core-daemon processes…',
                        stopDuplicateDaemons: true,
                        _daemonConflictPrompted: true,
                    });
                }
            }
        }

        const message = (data && data.error) ? data.error : `HTTP ${resp.status}`;
        coreState.last_tested_status = 'failure';
        coreState.last_tested_message = message;
        coreState.last_tested_at = nowIso;
        coreState.last_tested_host = coreState.grpc_host || '';
        coreState.last_tested_port = coreState.grpc_port || null;
        // A failed verification should disable Step 3 entry points until re-verified.
        coreState.validated = false;
        state.core_last_test_status = 'failure';
        state.core_last_test_host = coreState.last_tested_host;
        state.core_last_test_port = coreState.last_tested_port;
        state.core_last_test_at = nowIso;
        markGlobalCoreDisconnected();
        persistEditorState();
        const hidden = document.getElementById('scenarios_json');
        if (hidden) hidden.value = JSON.stringify({ scenarios: state.scenarios, active_index: activeIdx });
        updateProxmoxSummary(sidx);
        renderMain();
        const pwdInput = document.querySelector(`[data-hitl-core-field="ssh_password"][data-scen-idx="${sidx}"]`);
        if (pwdInput) pwdInput.removeAttribute('placeholder');

        // Provide immediate, explicit feedback in the status line (e.g., Execute modal).
        if (statusEl) {
            const atText = formatCoreTestTimestamp(coreState.last_tested_at);
            const suffix = atText ? ` • ${atText}` : '';
            statusEl.textContent = `Failed${suffix}`;
            statusEl.classList.remove('text-success', 'text-warning', 'text-muted');
            statusEl.classList.add('text-danger');
        }
        if (typeof setCoreConnectionHint === 'function') {
            if (hintOnFailure) {
                let detail = `${hintOnFailure}: ${message}`;
                try {
                    const advLines = (data && data.advanced_checks) ? _formatAdvancedCheckLines(data.advanced_checks) : [];
                    if (advLines && advLines.length) {
                        detail = `${detail}\n${advLines.join('\n')}`;
                    }
                } catch (e) {}
                setCoreConnectionHint(detail, 'danger');
            } else if (hintOnStart) {
                setCoreConnectionHint(message, 'danger');
            }
        }
        if (!suppressToasts) {
            try { showToast(`CORE test failed: ${message}`, { autohide: false }); } catch (e) {}
        }
        return { ok: false, message };
    } catch (err) {
        const message = err instanceof Error ? err.message : 'Connection test failed';
        coreState.last_tested_status = 'failure';
        coreState.last_tested_message = message;
        coreState.last_tested_at = new Date().toISOString();
        coreState.last_tested_host = coreState.grpc_host || '';
        coreState.last_tested_port = coreState.grpc_port || null;
        // A failed verification should disable Step 3 entry points until re-verified.
        coreState.validated = false;
        state.core_last_test_status = 'failure';
        state.core_last_test_host = coreState.last_tested_host;
        state.core_last_test_port = coreState.last_tested_port;
        state.core_last_test_at = coreState.last_tested_at;
        markGlobalCoreDisconnected();
        persistEditorState();
        const hidden = document.getElementById('scenarios_json');
        if (hidden) hidden.value = JSON.stringify({ scenarios: state.scenarios, active_index: activeIdx });
        updateProxmoxSummary(sidx);
        renderMain();
        const pwdInput = document.querySelector(`[data-hitl-core-field="ssh_password"][data-scen-idx="${sidx}"]`);
        if (pwdInput) pwdInput.removeAttribute('placeholder');
        if (typeof setCoreConnectionHint === 'function') {
            if (hintOnFailure) {
                setCoreConnectionHint(`${hintOnFailure}: ${message}`, 'danger');
            } else if (hintOnStart) {
                setCoreConnectionHint(message, 'danger');
            }
        }
        if (!suppressToasts) {
            try { showToast(`CORE test failed: ${message}`, { autohide: false }); } catch (e) {}
        }
        return { ok: false, message };
    } finally {
        restoreButton();
    }
}

async function hydrateCoreModalWithSecret(secretId, sidx, { scenarioName = '' } = {}) {
    if (!secretId || !coreConnectionModal) return;
    try {
        const creds = await fetchStoredCoreCredentials(secretId);
        if (!creds) return;
        if (!coreConnectionModal || coreConnectionModal.getAttribute('data-scen-idx') !== String(sidx)) {
            return;
        }
        const assignIfEmpty = (inputEl, value) => {
            if (!inputEl || inputEl.disabled) return;
            const strValue = value ?? '';
            if (!inputEl.value && strValue !== undefined && strValue !== null) {
                inputEl.value = strValue;
            }
        };
        assignIfEmpty(coreModalInputs.grpc_host, creds.grpc_host || creds.host || '');
        assignIfEmpty(coreModalInputs.grpc_port, creds.grpc_port || creds.port || 50051);
        assignIfEmpty(coreModalInputs.ssh_host, creds.ssh_host || creds.host || '');
        assignIfEmpty(coreModalInputs.ssh_port, creds.ssh_port || 22);
        assignIfEmpty(coreModalInputs.ssh_username, creds.ssh_username || '');
        assignIfEmpty(coreModalInputs.venv_bin, creds.venv_bin || CORE_DEFAULT_VENV_BIN);
        if (coreModalInputs.ssh_password && !coreModalInputs.ssh_password.disabled) {
            coreModalInputs.ssh_password.value = creds.ssh_password || '';
            if (creds.ssh_password) {
                coreModalInputs.ssh_password.removeAttribute('placeholder');
            }
        }
        if (typeof setCoreConnectionHint === 'function') {
            const label = scenarioName
                ? `Loaded stored CORE credentials for ${scenarioName}.`
                : 'Loaded stored CORE credentials from the vault.';
            setCoreConnectionHint(label, creds.ssh_password ? 'success' : 'info');
        }
    } catch (err) {
        console.warn('Failed to load stored CORE credentials', err);
        if (typeof setCoreConnectionHint === 'function' && coreConnectionModal && coreConnectionModal.getAttribute('data-scen-idx') === String(sidx)) {
            setCoreConnectionHint('Stored CORE credentials unavailable. Re-enter password to continue.', 'warning');
        }
    }
}

const CORE_MODAL_INPUT_IDS = {
    grpc_host: 'coreGrpcHost',
    grpc_port: 'coreGrpcPort',
    ssh_host: 'coreSshHost',
    ssh_port: 'coreSshPort',
    ssh_username: 'coreSshUsername',
    ssh_password: 'coreSshPassword',
    venv_bin: 'coreVenvBin',
};

function resolveCoreModalReferences() {
    if (!coreConnectionModal) {
        coreConnectionModal = document.getElementById('coreConnectionModal');
    }
    if (!coreConnectionForm) {
        coreConnectionForm = document.getElementById('coreConnectionForm');
    }
    if (!coreConnectionHint) {
        coreConnectionHint = document.getElementById('coreConnectionHint');
    }
    Object.entries(CORE_MODAL_INPUT_IDS).forEach(([field, id]) => {
        if (!coreModalInputs[field]) {
            const inputEl = document.getElementById(id);
            if (inputEl) {
                coreModalInputs[field] = inputEl;
                if (!inputEl.dataset.coreModalInputBound) {
                    inputEl.addEventListener('input', () => handleCoreModalInputChange(field));
                    if (inputEl.type === 'checkbox') {
                        inputEl.addEventListener('change', () => handleCoreModalInputChange(field));
                    }
                    inputEl.dataset.coreModalInputBound = '1';
                }
            }
        }
    });
}

async function handleCoreConnectionSave(event) {
    event?.preventDefault?.();
    resolveCoreModalReferences();
    if (IS_BUILDER_VIEW) {
        if (typeof setCoreConnectionHint === 'function') {
            setCoreConnectionHint('Builder view is read-only. Ask an admin to update CORE credentials.', 'info');
        }
        return;
    }
    if (!coreConnectionModal || !state?.scenarios?.length) {
        return;
    }
    const triggerButton = (event && event.currentTarget && event.currentTarget instanceof HTMLElement)
        ? event.currentTarget
        : (coreConnectionSaveBtn || document.getElementById('coreConnectionSaveBtn'));
    const targetIdxRaw = coreConnectionModal.getAttribute('data-scen-idx') || String(activeIdx);
    const sidx = parseInt(targetIdxRaw, 10);
    if (Number.isNaN(sidx) || !state.scenarios?.[sidx]) {
        return;
    }
    const scenario = state.scenarios[sidx];
    const hitlState = ensureHitlStateForScenario(scenario);
    const coreState = hitlState.core || (hitlState.core = {});
    const rememberToggle = document.getElementById('coreRememberCreds');
    const rememberCreds = rememberToggle ? !!rememberToggle.checked : shouldRememberCore(hitlState);
    coreState.remember_credentials = rememberCreds;
    const autoStartToggle = document.getElementById('coreAutoStartDaemon');
    const autoStartDaemon = autoStartToggle ? !!autoStartToggle.checked : !!(coreState.auto_start_daemon);
    coreState.auto_start_daemon = autoStartDaemon;
    const installServicesToggle = document.getElementById('coreInstallCustomServices');
    const installCustomServices = installServicesToggle ? !!installServicesToggle.checked : !!(coreState.install_custom_services);
    coreState.install_custom_services = installCustomServices;

    const advFixDockerToggle = document.getElementById('coreAdvFixDockerDaemon');
    const advRunCleanupToggle = document.getElementById('coreAdvRunCoreCleanup');
    const advCheckVersionToggle = document.getElementById('coreAdvCheckCoreVersion');
    const advRestartDaemonToggle = document.getElementById('coreAdvRestartCoreDaemon');
    const advAutoKillToggle = document.getElementById('coreAdvAutoKillSessions');
    const advFixDocker = advFixDockerToggle ? !!advFixDockerToggle.checked : !!(coreState.adv_fix_docker_daemon);
    const advRunCleanup = advRunCleanupToggle ? !!advRunCleanupToggle.checked : !!(coreState.adv_run_core_cleanup);
    const advCheckVersion = advCheckVersionToggle ? !!advCheckVersionToggle.checked : !!(coreState.adv_check_core_version);
    const advRestartDaemon = advRestartDaemonToggle ? !!advRestartDaemonToggle.checked : !!(coreState.adv_restart_core_daemon);
    const advAutoKill = advAutoKillToggle ? !!advAutoKillToggle.checked : !!(coreState.adv_auto_kill_sessions);
    coreState.adv_fix_docker_daemon = advFixDocker;
    coreState.adv_run_core_cleanup = advRunCleanup;
    coreState.adv_check_core_version = advCheckVersion;
    coreState.adv_restart_core_daemon = advRestartDaemon;
    coreState.adv_auto_kill_sessions = advAutoKill;
    const proxState = hitlState.proxmox || {};
    const prerequisitesMet = !!(proxState.validated && proxState.secret_id && coreState.vm_key);
    if (!prerequisitesMet) {
        if (typeof setCoreConnectionHint === 'function') {
            setCoreConnectionHint('Select and validate a CORE VM before saving connection details.', 'warning');
        }
        return;
    }
    if (coreConnectionForm && !coreConnectionForm.checkValidity()) {
        coreConnectionForm.classList.add('was-validated');
        const invalidControls = Array.from(coreConnectionForm.querySelectorAll(':invalid'));
        const invalidLabels = invalidControls.map((input) => {
            if (!(input instanceof HTMLElement)) return null;
            const id = input.id || input.getAttribute('name') || '';
            let labelText = '';
            if (id) {
                const escapedId = (window.CSS && typeof window.CSS.escape === 'function') ? window.CSS.escape(id) : id;
                const lbl = coreConnectionForm.querySelector(`label[for="${escapedId}"]`);
                if (lbl) {
                    labelText = lbl.textContent?.trim() || '';
                }
            }
            if (!labelText) {
                labelText = input.getAttribute('placeholder') || input.dataset.hitlCoreField || 'Field';
            }
            return labelText.trim();
        }).filter(Boolean);
        if (typeof setCoreConnectionHint === 'function') {
            const msg = invalidLabels.length
                ? `Fix the highlighted fields: ${invalidLabels.join(', ')}.`
                : 'Please fill out the required fields.';
            setCoreConnectionHint(msg, 'warning');
        }
        const firstInvalid = invalidControls[0];
        try {
            firstInvalid?.focus({ preventScroll: false });
            if (typeof firstInvalid?.select === 'function' && firstInvalid.type !== 'number') {
                firstInvalid.select();
            }
            firstInvalid?.scrollIntoView({ block: 'center', behavior: 'smooth' });
        } catch (err) {}
        coreConnectionForm?.reportValidity();
        return;
    }
    const snapshotBefore = JSON.stringify(coreState);
    Object.entries(coreModalInputs).forEach(([field, input]) => {
        if (!input || input.disabled) return;
        input.setAttribute('data-scen-idx', String(sidx));
        if (field === 'ssh_password' && input.value) {
            input.removeAttribute('placeholder');
        }
        handleCoreFieldUpdate(input, { rerender: false });
    });
    const snapshotAfter = JSON.stringify(coreState);
    const changed = snapshotBefore !== snapshotAfter;
    const modalRefresher = typeof window.refreshCoreConnectionModal === 'function'
        ? window.refreshCoreConnectionModal
        : null;
    if (changed) {
        updateProxmoxSummary(sidx);
        renderMain();
    } else if (modalRefresher) {
        modalRefresher(sidx);
    }
    const statusEl = document.querySelector(`[data-hitl-core-status="${sidx}"]`);

    await validateCoreConnection(sidx, {
        triggerButton,
        workingLabel: 'Validating…',
        statusEl,
        hintOnStart: 'Validating CORE connection…',
        hintOnSuccess: 'Connection saved and validated.',
        hintOnFailure: 'Validation failed',
        successToastMessage: 'CORE connection saved & validated',
        closeModalOnSuccess: true,
        rememberCredentials: rememberCreds,
        autoStartDaemon: autoStartDaemon,
        installCustomServices: installCustomServices,
        advFixDockerDaemon: advFixDocker,
        advRunCoreCleanup: advRunCleanup,
        advCheckCoreVersion: advCheckVersion,
        advRestartCoreDaemon: advRestartDaemon,
        advAutoKillSessions: advAutoKill,
        showSummaryOnSuccess: true,
    });
}

function wireCoreConnectionSaveButton() {
    if (!coreConnectionSaveBtn) {
        coreConnectionSaveBtn = document.getElementById('coreConnectionSaveBtn');
    }
    if (!coreConnectionSaveBtn) return;
    if (!coreConnectionSaveBtn.dataset.coreSaveBound) {
        coreConnectionSaveBtn.addEventListener('click', handleCoreConnectionSave);
        coreConnectionSaveBtn.dataset.coreSaveBound = '1';
    }
}

function resolveCoreVenvTestElements() {
    if (!coreTestVenvBtn) {
        coreTestVenvBtn = document.getElementById('coreTestVenvBtn');
    }
    if (!coreVenvTestStatus) {
        coreVenvTestStatus = document.getElementById('coreVenvTestStatus');
    }
}

function setCoreVenvStatusDisplay(status, message) {
    resolveCoreVenvTestElements();
    if (!coreVenvTestStatus) {
        return;
    }
    let text = message;
    if (!text) {
        if (status === 'success') {
            text = 'Virtualenv verified.';
        } else if (status === 'failure') {
            text = 'Virtualenv test failed.';
        } else {
            text = 'Not tested.';
        }
    }
    coreVenvTestStatus.textContent = text;
    coreVenvTestStatus.classList.remove('text-success', 'text-danger', 'text-muted');
    if (status === 'success') {
        coreVenvTestStatus.classList.add('text-success');
    } else if (status === 'failure') {
        coreVenvTestStatus.classList.add('text-danger');
    } else {
        coreVenvTestStatus.classList.add('text-muted');
    }
}

function handleCoreModalInputChange(fieldName) {
    if (['venv_bin', 'ssh_host', 'ssh_username', 'ssh_password'].includes(fieldName)) {
        setCoreVenvStatusDisplay(null, null);
    }
    updateCoreVenvTestButtonState();
}

function updateCoreVenvTestButtonState() {
    resolveCoreModalReferences();
    resolveCoreVenvTestElements();
    if (!coreTestVenvBtn) {
        return;
    }
    if (IS_BUILDER_VIEW) {
        coreTestVenvBtn.disabled = true;
        coreTestVenvBtn.title = 'Builder view is read-only';
        return;
    }
    const venvInput = coreModalInputs.venv_bin;
    const hostInput = coreModalInputs.ssh_host;
    const usernameInput = coreModalInputs.ssh_username;
    const passwordInput = coreModalInputs.ssh_password;
    const grpcHostInput = coreModalInputs.grpc_host;
    const inputsDisabled = !!(venvInput && venvInput.disabled);
    const venvPath = (venvInput && venvInput.value ? venvInput.value.trim() : '');
    const sshHost = (hostInput && hostInput.value ? hostInput.value.trim() : '')
        || (grpcHostInput && grpcHostInput.value ? grpcHostInput.value.trim() : '');
    const sshUsername = (usernameInput && usernameInput.value ? usernameInput.value.trim() : '');
    const sshPassword = passwordInput ? passwordInput.value || '' : '';
    const enable = !inputsDisabled && !!(venvPath && sshHost && sshUsername && sshPassword);
    coreTestVenvBtn.disabled = !enable;
}

async function handleCoreVenvTest(event) {
    event?.preventDefault?.();
    resolveCoreModalReferences();
    resolveCoreVenvTestElements();
    if (!coreConnectionModal || !coreModalInputs.venv_bin) {
        return;
    }
    if (IS_BUILDER_VIEW) {
        setCoreVenvStatusDisplay(null, 'Builder view cannot run remote tests.');
        return;
    }
    const triggerButton = (event && event.currentTarget instanceof HTMLElement)
        ? event.currentTarget
        : coreTestVenvBtn;
    if (!triggerButton) {
        return;
    }
    const targetIdxRaw = coreConnectionModal.getAttribute('data-scen-idx') || String(activeIdx);
    const sidx = parseInt(targetIdxRaw, 10);
    if (Number.isNaN(sidx) || !state.scenarios?.[sidx]) {
        return;
    }
    const scenario = state.scenarios[sidx];
    const hitlState = ensureHitlStateForScenario(scenario);
    const coreState = hitlState.core || (hitlState.core = {});
    const venvPath = (coreModalInputs.venv_bin.value || '').trim();
    if (!venvPath) {
        setCoreVenvStatusDisplay('failure', 'Enter a venv bin path to test.');
        return;
    }
    const sshHost = (coreModalInputs.ssh_host?.value || coreState.ssh_host || coreState.grpc_host || '').trim()
        || (coreModalInputs.grpc_host?.value || '').trim();
    if (!sshHost) {
        setCoreVenvStatusDisplay('failure', 'Enter the SSH host before testing the virtualenv.');
        return;
    }
    const sshPortRaw = parseInt(coreModalInputs.ssh_port?.value || '', 10);
    const sshPort = Number.isFinite(sshPortRaw) && sshPortRaw > 0
        ? sshPortRaw
        : (Number(coreState.ssh_port) || 22);
    const sshUsername = (coreModalInputs.ssh_username?.value || '').trim();
    if (!sshUsername) {
        setCoreVenvStatusDisplay('failure', 'Enter the SSH username before testing the virtualenv.');
        return;
    }
    const sshPassword = coreModalInputs.ssh_password?.value || '';
    if (!sshPassword) {
        setCoreVenvStatusDisplay('failure', 'Enter the SSH password before testing the virtualenv.');
        return;
    }
    const originalLabel = triggerButton.textContent;
    triggerButton.disabled = true;
    triggerButton.textContent = 'Testing…';
    setCoreVenvStatusDisplay(null, 'Testing virtualenv…');
    const payload = {
        venv_bin: venvPath,
        ssh_host: sshHost,
        ssh_port: sshPort,
        ssh_username: sshUsername,
        ssh_password: sshPassword,
    };
    const persistVenvResult = (status, message, extra = {}) => {
        coreState.venv_test_status = status;
        coreState.venv_test_message = message;
        coreState.venv_test_at = new Date().toISOString();
        coreState.venv_test_python = extra.python || null;
        persistEditorState();
    };
    try {
        const resp = await fetch('/test_core_venv', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            credentials: 'same-origin',
            body: JSON.stringify(payload),
        });
        let data = null;
        try { data = await resp.json(); } catch (err) { data = null; }
        if (resp.ok && data?.ok) {
            const msg = data.message || 'Virtualenv verified.';
            setCoreVenvStatusDisplay('success', msg);
            persistVenvResult('success', msg, { python: data.python_executable || null });
            if (typeof showToast === 'function') {
                try { showToast('CORE venv verified', { autohide: true, delay: 2200 }); } catch (_) {}
            }
        } else {
            const message = (data && data.error) ? data.error : `HTTP ${resp.status}`;
            setCoreVenvStatusDisplay('failure', message);
            persistVenvResult('failure', message, { python: null });
            if (typeof showToast === 'function') {
                try { showToast(`CORE venv test failed: ${message}`, { autohide: false }); } catch (_) {}
            }
        }
    } catch (err) {
        const message = err instanceof Error ? err.message : 'Virtualenv test failed.';
        setCoreVenvStatusDisplay('failure', message);
        persistVenvResult('failure', message, { python: null });
        if (typeof showToast === 'function') {
            try { showToast(message, { autohide: false }); } catch (_) {}
        }
    } finally {
        triggerButton.disabled = false;
        if (originalLabel !== undefined) {
            triggerButton.textContent = originalLabel;
        }
    }
}

function wireCoreVenvTestButton() {
    resolveCoreVenvTestElements();
    if (!coreTestVenvBtn) {
        return;
    }
    if (!coreTestVenvBtn.dataset.coreVenvBound) {
        coreTestVenvBtn.addEventListener('click', handleCoreVenvTest);
        coreTestVenvBtn.dataset.coreVenvBound = '1';
    }
    updateCoreVenvTestButtonState();
}

// --- Scenario multi-select support ---
let selectedScenarioIds = new Set();
try {
    const savedSel = JSON.parse(localStorage.getItem('coretg_selected_scenarios')||'[]');
    if (Array.isArray(savedSel)) savedSel.forEach(id => selectedScenarioIds.add(id));
} catch(e){}

function persistScenarioSelection() {
    try { localStorage.setItem('coretg_selected_scenarios', JSON.stringify(Array.from(selectedScenarioIds))); } catch(e){}
}

function syncExternalIfxModalSaveLabel() {
    try {
        const modalEl = document.getElementById('externalIfxModal');
        if (!modalEl) return;
        const btn = document.getElementById('externalIfxModalSaveBtn');
        if (!btn) return;
        // Don't override while busy/spinning.
        if (btn.disabled && (btn.innerHTML || '').includes('spinner-border')) return;

        const toggle = modalEl.querySelector(`[data-hitl-toggle][data-scen-idx="${activeIdx}"]`);
        const enabled = toggle ? !!toggle.checked : !!(state?.scenarios?.[activeIdx]?.hitl?.enabled);
        btn.textContent = enabled ? 'Validate & Save' : 'Save';
    } catch (e) {}
}

function ensureScenarioIds() {
    let changed = false;
    const seen = new Set();
    try {
        (state.scenarios || []).forEach(s => {
            if (!s || typeof s !== 'object') return;
            let sid = (s._sid !== undefined && s._sid !== null) ? String(s._sid) : '';
            if (!sid || seen.has(sid)) {
                sid = generateScenarioSid();
                s._sid = sid;
                changed = true;
            }
            seen.add(sid);
        });
    } catch (e) {
        // Defensive: never block rendering due to SID repair.
    }

    // Drop stale selections that no longer exist (common after SID repair).
    try {
        if (selectedScenarioIds && selectedScenarioIds.size) {
            let selectionChanged = false;
            for (const sid of Array.from(selectedScenarioIds)) {
                if (!seen.has(String(sid))) {
                    selectedScenarioIds.delete(sid);
                    selectionChanged = true;
                }
            }
            if (selectionChanged) {
                persistScenarioSelection();
                try { updateBulkButtonsState(); } catch (e) {}
            }
        }
    } catch (e) {}

    if (changed) {
        try { persistEditorState(); } catch (e) {}
    }
}

function toggleScenarioSelection(id, checked) {
    if (checked) selectedScenarioIds.add(id); else selectedScenarioIds.delete(id);
    persistScenarioSelection();
    updateBulkButtonsState();
}

function selectAllScenarios() {
    ensureScenarioIds();
    const allIds = state.scenarios.map(s => s._sid);
    const allSelected = allIds.every(id => selectedScenarioIds.has(id));
    if (allSelected) { selectedScenarioIds.clear(); }
    else { allIds.forEach(id => selectedScenarioIds.add(id)); }
    persistScenarioSelection();
    renderSidebar();
}

async function deleteSelectedScenarios() {
    // Ensure scenario IDs are present/unique and selection doesn't contain stale IDs.
    try { ensureScenarioIds(); } catch (e) {}
    try {
        if (selectedScenarioIds && selectedScenarioIds.size) {
            const valid = new Set((state.scenarios || []).map(s => (s && s._sid !== undefined && s._sid !== null) ? String(s._sid) : '').filter(Boolean));
            let changed = false;
            for (const sid of Array.from(selectedScenarioIds)) {
                if (!valid.has(String(sid))) {
                    selectedScenarioIds.delete(sid);
                    changed = true;
                }
            }
            if (changed) {
                persistScenarioSelection();
                try { updateBulkButtonsState(); } catch (e) {}
            }
        }
    } catch (e) {}

    if (!selectedScenarioIds.size) return;
    const count = selectedScenarioIds.size;
    if (!confirm(`Delete ${count} selected scenario${count>1?'s':''}? This cannot be undone.`)) return;
    const beforeLen = state.scenarios.length;
    const deletedNames = [];
    const deletedSids = [];
    try {
        state.scenarios.forEach((s, idx) => {
            try {
                if (!s || typeof s !== 'object') return;
                const sid = (s._sid !== undefined && s._sid !== null) ? String(s._sid) : '';
                if (!sid) return;
                if (!selectedScenarioIds.has(sid)) return;
                deletedSids.push(sid);
                let name = (s.name && String(s.name).trim()) ? String(s.name).trim() : '';
                if (!name) {
                    // Ensure every scenario has a stable name so server-side deletion
                    // can match against snapshots and saved XML artifacts.
                    name = `Scenario ${idx+1}`;
                    s.name = name;
                }
                deletedNames.push(name);
            } catch (e) {}
        });
    } catch (e) {}

    try {
        if (deletedSids.length || deletedNames.length) {
            rememberDeletedScenarioMarks({ ids: deletedSids, names: deletedNames });
            try {
                const preview = deletedNames.slice(0, 6).join(', ');
                logInfo(`Marked deleted tombstones: ${preview}${deletedNames.length > 6 ? ' (+more)' : ''}`);
            } catch (_) {}
        }
    } catch (e) {}

    // Filter using string IDs to avoid type mismatches (e.g., number vs string).
    state.scenarios = (state.scenarios || []).filter(s => {
        try {
            const sid = (s && s._sid !== undefined && s._sid !== null) ? String(s._sid) : '';
            if (!sid) return true;
            return !selectedScenarioIds.has(sid);
        } catch (e) {
            return true;
        }
    });
    selectedScenarioIds.clear();
    if (!state.scenarios.length) {
        // Always keep at least one blank scenario to avoid empty editor state hassles
        state.scenarios.push(defaultScenario());
        activeIdx = 0;
    } else {
        if (activeIdx >= state.scenarios.length) activeIdx = state.scenarios.length - 1;
    }
    try {
        const deletedCount = beforeLen - state.scenarios.length;
        logInfo(`Deleted ${deletedCount} scenarios`);
        if (deletedNames.length) {
            const preview = deletedNames.slice(0, 12).join(', ');
            const more = deletedNames.length > 12 ? ` (+${deletedNames.length - 12} more)` : '';
            logInfo(`Delete names sent to server: ${preview}${more}`);
        }
    } catch (e) {
        logInfo(`Deleted ${beforeLen - state.scenarios.length} scenarios`);
    }
    persistEditorState();
    persistScenarioSelection();
    // Ensure server-side editor snapshot is updated immediately so a quick refresh
    // cannot resurrect deleted scenarios.
    try {
        if (typeof flushServerSnapshotPersistNow === 'function') {
            const snapRes = await flushServerSnapshotPersistNow();
            if (snapRes && snapRes.ok === false) {
                try { showToast(`Warning: server snapshot not updated (${snapRes.error || 'unknown error'}). Deleted scenarios may reappear on refresh.`, { autohide: true, delay: 5000 }); } catch (_) {}
            }
        }
    } catch (e) {
        try { showToast('Warning: failed to flush server snapshot; deleted scenarios may reappear on refresh.', { autohide: true, delay: 5000 }); } catch (_) {}
    }
    try { previewState.dirty = true; updatePlanButtons(); } catch(e){}
    render();

    // Persist deletion across refresh: remove from server catalog and save snapshot.
    try {
        if (deletedNames.length) {
            const res = await fetch('/delete_scenarios', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                credentials: 'same-origin',
                body: JSON.stringify({ names: deletedNames }),
            });
            let payload = null;
            try { payload = await res.clone().json(); } catch (e) { payload = null; }
            if (!res.ok || (payload && payload.ok === false)) {
                const detail = (payload && (payload.error || payload.message))
                    ? String(payload.error || payload.message)
                    : (() => { try { return res.status ? ('HTTP ' + res.status) : 'HTTP error'; } catch (_) { return 'HTTP error'; } })();
                try { showToast(`Warning: delete_scenarios failed (${detail}).`, { autohide: true, delay: 6000 }); } catch (_) {}
            } else if (payload && typeof payload === 'object') {
                const removed = Number(payload.removed ?? payload.removed_count ?? payload.removedNames ?? payload.removed_names ?? payload.removed_scenarios) || 0;
                const remaining = Number(payload.remaining ?? payload.remaining_count) || 0;
                const artifacts = Number(payload.artifacts_removed) || 0;
                const snapRemoved = Number(payload.snapshot_scenarios_removed) || 0;
                const snapUpdated = Number(payload.snapshots_updated) || 0;
                const snapDeleted = Number(payload.snapshots_deleted) || 0;
                const historyRemoved = Number(payload.history_removed) || 0;
                const msg = `Server delete persisted: removed=${removed}, remaining=${remaining}, artifacts_removed=${artifacts}, snapshot_scenarios_removed=${snapRemoved}, snapshots_updated=${snapUpdated}, snapshots_deleted=${snapDeleted}, history_removed=${historyRemoved}`;
                try { logInfo(msg); } catch (e) {}
                try { showToast(msg, { autohide: true, delay: 6000 }); } catch (_) {}
            }
        }
    } catch (e) {
        console.warn('delete_scenarios failed', e);
        try { showToast('Warning: server catalog delete failed. Deleted scenarios may reappear on refresh.', { autohide: true, delay: 5000 }); } catch (_) {}
    }
    try {
        await autoSaveXml();
    } catch (e) {
        console.warn('autoSaveXml after delete failed', e);
        try { showToast('Delete was not persisted (save failed).', { autohide: true, delay: 3500 }); } catch (_) {}
    }
}

function updateBulkButtonsState() {
    const delBtn = document.getElementById('deleteSelectedScenariosBtn');
    if (!delBtn) return;
    if (selectedScenarioIds.size) { delBtn.removeAttribute('disabled'); delBtn.title = 'Delete selected'; }
    else { delBtn.setAttribute('disabled','disabled'); delBtn.title = 'No scenarios selected'; }
}

function renderSidebar() {
    ensureScenarioIds();
    const list = document.getElementById('scenarioList');
    list.innerHTML = '';
    const escapeHtml = (value) => (value ?? '').toString()
        .replace(/&/g,'&amp;')
        .replace(/</g,'&lt;')
        .replace(/>/g,'&gt;')
        .replace(/"/g,'&quot;')
        .replace(/'/g,'&#39;');
    state.scenarios.forEach((scen, idx) => {
        const sid = scen._sid;
        const a = document.createElement('a');
        a.href = '#';
        a.className = 'list-group-item list-group-item-action py-1' + (idx === activeIdx ? ' active bg-primary text-white' : '');
        // Build inner HTML with checkbox
        const isChecked = selectedScenarioIds.has(sid);
        const name = scen.name || `Scenario ${idx+1}`;
        const safeName = escapeHtml(name);
        const checkboxHtml = IS_BUILDER_VIEW ? '' : `<input type="checkbox" class="form-check-input me-2 scenario-select" data-sid="${sid}" ${isChecked? 'checked':''} onclick="event.stopPropagation(); toggleScenarioSelection('${sid}', this.checked);" />`;
        a.innerHTML = `<div class="d-flex align-items-center">
            ${checkboxHtml}
            <span class="flex-grow-1 text-truncate" title="${safeName}">${safeName}</span>
        </div>`;
        a.onclick = (e) => {
            e.preventDefault();
            activeIdx = idx;
            persistEditorState();
            render();
            try { refreshXmlDockPreview({ force: true }); } catch (err) {}
        };
        list.appendChild(a);
    });
    const appendScenarioBtn = document.getElementById('appendScenarioBtn');
    const importBtn = document.getElementById('importBtn');
    const exportBtn = document.getElementById('exportBtn');
    const selectAllBtn = document.getElementById('selectAllScenariosBtn');
    const deleteSelectedBtn = document.getElementById('deleteSelectedScenariosBtn');
    const hiddenLoadInput = document.getElementById('hiddenLoadInput');
    const hiddenLoadForm = document.getElementById('hiddenLoadForm');
    if (appendScenarioBtn && !IS_BUILDER_VIEW) {
        appendScenarioBtn.onclick = (e) => {
            e.preventDefault();
            logInfo('New scenario created');
            const newScenario = defaultScenario();
            try {
                newScenario.name = ensureUniqueScenarioName(newScenario.name, state.scenarios);
            } catch (e) {}
            try {
                const nkey = scenarioNameKey(newScenario.name);
                if (nkey && deletedScenarioNameKeys && deletedScenarioNameKeys.has(nkey)) {
                    // User is explicitly creating a new scenario; allow this name to persist.
                    deletedScenarioNameKeys.delete(nkey);
                    writeStringSetToLocalStorage(DELETED_SCENARIO_NAME_KEYS_STORAGE_KEY, deletedScenarioNameKeys);
                }
            } catch (e) {}
            state.scenarios.push(newScenario);
            activeIdx = state.scenarios.length - 1;
            persistEditorState();
            try { if (typeof flushServerSnapshotPersistNow === 'function') flushServerSnapshotPersistNow(); } catch (_) {}
            try { previewState.dirty = true; updatePlanButtons(); } catch(e){}
            render();
        };
    }
    if (importBtn) importBtn.onclick = (e) => { e.preventDefault(); logInfo('Import scenarios clicked'); hiddenLoadInput.click(); };
    if (hiddenLoadInput) hiddenLoadInput.onchange = () => { if (hiddenLoadInput.files && hiddenLoadInput.files.length > 0) { saveScrollBeforeNav(); hiddenLoadForm.submit(); } };
    if (exportBtn) exportBtn.onclick = (e) => {
        e.preventDefault();
        logInfo('Export clicked');
        const rp = state.result_path || '';
        if (!rp.endsWith('.xml')) {
            logWarn('Export blocked: no saved XML');
            alert('Please Save XML first (middle panel) to export the current scenarios.');
            return;
        }
        window.location.href = window.location.origin + '/download_report?path=' + encodeURIComponent(rp);
    };
    if (selectAllBtn && !IS_BUILDER_VIEW) {
        selectAllBtn.onclick = (e) => { e.preventDefault(); selectAllScenarios(); };
    }
    if (deleteSelectedBtn && !IS_BUILDER_VIEW) {
        deleteSelectedBtn.onclick = (e) => { e.preventDefault(); deleteSelectedScenarios(); };
    }
    const selectCoreVmBtn = document.getElementById('selectCoreVmBtn');
    const configHitlBtn = document.getElementById('configHitlBtn');
    const coreVmSelectModalEl = document.getElementById('coreVmSelectModal');
    const configHitlModalEl = document.getElementById('externalIfxModal');
    const openCoreVmSelectModal = () => {
        if (IS_BUILDER_VIEW) {
            const msg = 'CORE VM changes require admin access.';
            if (typeof showToast === 'function') {
                try { showToast(msg, { autohide: true, delay: 3200 }); } catch (_) {}
            } else if (window.alert) {
                window.alert(msg);
            }
            return;
        }
        if (!coreVmSelectModalEl || !window.bootstrap) return;
        const modalInstance = bootstrap.Modal.getInstance(coreVmSelectModalEl)
            || new bootstrap.Modal(coreVmSelectModalEl, { backdrop: true, keyboard: true });
        modalInstance.show();
    };

    if (selectCoreVmBtn && !IS_BUILDER_VIEW && !selectCoreVmBtn.dataset.hitlModalBound) {
        selectCoreVmBtn.addEventListener('click', openCoreVmSelectModal);
        selectCoreVmBtn.dataset.hitlModalBound = '1';
    }

    window.openCoreVmSelectModal = openCoreVmSelectModal;

    if (!IS_BUILDER_VIEW) {
        (() => {
            try {
                const url = new URL(window.location.href);
                if (url.searchParams.get('core_modal') === '1') {
                    setTimeout(openCoreVmSelectModal, 250);
                    url.searchParams.delete('core_modal');
                    const newQuery = url.searchParams.toString();
                    const queryPart = newQuery ? `?${newQuery}` : '';
                    const newUrl = `${url.pathname}${queryPart}${url.hash}`;
                    window.history.replaceState({}, '', newUrl);
                }
            } catch (err) {
                console.warn('Failed to auto-open CORE VM modal', err);
            }
        })();
    }
    if (configHitlBtn && !configHitlBtn.dataset.hitlModalBound) {
        configHitlBtn.addEventListener('click', () => {
            if (configHitlBtn.disabled) return;
            if (!configHitlModalEl || !window.bootstrap) return;
            const modalInstance = bootstrap.Modal.getInstance(configHitlModalEl) || new bootstrap.Modal(configHitlModalEl, { backdrop: true, keyboard: true });
            maybeAutoRefreshHitlInterfacesOnModalOpen(activeIdx);
            try { syncExternalIfxModalSaveLabel(); } catch (_) {}
            modalInstance.show();
            try {
                if (!configHitlModalEl.dataset.hitlSaveLabelBound) {
                    configHitlModalEl.addEventListener('shown.bs.modal', () => {
                        try { syncExternalIfxModalSaveLabel(); } catch (_) {}
                    });
                    configHitlModalEl.dataset.hitlSaveLabelBound = '1';
                }
            } catch (e) {}
        });
        configHitlBtn.dataset.hitlModalBound = '1';
    }
    updateBulkButtonsState();
}

function renderMain() {
    // Dispose any tooltips attached to scenario-specific UI before re-rendering.
    try {
        _hideDisposeTooltip(document.getElementById('configHitlBtnWrap'));
        _hideDisposeTooltip(document.getElementById('scenarioNameConfigHitlBtnWrap'));
        const meta = document.getElementById('scenarioMetaCard');
        if (meta) {
            meta.querySelectorAll('[data-bs-toggle="tooltip"]').forEach((el) => _hideDisposeTooltip(el));
        }
    } catch (e) {}

    const root = document.getElementById('editorRoot');
    if (root) {
        root.innerHTML = '';
    }
    // Always clear any scenario-specific cards that may have been injected outside
    // the editor root (e.g., above the base card), even when there are no scenarios.
    try {
        const existingMetaCard = document.getElementById('scenarioMetaCard');
        if (existingMetaCard && existingMetaCard.parentNode) {
            existingMetaCard.parentNode.removeChild(existingMetaCard);
        }
        const existingCoreCard = document.getElementById('scenarioHitlCoreCard');
        if (existingCoreCard && existingCoreCard.parentNode) {
            existingCoreCard.parentNode.removeChild(existingCoreCard);
        }
        const existingHitlCard = document.getElementById('scenarioHitlConfigCard');
        if (existingHitlCard && existingHitlCard.parentNode) {
            existingHitlCard.parentNode.removeChild(existingHitlCard);
        }
    } catch (e) {}

    if (!state.scenarios.length) {
        try { refreshScenariosExecuteButtonState(); } catch (e) {}
        try {
            if (SCENARIOS_ACTIVE_TAB === 'connection-setup') {
                const connectionRoot = document.getElementById('connectionSetupRoot');
                if (connectionRoot) {
                    connectionRoot.innerHTML = `
                        <div class="card mb-3">
                            <div class="card-body">
                                <div class="fw-semibold">Connection Setup</div>
                                <div class="text-muted small mt-1">Create or import a scenario to configure CORE / Participant settings.</div>
                            </div>
                        </div>`;
                }
            }
        } catch (e) {}
        return;
    }
    const scen = state.scenarios[activeIdx] || state.scenarios[0];
    try { bindHostInterfacesToScenarioCache(activeIdx); } catch (e) {}
    const escapeHtml = (value) => (value ?? '').toString()
        .replace(/&/g,'&amp;')
        .replace(/</g,'&lt;')
        .replace(/>/g,'&gt;')
        .replace(/"/g,'&quot;')
        .replace(/'/g,'&#39;');
    const safeScenarioName = escapeHtml(scen?.name || '');
    const defaultScenarioName = escapeHtml(`Scenario ${activeIdx + 1}`);

    // Scenario-name card button enablement (Config HITL Clear).
    const metaHitlState = ensureHitlStateForScenario(scen);
    const metaCoreState = metaHitlState.core || {};
    const metaHitlEnabled = !!metaHitlState.enabled;
    const metaHitlHasValues = (
        (Array.isArray(metaHitlState.interfaces) && metaHitlState.interfaces.length > 0)
        || (((metaHitlState.participant_proxmox_url || '').toString().trim()).length > 0)
        || !!metaHitlState.bridge_validated
        || (((metaCoreState.internal_bridge || '').toString().trim()).length > 0)
        || (((metaCoreState.internal_bridge_owner || '').toString().trim()).length > 0)
    );
    const metaHitlClearDisabled = (!metaHitlEnabled) || (!metaHitlHasValues);

    // Refresh persisted section collapse state (per scenario + section) early,
    // before any of the per-card collapse reads.
    try { collapseState = JSON.parse(localStorage.getItem('sectionCollapseState') || '{}'); } catch(e) { collapseState = {}; }

    const coreParticipantCollapseKey = `${activeIdx}::core_participant_setup`;
    const coreParticipantCollapsed = !!collapseState[coreParticipantCollapseKey];
    const existingMetaCard = document.getElementById('scenarioMetaCard');
    const existingConnectionCard = document.getElementById('scenarioConnectionSetupCard');
    const hitlEntryWrap = document.getElementById('hitlEntryButtonsWrap');
    // Capture existing button elements BEFORE removing/rebuilding containers.
    const selectCoreVmBtnEl = document.getElementById('selectCoreVmBtn');
    const configHitlBtnEl = document.getElementById('configHitlBtn');
    const hitlAdminBadgeEl = hitlEntryWrap ? hitlEntryWrap.querySelector('.badge') : null;
    if (existingMetaCard && existingMetaCard.parentNode) {
        existingMetaCard.parentNode.removeChild(existingMetaCard);
    }
    if (existingConnectionCard && existingConnectionCard.parentNode) {
        existingConnectionCard.parentNode.removeChild(existingConnectionCard);
    }

    const baseScenarioCard = document.getElementById('baseCoreScenarioCard');
    const connectionRoot = document.getElementById('connectionSetupRoot');

    // Scenario name card: Connection Setup tab only (do not show on Topology).
    if (SCENARIOS_ACTIVE_TAB === 'connection-setup') {
        const metaCard = document.createElement('div');
        metaCard.id = 'scenarioMetaCard';
        metaCard.className = 'card mb-3';
        metaCard.innerHTML = `
            <div class="card-body">
                <div class="d-flex flex-wrap justify-content-between align-items-end gap-3">
                    <div class="flex-grow-1" style="min-width: 240px;">
                        <label class="form-label mb-1 small text-muted" for="scenarioNameInput_${activeIdx}">Scenario name</label>
                        <input type="text" class="form-control" id="scenarioNameInput_${activeIdx}" data-field="name" data-scen-idx="${activeIdx}" value="${safeScenarioName}" placeholder="${defaultScenarioName}">
                    </div>
                </div>
            </div>`;
        if (connectionRoot) {
            connectionRoot.innerHTML = '';
            connectionRoot.appendChild(metaCard);
        } else if (root) {
            root.appendChild(metaCard);
        }
    }

    // Connection Setup tab: show CORE / Participant Setup in its own card.
    if (SCENARIOS_ACTIVE_TAB === 'connection-setup') {
        const connectionCard = document.createElement('div');
        connectionCard.id = 'scenarioConnectionSetupCard';
        connectionCard.className = 'card mb-3';
        connectionCard.innerHTML = `
            <div class="card-header d-flex justify-content-between align-items-center gap-2">
                <strong>CORE / Participant Setup</strong>
                <span id="scenarioNameHitlStatusBadge" class="badge text-bg-secondary">Not configured</span>
            </div>
            <div class="card-body">
                ${IS_BUILDER_VIEW ? `
                    <div class="small text-body" id="scenarioNameBuilderSetupStatus">Not yet Setup by Admin</div>
                ` : `
                    <div class="table-responsive">
                        <table class="table table-sm mb-0 align-middle">
                            <tbody>
                                <tr>
                                    <td style="width: 240px;">
                                        <div class="d-flex flex-column gap-2">
                                            <div id="scenarioNameCoreBtnSlot"></div>
                                            <button type="button" class="btn btn-outline-secondary hitl-entry-btn" id="scenarioNameCoreVerifyBtn" title="Verify CORE/Proxmox settings">Verify</button>
                                            <button type="button" class="btn btn-outline-danger hitl-entry-btn" id="scenarioNameCoreClearBtn" title="Clear selected CORE VM and reset HITL mappings/bridge fields">Clear</button>
                                        </div>
                                    </td>
                                    <td>
                                        <div class="small text-body" id="scenarioNameCoreSummary"></div>
                                    </td>
                                </tr>
                                <tr>
                                    <td style="width: 240px;">
                                        <div class="d-flex flex-column gap-2">
                                            <div id="scenarioNameHitlBtnSlot"></div>
                                            <button type="button" class="btn btn-outline-secondary hitl-entry-btn" id="scenarioNameHitlVerifyBtn" title="Verify HITL bridge settings">Verify</button>
                                            <button type="button" class="btn btn-outline-danger hitl-entry-btn" id="scenarioNameHitlClearBtn" title="Clear HITL interface mappings and bridge settings" ${metaHitlClearDisabled ? 'disabled' : ''}>Clear</button>
                                        </div>
                                    </td>
                                    <td>
                                        <div class="small text-body" id="scenarioNameHitlSummary"></div>
                                    </td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                `}
            </div>`;
        if (connectionRoot) {
            connectionRoot.appendChild(connectionCard);
        } else if (baseScenarioCard && baseScenarioCard.parentNode) {
            baseScenarioCard.parentNode.insertBefore(connectionCard, baseScenarioCard);
        } else {
            root.appendChild(connectionCard);
        }
    }

    // Render the optional entry buttons in the "CORE / Participant Setup (optional)"
    // card via proxy buttons, while keeping the original header buttons hidden.
    if (!IS_BUILDER_VIEW) {
        const coreBtnSlot = document.getElementById('scenarioNameCoreBtnSlot');
        const hitlBtnSlot = document.getElementById('scenarioNameHitlBtnSlot');
        const makeProxyBtn = (originalBtn, proxyId) => {
            if (!originalBtn) return null;
            const wrap = document.createElement('span');
            wrap.className = 'd-inline-block w-100';
            wrap.tabIndex = 0;
            wrap.id = `${proxyId}Wrap`;
            const btn = document.createElement('button');
            btn.type = 'button';
            btn.id = proxyId;
            btn.className = `${originalBtn.className} w-100 hitl-entry-btn`;
            btn.textContent = originalBtn.textContent || '';
            btn.disabled = !!originalBtn.disabled;
            const title = originalBtn.getAttribute('title');
            if (title) btn.setAttribute('title', title);
            if (btn.disabled && title) {
                _ensureHoverOnlyTooltip(wrap, title);
            }
            btn.addEventListener('click', (ev) => {
                ev.preventDefault();
                try { originalBtn.click(); } catch (e) {}
            });
            wrap.appendChild(btn);
            return wrap;
        };
        try {
            if (coreBtnSlot && selectCoreVmBtnEl) {
                coreBtnSlot.innerHTML = '';
                const proxy = makeProxyBtn(selectCoreVmBtnEl, 'scenarioNameSelectCoreVmBtn');
                if (proxy) coreBtnSlot.appendChild(proxy);
            }
            if (hitlBtnSlot && configHitlBtnEl) {
                hitlBtnSlot.innerHTML = '';
                const proxy = makeProxyBtn(configHitlBtnEl, 'scenarioNameConfigHitlBtn');
                if (proxy) hitlBtnSlot.appendChild(proxy);
            }
        } catch (e) {}
    }

    // Tooltips (native title tooltip) for the optional entry points.
    try {
        const selectBtn = document.getElementById('selectCoreVmBtn');
        if (selectBtn) {
            selectBtn.setAttribute('title', 'Select a Proxmox resource and remote CORE VM for HITL runs.');
        }
        const cfgBtn = document.getElementById('configHitlBtn');
        if (cfgBtn) {
            // Keep gating tooltip if disabled; otherwise show the purpose.
            if (!cfgBtn.disabled) {
                cfgBtn.setAttribute('title', 'Configure HITL interfaces and participant VM mappings for this scenario.');
            } else if (!cfgBtn.getAttribute('title')) {
                cfgBtn.setAttribute('title', 'CORE VM has to be selected/verified');
            }
        }
    } catch (e) {}

    // Bind scenario-name Verify buttons (buttons are recreated every renderMain).
    try {
        const coreVerifyBtn = document.getElementById('scenarioNameCoreVerifyBtn');
        if (coreVerifyBtn) {
            coreVerifyBtn.addEventListener('click', async () => {
                await verifyScenarioCoreSetup(activeIdx, { triggerButton: coreVerifyBtn });
            });
        }
        const hitlVerifyBtn = document.getElementById('scenarioNameHitlVerifyBtn');
        if (hitlVerifyBtn) {
            hitlVerifyBtn.addEventListener('click', async () => {
                await verifyScenarioHitlBridge(activeIdx, { triggerButton: hitlVerifyBtn });
            });
        }
        const coreClearBtn = document.getElementById('scenarioNameCoreClearBtn');
        if (coreClearBtn) {
            coreClearBtn.addEventListener('click', async () => {
                await clearScenarioCoreVmSelection(activeIdx, { triggerButton: coreClearBtn });
            });
        }
        const hitlClearBtn = document.getElementById('scenarioNameHitlClearBtn');
        if (hitlClearBtn) {
            hitlClearBtn.addEventListener('click', async () => {
                await clearScenarioHitlConfig(activeIdx, { triggerButton: hitlClearBtn });
            });
        }
    } catch (e) {}

    // Shared Execute button: require a verified CORE VM for this project/scenario.
    try { refreshScenariosExecuteButtonState(); } catch (e) {}


    const removeExistingCard = (cardId) => {
        const existing = document.getElementById(cardId);
        if (existing && existing.parentNode) {
            existing.parentNode.removeChild(existing);
        }
    };
    removeExistingCard('scenarioHitlCoreCard');
    removeExistingCard('scenarioHitlConfigCard');

    try { bindHostInterfacesToScenarioCache(activeIdx); } catch (e) {}
    const hostInterfaces = getEffectiveHostInterfacesForScenario(activeIdx);
    const hitl = ensureHitlStateForScenario(scen);
    const proxmox = hitl.proxmox || { url: '', port: 8006, username: '', password: '' };
    const participantProxmoxUrlRaw = (hitl.participant_proxmox_url || '').toString();
    const participantProxmoxUrlHtml = escapeHtml(participantProxmoxUrlRaw);
    const participantProxmoxUrlHasValue = participantProxmoxUrlRaw.trim().length > 0;
    // In builder view, credentials are intentionally hidden and secret-backed actions are disabled.
    // Treat the presence of an admin-stored secret as sufficient signal that validation happened in admin view.
    const proxValidated = IS_BUILDER_VIEW
        ? !!proxmox.secret_id
        : !!(proxmox.validated && proxmox.secret_id);
    const hasProxmox = IS_BUILDER_VIEW
        ? !!(proxmox.url || proxmox.secret_id)
        : !!(proxmox.url && proxmox.username);
    const proxPort = proxmox.port ?? 8006;
    const proxSummaryText = IS_BUILDER_VIEW
        ? (proxValidated
            ? 'Proxmox credentials validated by an admin.'
            : ((proxmox.url || '').toString().trim()
                ? 'Proxmox URL configured (credentials managed by an admin).'
                : 'Proxmox resource not assigned.'))
        : (hasProxmox
            ? (proxValidated
                ? `Proxmox validated for ${proxmox.username} @ ${proxmox.url}:${proxPort}`
                : `Proxmox pending validation for ${proxmox.username} @ ${proxmox.url}:${proxPort}`)
            : 'Proxmox resource not assigned.');
    const proxSummaryHtml = escapeHtml(proxSummaryText);
    const proxSummaryClass = proxValidated ? 'text-success' : (hasProxmox ? 'text-warning' : 'text-muted');
    const proxHasSecret = !!proxmox.secret_id;
    const proxHasAny = proxHasSecret || hasProxmox;
    const proxAssignLabel = proxHasSecret ? 'Update Proxmox Resource' : 'Assign Proxmox Resource';
    const proxInventoryInfo = (proxmox.inventory && typeof proxmox.inventory === 'object') ? proxmox.inventory : { fetched_at: null, vms: [] };
    const proxInventory = Array.isArray(proxInventoryInfo.vms) ? proxInventoryInfo.vms : [];
    const proxInventoryBusy = proxInventoryFetchInFlight.has(activeIdx);
    const proxInventoryError = proxmox.inventory_error ? proxmox.inventory_error.toString() : '';
    let proxInventoryStatus = '';
    if (!hasProxmox) {
        proxInventoryStatus = 'Assign credentials to load VM inventory.';
    } else if (!proxValidated) {
        proxInventoryStatus = 'Validate credentials to load VM inventory.';
    } else if (proxInventoryBusy) {
        proxInventoryStatus = 'Fetching Proxmox VM inventory…';
    } else if (proxInventory.length) {
        let fetchedReadable = '';
        if (proxInventoryInfo.fetched_at) {
            try {
                fetchedReadable = new Date(proxInventoryInfo.fetched_at).toLocaleString();
            } catch (err) {
                fetchedReadable = '';
            }
        }
        proxInventoryStatus = `Loaded ${proxInventory.length} VM${proxInventory.length === 1 ? '' : 's'}${fetchedReadable ? ` • Last fetched ${fetchedReadable}` : ''}`;
    } else if (proxInventoryError) {
        proxInventoryStatus = `Inventory error: ${proxInventoryError}`;
    } else {
        proxInventoryStatus = 'No VMs reported. Refresh to retry.';
    }
    const proxInventoryStatusHtml = escapeHtml(proxInventoryStatus);
    const proxRefreshDisabledAttr = (proxValidated && !proxInventoryBusy) ? '' : 'disabled';
    if (PROXMOX_INVENTORY_AUTO_REFRESH_ENABLED && proxValidated && !proxInventoryBusy && !proxInventory.length && !proxInventoryError) {
        fetchProxmoxInventory(activeIdx)
            .catch(err => console.warn('Proxmox inventory fetch failed', err));
    }
    const normalizeHost = (raw) => {
        if (!raw && raw !== 0) return '';
        let text = String(raw).trim().toLowerCase();
        if (text.startsWith('[') && text.endsWith(']')) text = text.slice(1, -1);
        if (text.startsWith('::ffff:') && /^::ffff:\d+\.\d+\.\d+\.\d+$/.test(text)) {
            text = text.replace('::ffff:', '');
        }
        return text;
    };
    const core = hitl.core || {};
    const coreVmKey = (core.vm_key || '').toString();
    const coreVmName = (core.vm_name || '').toString();
    const coreHost = (core.grpc_host || '').toString().trim();
    const corePort = Number.isFinite(Number(core.grpc_port)) && Number(core.grpc_port) > 0 ? Number(core.grpc_port) : 50051;
    const coreSshHostRaw = (core.ssh_host || '').toString().trim();
    const coreSshHost = coreSshHostRaw || coreHost;
    const coreSshPort = Number.isFinite(Number(core.ssh_port)) && Number(core.ssh_port) > 0 ? Number(core.ssh_port) : 22;
    const coreUser = (core.ssh_username || '').toString().trim();
    const coreSecretId = typeof core.core_secret_id === 'string' ? core.core_secret_id.trim() : '';
    const coreHasSecret = !!coreSecretId;
    const corePasswordRaw = (core.ssh_password || '').toString();
    const corePassword = corePasswordRaw;
    const corePasswordAvailable = !!corePasswordRaw || coreHasSecret;
    const vmKeyParts = coreVmKey ? coreVmKey.split('::') : [];
    const vmKeyNodePart = (vmKeyParts[0] || '').trim();
    const vmKeyIdPart = (vmKeyParts[1] || '').trim();
    const cachedVmInterfaceCount = Number.isFinite(Number(core.cached_vm_interface_count)) ? Number(core.cached_vm_interface_count) : null;
    const liveSelectedCoreVm = proxInventory.find(vm => `${vm.node ?? ''}::${vm.vmid ?? ''}` === coreVmKey) || null;
    const fallbackCoreVm = (!liveSelectedCoreVm && coreVmKey) ? {
        name: coreVmName || '',
        node: core.vm_node || vmKeyNodePart || '',
        status: core.cached_vm_status || '',
        vmid: vmKeyIdPart || '',
        interface_count_hint: cachedVmInterfaceCount,
    } : null;
    const resolvedCoreVm = liveSelectedCoreVm
        ? { ...liveSelectedCoreVm, cached: false }
        : (fallbackCoreVm ? { ...fallbackCoreVm, cached: true } : null);
    const resolvedVmInterfaceCount = (() => {
        if (resolvedCoreVm && Array.isArray(resolvedCoreVm.interfaces)) {
            return resolvedCoreVm.interfaces.length;
        }
        if (resolvedCoreVm && Number.isFinite(resolvedCoreVm.interface_count_hint)) {
            return Number(resolvedCoreVm.interface_count_hint);
        }
        if (cachedVmInterfaceCount !== null) {
            return cachedVmInterfaceCount;
        }
        return null;
    })();
    const interfaceCountKnown = resolvedVmInterfaceCount !== null;
    const coreVmHasInterfaces = !coreVmKey || !interfaceCountKnown || resolvedVmInterfaceCount >= 1;
    const coreVmSupportsHitl = !coreVmKey || !interfaceCountKnown || resolvedVmInterfaceCount >= 2;
    const coreVmNode = resolvedCoreVm && resolvedCoreVm.node !== undefined && resolvedCoreVm.node !== null
        ? String(resolvedCoreVm.node).trim()
        : (core.vm_node ? String(core.vm_node).trim() : vmKeyNodePart);
    const coreVmNameDisplay = IS_BUILDER_VIEW ? '' : coreVmName;
    const coreVmNodeDisplay = IS_BUILDER_VIEW ? '' : coreVmNode;
    const coreInputsComplete = !!(coreVmKey && coreHost && corePort && coreSshHost && coreSshPort && coreUser && corePasswordAvailable);
    const coreTestSuccess = core.last_tested_status === 'success';
    const coreTestMatches = coreTestSuccess
        && !!core.last_tested_host
        && normalizeHost(core.last_tested_host) === normalizeHost(coreHost)
        && Number(core.last_tested_port) === Number(corePort);
    const coreConnectionReady = proxValidated && coreInputsComplete && coreVmHasInterfaces && coreTestMatches;
    const coreReady = coreConnectionReady && coreVmSupportsHitl;
    const coreHitlBlocked = coreConnectionReady && !coreVmSupportsHitl;
    const coreTestable = proxValidated && coreInputsComplete && coreVmHasInterfaces;
    const hitlAuthReady = proxValidated && coreHasSecret && !!coreVmKey;
    const coreVmInterfaceWarning = (() => {
        if (!coreVmKey || !interfaceCountKnown) return '';
        if (!coreVmHasInterfaces) {
            const count = resolvedVmInterfaceCount || 0;
            return `<div class="alert alert-danger small mt-2 mb-0">Selected VM exposes ${count} network interface${count === 1 ? '' : 's'}. Add at least one interface to enable CORE connectivity.</div>`;
        }
        return '';
    })();
    const hostLookup = new Map();
    hostInterfaces
        .filter(it => it && typeof it === 'object')
        .forEach((it) => {
            const rawName = (it.name ?? it.interface ?? it.iface ?? it.id ?? '').toString().trim();
            if (!rawName) return;
            hostLookup.set(rawName, it);
            const normalized = normalizeHostInterfaceName(rawName);
            if (normalized && normalized !== rawName) {
                hostLookup.set(normalized, it);
            }
        });
    const getBridgeName = (iface) => {
        const direct = iface.bridge || iface.proxmox_bridge;
        if (direct) return String(direct).trim();
        const prox = iface.proxmox && typeof iface.proxmox === 'object' ? iface.proxmox : null;
        if (prox) {
            if (prox.bridge) return String(prox.bridge).trim();
            if (prox.raw && typeof prox.raw === 'object' && prox.raw.bridge) return String(prox.raw.bridge).trim();
        }
        return '';
    };
    const isVmbr0Bridge = (iface) => getBridgeName(iface).toLowerCase() === 'vmbr0';
    const describeIface = (iface) => {
        if (!iface || typeof iface !== 'object') return '';
        const parts = [];
        if (Array.isArray(iface.ipv4) && iface.ipv4.length) {
            parts.push(iface.ipv4.filter(Boolean).join(', '));
        }
        if ((!parts.length) && Array.isArray(iface.ipv6) && iface.ipv6.length) {
            parts.push(iface.ipv6.filter(Boolean)[0]);
        }
        if (iface.mac) parts.push(`MAC ${iface.mac}`);
        if (iface.mtu) parts.push(`MTU ${iface.mtu}`);
        if (iface.speed) parts.push(`${iface.speed} Mbps`);
        const bridgeName = getBridgeName(iface);
        if (bridgeName) parts.push(`Bridge ${bridgeName}`);
        if (iface.proxmox && typeof iface.proxmox === 'object') {
            const prox = iface.proxmox;
            const proxBits = [];
            const vmName = prox.vm_name || prox.raw?.vm_name || prox.raw?.name;
            const vmNode = prox.vm_node || prox.raw?.node;
            const ifaceId = prox.id || prox.raw?.id || prox.raw?.interface_id;
            if (vmName) proxBits.push(`${vmName}`);
            if (vmNode) proxBits.push(`node ${vmNode}`);
            if (ifaceId) proxBits.push(`iface ${ifaceId}`);
            if (prox.macaddr && prox.macaddr !== iface.mac) proxBits.push(prox.macaddr);
            if (prox.bridge) proxBits.push(`bridge ${prox.bridge}`);
            if (prox.model) proxBits.push(prox.model);
            if (proxBits.length) {
                parts.push(`Proxmox ${proxBits.join(' • ')}`);
            } else {
                parts.push('Proxmox mapping detected');
            }
        }
        return parts.join(' • ');
    };
    const normalizeVmInterfaceId = (vmIface) => {
        if (!vmIface || typeof vmIface !== 'object') return '';
        const rawId = vmIface.id ?? vmIface.interface_id ?? vmIface.name ?? '';
        return rawId ? String(rawId).trim() : '';
    };
    const isPhysicalVmInterface = (vmIface) => {
        if (!vmIface || typeof vmIface !== 'object') return false;
        const id = normalizeVmInterfaceId(vmIface);
        if (!id) return false;
        const bridge = (vmIface.bridge ?? '').toString().trim();
        if (!bridge) return false;
        if (bridge.toLowerCase() === 'vmbr0') return false;
        return true;
    };
    const getPhysicalVmInterfaces = (vm) => {
        if (!vm || typeof vm !== 'object') return [];
        const interfaces = Array.isArray(vm.interfaces) ? vm.interfaces : [];
        return interfaces.filter(isPhysicalVmInterface);
    };
    const describeVmInterface = (vmIface) => {
        if (!vmIface || typeof vmIface !== 'object') return '';
        const parts = [];
        const bridge = (vmIface.bridge ?? '').toString().trim();
        const macaddr = (vmIface.macaddr ?? '').toString().trim();
        const model = (vmIface.model ?? '').toString().trim();
        if (bridge) parts.push(`bridge ${bridge}`);
        if (macaddr) parts.push(macaddr);
        if (model) parts.push(model);
        return parts.join(' • ');
    };
    if (typeof window !== 'undefined') {
        window.getPhysicalVmInterfaces = getPhysicalVmInterfaces;
        window.describeVmInterface = describeVmInterface;
        window.normalizeVmInterfaceId = normalizeVmInterfaceId;
    }
    const summarizePhysicalVmInterfaces = (vm) => {
        const physical = getPhysicalVmInterfaces(vm);
        if (!physical.length) return '';
        const entries = physical.map(vmIface => {
            const ifaceId = normalizeVmInterfaceId(vmIface) || '(unknown)';
            const desc = describeVmInterface(vmIface);
            return desc ? `${ifaceId} (${desc})` : ifaceId;
        });
        return entries.join(', ');
    };
    const hitlInterfaces = Array.isArray(hitl.interfaces) ? hitl.interfaces : [];
    const hasHitlInterfaces = hitlInterfaces.length > 0;
    const hitlToggleWasEnabled = !!hitl.enabled;
    const extSelections = hitlInterfaces.filter(iface => iface?.external_vm && (iface.external_vm.vm_key || iface.external_vm.vmid || iface.external_vm.vm_name)).length;
    const extSelectionsWithIface = hitlInterfaces.filter(iface => iface?.external_vm && (iface.external_vm.vm_key || iface.external_vm.vmid || iface.external_vm.vm_name) && iface.external_vm.interface_id).length;
    const step3EnabledForVerify = hitlToggleWasEnabled && hitlAuthReady;
    const hitlBridgeVerifyReady = !!(
        hitlAuthReady
        && step3EnabledForVerify
        && hitlInterfaces.length > 0
        && proxValidated
        && !proxInventoryBusy
        && !proxInventoryError
        && extSelections > 0
        && extSelectionsWithIface > 0
    );

    // Scenario-name card summary (tabular, separated per button).
    try {
        const coreSummaryEl = document.getElementById('scenarioNameCoreSummary');
        const hitlSummaryEl = document.getElementById('scenarioNameHitlSummary');
        const sectionEl = document.getElementById('scenarioNameHitlSection');
        const badgeEl = document.getElementById('scenarioNameHitlStatusBadge');
        const builderStatusEl = document.getElementById('scenarioNameBuilderSetupStatus');
        const clearStatusClasses = () => {
            if (badgeEl) badgeEl.classList.remove('text-bg-secondary', 'text-bg-info', 'text-bg-warning', 'text-bg-success');
            if (sectionEl) sectionEl.classList.remove('border-secondary', 'border-info', 'border-warning', 'border-success');
        };

        // Builder view intentionally omits the collapsible detail table.
        // Still compute and render status into the badge + builderStatusEl.
        if ((coreSummaryEl && hitlSummaryEl) || (IS_BUILDER_VIEW && builderStatusEl)) {
            const coreTouched = !!(coreVmKey || coreHost || coreUser || coreSecretId || hasProxmox || proxHasSecret);
            const hitlTouched = !!(participantProxmoxUrlHasValue || hitlToggleWasEnabled || hasHitlInterfaces || extSelections);
            const anyTouched = coreTouched || hitlTouched;

            const coreConfigured = !!(hasProxmox || proxHasSecret || coreVmKey || coreHost || coreUser || coreHasSecret);
            const coreValidated = IS_BUILDER_VIEW
                ? !!(proxValidated && coreHasSecret && coreVmKey)
                : !!(proxValidated && coreTestMatches);
            const hitlConfigured = !!(participantProxmoxUrlHasValue || hasHitlInterfaces || extSelections || hitlToggleWasEnabled);
            const hitlEnabled = !!hitlToggleWasEnabled;
            const hitlStep4Applied = !!((core.internal_bridge || '').toString().trim());

            const getVmKeyFromParts = (node, vmid) => {
                const n = (node ?? '').toString().trim();
                const v = (vmid ?? '').toString().trim();
                if (!n || !v) return '';
                return `${n}::${v}`;
            };
            const findVmInInventory = (vmKey) => {
                if (!vmKey) return null;
                return proxInventory.find(vm => `${vm?.node ?? ''}::${vm?.vmid ?? ''}` === vmKey) || null;
            };
            const resolveInterfaceBridge = (vm, ifaceIdRaw) => {
                if (!vm || !ifaceIdRaw) return '';
                const ifaceId = (ifaceIdRaw ?? '').toString().trim();
                if (!ifaceId) return '';
                const ifaces = Array.isArray(vm.interfaces) ? vm.interfaces : [];
                const match = ifaces.find((it) => {
                    const id = (it?.id ?? it?.interface_id ?? it?.iface ?? it?.name ?? '').toString().trim();
                    return id === ifaceId;
                }) || null;
                const bridge = (match?.bridge ?? match?.interface_bridge ?? match?.proxmox_bridge ?? match?.raw?.bridge ?? '').toString().trim();
                return bridge;
            };

            const coreVmForBridge = findVmInInventory(coreVmKey);
            // Step 4 only requires configuring at least one participant attachment (VM + interface).
            // Do not require *every* HITL interface to be mapped to an external VM.
            // If the user picked an external VM for any interface, require the external interface id as well.
            const hitlMappingsSufficient = !!(
                hitlEnabled
                && hasHitlInterfaces
                && extSelectionsWithIface > 0
                && extSelectionsWithIface === extSelections
            );

            const bridgePairs = hitlInterfaces
                .map((iface) => {
                    const proxTarget = (iface && iface.proxmox_target && typeof iface.proxmox_target === 'object') ? iface.proxmox_target : null;
                    const ext = (iface && iface.external_vm && typeof iface.external_vm === 'object') ? iface.external_vm : null;
                    const coreIfaceId = (proxTarget?.interface_id ?? '').toString().trim();
                    const extIfaceId = (ext?.interface_id ?? '').toString().trim();

                    // Builder view may not have access to live inventories; prefer persisted hints.
                    const coreBridgeHint = (iface?.core_bridge ?? iface?.bridge ?? '').toString().trim();

                    const coreBridgeStored = (proxTarget?.bridge ?? '').toString().trim();
                    const extBridgeStored = (ext?.interface_bridge ?? '').toString().trim();

                    const coreBridgeFromHostIface = (() => {
                        try {
                            const name = (iface?.name ?? '').toString().trim();
                            if (!name) return '';
                            const hostIface = hostLookup.get(name);
                            if (!hostIface) return '';
                            return (getBridgeName(hostIface) ?? '').toString().trim();
                        } catch (e) {
                            return '';
                        }
                    })();

                    const extVmKey = (ext?.vm_key ?? '').toString().trim() || getVmKeyFromParts(ext?.vm_node, ext?.vmid);
                    const extVmForBridge = findVmInInventory(extVmKey);

                    const coreBridge = coreBridgeHint || coreBridgeStored || coreBridgeFromHostIface || resolveInterfaceBridge(coreVmForBridge, coreIfaceId);
                    const extBridge = extBridgeStored || resolveInterfaceBridge(extVmForBridge, extIfaceId);

                    const name = (iface?.name ?? '').toString().trim();
                    return {
                        name,
                        coreIfaceId,
                        extIfaceId,
                        coreBridge,
                        extBridge,
                    };
                })
                .filter((row) => row.name || row.coreIfaceId || row.extIfaceId);

            const normalizeBridge = (b) => (b ?? '').toString().trim().toLowerCase();
            const hitlBridgesKnown = bridgePairs.length > 0 && bridgePairs.every(p => !!normalizeBridge(p.coreBridge) && !!normalizeBridge(p.extBridge));
            const hitlBridgesMatch = bridgePairs.length > 0 && bridgePairs.every(p => normalizeBridge(p.coreBridge) === normalizeBridge(p.extBridge));

            // "Ready" should reflect completion through Step 4. Step 5 (Participant UI URL) is optional.
            // Verification can succeed even if Step 4 wasn't "applied" (internal bridge not yet persisted).
            // Also, users may verify before running the CORE connection "Test".
            // Only block Ready if we can positively detect a mismatch.
            const hitlBridgeMismatchKnown = bridgePairs.length > 0 && bridgePairs.some(p => {
                const coreNorm = normalizeBridge(p.coreBridge);
                const extNorm = normalizeBridge(p.extBridge);
                return !!coreNorm && !!extNorm && coreNorm !== extNorm;
            });

            // Mirror Verify prerequisites rather than requiring Apply/Test.
            const hitlSummaryPrereqsReady = !!(
                hitlAuthReady
                && hitlEnabled
                && coreVmSupportsHitl
                && proxValidated
                && !proxInventoryBusy
                && !proxInventoryError
                && hitlMappingsSufficient
            );
            let hitlReady = !!(hitlSummaryPrereqsReady && !hitlBridgeMismatchKnown);

            // Builder view: rely on admin-managed safe signals rather than strict per-interface
            // mapping completeness (builders may not have inventory details to satisfy it).
            if (IS_BUILDER_VIEW) {
                const builderCoreReady = !!(proxValidated && coreHasSecret && !!coreVmKey && coreVmSupportsHitl);
                const builderHitlReady = hitlEnabled
                    ? !!(builderCoreReady && hasHitlInterfaces)
                    : builderCoreReady;
                hitlReady = !!(builderHitlReady && !hitlBridgeMismatchKnown);
            }

            // Builder view: show a single status line, but DO NOT abort renderMain.
            if (IS_BUILDER_VIEW && builderStatusEl) {
                const label = hitlReady ? 'Ready' : 'Not yet Setup by Admin';
                builderStatusEl.textContent = label;
                clearStatusClasses();
                if (badgeEl) {
                    badgeEl.textContent = label;
                    badgeEl.classList.add(hitlReady ? 'text-bg-success' : 'text-bg-secondary');
                }
                if (sectionEl) sectionEl.classList.add(hitlReady ? 'border-success' : 'border-secondary');
            } else if (coreSummaryEl && hitlSummaryEl) {
                if (!anyTouched) {
                    coreSummaryEl.innerHTML = '<div class="text-muted">Not configured</div>';
                    hitlSummaryEl.innerHTML = '<div class="text-muted">Not configured</div>';
                    clearStatusClasses();
                    if (badgeEl) {
                        badgeEl.textContent = 'Not configured';
                        badgeEl.classList.add('text-bg-secondary');
                    }
                    if (sectionEl) sectionEl.classList.add('border-secondary');
                } else {
                // Make it obvious if configured/verified/ready.
                clearStatusClasses();
                if (hitlReady || (coreValidated && !hitlConfigured)) {
                    if (badgeEl) {
                        badgeEl.textContent = hitlReady ? 'Ready' : 'Verified';
                        badgeEl.classList.add('text-bg-success');
                    }
                    if (sectionEl) sectionEl.classList.add('border-success');
                } else if ((coreConfigured && !coreValidated) || (hitlEnabled && !hitlReady) || (hitlConfigured && !hitlReady)) {
                    if (badgeEl) {
                        badgeEl.textContent = 'Needs verification';
                        badgeEl.classList.add('text-bg-warning');
                    }
                    if (sectionEl) sectionEl.classList.add('border-warning');
                } else {
                    if (badgeEl) {
                        badgeEl.textContent = 'Configured';
                        badgeEl.classList.add('text-bg-info');
                    }
                    if (sectionEl) sectionEl.classList.add('border-info');
                }

                const esc = (value) => escapeHtml((value ?? '').toString());
                const htmlVal = (html) => ({ __html: String(html ?? '') });
                const isHtmlVal = (value) => {
                    return !!(value && typeof value === 'object' && Object.prototype.hasOwnProperty.call(value, '__html'));
                };
                const iconFor = (state) => {
                    switch (state) {
                        case 'ok':
                            return '<i class="bi bi-check-square-fill text-success"></i>';
                        case 'partial':
                            return '<i class="bi bi-dash-square-fill text-warning"></i>';
                        case 'no':
                        default:
                            return '<i class="bi bi-square text-muted"></i>';
                    }
                };
                const renderKvTable = (rows, emptyLabel = 'Not configured') => {
                    if (!rows || !rows.length) {
                        return `<div class="text-muted">${esc(emptyLabel)}</div>`;
                    }
                    const body = rows.map(([k, v, state]) => {
                        const icon = iconFor(state);
                        const key = (k ?? '').toString();
                        const isStatusRow = key === 'Status';
                        const vIsHtml = isHtmlVal(v);
                        let vEsc = vIsHtml ? (v.__html ?? '') : esc(v);
                        if (isStatusRow && !vIsHtml) {
                            // Emphasize key words in a safe way by applying replacements after escaping.
                            vEsc = vEsc
                                .replace(/\bReady\b/g, '<span class="fw-bold">Ready</span>')
                                .replace(/\bVerified\b/g, '<span class="fw-bold">Verified</span>');
                        }

                        return `<tr><th class="fw-semibold" style="width: 160px;">${esc(k)}</th><td class="text-body">${icon} <span>${vEsc}</span></td></tr>`;
                    }).join('');
                    return `<table class="table table-sm mb-0"><tbody>${body}</tbody></table>`;
                };

                const coreRows = [];
                const coreStatusLabel = coreValidated
                    ? (IS_BUILDER_VIEW ? 'Verified by admin' : 'Verified')
                    : (coreConfigured
                        ? (IS_BUILDER_VIEW ? 'Configured by admin' : 'Configured (not verified)')
                        : 'Not configured');
                coreRows.push(['Status', coreStatusLabel, coreValidated ? 'ok' : (coreConfigured ? 'partial' : 'no')]);

                // Proxmox details (URL + user + validated)
                const proxUrl = (proxmox?.url || '').toString().trim();
                const proxUser = (proxmox?.username || '').toString().trim();
                const proxPortDisplay = (proxmox?.port ?? proxPort);
                const proxUrlDisplay = proxUrl ? `${proxUrl}:${proxPortDisplay}` : 'Not set';
                coreRows.push(['Proxmox', proxUrlDisplay, proxUrl ? 'ok' : ((proxHasSecret || proxUser) ? 'partial' : 'no')]);
                if (IS_BUILDER_VIEW) {
                    const proxUserLabel = proxHasSecret
                        ? (proxValidated ? 'Not visible in builder view — Validated by admin' : 'Not visible in builder view — Managed by admin')
                        : 'Not visible in builder view';
                    coreRows.push(['Proxmox User', proxUserLabel, proxHasSecret ? (proxValidated ? 'ok' : 'partial') : 'no']);
                } else {
                    coreRows.push(['Proxmox User', proxUser ? `${proxUser} — ${proxValidated ? 'Validated' : 'Not validated'}` : 'Not set', proxUser ? (proxValidated ? 'ok' : 'partial') : 'no']);
                }

                const coreVmRowLabel = (coreVmName || coreVmKey)
                    ? (IS_BUILDER_VIEW ? 'Assigned by admin' : (coreVmName || 'Selected'))
                    : 'Not selected';
                coreRows.push(['CORE VM', coreVmRowLabel, (coreVmName || coreVmKey) ? 'ok' : 'no']);
                coreRows.push(['gRPC', coreHost ? `${coreHost}:${corePort}` : 'Not set', coreHost ? 'ok' : 'no']);
                if (IS_BUILDER_VIEW) {
                    const sshUserLabel = coreHasSecret
                        ? (coreValidated ? 'Not set in builder view — Verified by admin' : 'Not set in builder view — Managed by admin')
                        : 'Not set in builder view';
                    coreRows.push(['SSH User', sshUserLabel, coreHasSecret ? (coreValidated ? 'ok' : 'partial') : 'no']);
                } else {
                    coreRows.push(['SSH User', coreUser ? `${coreUser} — ${coreValidated ? 'Verified' : 'Not verified'}` : 'Not set', coreUser ? (coreValidated ? 'ok' : 'partial') : 'no']);
                }
                coreSummaryEl.innerHTML = renderKvTable(coreTouched ? coreRows : [], 'Not configured');

                const hitlRows = [];
                hitlRows.push(['Status', hitlReady ? 'Ready' : (hitlConfigured ? 'Configured (not ready)' : 'Not configured'), hitlReady ? 'ok' : (hitlConfigured ? 'partial' : 'no')]);
                hitlRows.push(['Enabled', hitlEnabled ? 'Yes' : 'No', hitlEnabled ? 'ok' : 'no']);
                const ifaceNames = hitlInterfaces
                    .map(iface => (iface && iface.name ? String(iface.name).trim() : ''))
                    .filter(Boolean);
                const ifaceNamesUnique = Array.from(new Set(ifaceNames));
                const ifaceValue = ifaceNamesUnique.length
                    ? `${ifaceNamesUnique.length}: ${ifaceNamesUnique.join(', ')}`
                    : '0';

                const coreBridgeNames = bridgePairs
                    .map(p => (p.coreBridge ?? '').toString().trim())
                    .filter(Boolean);
                const extBridgeNames = bridgePairs
                    .map(p => (p.extBridge ?? '').toString().trim())
                    .filter(Boolean);
                const coreBridgeNamesUnique = Array.from(new Set(coreBridgeNames));
                const extBridgeNamesUnique = Array.from(new Set(extBridgeNames));
                const coreBridgeValue = coreBridgeNamesUnique.length
                    ? `${coreBridgeNamesUnique.length}: ${coreBridgeNamesUnique.join(', ')}`
                    : 'Not set';
                const extBridgeValue = extBridgeNamesUnique.length
                    ? `${extBridgeNamesUnique.length}: ${extBridgeNamesUnique.join(', ')}`
                    : 'Not set';

                const bridgeRowHtml = (() => {
                    if (!bridgePairs.length) return '';
                    const blocks = bridgePairs
                        .map((p) => {
                            const coreName = (coreVmName || coreVmKey || 'CORE VM').toString().trim();
                            // CORE-side interface identifier should mirror "CORE VM Interfaces" (the HITL interface name).
                            const coreIf = ((p.name || p.coreIfaceId || '').toString().trim()) || '—';
                            const coreBridgeRaw = (p.coreBridge || '').toString().trim();

                            const mappedName = (() => {
                                const iface = hitlInterfaces.find(it => (it?.name ?? '').toString().trim() === (p.name ?? '').toString().trim());
                                const ext = (iface && iface.external_vm && typeof iface.external_vm === 'object') ? iface.external_vm : null;
                                const name = (ext?.vm_name ?? '').toString().trim();
                                const key = (ext?.vm_key ?? '').toString().trim();
                                const vmid = (ext?.vmid ?? '').toString().trim();
                                return name || key || (vmid ? `VM ${vmid}` : 'Mapped');
                            })();
                            const mappedIf = (p.extIfaceId || '').toString().trim() || '—';
                            const mappedBridgeRaw = (p.extBridge || '').toString().trim();

                            const coreBridgeNorm = (coreBridgeRaw || '').toLowerCase();
                            const mappedBridgeNorm = (mappedBridgeRaw || '').toLowerCase();
                            const matchKnown = !!(coreBridgeNorm && mappedBridgeNorm);
                            const bridgesMatch = matchKnown && coreBridgeNorm === mappedBridgeNorm;
                            const bridgeClass = bridgesMatch ? 'text-success' : 'text-danger';

                            const coreBridgeHtml = coreBridgeRaw
                                ? `<span class="fw-bold ${bridgeClass}">${esc(coreBridgeRaw)}</span>`
                                : `<span class="fw-bold text-danger">Not set</span>`;
                            const mappedBridgeHtml = mappedBridgeRaw
                                ? `<span class="fw-bold ${bridgeClass}">${esc(mappedBridgeRaw)}</span>`
                                : `<span class="fw-bold text-danger">Not set</span>`;

                            return `
                                <table class="table table-sm table-borderless mb-0">
                                    <thead>
                                        <tr class="text-muted" style="font-size: 0.85em;">
                                            <th style="width: 120px;"></th>
                                            <th style="width: 260px;">VM Name</th>
                                            <th style="width: 90px;">Ifx</th>
                                            <th>Bridge <span class="text-muted">(must match)</span></th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        <tr>
                                            <td class="text-muted">CORE VM</td>
                                            <td>${esc(coreName)}</td>
                                            <td>${esc(coreIf)}</td>
                                            <td>${coreBridgeHtml}</td>
                                        </tr>
                                        <tr>
                                            <td class="text-muted">Mapped VM</td>
                                            <td>${esc(mappedName)}</td>
                                            <td>${esc(mappedIf)}</td>
                                            <td>${mappedBridgeHtml}</td>
                                        </tr>
                                    </tbody>
                                </table>`;
                        })
                        .filter(Boolean);
                    return blocks.join('<div class="my-2"></div>');
                })();

                if (bridgeRowHtml) {
                    const allKnown = bridgePairs.length > 0 && bridgePairs.every(p => (p.coreBridge || '').toString().trim() && (p.extBridge || '').toString().trim());
                    const allMatch = bridgePairs.length > 0 && bridgePairs.every(p => (p.coreBridge || '').toString().trim().toLowerCase() === (p.extBridge || '').toString().trim().toLowerCase());
                    const rowState = allKnown ? (allMatch ? 'ok' : 'partial') : 'partial';
                    hitlRows.push(['Mapped Interfaces', htmlVal(bridgeRowHtml), rowState]);
                } else {
                    hitlRows.push(['Mapped Interfaces', 'Not set', (ifaceNamesUnique.length || extSelectionsWithIface) ? 'partial' : 'no']);
                }

                const mappedVmIfaceLabels = hitlInterfaces
                    .map(iface => {
                        const ext = iface && iface.external_vm && typeof iface.external_vm === 'object' ? iface.external_vm : null;
                        if (!ext) return '';
                        const ifaceId = (ext.interface_id ?? '').toString().trim();
                        if (!ifaceId) return '';
                        const name = (ext.vm_name ?? '').toString().trim();
                        const key = (ext.vm_key ?? '').toString().trim();
                        const vmid = (ext.vmid ?? '').toString().trim();
                        const vmLabel = name || key || (vmid ? `VM ${vmid}` : '');
                        return vmLabel ? `${vmLabel}: ${ifaceId}` : ifaceId;
                    })
                    .filter(Boolean);
                const mappedVmIfaceLabelsUnique = Array.from(new Set(mappedVmIfaceLabels));
                const mappedVmIfaceValue = mappedVmIfaceLabelsUnique.length
                    ? `${mappedVmIfaceLabelsUnique.length}: ${mappedVmIfaceLabelsUnique.join(', ')}`
                    : 'Not set';

                const participantUrlValue = participantProxmoxUrlHasValue
                    ? participantProxmoxUrlRaw
                    : 'Not set';
                hitlRows.push(['Participant UI', participantUrlValue, participantProxmoxUrlHasValue ? 'ok' : 'no']);
                hitlSummaryEl.innerHTML = renderKvTable(hitlTouched ? hitlRows : [], 'Not configured');
                }
            }
        }
    } catch (e) {}

    // Scenario-name Verify buttons gating.
    try {
        const coreVerifyBtn = document.getElementById('scenarioNameCoreVerifyBtn');
        if (coreVerifyBtn) {
            const coreVerifyReady = !!coreTestable;
            coreVerifyBtn.disabled = !coreVerifyReady;
            const coreHint = coreVerifyReady
                ? 'Verify Proxmox + CORE connection (Steps 1 & 2).'
                : (!proxValidated
                    ? 'Complete Step 1 (Validate Proxmox credentials) first.'
                    : (!coreVmKey
                        ? 'Complete Step 2 (Select CORE VM) first.'
                        : (!coreInputsComplete
                            ? 'Complete Step 2 connection details (gRPC/SSH host/ports, SSH user, password) first.'
                            : (!coreVmHasInterfaces
                                ? 'Selected CORE VM must expose at least one interface to verify.'
                                : 'Complete Steps 1 and 2 first.'))));
            coreVerifyBtn.setAttribute('title', coreHint);
        }
        const hitlVerifyBtn = document.getElementById('scenarioNameHitlVerifyBtn');
        if (hitlVerifyBtn) {
            hitlVerifyBtn.disabled = !hitlBridgeVerifyReady;
            const hitlHint = hitlBridgeVerifyReady
                ? 'Verify HITL bridge settings (Steps 3 & 4).'
                : (!hitlAuthReady
                    ? (describeConfigHitlGate({ proxValidated, coreHasSecret, coreVmKey }) || 'Complete Steps 1 and 2 first.')
                    : (!step3EnabledForVerify
                        ? 'Enable the Hardware in the Loop toggle (Step 3) first.'
                        : (!hitlInterfaces.length
                            ? 'Add at least one HITL interface (Step 3) first.'
                            : (proxInventoryBusy
                                ? 'Wait for the Proxmox inventory fetch to finish.'
                                : (proxInventoryError
                                    ? 'Resolve Proxmox inventory error before verifying.'
                                    : (extSelections <= 0
                                        ? 'Map at least one HITL interface to an external VM (Step 4) first.'
                                        : (extSelectionsWithIface <= 0
                                            ? 'Select an external VM interface (Step 4) first.'
                                            : 'Complete Steps 3 and 4 first.')))))));
            hitlVerifyBtn.setAttribute('title', hitlHint);
        }
    } catch (e) {}
    const selectedNames = new Set(hitlInterfaces.map(entry => (entry && entry.name ? entry.name : '')).filter(Boolean));
    const availableInterfaces = hostInterfaces.filter(iface => iface && !selectedNames.has(iface.name));
    const selectableInterfaces = availableInterfaces.filter(iface => iface && !isVmbr0Bridge(iface));
    const availableOptionsHtml = availableInterfaces.length
        ? availableInterfaces.map(iface => {
            const summary = describeIface(iface);
            const label = summary ? `${iface.name} — ${summary}` : iface.name;
            const disabled = isVmbr0Bridge(iface);
            const disabledAttr = disabled ? 'disabled data-hitl-bridge="vmbr0"' : '';
            const suffix = disabled ? ' (vmbr0 bridge)' : '';
            const title = disabled ? 'Interfaces on vmbr0 are reserved for the management bridge and cannot be selected for HITL.' : '';
            return `<option value="${escapeHtml(iface.name)}" ${disabledAttr} title="${escapeHtml(title)}">${escapeHtml(label + suffix)}</option>`;
        }).join('')
        : '<option disabled value="">All discovered interfaces selected</option>';
    const step3Enabled = hitlToggleWasEnabled && hitlAuthReady;
    const step3Disabled = !step3Enabled;
    // Step 5 should remain disabled until Step 3 is enabled and Step 4 has at least
    // one complete participant VM + interface selection.
    const step5Enabled = !!(
        step3Enabled
        && extSelectionsWithIface > 0
        && extSelectionsWithIface === extSelections
    );
    const step5Disabled = !step5Enabled;
    const step3ToggleDisabledAttr = hitlAuthReady ? '' : 'disabled';
    const step3ToggleTooltipAttr = hitlAuthReady ? '' : 'data-bs-toggle="tooltip" data-bs-title="Validate Steps 1 and 2 before enabling Hardware in the Loop."';
    const step3ToggleCheckedAttr = hitlToggleWasEnabled ? 'checked' : '';
    const attachmentControlsDisabledAttr = (coreReady && step3Enabled) ? '' : 'disabled';
    const interfaceNoticeText = (() => {
        if (!hitlAuthReady) {
            if (!proxValidated) return 'Validate Proxmox credentials (Step 1) to unlock HITL interface mappings.';
            if (!coreHasSecret) return 'Store CORE credentials (Step 2) to unlock HITL interface mappings.';
            if (!coreVmKey) return 'Select a CORE VM in Step 2 to unlock HITL interface mappings.';
            return 'Authenticate Steps 1 and 2 to manage HITL interface mappings.';
        }
        if (!hitlToggleWasEnabled) return 'Enable Hardware in the Loop to manage HITL interface mappings.';
        if (!coreVmKey) return 'Complete steps 1 and 2 to manage HITL interface mappings.';
        if (!coreVmHasInterfaces) {
            return 'Selected CORE VM must expose at least one interface before mapping HITL interfaces.';
        }
        if (!coreVmSupportsHitl) {
            return 'Selected CORE VM exposes only one interface. HITL cannot be used until a second interface is added.';
        }
        return 'Complete steps 1 and 2 to manage HITL interface mappings.';
    })();
    const interfaceNoticeClass = (() => {
        if (!hitlAuthReady) return 'alert-warning';
        if (!hitlToggleWasEnabled) return 'alert-info';
        if (!coreVmKey) return 'alert-info';
        if (!coreVmHasInterfaces) return 'alert-danger';
        if (!coreVmSupportsHitl) return 'alert-warning';
        return 'alert-info';
    })();
    const externalVmCandidates = proxInventory.filter(vm => {
        const vmKey = `${vm.node ?? ''}::${vm.vmid ?? ''}`;
        if (vmKey === coreVmKey) return false;
        if (!coreVmNode) return false;
        const vmNode = vm && vm.node !== undefined && vm.node !== null ? String(vm.node).trim() : '';
        return vmNode && vmNode === coreVmNode;
    });
    const step4BaseEnabled = step3Enabled && proxValidated && !!coreVmKey && hitlAuthReady;
    const step4HasCandidates = externalVmCandidates.length > 0;
    const step4Enabled = step4BaseEnabled && step4HasCandidates;
    const step4PrereqItems = [
        {
            ok: hitlAuthReady,
            label: hitlAuthReady ? 'Steps 1 and 2 authenticated' : 'Validate Proxmox (Step 1) and CORE credentials (Step 2)',
        },
        {
            ok: step3Enabled,
            label: step3Enabled ? 'Hardware in the Loop toggle is enabled' : 'Enable the Hardware in the Loop toggle in Step 3',
        },
        {
            ok: hasHitlInterfaces,
            label: hasHitlInterfaces ? 'At least one HITL interface selected in Step 3' : 'Add a HITL interface in Step 3',
        },
        {
            ok: proxValidated,
            label: proxValidated ? 'Proxmox credentials are validated' : 'Validate the Proxmox credentials (Step 1)',
        },
        {
            ok: !!coreVmKey,
            label: coreVmKey ? 'CORE VM selected in Step 2' : 'Select a CORE VM in Step 2',
        },
        {
            ok: !proxInventoryBusy,
            label: proxInventoryBusy ? 'Wait for the Proxmox inventory fetch to finish' : 'Proxmox inventory fetch complete',
        },
        {
            ok: !proxInventoryError,
            label: proxInventoryError ? `Resolve Proxmox inventory error: ${proxInventoryError}` : 'Proxmox inventory is available',
        },
    ];
    const step4BlockingItems = step4PrereqItems.filter(item => !item.ok);
    const step4PrereqList = step4BlockingItems.map(item => {
        const icon = '❌';
        const toneClass = 'text-danger';
        return `<li class="${toneClass}">${icon} ${escapeHtml(item.label)}</li>`;
    }).join('');
    const step4PrereqHtml = step4BlockingItems.length
        ? `<div class="alert alert-info small mt-2 mb-0"><div class="fw-semibold">Step 4 prerequisites</div><ul class="mb-0 ps-3" style="list-style: none;">${step4PrereqList}</ul></div>`
        : '';
    const availableSize = Math.min(8, Math.max(4, hostInterfaces.length || 4));
    const gateShouldHide = step3Enabled && coreReady && hitlAuthReady;
    const interfacesGateNotice = `<div class="alert ${interfaceNoticeClass} small mb-3 ${gateShouldHide ? 'd-none' : ''}" data-hitl-interface-gate="${activeIdx}">${interfaceNoticeText}</div>`;
    const allowStep3RefreshUi = !!hitlAuthReady;
    const interfacesRefreshBusyRaw = core.interfaces_refresh_inflight === true;
    const interfacesRefreshBusy = allowStep3RefreshUi ? interfacesRefreshBusyRaw : false;
    const lastInterfacesError = core.last_interfaces_error || '';
    const lastInterfacesAttempt = core.last_interfaces_attempt || '';
    const lastInterfacesRefresh = core.last_interfaces_refresh || '';
    const availableSelectDisabledAttr = (coreReady && step3Enabled) ? '' : 'disabled';
    const addInterfacesDisabledAttr = (coreReady && step3Enabled && availableInterfaces.length && !interfacesRefreshBusy) ? '' : 'disabled';
    const refreshInterfacesDisabledAttr = (step3Enabled && !interfacesRefreshBusy) ? '' : 'disabled';
    const removeInterfaceDisabledAttr = step3Enabled ? '' : 'disabled';
    const refreshButtonLabel = interfacesRefreshBusy
        ? '<span class="spinner-border spinner-border-sm me-2" role="status" aria-hidden="true"></span>Refreshing…'
        : 'Refresh list';
    const retryButtonLabel = interfacesRefreshBusy
        ? '<span class="spinner-border spinner-border-sm me-2" role="status" aria-hidden="true"></span>Refreshing…'
        : 'Refresh CORE VM Interfaces';
    const refreshStatusText = (() => {
        if (interfacesRefreshBusy) return 'Enumerating interfaces…';
        if (lastInterfacesRefresh) {
            const rel = describeTimestampRelative(lastInterfacesRefresh);
            const relSafe = rel ? escapeHtml(rel) : null;
            const exact = (() => {
                try { return escapeHtml(new Date(lastInterfacesRefresh).toLocaleString()); }
                catch (err) { return null; }
            })();
            const parts = [];
            if (relSafe) parts.push(`Last refreshed ${relSafe}`);
            if (!relSafe && exact) parts.push(`Last refreshed ${exact}`);
            if (relSafe && exact && relSafe !== exact) parts.push(`(${exact})`);
            if (!parts.length && exact) parts.push(`Last refreshed ${exact}`);
            if (!parts.length) parts.push('Interfaces cached from previous run.');
            const source = state.host_interfaces_source ? `Source: ${escapeHtml(String(state.host_interfaces_source))}` : '';
            if (source) parts.push(source);
            return parts.join(' • ');
        }
        if (lastInterfacesAttempt) {
            const rel = describeTimestampRelative(lastInterfacesAttempt);
            if (rel) return `Last attempt ${escapeHtml(rel)}`;
        }
        return '';
    })();
    const refreshStatusHtml = refreshStatusText ? `<div class="small text-muted mt-1" data-hitl-refresh-status="${activeIdx}">${refreshStatusText}</div>` : '';
    const interfacesEmptyMessage = (() => {
        if (!hitlAuthReady) {
            if (!proxValidated) return '<div class="alert alert-info mb-0">Validate Proxmox credentials in Step 1 to unlock HITL interfaces.</div>';
            if (!coreHasSecret) return '<div class="alert alert-info mb-0">Store CORE credentials in Step 2 to unlock HITL interfaces.</div>';
            if (!coreVmKey) return '<div class="alert alert-info mb-0">Select a CORE VM in Step 2 to unlock HITL interfaces.</div>';
        }
        if (interfacesRefreshBusy) {
            return '<div class="alert alert-info mb-0">Enumerating interfaces from CORE…</div>';
        }
        if (lastInterfacesError) {
            const rel = describeTimestampRelative(lastInterfacesAttempt);
            const detail = rel ? ` <span class="text-muted">(Last attempt ${escapeHtml(rel)})</span>` : '';
            return `<div class="alert alert-danger mb-0">${escapeHtml(lastInterfacesError)}${detail}</div>`;
        }
        if (lastInterfacesAttempt) {
            const rel = describeTimestampRelative(lastInterfacesAttempt);
            const label = rel ? ` ${escapeHtml(rel)}` : ' previously';
            return `<div class="alert alert-warning mb-0">No interfaces were reported during the last refresh${label}. Verify the CORE VM has multiple adapters and try again.</div>`;
        }
        return '<div class="alert alert-info mb-0">Refresh to load interfaces from the CORE VM.</div>';
    })();
    const externalVmRowsHtml = (() => {
        if (!hasHitlInterfaces || !step3Enabled || (Array.isArray(hostInterfaces) && hostInterfaces.length === 0)) {
            return '<div class="text-muted small">Complete Step 3 (enable HITL and add at least one interface) to configure external connectivity.</div>';
        }
        if (!externalVmCandidates.length) {
            if (!coreVmNode) {
                return '<div class="alert alert-warning small mb-0">Unable to determine the CORE VM\'s Proxmox node. Refresh the inventory so external VMs on the same node can be suggested.</div>';
            }
            const nodeHint = ` on node ${escapeHtml(coreVmNode)}`;
            return `<div class="alert alert-warning small mb-0">No eligible Proxmox VMs${nodeHint} detected that share the CORE VM's node. Refresh the inventory after provisioning additional VMs on the same node.</div>`;
        }
        return hitlInterfaces.map((iface, ifaceIdx) => {
            if (!iface || typeof iface !== 'object') return '';
            const safeName = escapeHtml(iface.name || `Interface ${ifaceIdx + 1}`);
            const selectedExternal = (iface.external_vm && typeof iface.external_vm === 'object') ? iface.external_vm : null;
            const selectedKey = selectedExternal?.vm_key ? String(selectedExternal.vm_key) : '';
            const vmOptionMarkup = externalVmCandidates
                .filter(vm => `${vm.node ?? ''}::${vm.vmid ?? ''}` !== coreVmKey)
                .map(vm => {
                    const vmKey = `${vm.node ?? ''}::${vm.vmid ?? ''}`;
                    const ifaceCount = getPhysicalVmInterfaces(vm).length;
                    const vmName = vm.name ? String(vm.name) : `VM ${vm.vmid}`;
                    const labelParts = [`${vmName} (${ifaceCount} interface${ifaceCount === 1 ? '' : 's'})`];
                    if (vm.node) labelParts.push(`node ${vm.node}`);
                    if (vm.status) labelParts.push(`status ${vm.status}`);
                    return {
                        key: vmKey,
                        label: labelParts.join(' — '),
                        ifaceCount,
                        selected: vmKey === selectedKey,
                    };
                })
                .sort((a, b) => {
                    if (b.ifaceCount !== a.ifaceCount) return b.ifaceCount - a.ifaceCount;
                    const nameA = a.label.toLowerCase();
                    const nameB = b.label.toLowerCase();
                    if (nameA < nameB) return -1;
                    if (nameA > nameB) return 1;
                    return 0;
                })
                .map(option => `<option value="${escapeHtml(option.key)}" ${option.selected ? 'selected' : ''}>${escapeHtml(option.label)}</option>`);
            const selectDisabledAttr = step4Enabled ? '' : 'disabled';
            const selectedVm = selectedKey ? proxInventory.find(vm => `${vm.node ?? ''}::${vm.vmid ?? ''}` === selectedKey) : null;
            const physicalInterfaces = selectedVm ? getPhysicalVmInterfaces(selectedVm) : [];
            const physicalInterfacesSummary = selectedVm ? summarizePhysicalVmInterfaces(selectedVm) : '';
            const selectedIfaceId = selectedExternal?.interface_id ? String(selectedExternal.interface_id).trim() : '';
            const interfaceOptionList = physicalInterfaces.map(vmIface => {
                const ifaceId = normalizeVmInterfaceId(vmIface);
                const desc = describeVmInterface(vmIface);
                const label = desc ? `${ifaceId} — ${desc}` : ifaceId;
                return `<option value="${escapeHtml(ifaceId)}" ${ifaceId === selectedIfaceId ? 'selected' : ''}>${escapeHtml(label)}</option>`;
            });
            if (selectedIfaceId && !physicalInterfaces.some(vmIface => normalizeVmInterfaceId(vmIface) === selectedIfaceId)) {
                interfaceOptionList.unshift(`<option value="${escapeHtml(selectedIfaceId)}" selected>${escapeHtml(`${selectedIfaceId} (not detected)`)}</option>`);
            }
            const interfaceOptionsMarkup = ['<option value="">Select interface…</option>', ...interfaceOptionList].join('');
            const interfaceSelectDisabledAttr = (step4BaseEnabled && !!selectedKey) ? '' : 'disabled';
            const refreshExternalInterfacesDisabledAttr = (step4BaseEnabled && !!selectedKey && !proxInventoryBusy) ? '' : 'disabled';
            const helperParts = [];
            if (selectedExternal?.vm_name) helperParts.push(String(selectedExternal.vm_name));
            if (selectedExternal?.vm_node) helperParts.push(`node ${selectedExternal.vm_node}`);
            if (selectedExternal?.vmid !== undefined && selectedExternal?.vmid !== null && selectedExternal.vmid !== '') {
                helperParts.push(`ID ${selectedExternal.vmid}`);
            }
            if (selectedExternal?.interface_id) helperParts.push(`iface ${selectedExternal.interface_id}`);
            const helperHtml = helperParts.length ? `<div class="form-text">Selected: ${escapeHtml(helperParts.join(' • '))}</div>` : '';
            const interfaceSummaryParts = [];
            if (selectedExternal?.interface_bridge) interfaceSummaryParts.push(`bridge ${selectedExternal.interface_bridge}`);
            if (selectedExternal?.interface_mac) interfaceSummaryParts.push(selectedExternal.interface_mac);
            if (selectedExternal?.interface_model) interfaceSummaryParts.push(selectedExternal.interface_model);
            const interfaceSummaryHtml = interfaceSummaryParts.length ? `<div class="form-text">${escapeHtml(interfaceSummaryParts.join(' • '))}</div>` : '';
            const availableInterfacesHint = physicalInterfacesSummary ? `<div class="form-text text-muted">Physical interfaces: ${escapeHtml(physicalInterfacesSummary)}</div>` : '';
            let interfaceFooterHtml = '';
            if (!selectedKey) {
                interfaceFooterHtml = '<div class="form-text text-muted">Select a VM to choose its interface.</div>';
            } else if (!physicalInterfaces.length) {
                interfaceFooterHtml = '<div class="alert alert-warning small mt-2 mb-0">No physical interfaces detected on this VM (bridged adapters only).</div>';
            } else if (!selectedIfaceId) {
                interfaceFooterHtml = '<div class="form-text text-muted">Select the interface that should connect through this HITL link.</div>';
            }
            return `
                <div class="border rounded p-2 mb-2">
                    <div class="fw-semibold mb-1">CORE VM IFX Mapping: ${safeName}</div>
                    <label class="form-label small mb-1" for="hitlExternalVm_${activeIdx}_${ifaceIdx}">Participant VM</label>
                    <select class="form-select form-select-sm" id="hitlExternalVm_${activeIdx}_${ifaceIdx}" data-hitl-external-vm-select data-scen-idx="${activeIdx}" data-iface-index="${ifaceIdx}" ${selectDisabledAttr}>
                        <option value="">Select VM…</option>
                        ${vmOptionMarkup.join('')}
                    </select>
                    ${helperHtml}
                    <label class="form-label small mb-1 mt-2" for="hitlExternalVmIface_${activeIdx}_${ifaceIdx}">VM Interface</label>
                    <select class="form-select form-select-sm" id="hitlExternalVmIface_${activeIdx}_${ifaceIdx}" data-hitl-external-vm-iface-select data-scen-idx="${activeIdx}" data-iface-index="${ifaceIdx}" ${interfaceSelectDisabledAttr}>
                        ${interfaceOptionsMarkup}
                    </select>
                    <div class="d-flex flex-wrap gap-2 mt-2">
                        <button type="button" class="btn btn-sm btn-outline-secondary" data-hitl-step4-refresh data-scen-idx="${activeIdx}" data-iface-index="${ifaceIdx}" ${refreshExternalInterfacesDisabledAttr}>Refresh interfaces</button>
                    </div>
                    ${availableInterfacesHint}
                    ${interfaceSummaryHtml}
                    ${interfaceFooterHtml}
                </div>`;
        }).join('');
    })();
    const step4Content = (() => {
        if (!hasHitlInterfaces) {
            return '<div class="alert alert-info small mb-0">Add at least one HITL interface in Step 3 to configure external connectivity.</div>' + step4PrereqHtml;
        }
        if (!hitl.enabled) {
            return '<div class="alert alert-info small mb-0">Enable Hardware in the Loop to configure external connectivity.</div>' + step4PrereqHtml;
        }
        if (!proxValidated) {
            return '<div class="alert alert-warning small mb-0">Validate Proxmox credentials to load eligible VMs.</div>' + step4PrereqHtml;
        }
        if (proxInventoryBusy) {
            return '<div class="small text-muted">Loading Proxmox VM inventory…</div>' + step4PrereqHtml;
        }
        if (proxInventoryError) {
            return `<div class="alert alert-danger small mb-0">${escapeHtml(proxInventoryError)}</div>` + step4PrereqHtml;
        }
        if (!coreVmKey) {
            return '<div class="alert alert-warning small mb-0">Select a CORE VM in Step 2 before configuring external connectivity.</div>' + step4PrereqHtml;
        }
        if (!step4HasCandidates) {
            return externalVmRowsHtml + step4PrereqHtml;
        }
        return externalVmRowsHtml + step4PrereqHtml;
    })();
    const selectedInterfacesHtml = (hitl.interfaces && hitl.interfaces.length)
        ? hitl.interfaces.map((iface, ifaceIdx) => {
            const safeName = escapeHtml(iface.name || 'interface');
            const hostInfo = hostLookup.get(iface.name);
            const proxMapping = hostInfo && typeof hostInfo.proxmox === 'object' ? hostInfo.proxmox : null;
            const summary = describeIface(hostInfo || iface);
            const missingBadge = hostInfo ? '' : '<span class="badge rounded-pill text-bg-warning">Not detected</span>';
            const vmbrBadge = isVmbr0Bridge(hostInfo || iface) ? '<span class="badge rounded-pill text-bg-warning">vmbr0</span>' : '';
            const proxBadge = (() => {
                if (!proxMapping) return '';
                const vmName = proxMapping.vm_name || proxMapping.raw?.vm_name || proxMapping.raw?.name || '';
                const ifaceId = proxMapping.id || proxMapping.raw?.id || proxMapping.raw?.interface_id || '';
                const node = proxMapping.vm_node || proxMapping.raw?.node || '';
                const labelParts = [];
                if (vmName) labelParts.push(vmName);
                if (ifaceId) labelParts.push(ifaceId);
                if (node) labelParts.push(`node ${node}`);
                if (!labelParts.length && proxMapping.macaddr) labelParts.push(proxMapping.macaddr);
                const badgeLabel = labelParts.length ? labelParts.join(' • ') : 'Proxmox match';
                return `<span class="badge rounded-pill text-bg-info">${escapeHtml(badgeLabel)}</span>`;
            })();
            const summaryHtml = summary ? escapeHtml(summary) : 'No address information available';
            const attachmentValue = normalizeHitlAttachment(iface.attachment);
            const attachmentLabel = escapeHtml(prettyHitlAttachment(attachmentValue));
            const optionsMarkup = HITL_ATTACHMENT_CHOICES
                .map(opt => `<option value="${opt.value}" ${opt.value === attachmentValue ? 'selected' : ''}>${escapeHtml(opt.label)}</option>`)
                .join('');
            return `<div class="border rounded p-2 mb-2 d-flex justify-content-between align-items-start gap-2 flex-wrap">
                        <div class="flex-grow-1">
                            <div class="fw-semibold d-flex align-items-center gap-2 flex-wrap">${safeName}${missingBadge}${vmbrBadge}${proxBadge}<span class="badge rounded-pill text-bg-secondary">${attachmentLabel}</span></div>
                            <div class="small text-muted">${summaryHtml}</div>
                            <div class="mt-2">
                                <label class="form-label small mb-1" for="hitlAttach_${activeIdx}_${ifaceIdx}">Attach to</label>
                                <select class="form-select form-select-sm" id="hitlAttach_${activeIdx}_${ifaceIdx}" data-hitl-attach data-scen-idx="${activeIdx}" data-iface-index="${ifaceIdx}" ${attachmentControlsDisabledAttr}>
                                    ${optionsMarkup}
                                </select>
                            </div>
                        </div>
                        <button type="button" class="btn btn-sm btn-outline-danger" data-hitl-remove data-scen-idx="${activeIdx}" data-iface="${safeName}" ${removeInterfaceDisabledAttr}>Remove</button>
                    </div>`;
        }).join('')
        : '<div class="text-muted small">No interfaces selected.</div>';
    const hitlInterfacesMarkup = hostInterfaces.length
        ? `
            ${interfacesGateNotice}
            <div class="row g-3">
                <div class="col-md-6">
                    <label class="form-label">Available interfaces</label>
                    <select class="form-select" multiple size="${availableSize}" data-hitl-available data-scen-idx="${activeIdx}" id="hitlAvailable_${activeIdx}" ${availableSelectDisabledAttr}>
                        ${availableOptionsHtml}
                    </select>
                    <div class="d-flex flex-wrap gap-2 mt-2">
                        <button type="button" class="btn btn-sm btn-outline-primary" data-hitl-add data-scen-idx="${activeIdx}" ${addInterfacesDisabledAttr}>Add selected</button>
                        <button type="button" class="btn btn-sm btn-outline-secondary" data-hitl-refresh data-scen-idx="${activeIdx}" ${refreshInterfacesDisabledAttr} ${interfacesRefreshBusy ? 'data-refresh-busy="1"' : ''}>${refreshButtonLabel}</button>
                    </div>
                    <div class="form-text">Use ⌘/Ctrl to multi-select before adding.</div>
                    ${refreshStatusHtml}
                    ${!hasHitlInterfaces ? '<div class="alert alert-info small mt-3 mb-0">Add at least one interface to enable CORE VM IFX mapping.</div>' : ''}
                </div>
                ${hasHitlInterfaces ? `
                <div class="col-md-6">
                    <label class="form-label">Selected interfaces</label>
                    <div id="hitlSelected_${activeIdx}">
                        ${selectedInterfacesHtml}
                    </div>
                </div>` : ''}
            </div>
        </div>
    </div>`
        : `
            ${interfacesGateNotice}
            ${interfacesEmptyMessage}
            <div class="d-flex flex-wrap gap-2 mt-3">
                <button type="button" class="btn btn-sm btn-outline-secondary" data-hitl-refresh data-scen-idx="${activeIdx}" ${refreshInterfacesDisabledAttr} ${interfacesRefreshBusy ? 'data-refresh-busy="1"' : ''}>${retryButtonLabel}</button>
            </div>
            ${refreshStatusHtml}`;

    let coreVmOptionsMarkup = '';
    if (proxInventory.length) {
        const optionList = proxInventory.map(vm => {
            const vmKey = `${vm.node ?? ''}::${vm.vmid ?? ''}`;
            const vmDisplayName = vm.name ? String(vm.name) : `VM ${vm.vmid}`;
            const ifaceCount = Array.isArray(vm.interfaces) ? vm.interfaces.length : 0;
            const parts = [vmDisplayName];
            if (vm.node) parts.push(`node ${vm.node}`);
            if (vm.status) parts.push(`status ${vm.status}`);
            if (vm.vmid !== undefined && vm.vmid !== null) parts.push(`ID ${vm.vmid}`);
            if (ifaceCount) parts.push(`${ifaceCount} interface${ifaceCount === 1 ? '' : 's'}`);
            return `<option value="${escapeHtml(vmKey)}" ${vmKey === coreVmKey ? 'selected' : ''}>${escapeHtml(parts.join(' — '))}</option>`;
        });
        coreVmOptionsMarkup = ['<option value="">Select VM…</option>', ...optionList].join('');
    } else if (coreVmKey) {
        const fallbackLabelParts = [];
        if (coreVmName) fallbackLabelParts.push(coreVmName);
        if (coreVmNode) fallbackLabelParts.push(`node ${coreVmNode}`);
        fallbackLabelParts.push('cached selection');
        const fallbackLabel = fallbackLabelParts.filter(Boolean).join(' — ');
        coreVmOptionsMarkup = [
            '<option value="">Select VM…</option>',
            `<option value="${escapeHtml(coreVmKey)}" selected>${escapeHtml(fallbackLabel)}</option>`
        ].join('');
    } else {
        coreVmOptionsMarkup = '<option value="">No VMs available (refresh list)</option>';
    }

    const coreVmDetailsHtml = (() => {
        if (!coreVmKey) {
            return '';
        }
        if (!resolvedCoreVm) {
            return '<div class="alert alert-info small mb-0">Previously selected CORE VM preserved. Refresh the VM list to view details.</div>';
        }
        const name = escapeHtml(resolvedCoreVm.name ? String(resolvedCoreVm.name) : (resolvedCoreVm.vmid ? `VM ${resolvedCoreVm.vmid}` : 'Selected VM'));
        const node = escapeHtml(resolvedCoreVm.node ? String(resolvedCoreVm.node) : (coreVmNode || '—'));
        const status = resolvedCoreVm.status ? escapeHtml(String(resolvedCoreVm.status)) : (resolvedCoreVm.cached ? 'cached' : null);
        const vmid = resolvedCoreVm.vmid !== undefined && resolvedCoreVm.vmid !== null && resolvedCoreVm.vmid !== ''
            ? escapeHtml(String(resolvedCoreVm.vmid))
            : (vmKeyIdPart ? escapeHtml(vmKeyIdPart) : '—');
        const ifaceCountValue = interfaceCountKnown ? (resolvedVmInterfaceCount || 0) : null;
        const ifaceInfo = ifaceCountValue === null
            ? 'Interfaces unknown. Refresh VM list to confirm.'
            : `${ifaceCountValue} interface${ifaceCountValue === 1 ? '' : 's'}`;
        const ifaceLabel = escapeHtml(ifaceInfo);
        const cachedBadge = resolvedCoreVm.cached ? '<span class="badge text-bg-warning text-uppercase">Cached</span>' : (status ? `<span class="badge text-bg-secondary text-uppercase">${status}</span>` : '');
        return `
            <div class="border rounded p-3 bg-light small">
                <div class="d-flex justify-content-between align-items-center mb-2">
                    <span class="fw-semibold">${name}</span>
                    ${cachedBadge}
                </div>
                <dl class="row mb-0">
                    <dt class="col-5 text-muted">Node</dt><dd class="col-7">${node || '—'}</dd>
                    <dt class="col-5 text-muted">VM ID</dt><dd class="col-7">${vmid}</dd>
                    <dt class="col-5 text-muted">Interfaces</dt><dd class="col-7">${ifaceLabel}</dd>
                </dl>
            </div>`;
    })();

    const coreStoredSummary = (core.stored_summary && typeof core.stored_summary === 'object') ? core.stored_summary : null;
    const coreStoredAtRaw = core.last_validated_at || (coreStoredSummary && coreStoredSummary.stored_at) || '';
    const testedAtDisplay = core.last_tested_at ? (() => {
        try { return new Date(core.last_tested_at).toLocaleString(); } catch (err) { return null; }
    })() : null;
    const storedAtDisplay = coreStoredAtRaw ? (() => {
        try { return new Date(coreStoredAtRaw).toLocaleString(); } catch (err) { return null; }
    })() : null;
    let coreStatusText = '';
    let coreStatusClass = 'text-muted';
    if (!proxValidated) {
        coreStatusText = 'Validate Proxmox credentials to choose a CORE VM.';
    } else if (!coreVmKey) {
        coreStatusText = 'Select a CORE VM to configure connection details.';
    } else if (!coreVmHasInterfaces) {
        const count = interfaceCountKnown ? (resolvedVmInterfaceCount || 0) : 0;
        coreStatusText = `Selected CORE VM exposes ${count} network interface${count === 1 ? '' : 's'}. Add at least one interface to enable CORE connectivity.`;
        coreStatusClass = 'text-danger';
    } else if (!coreInputsComplete) {
        coreStatusText = 'Use Configure Connection to enter gRPC and SSH details, including credentials.';
        coreStatusClass = 'text-warning';
    } else if (!coreVmSupportsHitl) {
        if (coreHitlBlocked) {
            const vmNote = coreVmName ? ` • ${coreVmName}` : '';
            const storedNote = storedAtDisplay ? ` • Credentials stored ${storedAtDisplay}` : '';
            coreStatusText = `CORE connection verified${testedAtDisplay ? ` • Last tested ${testedAtDisplay}` : ''}${vmNote}${storedNote}. Add a second interface before enabling HITL mappings in Step 3.`;
        } else {
            coreStatusText = 'Selected CORE VM exposes only one interface. Add a second interface before enabling HITL mappings in Step 3.';
        }
        coreStatusClass = 'text-warning';
    } else if (coreReady) {
        const storedNote = storedAtDisplay ? ` • Credentials stored ${storedAtDisplay}` : '';
        const vmNote = coreVmName ? ` • ${coreVmName}` : '';
        coreStatusText = `CORE connection verified${testedAtDisplay ? ` • Last tested ${testedAtDisplay}` : ''}${vmNote}${storedNote}`;
        coreStatusClass = 'text-success';
    } else if (coreHasSecret && coreTestSuccess) {
        coreStatusText = 'Stored CORE credentials available. Re-test if connection details changed.';
        coreStatusClass = 'text-warning';
    } else if (core.last_tested_status === 'failure') {
        coreStatusText = core.last_tested_message ? `Last test failed: ${core.last_tested_message}` : 'CORE connection test failed.';
        coreStatusClass = 'text-danger';
    } else if (core.last_tested_status === 'success') {
        coreStatusText = 'CORE connection test succeeded for a different endpoint. Update details or re-test.';
        coreStatusClass = 'text-warning';
    } else {
        coreStatusText = 'Test the CORE connection to continue.';
        coreStatusClass = 'text-warning';
    }
    const coreStatusHtml = escapeHtml(coreStatusText);
    const coreInputsDisabled = !(proxValidated && coreVmKey);
    const testBtnDisabledAttr = coreTestable ? '' : 'disabled';
    const configureBtnDisabledAttr = (!coreVmKey || !proxValidated || proxInventoryBusy) ? 'disabled' : '';
    const coreVmVerified = !!(core && core.validated === true && coreHasSecret && !!coreVmKey);
        const coreConnectionSummaryHtml = (() => {
            if (IS_BUILDER_VIEW) {
                const summaryBody = coreVmKey
                    ? '<div class="text-muted small">Connection configured by an administrator.</div>'
                    : '<div class="text-muted small">No CORE VM assigned yet.</div>';
                return `
                    <div class="border rounded p-3 bg-light-subtle">
                        <h6 class="text-uppercase small mb-2">Connection</h6>
                        ${summaryBody}
                    </div>`;
            }
            const summarizeEndpoint = () => {
                if (!coreVmKey) return '';
                const grpcLabel = coreHost ? `${escapeHtml(coreHost)}:${corePort}` : '<span class="text-danger">Not set</span>';
                const sshHostLabel = coreSshHost ? escapeHtml(coreSshHost) : '<span class="text-danger">Not set</span>';
                const sshPortLabel = coreSshPort ? String(coreSshPort) : '<span class="text-danger">Not set</span>';
                const sshUserLabel = coreUser ? escapeHtml(coreUser) : '<span class="text-danger">Not set</span>';
                const pwdLabel = coreHasSecret
                    ? '<span class="text-success">Stored securely</span>'
                    : (corePasswordRaw ? '<span class="text-success">Provided</span>' : '<span class="text-danger">Not set</span>');
                return `
                    <dl class="row small mb-0">
                        <dt class="col-5 text-muted">gRPC Endpoint</dt><dd class="col-7">${grpcLabel}</dd>
                        <dt class="col-5 text-muted">SSH Host</dt><dd class="col-7">${sshHostLabel}</dd>
                        <dt class="col-5 text-muted">SSH Port</dt><dd class="col-7">${sshPortLabel}</dd>
                        <dt class="col-5 text-muted">SSH Username</dt><dd class="col-7">${sshUserLabel}</dd>
                        <dt class="col-5 text-muted">Password</dt><dd class="col-7">${pwdLabel}</dd>
                    </dl>`;
            };
            return `
                <div class="border rounded p-3 bg-light-subtle">
                    <h6 class="text-uppercase small mb-2">Connection</h6>
                    ${summarizeEndpoint()}
                </div>`;
        })();

    const step1SectionHtml = `
        <div class="mb-4" data-hitl-step="1">
            <h6 class="mb-2">Step 1 — Proxmox Resource</h6>
            <div class="d-flex flex-wrap align-items-center justify-content-between gap-2">
                <div class="${proxSummaryClass} small" data-proxmox-summary="${activeIdx}">${proxSummaryHtml}</div>
                <div class="d-flex flex-wrap align-items-center gap-2">
                    <span class="badge rounded-pill text-bg-info" data-proxmox-refresh-badge="${activeIdx}" style="${proxInventoryBusy ? '' : 'display:none;'}">Refreshing vm list</span>
                    <button type="button" class="btn btn-sm btn-outline-primary" data-proxmox-assign data-scen-idx="${activeIdx}">${proxAssignLabel}</button>
                    <button type="button" class="btn btn-sm btn-outline-secondary" data-proxmox-refresh data-scen-idx="${activeIdx}" ${proxRefreshDisabledAttr}>Refresh VM List</button>
                    <button type="button" class="btn btn-sm btn-outline-danger" data-proxmox-clear data-scen-idx="${activeIdx}" ${proxHasAny ? '' : 'disabled'}>Clear Proxmox Resource</button>
                </div>
            </div>
            <div class="small text-muted mt-2" data-proxmox-inventory-status="${activeIdx}">${proxInventoryStatusHtml}</div>
        </div>`;
    const step2SectionHtml = (() => {
        if (IS_BUILDER_VIEW) {
            const builderNotice = '<div class="alert alert-secondary small mb-3">CORE VM selection and credentials are managed by an admin. Contact them to request changes.</div>';
            const vmSummary = coreVmKey
                ? '<div class="alert alert-info small mb-0">CORE VM assigned by an administrator.</div>'
                : '<div class="alert alert-info small mb-0">No CORE VM assigned yet.</div>';
            return `
                <div class="mb-4" data-hitl-step="2">
                    <h6 class="mb-2">Step 2 — CORE VM &amp; Credentials</h6>
                    ${builderNotice}
                    <div class="row g-3 align-items-start">
                        <div class="col-md-6">
                            ${vmSummary}
                        </div>
                        <div class="col-md-6">
                            <div data-hitl-core-connection="${activeIdx}">${coreConnectionSummaryHtml}</div>
                        </div>
                    </div>
                    <div class="small mt-2 ${coreStatusClass}" data-hitl-core-status="${activeIdx}">${coreStatusHtml}</div>
                </div>`;
        }
        return `
        <div class="mb-4" data-hitl-step="2">
            <div class="d-flex justify-content-between align-items-center gap-2 mb-2">
                <h6 class="m-0">Step 2 — CORE VM &amp; Credentials</h6>
                <button type="button" class="btn btn-sm btn-outline-secondary" data-hitl-core-clear data-scen-idx="${activeIdx}" ${(coreVmKey || coreHost || coreUser || coreHasSecret) ? '' : 'disabled'}>Clear CORE Settings</button>
            </div>
            ${!proxValidated
                ? '<div class="alert alert-warning small mb-0">Validate Proxmox credentials to unlock CORE VM selection.</div>'
                : proxInventoryBusy
                    ? '<div class="small text-muted">Loading Proxmox VM inventory…</div>'
                    : proxInventoryError
                        ? `<div class="alert alert-danger small mb-3">${escapeHtml(proxInventoryError)}</div>`
                        : ''}
            ${proxValidated && !proxInventoryBusy && !proxInventoryError
                ? `
                    <div class="row g-3 align-items-start">
                        <div class="col-md-6">
                            <label class="form-label small" for="hitlCoreVm_${activeIdx}">CORE VM</label>
                            <select class="form-select form-select-sm mt-1" id="hitlCoreVm_${activeIdx}" data-hitl-core-vm-select data-scen-idx="${activeIdx}" ${proxInventory.length && !proxInventoryBusy ? '' : 'disabled'}>
                                ${coreVmOptionsMarkup}
                            </select>
                            <button type="button" class="btn btn-sm btn-outline-primary mt-2" data-hitl-core-configure data-scen-idx="${activeIdx}" ${configureBtnDisabledAttr}>Configure Connection</button>
                            ${coreVmInterfaceWarning}
                        </div>
                        <div class="col-md-6">
                            <div data-hitl-core-summary="${activeIdx}">${coreVmDetailsHtml}</div>
                        </div>
                    </div>
                    <div class="mt-3" data-hitl-core-connection="${activeIdx}">${coreConnectionSummaryHtml}</div>
                    <div class="d-flex flex-wrap gap-2 mt-3">
                        <button type="button" class="btn btn-sm btn-outline-primary" data-hitl-core-test data-scen-idx="${activeIdx}" ${testBtnDisabledAttr}>Test CORE Connection</button>
                    </div>
                    <div class="small mt-2 ${coreStatusClass}" data-hitl-core-status="${activeIdx}">${coreStatusHtml}</div>
                ` : ''}
        </div>`;
    })();
    const step3SectionHtml = `
        <div class="mb-4" data-hitl-step="3">
            <div class="d-flex justify-content-between align-items-center gap-2 mb-2">
                <h6 class="m-0">Step 3 — Hardware in the Loop</h6>
                <div class="form-check form-switch m-0" ${step3ToggleTooltipAttr}>
                    <input class="form-check-input" type="checkbox" id="hitlToggle_${activeIdx}" data-hitl-toggle data-scen-idx="${activeIdx}" ${step3ToggleCheckedAttr} ${step3ToggleDisabledAttr}>
                    <label class="form-check-label small" for="hitlToggle_${activeIdx}">Enable</label>
                </div>
            </div>
            ${(!hitlAuthReady && hitlToggleWasEnabled) ? '<div class="alert alert-warning py-2 px-3 small mb-3">HITL remains disabled until Steps 1 and 2 are authenticated again.</div>' : ''}
            <fieldset class="hitl-step-fieldset ${step3Disabled ? 'hitl-step-disabled' : ''}" ${step3Disabled ? 'disabled' : ''} data-hitl-step3-body>
                ${hitlInterfacesMarkup}
            </fieldset>
        </div>`;
    const step4SectionHtml = `
        <div class="mb-4" data-hitl-step="4">
            <h6 class="mb-2">Step 4 — CTF Participant VM</h6>
            <div class="form-text mb-2">Choose a VM that will connect a participant to the scenario.</div>
            <fieldset class="hitl-step-fieldset ${step3Disabled ? 'hitl-step-disabled' : ''}" ${step3Disabled ? 'disabled' : ''} data-hitl-step4-body>
                ${step4Content}
            </fieldset>
            <div class="text-center small text-muted mt-2">▼ Step 5 below</div>
        </div>`;
    const participantUrlStatusClass = participantProxmoxUrlHasValue ? 'text-success' : 'text-muted';
    const participantUrlStatusText = participantProxmoxUrlHasValue
        ? PARTICIPANT_STATUS_SAVED_TEXT
        : PARTICIPANT_STATUS_EMPTY_TEXT;
    const part5SectionHtml = `
        <div data-hitl-part="5">
            <h6 class="mb-2">Step 5 — Participant UI (optional)</h6>
            <div class="form-text mb-3">Paste the Proxmox console or landing URL that participants should use. This adds the Participant UI navigation tab and links the HITL interface entry so facilitators and players open the same console.</div>
            <fieldset class="hitl-step-fieldset ${step5Disabled ? 'hitl-step-disabled' : ''}" ${step5Disabled ? 'disabled' : ''} data-hitl-step5-body>
                <div class="mb-3">
                    <label class="form-label small" for="participantProxmoxUrl_${activeIdx}">Participant UI URL</label>
                    <input type="url" class="form-control form-control-sm" id="participantProxmoxUrl_${activeIdx}" placeholder="https://proxmox.example.local" autocomplete="url" data-hitl-participant-url data-scen-idx="${activeIdx}" value="${participantProxmoxUrlHtml}">
                    <div class="form-text">Accepts HTTP or HTTPS targets, including console paths.</div>
                    <div class="form-text">The Apply button pins this URL to the editor and navigation tab, while Clear removes the Participant shortcut.</div>
                    <div class="small ${participantUrlStatusClass} mt-2" data-hitl-participant-status="${activeIdx}">${escapeHtml(participantUrlStatusText)}</div>
                </div>
                <div class="d-flex flex-wrap gap-2">
                    <button type="button" class="btn btn-sm btn-outline-primary" data-hitl-participant-apply data-scen-idx="${activeIdx}">Apply Participant URL</button>
                    <button type="button" class="btn btn-sm btn-outline-secondary" data-hitl-participant-clear data-scen-idx="${activeIdx}" ${participantProxmoxUrlHasValue ? '' : 'disabled'}>Clear Participant URL</button>
                </div>
                <div class="small text-muted mt-2" data-hitl-participant-feedback="${activeIdx}"></div>
            </fieldset>
        </div>`;
    const coreSectionsHtml = `${step1SectionHtml}${step2SectionHtml}`;
    const hitlSectionsHtml = `${step3SectionHtml}${step4SectionHtml}${part5SectionHtml}`;
    const coreCard = document.createElement('div');
    coreCard.id = 'scenarioHitlCoreCard';
    coreCard.className = 'card mb-3';
    coreCard.innerHTML = `<div class="card-body">${coreSectionsHtml}</div>`;
    const hitlCard = document.createElement('div');
    hitlCard.id = 'scenarioHitlConfigCard';
    hitlCard.className = 'card mb-3';
    hitlCard.innerHTML = `<div class="card-body">${hitlSectionsHtml}<div class="small text-muted mt-3" data-hitl-status="${activeIdx}"></div></div>`;
    const mountCardInto = (cardEl, containerId) => {
        const container = document.getElementById(containerId);
        if (container) {
            container.innerHTML = '';
            container.appendChild(cardEl);
        } else if (baseScenarioCard && baseScenarioCard.parentNode) {
            baseScenarioCard.parentNode.insertBefore(cardEl, baseScenarioCard);
        } else {
            root.appendChild(cardEl);
        }
    };
    mountCardInto(coreCard, 'coreVmSelectContainer');
    mountCardInto(hitlCard, 'externalIfxHitlContainer');

    if (typeof setupPreviewCollapsers === 'function') {
        setupPreviewCollapsers();
    }

    try { updateProxmoxSummary(activeIdx); } catch (err) { console.warn('Failed to refresh Proxmox summary', err); }

    toggleExternalIfxModalBusy(proxInventoryFetchInFlight.size > 0);

    updateHitlStatusForScenario(activeIdx);
    updateHitlEntryButtons({ coreVmVerified });
    // Prefer previously selected/available interfaces when Steps 1 and 2 are validated.
    // Only consider auto-refresh when explicitly enabled and no prior data exists.
    const shouldAutoRefreshHostIfx = HOST_INTERFACES_AUTO_REFRESH_ENABLED
        && !(hitlAuthReady && (hostInterfaces.length > 0 || hasHitlInterfaces));
    if (shouldAutoRefreshHostIfx) {
        scheduleAutoRefreshHostInterfaces(activeIdx);
    }

    const refreshCoreConnectionModal = (sidx) => {
        if (!coreConnectionModal) return;
        const scenario = state.scenarios?.[sidx];
        if (!scenario) return;
        const hitlState = ensureHitlStateForScenario(scenario);
        const proxState = hitlState.proxmox || {};
        const coreState = hitlState.core || (hitlState.core = {});
        const proxValidatedForScenario = !!(proxState.validated && proxState.secret_id);
        const hasVmSelection = !!coreState.vm_key;
        const builderLocked = !!IS_BUILDER_VIEW;
        const inputsDisabled = builderLocked || !(proxValidatedForScenario && hasVmSelection);
        const effectiveVenv = (coreState.venv_bin || '').trim() || CORE_DEFAULT_VENV_BIN;
        coreConnectionModal.setAttribute('data-scen-idx', String(sidx));
        if (coreConnectionForm) {
            coreConnectionForm.classList.remove('was-validated');
        }
        if (coreRememberInput) {
            coreRememberInput.checked = shouldRememberCore(hitlState);
            coreRememberInput.disabled = builderLocked || !proxValidatedForScenario;
        }
        if (coreAutoStartInput) {
            coreAutoStartInput.checked = !!(coreState.auto_start_daemon);
            coreAutoStartInput.disabled = builderLocked || inputsDisabled;
        }
        if (coreAdvFixDockerDaemonInput) {
            coreAdvFixDockerDaemonInput.checked = !!(coreState.adv_fix_docker_daemon);
            coreAdvFixDockerDaemonInput.disabled = builderLocked || inputsDisabled;
        }
        if (coreAdvRunCoreCleanupInput) {
            coreAdvRunCoreCleanupInput.checked = !!(coreState.adv_run_core_cleanup);
            coreAdvRunCoreCleanupInput.disabled = builderLocked || inputsDisabled;
        }
        if (coreAdvCheckCoreVersionInput) {
            coreAdvCheckCoreVersionInput.checked = !!(coreState.adv_check_core_version);
            coreAdvCheckCoreVersionInput.disabled = builderLocked || inputsDisabled;
        }
        if (coreAdvRestartCoreDaemonInput) {
            coreAdvRestartCoreDaemonInput.checked = !!(coreState.adv_restart_core_daemon);
            coreAdvRestartCoreDaemonInput.disabled = builderLocked || inputsDisabled;
        }
        if (coreAdvAutoKillSessionsInput) {
            coreAdvAutoKillSessionsInput.checked = !!(coreState.adv_auto_kill_sessions);
            coreAdvAutoKillSessionsInput.disabled = builderLocked || inputsDisabled;
        }
        if (coreModalInputs.grpc_host) {
            coreModalInputs.grpc_host.value = coreState.grpc_host || '';
            coreModalInputs.grpc_host.disabled = inputsDisabled;
            coreModalInputs.grpc_host.setAttribute('data-scen-idx', String(sidx));
        }
        if (coreModalInputs.grpc_port) {
            const port = Number.isFinite(Number(coreState.grpc_port)) && Number(coreState.grpc_port) > 0 ? Number(coreState.grpc_port) : 50051;
            coreModalInputs.grpc_port.value = port;
            coreModalInputs.grpc_port.disabled = inputsDisabled;
            coreModalInputs.grpc_port.setAttribute('data-scen-idx', String(sidx));
        }
        if (coreModalInputs.venv_bin) {
            coreModalInputs.venv_bin.value = effectiveVenv;
            coreModalInputs.venv_bin.disabled = inputsDisabled;
            coreModalInputs.venv_bin.setAttribute('data-scen-idx', String(sidx));
        }
        if (coreModalInputs.ssh_host) {
            coreModalInputs.ssh_host.value = coreState.ssh_host || '';
            coreModalInputs.ssh_host.disabled = inputsDisabled;
            coreModalInputs.ssh_host.setAttribute('data-scen-idx', String(sidx));
        }
        if (coreModalInputs.ssh_port) {
            const sshPort = Number.isFinite(Number(coreState.ssh_port)) && Number(coreState.ssh_port) > 0 ? Number(coreState.ssh_port) : 22;
            coreModalInputs.ssh_port.value = sshPort;
            coreModalInputs.ssh_port.disabled = inputsDisabled;
            coreModalInputs.ssh_port.setAttribute('data-scen-idx', String(sidx));
        }
        if (coreModalInputs.ssh_username) {
            coreModalInputs.ssh_username.value = coreState.ssh_username || '';
            coreModalInputs.ssh_username.disabled = inputsDisabled;
            coreModalInputs.ssh_username.setAttribute('data-scen-idx', String(sidx));
        }
        if (coreModalInputs.ssh_password) {
            const pwdVal = coreState.ssh_password || '';
            coreModalInputs.ssh_password.value = pwdVal;
            if (coreState.core_secret_id && !pwdVal) {
                coreModalInputs.ssh_password.setAttribute('placeholder', 'Stored securely');
            } else {
                coreModalInputs.ssh_password.removeAttribute('placeholder');
            }
            coreModalInputs.ssh_password.disabled = inputsDisabled;
            coreModalInputs.ssh_password.setAttribute('data-scen-idx', String(sidx));
        }
        resolveCoreVenvTestElements();
        setCoreVenvStatusDisplay(coreState.venv_test_status || null, coreState.venv_test_message || null);
        updateCoreVenvTestButtonState();
        if (coreConnectionSaveBtn) {
            coreConnectionSaveBtn.disabled = inputsDisabled;
            coreConnectionSaveBtn.classList.toggle('d-none', builderLocked);
        }
        if (typeof setCoreConnectionHint === 'function') {
            if (builderLocked) {
                setCoreConnectionHint('Builder view is read-only. Contact an admin to change CORE credentials.', 'info');
            } else if (!hasVmSelection) {
                setCoreConnectionHint('Select a CORE VM to configure connection details.', 'warning');
            } else if (!proxValidatedForScenario) {
                setCoreConnectionHint('Validate Proxmox credentials before editing CORE connection details.', 'warning');
            } else if (coreState.core_secret_id) {
                setCoreConnectionHint('Update SSH credentials to update stored secrets. Leave password blank to keep the existing vault record.', 'success');
            } else {
                setCoreConnectionHint('Provide gRPC host/port and SSH credentials. Passwords are stored securely after a successful test.', 'info');
            }
        }
    };

    window.refreshCoreConnectionModal = refreshCoreConnectionModal;

    refreshCoreConnectionModal(activeIdx);

    if (!IS_BUILDER_VIEW) {
        document.querySelectorAll('[data-hitl-core-configure]').forEach(btn => {
            btn.onclick = () => {
                const sidx = parseInt(btn.getAttribute('data-scen-idx'));
                if (isNaN(sidx) || !state.scenarios?.[sidx]) return;
                if (!coreConnectionModal || !window.bootstrap) {
                    console.warn('CORE connection modal unavailable');
                    return;
                }
                refreshCoreConnectionModal(sidx);
                const modalInstance = bootstrap.Modal.getInstance(coreConnectionModal) || new bootstrap.Modal(coreConnectionModal, { backdrop: true, keyboard: true });
                modalInstance.show();
                setTimeout(() => {
                    try {
                        const primaryInput = coreModalInputs.grpc_host && !coreModalInputs.grpc_host.disabled
                            ? coreModalInputs.grpc_host
                            : coreModalInputs.ssh_username;
                        primaryInput?.focus();
                        primaryInput?.select?.();
                    } catch (err) {}
                }, 150);
            };
        });
    }

    wireCoreConnectionSaveButton();
    wireCoreVenvTestButton();

    (function installCoreNavGuard(){
        if (IS_BUILDER_VIEW) {
            return;
        }
        const NAV_GUARD_DATA_KEY = 'coreNavGuardInstalled';
        const navLink = document.getElementById('navCoreLink');
        if (!navLink || navLink.dataset[NAV_GUARD_DATA_KEY] === '1') {
            return;
        }
        navLink.dataset[NAV_GUARD_DATA_KEY] = '1';
        const ensureModalHook = () => {
            resolveCoreModalReferences();
            const modal = coreConnectionModal;
            if (modal && !modal.dataset.coreNavAwaitResetHook) {
                modal.addEventListener('hidden.bs.modal', () => {
                    window._coreNavAwaitingValidation = null;
                });
                modal.dataset.coreNavAwaitResetHook = '1';
            }
        };
        const hasCoreVmSelection = () => {
            try {
                const { scenario } = getActiveScenarioContext();
                if (!scenario) return false;
                const hitlState = ensureHitlStateForScenario(scenario);
                const coreState = hitlState.core || {};
                const vmKey = (coreState.vm_key || '').toString().trim();
                return vmKey.length > 0;
            } catch (err) {
                return false;
            }
        };

        const hasVerifiedCoreConnection = () => {
            try {
                const { scenario } = getActiveScenarioContext();
                if (!scenario) return false;
                const hitlState = ensureHitlStateForScenario(scenario);
                const coreState = hitlState.core || {};
                const status = (coreState.last_tested_status || '').toString().trim().toLowerCase();
                return status === 'success';
            } catch (err) {
                return false;
            }
        };

        const openCoreNavBlockedModal = () => {
            const modalEl = document.getElementById('coreNavBlockedModal');
            if (modalEl && window.bootstrap) {
                const modalInstance = bootstrap.Modal.getInstance(modalEl)
                    || new bootstrap.Modal(modalEl, { backdrop: true, keyboard: true });
                modalInstance.show();
            }
        };
        const ensureValidationHook = () => {
            if (window.__coreNavValidationHookInstalled) {
                return;
            }
            const original = window.validateCoreConnection;
            if (typeof original !== 'function') {
                return;
            }
            window.validateCoreConnection = async function wrappedValidateCoreConnection(...args) {
                const result = await original.apply(this, args);
                if (result && result.ok && window._coreNavAwaitingValidation) {
                    const target = window._coreNavAwaitingValidation;
                    window._coreNavAwaitingValidation = null;
                    window.location.href = target;
                }
                return result;
            };
            window.__coreNavValidationHookInstalled = true;
        };
        const openModalForActiveScenario = () => {
            const ctx = getActiveScenarioContext();
            let scenarioIdx = Number.isInteger(ctx.idx) ? ctx.idx : null;
            if (!Number.isInteger(scenarioIdx) && Number.isInteger(activeIdx)) {
                scenarioIdx = activeIdx;
            }
            ensureModalHook();
            if (typeof refreshCoreConnectionModal === 'function' && Number.isInteger(scenarioIdx)) {
                refreshCoreConnectionModal(scenarioIdx);
            }
            if (coreConnectionModal && window.bootstrap) {
                const modalInstance = bootstrap.Modal.getInstance(coreConnectionModal) || new bootstrap.Modal(coreConnectionModal, { backdrop: true, keyboard: true });
                modalInstance.show();
                setTimeout(() => {
                    try {
                        const primaryInput = coreModalInputs.grpc_host && !coreModalInputs.grpc_host.disabled
                            ? coreModalInputs.grpc_host
                            : coreModalInputs.ssh_username;
                        primaryInput?.focus();
                        primaryInput?.select?.();
                    } catch (_) {}
                }, 150);
            }
        };
        navLink.addEventListener('click', (event) => {
            // The navbar click handler shows a global loading modal in capture phase.
            // If we block navigation here, explicitly hide it so the UI doesn't get trapped.
            try { if (typeof window.CORETG_HIDE_NAV_LOADING === 'function') window.CORETG_HIDE_NAV_LOADING(); } catch (_) {}

            if (!hasCoreVmSelection()) {
                event.preventDefault();
                // Persist any newly-created project state before opening the blocked dialog.
                try { if (typeof persistEditorState === 'function') persistEditorState(); } catch (_) {}
                try { if (typeof flushServerSnapshotPersistNow === 'function') flushServerSnapshotPersistNow(); } catch (_) {}
                openCoreNavBlockedModal();
                return;
            }

            if (hasVerifiedCoreConnection()) {
                return;
            }

            event.preventDefault();
            // Persist any newly-created project state before opening the validation flow.
            try { if (typeof persistEditorState === 'function') persistEditorState(); } catch (_) {}
            try { if (typeof flushServerSnapshotPersistNow === 'function') flushServerSnapshotPersistNow(); } catch (_) {}
            window._coreNavAwaitingValidation = navLink.href;
            ensureValidationHook();
            openModalForActiveScenario();
            if (typeof setCoreConnectionHint === 'function') {
                setCoreConnectionHint('Verify the CORE connection before opening the CORE page.', 'warning');
            }
        });
    })();

    // --- Host density normalization for Node Information ---
    try {
        const ni = scen.sections && scen.sections['Node Information'];
        if (ni) {
            ni.items = ni.items || [];
            // Ensure at least one weight row (Random) exists for fallback if all removed
            let randomRow = ni.items.find(it => !(it.v_metric==='Count') && (it.selected||'').toLowerCase()==='random');
            if (!randomRow) {
                // Add with temporary factor 0 (will be set if needed)
                ni.items.unshift({ selected:'Random', factor: 0.0 });
                randomRow = ni.items[0];
            }
            // Mark the first Random weight row as protected residual; unmark any other Random weight rows
            randomRow._protected_random = true;
            ni.items.forEach(it => {
                if (it !== randomRow && (it.v_metric !== 'Count') && ((it.selected||'').toLowerCase()==='random')) {
                    if (it._protected_random) delete it._protected_random;
                }
            });
            const weightRows = ni.items.filter(it => !(it.v_metric==='Count'));
            weightRows.forEach(it => { let f = parseFloat(it.factor); if (isNaN(f) || f < 0) f = 0; it.factor = f; });
            // Sum excluding Random for decision
            const nonRandom = weightRows.filter(it => (it.selected||'').toLowerCase()!=='random');
            let nonRandomSum = nonRandom.reduce((a,b)=> a + (parseFloat(b.factor)||0), 0);
            if (nonRandom.length === 0) {
                // Only Random exists; set to 1.0
                randomRow.factor = 1.0; nonRandomSum = 0;
            } else {
                if (nonRandomSum >= 1.0) {
                    randomRow.factor = 0.0; // others define full density
                } else {
                    randomRow.factor = 1.0 - nonRandomSum;
                }
            }
            // Final normalization (should already sum to 1.0)
            const finalSum = weightRows.reduce((a,b)=> a + (parseFloat(b.factor)||0), 0);
            if (Math.abs(finalSum - 1.0) > 1e-6 && finalSum > 0) {
                // scale all
                weightRows.forEach(it => { it.factor = (parseFloat(it.factor)||0)/finalSum; });
            }
        }
    } catch(e) { console.warn('Normalization error', e); }
    // No auto-insertion of Count rows for Node Information; totals should only include user-added Count rows
    // Scenario header with Count for Density (base host pool) restored
    const niSec = scen.sections['Node Information'] || { items: [] };
    const niItems = niSec.items || [];
    const niWeightRows = niItems.filter(it => (it.v_metric || (it.selected==='Specific'?'Count':'Weight')) === 'Weight');
    const niCountRows = niItems.filter(it => (it.v_metric || (it.selected==='Specific'?'Count':'Weight')) === 'Count');
    // Base removed: host total now purely additive Count rows when no base; or proportional part is implied but base count is scenario-level (not editable here)
    let densityCountVal = 10;
    try {
        if (scen.density_count !== undefined && scen.density_count !== null && scen.density_count !== '') {
            const parsed = parseInt(scen.density_count, 10);
            if (!isNaN(parsed)) densityCountVal = parsed;
        }
    } catch(e) { densityCountVal = 10; }
    densityCountVal = Math.max(DENSITY_COUNT_MIN, Math.min(DENSITY_COUNT_MAX, densityCountVal));
    scen.density_count = densityCountVal;
    const densityBounds = resolveDensityBoundsForScenario(scen);
    densityCountVal = applyDensityBoundsToScenario(scen, densityBounds) ?? densityCountVal;
    const densityMinEnabled = densityBounds.minEnabled;
    const densityMaxEnabled = densityBounds.maxEnabled;
    const densityMinDisplayValue = densityMinEnabled && typeof densityBounds.minValue === 'number' ? densityBounds.minValue : '';
    const densityMaxDisplayValue = densityMaxEnabled && typeof densityBounds.maxValue === 'number' ? densityBounds.maxValue : '';
    const niBase = densityCountVal;
    const niAdd = niCountRows.reduce((a,it)=> a + (parseInt(it.v_count,10)||0), 0);
    const niTotal = niBase + niAdd;
    const niTitle = 'Hosts = Base (Count for Density) allocated by weight rows + additive Count rows';
    // Build allocation breakdown tooltip for weight rows
    let allocTip = niTitle;
    if (niWeightRows.length) {
        const wTotal = niWeightRows.reduce((a,it)=> a + (parseFloat(it.factor)||0), 0) || 0;
        if (wTotal > 0) {
            const parts = niWeightRows.map(it => {
                const f = parseFloat(it.factor)||0;
                const pct = wTotal ? ((f / wTotal) * 100).toFixed(1) : '0.0';
                const label = (it.selected || 'Row');
                return `${label}:${f}(${pct}%)`;
            });
            allocTip += ' | Weights: ' + parts.join(', ');
        }
    }
    const hostBadgeClass = (niWeightRows.length && niBase === 0 && niAdd > 0) ? 'text-bg-warning' : 'text-bg-primary';
    // Simplified host summary: remove ΣW badge, allocation popover, and auto-scale functionality
    const hostSummaryHtml = `<span class=\"badge rounded-pill ${hostBadgeClass} host-total-badge ms-2\" data-bs-toggle=\"tooltip\" title=\"${allocTip.replace(/"/g,'&quot;')}\">Hosts: ${niWeightRows.length ? (niBase + ' + ' + niAdd + ' = ' + niTotal) : (niAdd)}</span>`;
    const densityBaseTip = 'Base host pool used only for weight-based density calculations; Count rows are additive beyond this.';
    const densityBaseTipEsc = densityBaseTip.replace(/"/g,'&quot;');
    const boundsRestrictionTip = IS_BUILDER_VIEW
        ? 'Restrictions set by the admin.'
        : 'Set optional Min/Max bounds to guide builder runs.';
    const densityBoundChipFragments = [];
    if (!IS_BUILDER_VIEW || densityMinEnabled) {
        densityBoundChipFragments.push(buildBoundChip({
            label: 'Min',
            baseField: 'scenario_density_min',
            enabled: !!densityMinEnabled,
            value: densityMinDisplayValue,
            controlsDisabled: false,
            min: DENSITY_COUNT_MIN,
            max: DENSITY_COUNT_MAX,
            step: 1,
            width: 110,
            scenarioIdx: activeIdx,
            placeholder: 'Min',
            tooltip: boundsRestrictionTip,
            readOnly: IS_BUILDER_VIEW,
        }));
    }
    if (!IS_BUILDER_VIEW || densityMaxEnabled) {
        densityBoundChipFragments.push(buildBoundChip({
            label: 'Max',
            baseField: 'scenario_density_max',
            enabled: !!densityMaxEnabled,
            value: densityMaxDisplayValue,
            controlsDisabled: false,
            min: DENSITY_COUNT_MIN,
            max: DENSITY_COUNT_MAX,
            step: 1,
            width: 110,
            scenarioIdx: activeIdx,
            placeholder: 'Max',
            tooltip: boundsRestrictionTip,
            readOnly: IS_BUILDER_VIEW,
        }));
    }
    const densityBoundsRow = densityBoundChipFragments.length
        ? `<div class="d-flex flex-wrap align-items-center gap-2">${densityBoundChipFragments.join('')}</div>`
        : '';
    const densityBaseHtml = `
        <div class=\"d-flex flex-wrap align-items-center gap-3\">
            <div class=\"d-flex align-items-center gap-1\">
                <label class=\"form-label mb-0\">Count for Density</label>
                <button type=\"button\" class=\"btn btn-link btn-sm p-0 text-muted\" tabindex=\"0\" data-bs-toggle=\"tooltip\" data-bs-placement=\"top\" data-bs-title=\"${densityBaseTipEsc}\">
                    <i class=\"bi bi-info-circle\"></i>
                </button>
                <input type=\"number\" min=\"${DENSITY_COUNT_MIN}\" max=\"${DENSITY_COUNT_MAX}\" step=\"1\" class=\"form-control form-control-sm\" style=\"width:120px\" value=\"${densityCountVal}\" data-scen-idx=\"${activeIdx}\" data-field=\"scenario_density_count\" />
            </div>
            ${densityBoundsRow}
        </div>`;
    const headerRow = document.createElement('div');
    const rawSectionNames = Object.keys(scen.sections || {});
    const filteredSectionNames = rawSectionNames.filter(name => name !== 'Notes' && name !== 'Events' && name !== 'HITL');
    const secNames = [];
    if (filteredSectionNames.includes('Node Information')) {
        secNames.push('Node Information');
    }
    filteredSectionNames.forEach(name => {
        if (name !== 'Node Information') {
            secNames.push(name);
        }
    });
    // Base host pool for density-driven (weight) allocations comes from scenario.density_count
    const baseHostPool = (scen.density_count !== undefined && scen.density_count !== null && scen.density_count !== '' ? (parseInt(scen.density_count,10)||0) : 10);
    secNames.forEach(name => {
        const sec = scen.sections[name] || { items: [] };
    const hasNodes = (name === 'Node Information');
        const itemCount = (sec.items || []).length;
        // Determine if any weight rows exist in this section (used for Node Information behavior)
        const hasWeightRowsPre = hasNodes ? ((sec.items || []).some(it => ((it.v_metric || (it.selected==='Specific'? 'Count' : 'Weight')) === 'Weight'))) : false;
        // Always ensure density has a sensible default value
        if (!hasNodes) {
            if (sec.density === undefined || sec.density === null || isNaN(sec.density)) {
                sec.density = 0.5;
            }
        }
        const densVal = sec.density;
        const nodesVal = '';
        const extraNodeCount = hasNodes ? ((sec.items || []).reduce((acc, it) => {
            const metric = it.v_metric || (it.selected==='Specific'?'Count':'Weight');
            return acc + (metric === 'Count' ? (parseInt(it.v_count) || 0) : 0);
        }, 0)) : 0;
    const hasWeightRows = hasNodes ? hasWeightRowsPre : false;
    const totalNodeCount = hasNodes ? (extraNodeCount + (hasWeightRowsPre ? niBase : 0)) : 0;
    const totalNodesLabel = hasNodes ? (totalNodeCount === 1 ? 'Total Node' : 'Total Nodes') : '';
    // Define totalPlanned (was previously referenced but never declared, causing a ReferenceError that prevented section rendering)
    const totalPlanned = hasNodes ? totalNodeCount : 0;
        // Improved initial collapse behavior:
        // - Always expand Node Information (primary planning surface)
        // - Other sections start collapsed only if empty
        let collapsed;
        if (name === 'Node Information') collapsed = false; else collapsed = (itemCount === 0);
        // Override with persisted state if present
        const collapseKey = `${activeIdx}::${name}`;
        if (collapseState.hasOwnProperty(collapseKey)) {
            collapsed = !!collapseState[collapseKey];
        }
        const card = document.createElement('div');
        card.className = 'card mb-3';
        const collapseId = `collapse-${name.replace(/\s+/g,'-')}`;
        const iconHtml = itemCount > 0
            ? `<i class='bi bi-collection-fill text-success' data-bs-toggle="tooltip" data-bs-title="${itemCount} item(s)"></i>`
            : `<i class='bi bi-collection text-muted' data-bs-toggle="tooltip" data-bs-title="No items"></i>`;
        // Enhanced tooltip text clarifying how combined total is derived.
        const totalNodesTooltip = hasNodes ? 'Combined total = (sum of all Count-based row counts) + (Total Nodes if any Weight-based rows exist). Weight rows allocate Total Nodes by their weights; Count rows are absolute and do not affect weights.' : '';
        // Compute planned badges (hosts / routers / vulns) for this section
        let hostBadge = '';
        if (name === 'Node Information') {
            const basePart = hasWeightRows ? niBase : 0;
            const additivePart = extraNodeCount;
            const totalPlannedHosts = basePart + additivePart;
            if (hasWeightRows || additivePart > 0) {
                const display = hasWeightRows ? `${basePart} + ${additivePart} = ${totalPlannedHosts}` : `${additivePart}`;
                hostBadge = `<span class=\"badge rounded-pill text-bg-primary ms-2 host-total-badge\" data-bs-toggle=\"tooltip\" title=\"${allocTip.replace(/"/g,'&quot;')}\">Hosts: ${display}</span>`;
            }
        }
        const hostSummaryBlock = (name === 'Node Information' && (niBase > 0 || niAdd > 0 || hasWeightRows))
            ? `<div class="d-flex align-items-center gap-2">${hostSummaryHtml}</div>`
            : '';
        const nodeMetaHtml = (name === 'Node Information')
            ? `<div class="d-flex flex-wrap align-items-center justify-content-between gap-3 mb-3">
                    ${densityBaseHtml}
                    ${hostSummaryBlock}
                </div>`
            : '';
        let routingBadge = '';
        if (name === 'Routing') {
            const rItems = sec.items || [];
            const rRows = rItems.map(it => ({ metric: (it.v_metric || 'Weight'), it }));
            const rCountRows = rRows.filter(r => r.metric === 'Count');
            const rWeightRows = rRows.filter(r => r.metric === 'Weight');
            const densR = (typeof sec.density === 'number') ? sec.density : 0;
            const explicit = rCountRows.reduce((a,r)=> a + (parseInt(r.it.v_count,10)||0), 0);
            let derived = 0;
            if (rWeightRows.length && densR > 0) {
                const frac = Math.max(0, Math.min(1, densR));
                derived = Math.round(baseHostPool * frac);
            }
            const total = explicit + derived;
            if (total > 0) routingBadge = `<span class=\"badge rounded-pill text-bg-secondary ms-2\" title=\"Routers planned additively: Count rows + (Density * Base Hosts). Density constrained 0..1.\">Routers: ${total}</span>`;
        }
        let vulnBadge = '';
        if (name === 'Vulnerabilities') {
            const vItems = sec.items || [];
            const vRows = vItems.map(it => ({ metric: (it.v_metric || (it.selected==='Specific'?'Count':'Weight')), it }));
            const vCountRows = vRows.filter(r => r.metric === 'Count');
            const vWeightRows = vRows.filter(r => r.metric === 'Weight');
            const densV = (typeof sec.density === 'number') ? sec.density : 0;
            const explicit = vCountRows.reduce((a,r)=> a + (parseInt(r.it.v_count,10)||0), 0);
            let derived = 0;
            if (vWeightRows.length && densV > 0) derived = Math.round(baseHostPool * Math.min(1, densV));
            const total = explicit + derived;
            if (total > 0) vulnBadge = `<span class=\"badge rounded-pill text-bg-info ms-2\" title=\"Vulnerability assignments additive: Count rows + (Density * Base Hosts). Density clipped to 1.0 when fractional.\">Vulns: ${total}</span>`;
        }
    const badgeSpan = hostBadge + routingBadge + vulnBadge;
        card.innerHTML = `
            <div class="card-header d-flex align-items-center gap-2">
                ${iconHtml}
                <strong>${name}</strong>${badgeSpan}
                <div class="ms-auto d-flex gap-2">
                    <button class="btn btn-sm btn-outline-primary" data-action="add-item" data-scen-idx="${activeIdx}" data-sec="${name}">Add</button>
                    <button class="btn btn-sm btn-outline-secondary" type="button" data-action="toggle-collapse" data-target="#${collapseId}">${collapsed ? 'Expand' : 'Collapse'}</button>
                </div>
            </div>
            <div id="${collapseId}" class="card-body" style="display:${collapsed ? 'none':'block'};">
                ${nodeMetaHtml}
                                <div class="table-responsive">
                                                                                <table class="table table-sm align-middle">
                                                                                        <thead>
                                                                                            <tr>
                                                                                                <th style="width:280px"></th>
                                                                                                <th></th>
                                                                                                <th style="width:160px"></th>
                                                                                                <th style="width:80px"></th>
                                                                                            </tr>
                                                                                        </thead>
                                                                    <tbody>
                                                                                ${(() => {
                                                                                const items = sec.items || [];
                                                                                const rowsByMetric = items.map((it, iidx) => ({ it, iidx, metric: (it.v_metric || (name==='Vulnerabilities' && (it.selected||'Category')==='Specific' ? 'Count' : 'Weight')) }));
                                                                                const weights = rowsByMetric.filter(x => x.metric === 'Weight');
                                                                                const counts = rowsByMetric.filter(x => x.metric === 'Count');
                                                                                // If there are no remaining weight rows but a stale total_nodes exists, clear it (frontend-only cleanup)
                                                                                if (name === 'Node Information' && weights.length === 0) {
                                                                                    const secRef = state.scenarios[activeIdx].sections[name];
                                                                                    if (secRef && secRef.total_nodes) { secRef.total_nodes = 0; }
                                                                                }
                                                                                const parts = [];
                                                                                const showWeightHeader = (weights.length > 0);
                                        if (showWeightHeader) {
                                                                                    const densCtrl = (
                                                                                        name === 'Node Information'
                                                                                            ? `<div class=\"d-flex align-items-center justify-content-end gap-2 small text-muted\"><span>Density</span><input disabled class=\"form-control form-control-sm\" style=\"width:80px\" value=\"1.0\"></div>`
                                                                                                : (name === 'Routing'
                                                                                                                                                                                                ? `<div class=\"d-flex align-items-center justify-content-end gap-2\">`
                                                                                                                                                                                                        + `<span>Density</span>`
                                                                                                                                                                                                        + `<input type=\"number\" step=\"0.01\" min=\"0\" max=\"1\" class=\"form-control form-control-sm\" style=\"width:120px\" placeholder=\"e.g., 0.25\" value=\"${densVal}\" data-scen-idx=\"${activeIdx}\" data-sec=\"${name}\" data-field=\"density\">`
                                                                                                                                                                                                    + `</div>`
                                                                                                                                                                                                : (() => {
                                                                                                                                                                                                    const tooltip = (name === 'Services')
                                                                                                                                                                                                        ? 'Services: per-item Count overrides density; assigns exactly that many hosts the selected service.'
                                                                                                                                                                                                        : (name === 'Traffic')
                                                                                                                                                                                                            ? 'Traffic: per-item Count overrides density; creates exactly that many sender/receiver pairs.'
                                                                                                                                                                                                            : (name === 'Segmentation')
                                                                                                                                                                                                                ? 'Segmentation: per-item Count overrides density; plans exactly that many slots (NAT prioritized).'
                                                                                                                                                                                                                : '';
                                                                                                                                                                                                    let info = '';
                                                                                                                                                                                                    // Density tooltip removed
                                                                                                                                                                                                    return '<div class="d-flex align-items-center justify-content-end gap-2">'
                                                                                                                                                                                                        + '<span>Density</span>'
                                                                                                                                                                                                        + info
                                                                                                                                                                                                        + '<input type="number" step="0.01" min="0" max="1" class="form-control form-control-sm" style="width:100px" value="' + densVal + '" data-scen-idx="' + activeIdx + '" data-sec="' + name + '" data-field="density">'
                                                                                                                                                                                                    + '</div>';
                                                                                                                                                                                                })()
                                                                                                                                                                                            )
                                                                                                                                                                        );
                                                                                    parts.push(`<tr class=\"table-light\"><td colspan=\"2\"><strong>Weight-based</strong></td><td class=\"text-end\">${densCtrl}</td><td></td></tr>`);
                                                                                    if (weights.length) { parts.push(weights.map(x => renderItemRow(activeIdx, name, x.iidx, x.it)).join('')); }
                                                                                }
                                                                                if (counts.length) {
                                                                                    const countHdr = 'Count-based';
                                                                                    const secRef = state.scenarios[activeIdx].sections[name];
                                                                                    const countBounds = resolveSectionCountBounds(secRef, counts);
                                                                                    const boundChipFragments = [];
                                                                                    if (!IS_BUILDER_VIEW || countBounds.minEnabled) {
                                                                                        boundChipFragments.push(buildBoundChip({
                                                                                            label: 'Min',
                                                                                            baseField: 'node_count_min',
                                                                                            enabled: !!countBounds.minEnabled,
                                                                                            value: countBounds.minValue,
                                                                                            controlsDisabled: !!countBounds.controlsDisabled,
                                                                                            min: NODE_COUNT_MIN,
                                                                                            max: NODE_COUNT_MAX,
                                                                                            step: 1,
                                                                                            width: 90,
                                                                                            scenarioIdx: activeIdx,
                                                                                            sectionName: name,
                                                                                            placeholder: 'Min',
                                                                                            tooltip: boundsRestrictionTip,
                                                                                            readOnly: IS_BUILDER_VIEW,
                                                                                        }));
                                                                                    }
                                                                                    if (!IS_BUILDER_VIEW || countBounds.maxEnabled) {
                                                                                        boundChipFragments.push(buildBoundChip({
                                                                                            label: 'Max',
                                                                                            baseField: 'node_count_max',
                                                                                            enabled: !!countBounds.maxEnabled,
                                                                                            value: countBounds.maxValue,
                                                                                            controlsDisabled: !!countBounds.controlsDisabled,
                                                                                            min: NODE_COUNT_MIN,
                                                                                            max: NODE_COUNT_MAX,
                                                                                            step: 1,
                                                                                            width: 90,
                                                                                            scenarioIdx: activeIdx,
                                                                                            sectionName: name,
                                                                                            placeholder: 'Max',
                                                                                            tooltip: boundsRestrictionTip,
                                                                                            readOnly: IS_BUILDER_VIEW,
                                                                                        }));
                                                                                    }
                                                                                    const boundsControls = boundChipFragments.length
                                                                                        ? `<div class="d-flex flex-wrap align-items-center gap-2 node-total-bounds-controls">${boundChipFragments.join('')}</div>`
                                                                                        : '';
                                                                                    const countHeaderHtml = `
                                                                                        <div class="d-flex flex-wrap align-items-center gap-2">
                                                                                            <strong>${countHdr}</strong>
                                                                                            ${boundsControls}
                                                                                        </div>`;

                                                                                    parts.push(`<tr class=\"table-light\"><td colspan=\"4\">${countHeaderHtml}</td></tr>`);
                                                                                    parts.push(counts.map(x => renderItemRow(activeIdx, name, x.iidx, x.it)).join(''));
                                                                                }
                                                                                return parts.join('');
                                                                            })()}
                                                                    </tbody>
                    </table>
                </div>
                                        <div class="text-danger small mt-1 section-warning" data-scen-idx="${activeIdx}" data-sec="${name}" style="display:none">Weights must sum to 1.000</div>
                                        ${name==='Routing' ? `
                                        <div id="routingEdgesWarnings" class="alert alert-warning py-2 px-3 small mt-3 d-none"></div>
                                        <div class="d-flex flex-wrap align-items-center gap-3 mt-3 small" id="routingEdgesSummary" style="display:none;">
                                                <div><strong>Policy:</strong> <span data-role="edges-policy">(pending)</span></div>
                                        </div>
                                        ` : ''}
            </div>`;
        root.appendChild(card);
    });
    // Apply visibility rule for H/S bounds after DOM built
    updateHsBoundsVisibility();
        // activate tooltips for icons
        if(window.bootstrap){
            const tts = root.querySelectorAll('[data-bs-toggle="tooltip"]');
            tts.forEach(el => new bootstrap.Tooltip(el));
        }

    // Notes card (collapsible, collapsed by default)
    const notesCard = document.createElement('div');
    notesCard.className = 'card mb-3';
    const hasNotes = (scen.notes||'').trim().length>0;
    const collapseId = `notesCollapse_${activeIdx}`;
    notesCard.innerHTML = `
        <div class="card-header d-flex justify-content-between align-items-center">
            <button class="btn btn-sm btn-link text-decoration-none p-0 d-flex align-items-center gap-2" type="button" data-bs-toggle="collapse" data-bs-target="#${collapseId}" aria-expanded="false" aria-controls="${collapseId}">
                <span class="me-1">Notes</span>
                <span id="notesIndicator_${activeIdx}" class="d-inline-flex align-items-center" data-bs-toggle="tooltip" data-bs-title="${hasNotes? 'Notes present':'No notes'}">
                    ${hasNotes ? `<i class='bi bi-journal-text text-success'></i>` : `<i class='bi bi-journal text-muted'></i>`}
                </span>
            </button>
            <small class="text-muted">optional</small>
        </div>
        <div id="${collapseId}" class="collapse">
            <div class="card-body p-2">
                <textarea class="form-control" rows="3" data-scen-idx="${activeIdx}" data-field="notes" placeholder="Add scenario notes (markdown supported)">${scen.notes || ''}</textarea>
            </div>
        </div>`;
    root.appendChild(notesCard);

    wireHandlers();
    // Populate dynamic vuln selects after DOM paint
    populateVulnSelects();
    // Hook up Specific picker buttons
    document.querySelectorAll('[data-action="pick-specific"]').forEach(btn => {
        const handler = () => {
            const sidx = parseInt(btn.getAttribute('data-scen-idx'));
            const sec = btn.getAttribute('data-sec');
            const iidx = parseInt(btn.getAttribute('data-item-idx'));
            openVulnPicker(sidx, sec, iidx);
        };
        // Attach the click handler (fix: previously not wired)
        btn.addEventListener('click', handler);
    });
}

function clampDensityCountValue(raw) {
    const parsed = parseInt(raw, 10);
    if (Number.isNaN(parsed)) return null;
    return Math.max(DENSITY_COUNT_MIN, Math.min(DENSITY_COUNT_MAX, parsed));
}

function resolveDensityBoundsForScenario(scen) {
    const result = {
        minEnabled: false,
        maxEnabled: false,
        minValue: null,
        maxValue: null,
    };
    if (!scen) {
        return result;
    }
    if (scen.density_count_min_enabled) {
        let minValue = clampDensityCountValue(scen.density_count_min);
        if (minValue === null) {
            minValue = clampDensityCountValue(scen.density_count);
        }
        if (minValue === null) {
            minValue = DENSITY_COUNT_MIN;
        }
        scen.density_count_min = minValue;
        result.minEnabled = true;
        result.minValue = minValue;
    }
    if (scen.density_count_max_enabled) {
        let maxValue = clampDensityCountValue(scen.density_count_max);
        if (maxValue === null) {
            maxValue = clampDensityCountValue(scen.density_count);
        }
        if (maxValue === null) {
            maxValue = DENSITY_COUNT_MAX;
        }
        scen.density_count_max = maxValue;
        result.maxEnabled = true;
        result.maxValue = maxValue;
    }
    if (result.minEnabled && result.maxEnabled && (result.minValue ?? 0) > (result.maxValue ?? 0)) {
        result.maxValue = result.minValue;
        scen.density_count_max = result.maxValue;
    }
    return result;
}

function applyDensityBoundsToScenario(scen, bounds) {
    if (!scen) return null;
    let countValue = clampDensityCountValue(scen.density_count);
    if (countValue === null) {
        countValue = DENSITY_COUNT_MIN;
    }
    if (bounds?.minEnabled && typeof bounds.minValue === 'number' && countValue < bounds.minValue) {
        countValue = bounds.minValue;
    }
    if (bounds?.maxEnabled && typeof bounds.maxValue === 'number' && countValue > bounds.maxValue) {
        countValue = bounds.maxValue;
    }
    scen.density_count = countValue;
    return countValue;
}

function enforceDensityBounds(idx) {
    if (Number.isNaN(idx) || !state.scenarios?.[idx]) return null;
    const scen = state.scenarios[idx];
    const bounds = resolveDensityBoundsForScenario(scen);
    return applyDensityBoundsToScenario(scen, bounds);
}

function refreshScenarioStateAfterCountEdit() {
    renderMain();
    const hidden = document.getElementById('scenarios_json');
    if (hidden) {
        hidden.value = JSON.stringify({ scenarios: state.scenarios, active_index: activeIdx });
    }
    persistEditorState();
    try { previewState.dirty = true; updatePlanButtons(); } catch (e) {}
}

function clampNodeCountValue(raw) {
    const parsed = parseInt(raw, 10);
    if (Number.isNaN(parsed)) return null;
    return Math.max(NODE_COUNT_MIN, Math.min(NODE_COUNT_MAX, parsed));
}

function buildBoundChip(options = {}) {
    const {
        label = '',
        baseField = '',
        enabled = false,
        value = null,
        controlsDisabled = false,
        min = null,
        max = null,
        step = 1,
        width = 90,
        scenarioIdx = null,
        sectionName = null,
        placeholder = '',
        tooltip = '',
        tooltipPlacement = 'top',
        readOnly = false,
    } = options;
    if (!baseField) return '';
    const enableField = `${baseField}_enabled`;
    const dataAttrs = [];
    if (Number.isInteger(scenarioIdx)) {
        dataAttrs.push(`data-scen-idx="${scenarioIdx}"`);
    }
    if (sectionName) {
        dataAttrs.push(`data-sec="${sectionName}"`);
    }
    const scopeAttrs = dataAttrs.length ? ` ${dataAttrs.join(' ')}` : '';
    const checkedAttr = enabled ? 'checked' : '';
    const isReadOnly = !!readOnly;
    const checkboxDisabled = (controlsDisabled || isReadOnly) ? 'disabled' : '';
    const inputDisabled = controlsDisabled ? 'disabled' : (!enabled ? 'disabled' : '');
    const readonlyAttr = (isReadOnly && !controlsDisabled && enabled) ? 'readonly' : '';
    const tabindexAttr = isReadOnly ? 'tabindex="-1"' : '';
    const numericValue = (typeof value === 'number' && !Number.isNaN(value)) ? value : '';
    const displayValue = (controlsDisabled || !enabled) ? '' : numericValue;
    const placeholderText = placeholder || label || '';
    const minAttr = (typeof min === 'number') ? `min="${min}"` : '';
    const maxAttr = (typeof max === 'number') ? `max="${max}"` : '';
    const stepAttr = (typeof step === 'number') ? `step="${step}"` : '';
    const tooltipAttr = tooltip ? ` data-bs-toggle="tooltip" data-bs-placement="${tooltipPlacement}" data-bs-title="${tooltip.replace(/"/g,'&quot;')}"` : '';
    return `
        <div class="node-bound-chip border border-secondary-subtle rounded-pill px-2 py-1 bg-body-tertiary d-flex align-items-center gap-2${controlsDisabled ? ' opacity-50' : ''}"${tooltipAttr}>
            <div class="form-check form-check-inline mb-0">
                <input class="form-check-input" type="checkbox" data-field="${enableField}"${scopeAttrs} ${checkedAttr} ${checkboxDisabled} />
                <label class="form-check-label small mb-0">${label}</label>
            </div>
            <input type="number" ${minAttr} ${maxAttr} ${stepAttr} class="form-control form-control-sm bg-transparent border-0 shadow-none" style="width:${width}px" value="${displayValue}" data-field="${baseField}"${scopeAttrs} ${inputDisabled} ${readonlyAttr} ${tabindexAttr} placeholder="${placeholderText}">
        </div>`;
}

function collectSectionCountRows(section) {
    if (!section || !Array.isArray(section.items)) return [];
    const rows = [];
    section.items.forEach((item, index) => {
        const metric = item && (item.v_metric || ((item.selected === 'Specific') ? 'Count' : 'Weight'));
        if (metric === 'Count') {
            rows.push({ item, index });
        }
    });
    return rows;
}

function prepareSectionCountRowRefs(section, seedRows) {
    if (Array.isArray(seedRows) && seedRows.length) {
        return seedRows
            .map(entry => {
                const item = entry.item || entry.it || entry;
                const idx = (typeof entry.index === 'number') ? entry.index : entry.iidx;
                if (!item || Number.isNaN(idx)) return null;
                const metric = item.v_metric || ((item.selected === 'Specific') ? 'Count' : 'Weight');
                if (metric !== 'Count') return null;
                return { item, index: idx };
            })
            .filter(Boolean);
    }
    return collectSectionCountRows(section);
}

function sumSectionCountRowValues(rowRefs) {
    if (!Array.isArray(rowRefs)) return 0;
    return rowRefs.reduce((acc, entry) => {
        const val = clampNodeCountValue(entry.item?.v_count);
        return acc + (val === null ? NODE_COUNT_MIN : val);
    }, 0);
}

function resolveSectionCountBounds(section, seedRows) {
    const rowRefs = prepareSectionCountRowRefs(section, seedRows);
    const rowCount = rowRefs.length;
    const minFeasible = rowCount * NODE_COUNT_MIN;
    const result = {
        minEnabled: false,
        maxEnabled: false,
        minValue: null,
        maxValue: null,
        rowCount,
        controlsDisabled: rowCount === 0,
    };
    if (!section || !rowCount) {
        return result;
    }
    const currentTotal = sumSectionCountRowValues(rowRefs);
    if (section.node_count_min_enabled) {
        let minValue = clampNodeCountValue(section.node_count_min);
        if (minValue === null) minValue = clampNodeCountValue(currentTotal);
        if (minValue === null) minValue = minFeasible || NODE_COUNT_MIN;
        if (minValue < minFeasible) minValue = minFeasible;
        section.node_count_min = minValue;
        result.minEnabled = true;
        result.minValue = minValue;
    }
    if (section.node_count_max_enabled) {
        let maxValue = clampNodeCountValue(section.node_count_max);
        if (maxValue === null) maxValue = clampNodeCountValue(currentTotal);
        if (maxValue === null) maxValue = Math.max(minFeasible, currentTotal || NODE_COUNT_MIN);
        if (result.minEnabled && maxValue < (result.minValue ?? minFeasible)) {
            maxValue = result.minValue;
        }
        if (maxValue < minFeasible) {
            maxValue = minFeasible;
        }
        section.node_count_max = maxValue;
        result.maxEnabled = true;
        result.maxValue = maxValue;
    }
    return result;
}

function orderSectionCountRows(rowRefs, preferredIdx) {
    if (!Array.isArray(rowRefs)) return [];
    const ordered = [];
    const preferred = (typeof preferredIdx === 'number') ? rowRefs.find(entry => entry.index === preferredIdx) : null;
    if (preferred) ordered.push(preferred);
    rowRefs.forEach(entry => {
        if (!ordered.includes(entry)) {
            ordered.push(entry);
        }
    });
    return ordered;
}

function increaseSectionCountRows(rowRefs, delta, preferredIdx) {
    if (!Array.isArray(rowRefs) || !rowRefs.length || delta <= 0) return false;
    const targetList = orderSectionCountRows(rowRefs, preferredIdx);
    const target = targetList[0];
    if (!target) return false;
    let current = clampNodeCountValue(target.item.v_count);
    if (current === null) current = NODE_COUNT_MIN;
    target.item.v_count = current + delta;
    return true;
}

function decreaseSectionCountRows(section, rowRefs, delta, preferredIdx) {
    if (!Array.isArray(rowRefs) || !rowRefs.length || delta <= 0) return false;
    let remaining = delta;
    let changed = false;
    const ordered = orderSectionCountRows(rowRefs, preferredIdx);
    ordered.forEach(entry => {
        if (remaining <= 0) return;
        let current = clampNodeCountValue(entry.item.v_count);
        if (current === null) current = NODE_COUNT_MIN;
        const reducible = Math.max(0, current - NODE_COUNT_MIN);
        if (reducible <= 0) return;
        const take = Math.min(reducible, remaining);
        entry.item.v_count = current - take;
        remaining -= take;
        changed = true;
    });
    if (remaining > 0 && section && section.node_count_max_enabled) {
        section.node_count_max = sumSectionCountRowValues(rowRefs);
    }
    return changed;
}

function enforceSectionCountBoundsForScenario(sidx, secName, preferredIdx = null) {
    if (Number.isNaN(sidx) || !state.scenarios?.[sidx] || !secName) return false;
    const scenario = state.scenarios[sidx];
    const section = scenario.sections?.[secName];
    if (!section) return false;
    const rowRefs = collectSectionCountRows(section);
    if (!rowRefs.length) return false;
    const bounds = resolveSectionCountBounds(section, rowRefs);
    let total = sumSectionCountRowValues(rowRefs);
    let changed = false;
    if (bounds.minEnabled && typeof bounds.minValue === 'number' && total < bounds.minValue) {
        const needed = bounds.minValue - total;
        if (needed > 0) {
            changed = increaseSectionCountRows(rowRefs, needed, preferredIdx) || changed;
            total = sumSectionCountRowValues(rowRefs);
        }
    }
    if (bounds.maxEnabled && typeof bounds.maxValue === 'number' && total > bounds.maxValue) {
        const excess = total - bounds.maxValue;
        if (excess > 0) {
            changed = decreaseSectionCountRows(section, rowRefs, excess, preferredIdx) || changed;
        }
    }
    return changed;
}

function updateHsBoundsVisibility(){
    try {
        document.querySelectorAll('[data-field="r2s_mode"]').forEach(selEl => {
            const modeVal = selEl.value;
            const wrapper = selEl.closest('.routing-edge-groups')?.querySelector('.hs-bounds-wrapper');
            if (wrapper) {
                if (modeVal === 'NonUniform') {
                    wrapper.classList.add('hs-show');
                } else {
                    wrapper.classList.remove('hs-show');
                }
            }
        });
    } catch(e) { /* ignore */ }
}

// renderSections was deprecated and removed; rendering is handled in renderMain()
function renderItemRow(sidx, secName, iidx, it) {
    // Build Selected options and current weight
    const weight = ((parseFloat(it.factor) || 0).toFixed(3));
    let opts = '';
    if (secName === 'Vulnerabilities') {
        const curRaw = it.selected || 'Category';
        const cur = (curRaw === 'Type/Vector') ? 'Category' : curRaw;
        const options = ['Category', 'Specific', 'Random'];
        opts = options.map(o => `<option ${o===cur?'selected':''}>${o}</option>`).join('');
    } else {
        const cur = it.selected || 'Random';
        // Per-section allowed options (excluding 'auto')
        let options = ['Random'];
        switch (secName) {
            case 'Node Information':
                options = ['Server', 'Workstation', 'PC', 'Docker', 'Random'];
                break;
            case 'Routing':
                options = ['RIP', 'RIPNG', 'BGP', 'OSPFv2', 'OSPFv3', 'Random'];
                break;
            case 'Services':
                options = ['SSH', 'HTTP', 'DHCPClient', 'Random'];
                break;
            case 'Traffic':
                options = ['Random', 'TCP', 'UDP', 'CUSTOM'];
                break;
            case 'Events':
                options = ['Script Path'];
                break;
            case 'Segmentation':
                options = ['Random', 'Firewall', 'NAT', 'CUSTOM'];
                break;
            default:
                options = ['Random'];
        }
        opts = options.map(o => `<option ${o===cur?'selected':''}>${o}</option>`).join('');
    }

    const extras = (() => {
        if (secName === 'Events') {
            return `<input class="form-control form-control-sm" placeholder="script path" value="${it.script_path || ''}" data-scen-idx="${sidx}" data-sec="${secName}" data-item-idx="${iidx}" data-field="script_path">`;
        }
        if (secName === 'Routing') {
            // Edges mode (Random/Min/Max/Exact). Random now acts like previous Auto (no extra links augmentation).
            const mode = it.r2r_mode || (it.r2r_edges !== undefined ? 'Exact' : 'Random');
            const val = (it.r2r_edges !== undefined && it.r2r_edges !== null) ? it.r2r_edges : '';
            const options = [
                {v:'Random', l:'Random'},
                {v:'Min', l:'Min'},
                {v:'Uniform', l:'Uniform'},
                {v:'Exact', l:'Exact'},
                {v:'NonUniform', l:'NonUniform'}
            ];
            const selHtml = `<select class="form-select form-select-sm routing-mode-select" style="width:105px" data-field="r2r_mode" data-scen-idx="${sidx}" data-sec="${secName}" data-item-idx="${iidx}">${options.map(o => `<option value="${o.v}" ${o.v===mode?'selected':''}>${o.l}</option>`).join('')}</select>`;
            // R-to-S (router to switch) connectivity policy (same option set)
            const r2sMode = it.r2s_mode || 'Random';
            const r2sVal = (it.r2s_edges !== undefined && it.r2s_edges !== null) ? it.r2s_edges : '';
            const r2sSel = `<select class="form-select form-select-sm routing-mode-select" style="width:105px" data-field="r2s_mode" data-scen-idx="${sidx}" data-sec="${secName}" data-item-idx="${iidx}">${options.map(o => `<option value="${o.v}" ${o.v===r2sMode?'selected':''}>${o.l}</option>`).join('')}</select>`;
            const r2sHostsMin = (it.r2s_hosts_min !== undefined && it.r2s_hosts_min !== null) ? it.r2s_hosts_min : 1;
            const r2sHostsMax = (it.r2s_hosts_max !== undefined && it.r2s_hosts_max !== null) ? it.r2s_hosts_max : 4;
            const showHsBounds = (r2sMode === 'NonUniform');
            return `
                <div class="d-flex flex-column gap-1 routing-edge-groups">
                    <div class="d-flex flex-wrap gap-2 align-items-center">
                        <label class="form-label mb-0 me-1" style="min-width:110px" title="Router-to-Router edge policy. Random = spanning tree; Min = chain; Uniform = balanced degrees; Exact = chain+augment to target; NonUniform = heterogeneous.">R-to-R Edges</label>
                        <div class="d-flex gap-3 align-items-end">
                            <div>${selHtml}</div>
                            <div class="edges-exact-input" style="display:${mode==='Exact'?'block':'none'};">
                                <input type="number" min="1" class="form-control form-control-sm edges-degree-input" style="width:110px" value="${val}" data-field="r2r_edges" data-scen-idx="${sidx}" data-sec="${secName}" data-item-idx="${iidx}" placeholder="Exact (e.g. 3)" aria-label="Exact router degree target" title="Target degree each router should attempt to reach (cannot reduce existing higher degrees).">
                            </div>
                        </div>
                    </div>
                    <div class="d-flex flex-wrap gap-2 align-items-center">
                        <label class="form-label mb-0 me-1" style="min-width:110px" title="Router-to-Switch attachment policy; controls how many distinct switches each router connects to.">R-to-S Edges</label>
                        <div class="d-flex gap-3 align-items-end flex-wrap align-items-center">
                            <div>${r2sSel}</div>
                            <div class="r2s-exact-input" style="display:${r2sMode==='Exact'?'block':'none'};">
                                <input type="number" min="1" class="form-control form-control-sm r2s-degree-input" style="width:110px" value="${r2sVal}" data-field="r2s_edges" data-scen-idx="${sidx}" data-sec="${secName}" data-item-idx="${iidx}" placeholder="Exact (e.g. 2)" aria-label="Exact router-to-switch target" title="Target number of switches per router (Exact mode).">
                            </div>
                            <div class="gap-2 align-items-end small hs-bounds-wrapper">
                                <div>
                                    <label class="form-label mb-0" style="font-size:0.7rem" title="Minimum hosts per created switch for this router row (preview & build).">H/S Min</label>
                                    <input type="number" min="1" max="32" class="form-control form-control-sm hs-min-input" style="width:70px" value="${r2sHostsMin}" data-field="r2s_hosts_min" data-scen-idx="${sidx}" data-sec="${secName}" data-item-idx="${iidx}" placeholder="min">
                                </div>
                                <div>
                                    <label class="form-label mb-0" style="font-size:0.7rem" title="Maximum hosts per created switch for this router row (preview & build).">H/S Max</label>
                                    <input type="number" min="1" max="64" class="form-control form-control-sm hs-max-input" style="width:70px" value="${r2sHostsMax}" data-field="r2s_hosts_max" data-scen-idx="${sidx}" data-sec="${secName}" data-item-idx="${iidx}" placeholder="max">
                                </div>
                            </div>
                        </div>
                    </div>
                </div>`;
        }
        if (secName === 'Traffic') {
            return `
                <div class="d-flex flex-wrap gap-2">
                    <div>
                        <label class="form-label mb-0">Payload</label>
                        <select class="form-select form-select-sm" data-field="content_type" data-scen-idx="${sidx}" data-sec="${secName}" data-item-idx="${iidx}">
                            ${['Random','text','photo','audio','video','gibberish'].map(ct => `<option value="${ct}" ${((it.content_type||'Random')===ct)?'selected':''}>${ct}</option>`).join('')}
                        </select>
                    </div>
                    <div class="traffic-config" style="display:${((it.content_type||'Random')==='Random')?'none':'block'};">
                        <label class="form-label mb-0">Pattern</label>
                        <select class="form-select form-select-sm" data-field="pattern" data-scen-idx="${sidx}" data-sec="${secName}" data-item-idx="${iidx}">
                            ${['continuous','periodic','burst','poisson','ramp'].map(p => `<option ${((it.pattern||'')===p)?'selected':''}>${p}</option>`).join('')}
                        </select>
                    </div>
                    <div class="traffic-config" style="display:${((it.content_type||'Random')==='Random')?'none':'block'};">
                        <label class="form-label mb-0">Rate (kbps)</label>
                        <input type="number" step="0.1" class="form-control form-control-sm" value="${it.rate_kbps ?? 64.0}" data-field="rate_kbps" data-scen-idx="${sidx}" data-sec="${secName}" data-item-idx="${iidx}">
                    </div>
                    <div class="traffic-config" style="display:${((it.content_type||'Random')==='Random')?'none':'block'};">
                        <label class="form-label mb-0">Period (s)</label>
                        <input type="number" step="0.1" class="form-control form-control-sm" value="${it.period_s ?? 1.0}" data-field="period_s" data-scen-idx="${sidx}" data-sec="${secName}" data-item-idx="${iidx}">
                    </div>
                    <div class="traffic-config" style="display:${((it.content_type||'Random')==='Random')?'none':'block'};">
                        <label class="form-label mb-0">Jitter (%)</label>
                        <input type="number" step="0.1" class="form-control form-control-sm" value="${it.jitter_pct ?? 10.0}" data-field="jitter_pct" data-scen-idx="${sidx}" data-sec="${secName}" data-item-idx="${iidx}">
                    </div>
                </div>`;
        }
        if (secName === 'Vulnerabilities') {
            const mode = it.selected || 'Type/Vector';
            if (mode === 'Specific') {
                const nm = it.v_name || '';
                // Try to obtain full description (prefer stored v_desc, else look up in catalog)
                let fullDesc = it.v_desc || '';
                if (!fullDesc && nm && window.VULN_CATALOG && Array.isArray(window.VULN_CATALOG.items)) {
                    const match = window.VULN_CATALOG.items.find(x => x.Name === nm && (!it.v_path || x.Path === it.v_path));
                    if (match && match.Description) { fullDesc = match.Description; }
                }
                const abbr = (s, n=80) => (s && s.length > n ? (s.slice(0, n-1) + '…') : (s||''));
                const esc = (s) => (s||'')
                    .replace(/&/g,'&amp;')
                    .replace(/</g,'&lt;')
                    .replace(/>/g,'&gt;')
                    .replace(/"/g,'&quot;')
                    .replace(/'/g,'&#39;');
                const descShort = abbr(fullDesc);
                const centerText = nm ? `${nm}${descShort ? ' — ' + descShort : ''}` : '<span class="text-muted">No selection</span>';
                return `<span class="small" ${fullDesc ? `data-bs-toggle="tooltip" data-bs-title="${esc(fullDesc)}"` : ''}>${centerText}</span>`;
            }
            return '';
        }
        return '';
    })();
    // Build first cell content, optionally augmenting Selected with Vulnerabilities controls
    const firstCell = (() => {
        const isProtectedRandom = (secName === 'Node Information') && ((it.selected||'').toLowerCase()==='random') && it._protected_random;
        const disabledAttr = isProtectedRandom ? 'disabled title="Residual Random row is auto-managed"' : '';
        const selectedCtl = `<select class="form-select form-select-sm" ${disabledAttr} data-field="selected" data-scen-idx="${sidx}" data-sec="${secName}" data-item-idx="${iidx}">${opts}</select>`;
        if (secName !== 'Vulnerabilities') return selectedCtl;
    const modeRaw = it.selected || 'Category';
    const mode = (modeRaw === 'Type/Vector') ? 'Category' : modeRaw;
    if (mode === 'Category') {
            return `
            <div class="d-flex flex-wrap gap-2 align-items-end">
                <div style="min-width:160px">${selectedCtl}</div>
                <div>
                    <label class="form-label mb-0">Type</label>
                    <select class="form-select form-select-sm vuln-type" data-field="v_type" data-scen-idx="${sidx}" data-sec="${secName}" data-item-idx="${iidx}"></select>
                </div>
                <div>
                    <label class="form-label mb-0">Vector</label>
                    <select class="form-select form-select-sm vuln-vector" data-field="v_vector" data-scen-idx="${sidx}" data-sec="${secName}" data-item-idx="${iidx}"></select>
                </div>
            </div>`;
        } else if (mode === 'Specific') {
            const nm = it.v_name || '';
            // Try to obtain full description (prefer stored v_desc, else look up in catalog)
            let fullDesc = it.v_desc || '';
            if (!fullDesc && nm && window.VULN_CATALOG && Array.isArray(window.VULN_CATALOG.items)) {
                const match = window.VULN_CATALOG.items.find(x => x.Name === nm && (!it.v_path || x.Path === it.v_path));
                if (match && match.Description) { fullDesc = match.Description; }
            }
            const abbr = (s, n=80) => (s && s.length > n ? (s.slice(0, n-1) + '…') : (s||''));
            const esc = (s) => (s||'')
                .replace(/&/g,'&amp;')
                .replace(/</g,'&lt;')
                .replace(/>/g,'&gt;')
                .replace(/"/g,'&quot;')
                .replace(/'/g,'&#39;');
            const descShort = abbr(fullDesc);
            return `
            <div class="d-flex flex-wrap gap-2 align-items-center">
                <div style="min-width:160px">${selectedCtl}</div>
                <button type="button" class="btn btn-sm btn-outline-primary" data-action="pick-specific" data-scen-idx="${sidx}" data-sec="${secName}" data-item-idx="${iidx}">Choose...</button>
            </div>`;
        }
        return selectedCtl;
    })();
    // Right-most: Weight or Count cell
    const weightCell = (() => {
        if (secName === 'Vulnerabilities') {
            const mode = it.selected || 'Type/Vector';
            const metric = it.v_metric || (mode === 'Specific' ? 'Count' : 'Weight');
            const metricSel = `<select class="form-select form-select-sm" style="min-width: 140px" data-field="v_metric" data-scen-idx="${sidx}" data-sec="${secName}" data-item-idx="${iidx}"><option ${metric==='Weight'?'selected':''}>Weight</option><option ${metric==='Count'?'selected':''}>Count</option></select>`;
            if (metric === 'Count') {
                const count = (parseInt(it.v_count, 10) || 5);
                return `<div class="d-flex gap-2">${metricSel}<input type="number" min="1" step="1" class="form-control form-control-sm" style="min-width: 120px" value="${count}" data-field="v_count" data-scen-idx="${sidx}" data-sec="${secName}" data-item-idx="${iidx}"></div>`;
            }
            return `<div class="d-flex gap-2">${metricSel}<input type="number" step="0.01" min="0" max="1" class="form-control form-control-sm weight-input" style="min-width: 120px" value="${weight}" data-field="factor" data-scen-idx="${sidx}" data-sec="${secName}" data-item-idx="${iidx}"></div>`;
        }
        // For all other sections, provide a Count/Weight selector as well
        const metric = it.v_metric || 'Weight';
        const metricSel = `<select class="form-select form-select-sm" style="min-width: 140px" data-field="v_metric" data-scen-idx="${sidx}" data-sec="${secName}" data-item-idx="${iidx}"><option ${metric==='Weight'?'selected':''}>Weight</option><option ${metric==='Count'?'selected':''}>Count</option></select>`;
        if (metric === 'Count') {
            const count = (parseInt(it.v_count, 10) || NODE_COUNT_MIN);
            return `<div class="d-flex gap-2">${metricSel}<input type="number" min="${NODE_COUNT_MIN}" max="${NODE_COUNT_MAX}" step="1" class="form-control form-control-sm" style="min-width: 120px" value="${count}" data-field="v_count" data-scen-idx="${sidx}" data-sec="${secName}" data-item-idx="${iidx}"></div>`;
        }
    const isProtectedRandom = (secName === 'Node Information') && ((it.selected||'').toLowerCase()==='random') && it._protected_random;
    const metricDisabled = isProtectedRandom ? 'disabled title="Residual Random row metric locked"' : '';
    const metricSelProtected = `<select class="form-select form-select-sm" ${metricDisabled} style="min-width: 140px" data-field="v_metric" data-scen-idx="${sidx}" data-sec="${secName}" data-item-idx="${iidx}"><option ${metric==='Weight'?'selected':''}>Weight</option><option ${metric==='Count'?'selected':''}>Count</option></select>`;
    const ro = isProtectedRandom ? 'readonly class="form-control form-control-sm weight-input bg-light" title="Auto-adjusted to keep sum=1.0"' : 'class="form-control form-control-sm weight-input"';
    return `<div class="d-flex gap-2">${metricSelProtected}<input type="number" step="0.01" min="0" max="1" ${ro} style="min-width: 120px" value="${weight}" data-field="factor" data-scen-idx="${sidx}" data-sec="${secName}" data-item-idx="${iidx}"></div>`;
    })();
    const removeBtnHtml = ((secName === 'Node Information') && ((it.selected||'').toLowerCase()==='random') && it._protected_random)
        ? '<span class="text-muted small" title="Residual Random row">&mdash;</span>'
        : `<button type="button" class="btn btn-sm btn-outline-danger" data-action="remove-item" data-scen-idx="${sidx}" data-sec="${secName}" data-item-idx="${iidx}">Remove</button>`;
    return `
        <tr>
            <td>${firstCell}</td>
            <td>${extras}</td>
            <td>${weightCell}</td>
            <td>${removeBtnHtml}</td>
        </tr>`;
}
// Render Vulnerabilities rows grouped with two row-headers
function renderVulnRows(sidx, secName, items) {
    const withIdx = items.map((it, iidx) => ({ it, iidx }));
    const typeOrRandom = withIdx.filter(x => (x.it.selected || 'Category') !== 'Specific');
    const specifics = withIdx.filter(x => (x.it.selected || 'Category') === 'Specific');
    const parts = [];
    if (typeOrRandom.length) {
        parts.push(`<tr class="table-light"><td colspan="4"><strong>Category or Random</strong></td></tr>`);
        parts.push(typeOrRandom.map(x => renderItemRow(sidx, secName, x.iidx, x.it)).join(''));
    }
    if (specifics.length) {
        parts.push(`<tr class="table-light"><td colspan="4"><strong>Specific</strong></td></tr>`);
        parts.push(specifics.map(x => renderItemRow(sidx, secName, x.iidx, x.it)).join(''));
    }
    return parts.join('');
}

function wireHandlers() {
    // Count for Density input handler
    document.querySelectorAll('input[data-field="scenario_density_count"]').forEach(inp => {
        inp.addEventListener('change', () => {
            const idx = parseInt(inp.getAttribute('data-scen-idx'));
            if (Number.isNaN(idx) || !state.scenarios?.[idx]) return;
            let val = clampDensityCountValue(inp.value);
            if (val === null) {
                val = DENSITY_COUNT_MIN;
            }
            state.scenarios[idx].density_count = val; // store at scenario level; do NOT mutate node rows
            enforceDensityBounds(idx);
            refreshScenarioStateAfterCountEdit();
        });
        // Prevent Enter key from triggering unintended form behavior (like adding a row)
        inp.addEventListener('keydown', (ev) => {
            if (ev.key === 'Enter') { ev.preventDefault(); inp.blur(); }
        });
    });
    document.querySelectorAll('input[data-field="scenario_density_min_enabled"]').forEach(inp => {
        inp.addEventListener('change', () => {
            const idx = parseInt(inp.getAttribute('data-scen-idx'));
            if (Number.isNaN(idx) || !state.scenarios?.[idx]) return;
            const scen = state.scenarios[idx];
            const enabled = !!inp.checked;
            scen.density_count_min_enabled = enabled;
            if (enabled && clampDensityCountValue(scen.density_count_min) === null) {
                const fallback = clampDensityCountValue(scen.density_count);
                scen.density_count_min = fallback === null ? DENSITY_COUNT_MIN : fallback;
            }
            enforceDensityBounds(idx);
            refreshScenarioStateAfterCountEdit();
        });
    });
    document.querySelectorAll('input[data-field="scenario_density_max_enabled"]').forEach(inp => {
        inp.addEventListener('change', () => {
            const idx = parseInt(inp.getAttribute('data-scen-idx'));
            if (Number.isNaN(idx) || !state.scenarios?.[idx]) return;
            const scen = state.scenarios[idx];
            const enabled = !!inp.checked;
            scen.density_count_max_enabled = enabled;
            if (enabled && clampDensityCountValue(scen.density_count_max) === null) {
                const fallback = clampDensityCountValue(scen.density_count);
                scen.density_count_max = fallback === null ? DENSITY_COUNT_MAX : fallback;
            }
            enforceDensityBounds(idx);
            refreshScenarioStateAfterCountEdit();
        });
    });
    const handleDensityBoundInput = (selector, fieldName, enabledField) => {
        document.querySelectorAll(selector).forEach(inp => {
            inp.addEventListener('change', () => {
                const idx = parseInt(inp.getAttribute('data-scen-idx'));
                if (Number.isNaN(idx) || !state.scenarios?.[idx]) return;
                const scen = state.scenarios[idx];
                let val = clampDensityCountValue(inp.value);
                if (val === null) {
                    inp.value = '';
                    delete scen[fieldName];
                    scen[enabledField] = false;
                } else {
                    scen[fieldName] = val;
                    scen[enabledField] = true;
                }
                enforceDensityBounds(idx);
                refreshScenarioStateAfterCountEdit();
            });
            inp.addEventListener('keydown', (ev) => {
                if (ev.key === 'Enter') { ev.preventDefault(); inp.blur(); }
            });
        });
    };
    handleDensityBoundInput('input[data-field="scenario_density_min"]', 'density_count_min', 'density_count_min_enabled');
    handleDensityBoundInput('input[data-field="scenario_density_max"]', 'density_count_max', 'density_count_max_enabled');
    document.querySelectorAll('[data-field]').forEach(el => {
        const sidx = parseInt(el.getAttribute('data-scen-idx'));
        const sec = el.getAttribute('data-sec');
        const field = el.getAttribute('data-field');
        const iidx = el.getAttribute('data-item-idx');
        const rowIdx = (iidx !== null && iidx !== undefined) ? parseInt(iidx, 10) : null;
        const handler = (ev) => {
            if (field === 'scenario_base_hosts') { return; }
            if (sec) {
                if (rowIdx !== null && !Number.isNaN(rowIdx)) {
                    const item = state.scenarios[sidx].sections[sec].items[rowIdx];
                    if (['factor','rate_kbps','period_s','jitter_pct','total_nodes','density','r2r_edges','r2s_edges','r2s_hosts_min','r2s_hosts_max'].includes(field)) {
                        item ? (item[field] = parseFloat(el.value)) : state.scenarios[sidx].sections[sec][field] = parseFloat(el.value);
                        if ((field === 'edges' || field === 'r2s_edges') && (isNaN(item[field]) || el.value === '')) {
                            // Allow blank to mean "unset" so generator can apply defaults
                            delete item[field];
                        }
                        if ((field === 'r2s_hosts_min' || field === 'r2s_hosts_max')) {
                            const mn = parseInt(item.r2s_hosts_min || 1, 10);
                            const mx = parseInt(item.r2s_hosts_max || 4, 10);
                            if (!isNaN(mn) && !isNaN(mx) && mn > mx) {
                                item.r2s_hosts_max = mn;
                            }
                            persistEditorState();
                        }
                        if (field === 'factor') {
                            adjustWeightsProportionally(sidx, sec, rowIdx);
                            updateWeightWarning(sidx, sec);
                            updateWeightInputsDisplay(sidx, sec);
                        }
                        if (field === 'edges' || field === 'r2s_edges') {
                            setTimeout(validateRoutingEdges, 20);
                        }
                    } else if (['pattern','content_type','selected','script_path','v_type','v_vector','v_name','v_path','v_count','v_metric','r2r_mode','r2s_mode'].includes(field)) {
                        const prev = item[field];
                        if (field === 'v_count') {
                            let n = clampNodeCountValue(el.value);
                            if (n === null) {
                                n = NODE_COUNT_MIN;
                            }
                            item[field] = n;
                            if (sec) {
                                enforceSectionCountBoundsForScenario(sidx, sec, rowIdx);
                            }
                        } else {
                            item[field] = el.value;
                        }
                        if(field === 'r2r_mode') {
                            item.r2r_mode = el.value;
                            if(el.value !== 'Exact') { delete item.edges; }
                            renderMain();
                            updateHsBoundsVisibility();
                            setTimeout(validateRoutingEdges, 50);
                        }
                        if(field === 'r2s_mode') {
                            item.r2s_mode = el.value;
                            if(el.value !== 'Exact') { delete item.r2s_edges; }
                            renderMain();
                            updateHsBoundsVisibility();
                            setTimeout(validateRoutingEdges, 50);
                        }
                        if (field === 'edges') {
                            setTimeout(validateRoutingEdges, 20);
                        } else if (field === 'content_type') {
                            // Re-render to reflect show/hide of traffic-config inputs when Random is selected
                            renderMain();
                        } else if (field === 'selected') {
                            if (item.selected === 'Specific') {
                                if (!item.v_count) item.v_count = 5;
                                if (!item.v_metric) item.v_metric = 'Count';
                            } else {
                                if (!item.v_metric) item.v_metric = 'Weight';
                            }
                            if (sec) {
                                enforceSectionCountBoundsForScenario(sidx, sec, rowIdx);
                            }
                            // Re-render to show/hide appropriate controls and recalc weight warnings
                            renderMain();
                        } else if (field === 'v_metric') {
                            // On metric toggle, normalize weights for current section and re-render
                            if (item.v_metric === 'Count' && (item.v_count === undefined || item.v_count === null || isNaN(parseInt(item.v_count, 10)))) {
                                item.v_count = 5;
                            }
                            redistributeEven(sidx, sec);
                            if (sec === 'Node Information') {
                                const secRef = state.scenarios[sidx].sections[sec];
                                const hasWeight = (secRef.items || []).some(it => (it.v_metric || 'Weight') === 'Weight');
                                if (!hasWeight && secRef.total_nodes) { secRef.total_nodes = 0; }
                                enforceSectionCountBoundsForScenario(sidx, sec, rowIdx);
                            }
                            updateWeightWarning(sidx, sec);
                            renderMain();
                        } else if (field === 'v_count') {
                            // Count change affects Total Nodes label
                            renderMain();
                        }
                    } else {
                        state.scenarios[sidx].sections[sec][field] = el.value;
                    }
                } else {
                    const sectionRef = state.scenarios[sidx].sections[sec];
                    if (!sectionRef) return;
                    if (field === 'density' || field === 'total_nodes') {
                        let v = parseFloat(el.value);
                        if (field === 'density') {
                            if (isNaN(v)) v = 0.0;
                            v = Math.max(0, Math.min(1, v)); // Clamp globally 0..1
                        }
                        sectionRef[field] = v;
                        // keep hidden for submit and update any warnings
                        if (field === 'density') { updateWeightWarning(sidx, sec); }
                        // Ensure Total Nodes label refreshes on total_nodes edits
                        if (field === 'total_nodes') { renderMain(); }
                    } else if (field === 'node_count_min_enabled' || field === 'node_count_max_enabled') {
                        if (ev?.type === 'input') return;
                        const enabled = !!el.checked;
                        const targetField = field === 'node_count_min_enabled' ? 'node_count_min' : 'node_count_max';
                        sectionRef[field] = enabled;
                        if (enabled) {
                            let fallback = clampNodeCountValue(sectionRef[targetField]);
                            if (fallback === null) {
                                const rows = collectSectionCountRows(sectionRef);
                                const total = sumSectionCountRowValues(rows);
                                fallback = total > 0 ? total : (rows.length * NODE_COUNT_MIN);
                            }
                            if (fallback === null || fallback === undefined) {
                                fallback = NODE_COUNT_MIN;
                            }
                            sectionRef[targetField] = fallback;
                        }
                        enforceSectionCountBoundsForScenario(sidx, sec);
                        refreshScenarioStateAfterCountEdit();
                        return;
                    } else if (field === 'node_count_min' || field === 'node_count_max') {
                        if (ev?.type === 'input') return;
                        let val = clampNodeCountValue(el.value);
                        const enabledField = `${field}_enabled`;
                        if (val === null) {
                            el.value = '';
                            delete sectionRef[field];
                            sectionRef[enabledField] = false;
                        } else {
                            sectionRef[field] = val;
                            sectionRef[enabledField] = true;
                        }
                        enforceSectionCountBoundsForScenario(sidx, sec);
                        refreshScenarioStateAfterCountEdit();
                        return;
                    } else {
                        sectionRef[field] = el.value;
                    }
                }
            } else {
                if (field === 'name') {
                    const raw = el.value ?? '';
                    if (ev?.type === 'change') {
                        const trimmed = raw.trim();
                        const finalName = trimmed || `Scenario ${sidx + 1}`;
                        let uniqueName = finalName;
                        try {
                            uniqueName = ensureUniqueScenarioName(finalName, state.scenarios, sidx);
                        } catch (e) {}
                        state.scenarios[sidx].name = uniqueName;
                        if (el.value !== uniqueName) {
                            el.value = uniqueName;
                        }
                        if (uniqueName !== finalName) {
                            try { showToast(`Scenario name already exists. Renamed to "${uniqueName}".`, { autohide: true, delay: 3500 }); } catch (_) {}
                        }
                        try { logInfo(`Scenario renamed to ${uniqueName}`); } catch(_) {}
                    } else {
                        state.scenarios[sidx].name = raw;
                    }
                }
                if (field === 'base-file') state.scenarios[sidx].base.filepath = el.value;
                if (field === 'notes') state.scenarios[sidx].notes = el.value;
                if(field === 'notes'){
                    try {
                        const ind = document.getElementById('notesIndicator_'+sidx);
                        if(ind){
                            const has = (el.value||'').trim().length>0;
                            ind.innerHTML = has ? `<i class='bi bi-journal-text text-success'></i>` : `<i class='bi bi-journal text-muted'></i>`;
                            ind.setAttribute('data-bs-title', has ? 'Notes present' : 'No notes');
                            if(window.bootstrap){ try { new bootstrap.Tooltip(ind); } catch(e){} }
                        }
                    } catch(e){}
                }
            }
            if (field === 'name') {
                renderSidebar();
            }
            // keep hidden for submit
            document.getElementById('scenarios_json').value = JSON.stringify({ scenarios: state.scenarios, active_index: activeIdx });
            // persist edits across navigation
            persistEditorState();
            logDebug(`Field change: scen=${sidx} sec=${sec||''} field=${field}`);
            try { previewState.dirty = true; updatePlanButtons(); } catch(e){}
        };
        el.addEventListener('input', handler);
        el.addEventListener('change', handler);
    });
    document.querySelectorAll('[data-action="remove-item"]').forEach(btn => {
        btn.onclick = () => {
            const sidx = parseInt(btn.getAttribute('data-scen-idx'));
            const sec = btn.getAttribute('data-sec');
            const iidx = parseInt(btn.getAttribute('data-item-idx'));
            state.scenarios[sidx].sections[sec].items.splice(iidx,1);
                        logInfo(`Removed item ${iidx} from ${sec}`);
              redistributeEven(sidx, sec);
              // Auto-clear total_nodes if Node Information loses its last weight-based row
              if (sec === 'Node Information') {
                  const secRef = state.scenarios[sidx].sections[sec];
                  const hasWeight = (secRef.items || []).some(it => (it.v_metric || 'Weight') === 'Weight');
                  if (!hasWeight && secRef.total_nodes) { secRef.total_nodes = 0; }
                  enforceSectionCountBoundsForScenario(sidx, sec);
              }
              // Re-render to refresh totals and labels
                            renderMain();
                            persistEditorState();
                            try { if (sec === 'Vulnerabilities' && typeof flushServerSnapshotPersistNow === 'function') flushServerSnapshotPersistNow(); } catch (_) {}
                            try { previewState.dirty = true; updatePlanButtons(); } catch(e){}
        };
    });
    document.querySelectorAll('[data-action="add-item"]').forEach(btn => {
        btn.onclick = () => {
            const sidx = parseInt(btn.getAttribute('data-scen-idx'));
            const sec = btn.getAttribute('data-sec');
            // Default selection logic: for Routing we prefer the first concrete protocol (not Random) so
            // routers don't silently become 'Random' unless user explicitly chooses it. Other sections
            // still start at 'Random' (or specialized default) as before.
            let defaultSelected = 'Random';
            if (sec === 'Routing') {
                try {
                    const opts = dropdownsBySection['Routing'] || [];
                    // pick the first option that isn't 'Random'
                    const concrete = opts.find(o => o !== 'Random');
                    if (concrete) defaultSelected = concrete;
                } catch(e){}
            }
            const item = { selected: defaultSelected, factor: 1.0 };
            if (sec === 'Events') item.script_path = '';
            if (sec === 'Traffic') { item.pattern = 'continuous'; item.rate_kbps = 64.0; item.period_s = 1.0; item.jitter_pct = 10.0; item.content_type = 'Random'; }
            if (sec === 'Vulnerabilities') { item.selected = 'Category'; item.v_type = 'Random'; item.v_vector = 'Random'; }
            // Default new rows: Node Information -> Count; others -> Weight.
            if (sec === 'Node Information') { item.v_metric = 'Count'; item.v_count = 5; }
            else { item.v_metric = 'Weight'; }
            state.scenarios[sidx].sections[sec].items.push(item);
                        logInfo(`Added item to ${sec}`);
              redistributeEven(sidx, sec);
            if (sec === 'Node Information') {
                const newIdx = state.scenarios[sidx].sections[sec].items.length - 1;
                enforceSectionCountBoundsForScenario(sidx, sec, newIdx);
            }
                            renderMain();
                            persistEditorState();
                            try { if (sec === 'Vulnerabilities' && typeof flushServerSnapshotPersistNow === 'function') flushServerSnapshotPersistNow(); } catch (_) {}
                            try { previewState.dirty = true; updatePlanButtons(); } catch(e){}
        };
    });
    document.querySelectorAll('[data-action="toggle-collapse"]').forEach(btn => {
        btn.onclick = () => {
            const targetSel = btn.getAttribute('data-target');
            const target = document.querySelector(targetSel);
            if (!target) return;
            const visible = target.style.display !== 'none';
            target.style.display = visible ? 'none' : 'block';
            btn.textContent = visible ? 'Expand' : 'Collapse';
            const secName = targetSel.replace('#collapse-','').replace(/-/g,' ');
            const collapseKey = `${activeIdx}::${secName}`;
            collapseState[collapseKey] = visible; // store collapsed state (true means now collapsed)
            try { localStorage.setItem('sectionCollapseState', JSON.stringify(collapseState)); } catch(e) {}
            logDebug(`Section toggle ${targetSel} -> ${visible ? 'collapsed':'expanded'}`);
        };
    });
    document.querySelectorAll('[data-hitl-toggle]').forEach(toggle => {
        toggle.addEventListener('change', () => {
            const sidx = parseInt(toggle.getAttribute('data-scen-idx'));
            if (isNaN(sidx) || !state.scenarios[sidx]) return;
            const hitlState = ensureHitlStateForScenario(state.scenarios[sidx]);
            hitlState.enabled = !!toggle.checked;
            logInfo(`HITL ${hitlState.enabled ? 'enabled' : 'disabled'} for scenario ${state.scenarios[sidx].name || sidx + 1}`);
            persistEditorState();
            const hidden = document.getElementById('scenarios_json');
            if (hidden) hidden.value = JSON.stringify({ scenarios: state.scenarios, active_index: activeIdx });
            renderMain();
            try { syncExternalIfxModalSaveLabel(); } catch (_) {}
        });
    });
    document.querySelectorAll('[data-hitl-add]').forEach(btn => {
        btn.addEventListener('click', () => {
            const sidx = parseInt(btn.getAttribute('data-scen-idx'));
            if (isNaN(sidx) || !state.scenarios[sidx]) return;
            const select = document.getElementById(`hitlAvailable_${sidx}`);
            if (!select) return;
            const chosen = Array.from(select.selectedOptions || []);
            if (!chosen.length) {
                try { showToast('Select one or more interfaces to add', { autohide: true, delay: 2000 }); } catch(e) {}
                return;
            }
            const hitlState = ensureHitlStateForScenario(state.scenarios[sidx]);
            try { bindHostInterfacesToScenarioCache(sidx); } catch (e) {}
            const catalog = getEffectiveHostInterfacesForScenario(sidx);
            const isVmbr0 = (entry) => {
                if (!entry) return false;
                const bridge = (entry.bridge || (entry.proxmox && entry.proxmox.bridge) || (entry.proxmox && entry.proxmox.raw && entry.proxmox.raw.bridge) || '').toString().trim().toLowerCase();
                return bridge === 'vmbr0';
            };
            let added = 0;
            let blocked = 0;
            chosen.forEach(opt => {
                const name = (opt.value || opt.textContent || '').trim();
                if (!name) return;
                if (hitlState.interfaces.some(entry => entry.name === name)) return;
                const hostInfo = catalog.find(entry => entry && entry.name === name);
                if (hostInfo && isVmbr0(hostInfo)) {
                    blocked += 1;
                    return;
                }
                const newEntry = { name, attachment: 'existing_router' };
                if (hostInfo) {
                    if (Array.isArray(hostInfo.ipv4)) newEntry.ipv4 = hostInfo.ipv4;
                    if (Array.isArray(hostInfo.ipv6)) newEntry.ipv6 = hostInfo.ipv6;
                    if (hostInfo.mac) newEntry.mac = hostInfo.mac;
                }
                hitlState.interfaces.push(newEntry);
                added += 1;
            });
            if (!added) {
                if (blocked) {
                    try { showToast('Interfaces on vmbr0 cannot be mapped for HITL.', { autohide: true, delay: 2500 }); } catch(e) {}
                } else {
                    try { showToast('Interfaces already selected', { autohide: true, delay: 2000 }); } catch(e) {}
                }
                return;
            }
            hitlState.enabled = true;
            logInfo(`Added ${added} HITL interface${added > 1 ? 's' : ''}`);
            if (blocked) {
                try { showToast('Skipped vmbr0 interfaces; they remain visible but unavailable.', { autohide: true, delay: 2500 }); } catch(e) {}
            }
            persistEditorState();
            const hidden = document.getElementById('scenarios_json');
            if (hidden) hidden.value = JSON.stringify({ scenarios: state.scenarios, active_index: activeIdx });
            renderMain();
        });
    });
    document.querySelectorAll('[data-hitl-attach]').forEach(select => {
        select.addEventListener('change', () => {
            const sidx = parseInt(select.getAttribute('data-scen-idx'));
            const ifaceIdx = parseInt(select.getAttribute('data-iface-index'));
            if (isNaN(sidx) || isNaN(ifaceIdx) || !state.scenarios[sidx]) return;
            const hitlState = ensureHitlStateForScenario(state.scenarios[sidx]);
            if (!Array.isArray(hitlState.interfaces) || !hitlState.interfaces[ifaceIdx]) return;
            const newValue = normalizeHitlAttachment(select.value);
            hitlState.interfaces[ifaceIdx].attachment = newValue;
            logInfo(`Updated HITL attachment for ${hitlState.interfaces[ifaceIdx].name || 'interface'} → ${newValue}`);
            persistEditorState();
            const hidden = document.getElementById('scenarios_json');
            if (hidden) hidden.value = JSON.stringify({ scenarios: state.scenarios, active_index: activeIdx });
            renderMain();
        });
    });
    document.querySelectorAll('[data-hitl-external-vm-select]').forEach(select => {
        select.addEventListener('change', () => {
            const sidx = parseInt(select.getAttribute('data-scen-idx'));
            const ifaceIdx = parseInt(select.getAttribute('data-iface-index'));
            if (isNaN(sidx) || isNaN(ifaceIdx) || !state.scenarios?.[sidx]) return;
            const scenario = state.scenarios[sidx];
            const hitlState = ensureHitlStateForScenario(scenario);
            if (!Array.isArray(hitlState.interfaces) || !hitlState.interfaces[ifaceIdx]) return;
            const ifaceEntry = hitlState.interfaces[ifaceIdx];
            const rawValue = (select.value || '').trim();
            const coreState = hitlState.core || {};
            const coreVmKeyCurrent = (coreState.vm_key || '').toString();
            const proxState = hitlState.proxmox || {};
            const inventory = proxState.inventory && Array.isArray(proxState.inventory.vms) ? proxState.inventory.vms : [];
            if (!rawValue) {
                delete ifaceEntry.external_vm;
                persistEditorState();
                const hidden = document.getElementById('scenarios_json');
                if (hidden) hidden.value = JSON.stringify({ scenarios: state.scenarios, active_index: activeIdx });
                renderMain();
                return;
            }
            if (rawValue === coreVmKeyCurrent) {
                logWarn('Ignoring selection of CORE VM for external connectivity');
                select.value = '';
                delete ifaceEntry.external_vm;
                try { showToast('Select a VM other than the CORE VM.', { autohide: true, delay: 2500 }); } catch (e) {}
                return;
            }
            const selectedVm = inventory.find(vm => `${vm.node ?? ''}::${vm.vmid ?? ''}` === rawValue);
            const [nodePart, vmidPartRaw] = rawValue.split('::');
            const vmidPart = vmidPartRaw && vmidPartRaw.trim() ? vmidPartRaw.trim() : '';
            const normalizedVmNode = selectedVm && selectedVm.node !== undefined && selectedVm.node !== null
                ? String(selectedVm.node).trim()
                : (nodePart || '').trim();
            const physicalInterfaces = selectedVm ? getPhysicalVmInterfaces(selectedVm) : [];
            const baseExternalVm = selectedVm
                ? {
                    vm_key: rawValue,
                    vm_node: normalizedVmNode,
                    vmid: selectedVm.vmid ?? vmidPart,
                    vm_name: selectedVm.name ?? '',
                    status: selectedVm.status ?? '',
                }
                : {
                    vm_key: rawValue,
                    vm_node: normalizedVmNode,
                    vmid: vmidPart,
                    vm_name: '',
                    status: '',
                };
            if (physicalInterfaces.length === 1) {
                const onlyIface = physicalInterfaces[0];
                const ifaceId = normalizeVmInterfaceId(onlyIface);
                if (ifaceId) {
                    baseExternalVm.interface_id = ifaceId;
                    baseExternalVm.interface_bridge = (onlyIface.bridge ?? '').toString().trim();
                    baseExternalVm.interface_mac = (onlyIface.macaddr ?? '').toString().trim();
                    baseExternalVm.interface_model = (onlyIface.model ?? '').toString().trim();
                }
            }
            ifaceEntry.external_vm = baseExternalVm;
            persistEditorState();
            const hidden = document.getElementById('scenarios_json');
            if (hidden) hidden.value = JSON.stringify({ scenarios: state.scenarios, active_index: activeIdx });
            renderMain();
            const labelParts = [];
            if (ifaceEntry.external_vm?.vm_name) labelParts.push(ifaceEntry.external_vm.vm_name);
            if (ifaceEntry.external_vm?.vm_node) labelParts.push(`node ${ifaceEntry.external_vm.vm_node}`);
            if (ifaceEntry.external_vm?.vmid !== undefined && ifaceEntry.external_vm?.vmid !== null && ifaceEntry.external_vm.vmid !== '') {
                labelParts.push(`ID ${ifaceEntry.external_vm.vmid}`);
            }
            if (ifaceEntry.external_vm?.interface_id) {
                labelParts.push(`iface ${ifaceEntry.external_vm.interface_id}`);
                if (ifaceEntry.external_vm.interface_bridge) labelParts.push(`bridge ${ifaceEntry.external_vm.interface_bridge}`);
            }
            try { showToast(`Linked ${ifaceEntry.name || 'interface'} to ${labelParts.join(' • ') || 'selected VM'}`, { autohide: true, delay: 2200 }); } catch (e) {}
        });
    });
    document.querySelectorAll('[data-hitl-external-vm-iface-select]').forEach(select => {
        select.addEventListener('change', () => {
            const sidx = parseInt(select.getAttribute('data-scen-idx'));
            const ifaceIdx = parseInt(select.getAttribute('data-iface-index'));
            if (isNaN(sidx) || isNaN(ifaceIdx) || !state.scenarios?.[sidx]) return;
            const scenario = state.scenarios[sidx];
            const hitlState = ensureHitlStateForScenario(scenario);
            if (!Array.isArray(hitlState.interfaces) || !hitlState.interfaces[ifaceIdx]) return;
            const ifaceEntry = hitlState.interfaces[ifaceIdx];
            if (!ifaceEntry.external_vm || typeof ifaceEntry.external_vm !== 'object') return;
            const rawValue = (select.value || '').trim();
            const proxState = hitlState.proxmox || {};
            const inventory = proxState.inventory && Array.isArray(proxState.inventory.vms) ? proxState.inventory.vms : [];
            const externalVmKey = ifaceEntry.external_vm.vm_key || '';
            const selectedVm = inventory.find(vm => `${vm.node ?? ''}::${vm.vmid ?? ''}` === externalVmKey);
            const physicalInterfaces = selectedVm ? getPhysicalVmInterfaces(selectedVm) : [];
            if (!rawValue) {
                delete ifaceEntry.external_vm.interface_id;
                delete ifaceEntry.external_vm.interface_bridge;
                delete ifaceEntry.external_vm.interface_mac;
                delete ifaceEntry.external_vm.interface_model;
                persistEditorState();
                const hidden = document.getElementById('scenarios_json');
                if (hidden) hidden.value = JSON.stringify({ scenarios: state.scenarios, active_index: activeIdx });
                renderMain();
                try { showToast(`Cleared external interface for ${ifaceEntry.name || 'interface'}.`, { autohide: true, delay: 2000 }); } catch (e) {}
                return;
            }
            const matchedIface = physicalInterfaces.find(vmIface => normalizeVmInterfaceId(vmIface) === rawValue) || null;
            ifaceEntry.external_vm.interface_id = rawValue;
            ifaceEntry.external_vm.interface_bridge = matchedIface && matchedIface.bridge ? String(matchedIface.bridge).trim() : '';
            ifaceEntry.external_vm.interface_mac = matchedIface && matchedIface.macaddr ? String(matchedIface.macaddr).trim() : '';
            ifaceEntry.external_vm.interface_model = matchedIface && matchedIface.model ? String(matchedIface.model).trim() : '';
            persistEditorState();
            const hidden = document.getElementById('scenarios_json');
            if (hidden) hidden.value = JSON.stringify({ scenarios: state.scenarios, active_index: activeIdx });
            renderMain();
            const labelParts = [];
            if (ifaceEntry.external_vm?.vm_name) labelParts.push(ifaceEntry.external_vm.vm_name);
            if (ifaceEntry.external_vm?.vm_node) labelParts.push(`node ${ifaceEntry.external_vm.vm_node}`);
            labelParts.push(`iface ${rawValue}`);
            if (ifaceEntry.external_vm.interface_bridge) labelParts.push(`bridge ${ifaceEntry.external_vm.interface_bridge}`);
            try { showToast(`Mapped ${ifaceEntry.name || 'interface'} to ${labelParts.join(' • ')}`, { autohide: true, delay: 2200 }); } catch (e) {}
        });
    });
    document.querySelectorAll('[data-hitl-step4-refresh]').forEach(btn => {
        btn.addEventListener('click', async () => {
            if (btn.disabled) return;
            const sidx = parseInt(btn.getAttribute('data-scen-idx'));
            if (isNaN(sidx) || !state.scenarios?.[sidx]) return;
            btn.disabled = true;
            const originalLabel = btn.innerHTML;
            btn.innerHTML = 'Refreshing…';
            try { showToast('Refreshing Proxmox interfaces…', { autohide: true, delay: 1800 }); } catch (e) {}
            try {
                await fetchProxmoxInventory(sidx, { force: true });
            } finally {
                // renderMain will rebuild the button; restore label in case this element persists before re-render
                btn.innerHTML = originalLabel;
            }
        });
    });
    const setParticipantUrlStatus = (sidx, rawValue) => {
        const indicator = document.querySelector(`[data-hitl-participant-status="${sidx}"]`);
        if (!indicator) return;
        const normalized = normalizeParticipantProxmoxHref(rawValue || '');
        if (normalized) {
            indicator.textContent = `${PARTICIPANT_STATUS_SAVED_TEXT} (${normalized})`;
            indicator.classList.remove('text-muted');
            indicator.classList.add('text-success');
        } else {
            indicator.textContent = PARTICIPANT_STATUS_EMPTY_TEXT;
            indicator.classList.remove('text-success');
            indicator.classList.add('text-muted');
        }
    };
    const setParticipantUrlFeedback = (sidx, message, tone) => {
        const el = document.querySelector(`[data-hitl-participant-feedback="${sidx}"]`);
        if (!el) return;
        const text = (message ?? '').toString();
        el.textContent = text;
        el.classList.remove('text-muted', 'text-success', 'text-danger');
        if (tone === 'success') {
            el.classList.add('text-success');
        } else if (tone === 'error') {
            el.classList.add('text-danger');
        } else {
            el.classList.add('text-muted');
        }
    };
    const buildEditorSnapshotPayloadForServer = () => {
        const baseUploadMeta = normalizeBaseUpload(state.base_upload) || (state.scenarios?.[0]?.base?.filepath || state.scenarios?.[0]?.base?.display_name ? {
            path: state.scenarios?.[0]?.base?.filepath || '',
            display_name: state.scenarios?.[0]?.base?.display_name || (state.scenarios?.[0]?.base?.filepath ? state.scenarios[0].base.filepath.split(/[/\\]/).pop() || '' : '')
        } : null);
        const coreForPersist = sanitizeCoreForPersist(state.core);
        const scenariosForSnapshot = cloneScenariosForSnapshot(state.scenarios || []);
        const snapshot = {
            scenarios: scenariosForSnapshot,
            result_path: state.result_path || null,
            core: coreForPersist || null,
            core_ok: !!state.core_ok,
            core_tested_host: state.core_tested_host || null,
            core_tested_port: state.core_tested_port || null,
            base_upload: baseUploadMeta,
            host_interfaces: Array.isArray(state.host_interfaces) ? state.host_interfaces : [],
            host_interfaces_source: state.host_interfaces_source || null,
            host_interfaces_metadata: state.host_interfaces_metadata || null,
            host_interfaces_fetched_at: state.host_interfaces_fetched_at || null,
        };
        snapshot.active_index = Number.isInteger(activeIdx) ? activeIdx : 0;
        try {
            const scenarioSignature = deriveScenarioSignature({ scenarios: scenariosForSnapshot });
            const trimmedScenarioToken = (scenarioQueryToken || '').trim();
            const resolvedScenarioQuery = trimmedScenarioToken || scenarioSignature || resolveScenarioQueryHint() || '';
            snapshot.scenario_query = resolvedScenarioQuery || null;
            if (!trimmedScenarioToken && resolvedScenarioQuery) {
                scenarioQueryToken = resolvedScenarioQuery;
            }
            const stableProjectHint = (() => {
                if (currentProjectKey && currentProjectKey !== DEFAULT_PROJECT_KEY) return currentProjectKey;
                if (snapshot.project_key_hint) return snapshot.project_key_hint;
                if (resolvedScenarioQuery) return resolvedScenarioQuery;
                if (snapshot.result_path) return snapshot.result_path;
                if (snapshot.base_upload && snapshot.base_upload.path) return snapshot.base_upload.path;
                return null;
            })();
            snapshot.project_key_hint = stableProjectHint;
        } catch (e) {
            /* best-effort */
        }
        scrubSnapshotTransientErrors(snapshot);
        return snapshot;
    };
    const persistParticipantUrlToServerNow = async () => {
        // Per requirement: HITL values are only persisted server-side once verified.
        // Keep participant URL local until HITL bridge verification/apply succeeds.
        return { ok: true, skipped: true };
    };
    const persistParticipantProxmoxUrl = (sidx, rawValue) => {
        if (Number.isNaN(sidx) || !state.scenarios?.[sidx]) return false;
        const scenario = state.scenarios[sidx];
        const hitlState = ensureHitlStateForScenario(scenario);
        const nextValue = (rawValue || '').trim();
        const previousValue = (hitlState.participant_proxmox_url || '').toString().trim();
        hitlState.participant_proxmox_url = nextValue;
        persistEditorState();
        const hidden = document.getElementById('scenarios_json');
        if (hidden) hidden.value = JSON.stringify({ scenarios: state.scenarios, active_index: activeIdx });
        updateParticipantProxmoxNavLink();
        setParticipantUrlStatus(sidx, nextValue);
        return previousValue !== nextValue;
    };
    const syncParticipantProxmoxControls = (sidx) => {
        const input = document.getElementById(`participantProxmoxUrl_${sidx}`);
        const hasValue = !!(input && input.value && input.value.trim());
        const clearBtn = document.querySelector(`[data-hitl-participant-clear][data-scen-idx="${sidx}"]`);
        if (clearBtn) clearBtn.disabled = !hasValue;
        setParticipantUrlStatus(sidx, input ? input.value : '');
    };
    document.querySelectorAll('[data-hitl-participant-url]').forEach(input => {
        const applyValue = () => {
            const sidx = parseInt(input.getAttribute('data-scen-idx'));
            if (isNaN(sidx) || !state.scenarios?.[sidx]) return;
            persistParticipantProxmoxUrl(sidx, input.value);
            syncParticipantProxmoxControls(sidx);
        };
        input.addEventListener('input', applyValue);
        input.addEventListener('change', applyValue);
        const sidx = parseInt(input.getAttribute('data-scen-idx'));
        if (!Number.isNaN(sidx)) {
            syncParticipantProxmoxControls(sidx);
        }
    });
    document.querySelectorAll('[data-hitl-participant-apply]').forEach(btn => {
        btn.addEventListener('click', async () => {
            if (btn.disabled) return;
            const sidx = parseInt(btn.getAttribute('data-scen-idx'));
            if (Number.isNaN(sidx)) return;
            const input = document.getElementById(`participantProxmoxUrl_${sidx}`);
            const value = input ? input.value : '';
            const originalHtml = btn.innerHTML;
            btn.disabled = true;
            btn.innerHTML = '<span class="spinner-border spinner-border-sm me-1" role="status" aria-hidden="true"></span>Saving';
            setParticipantUrlFeedback(sidx, 'Saving…', 'neutral');
            const changed = persistParticipantProxmoxUrl(sidx, value);
            syncParticipantProxmoxControls(sidx);
            // Refresh the CORE/Participant setup summary table (Participant UI row) immediately.
            try { renderMain(); } catch (e) {}
            const result = await persistParticipantUrlToServerNow();
            if (result && result.ok) {
                setParticipantUrlFeedback(sidx, 'Saved locally. Will persist after HITL Verify/Apply.', 'success');
                const toastMsg = changed ? 'Participant UI link saved locally.' : 'Participant UI link already up to date (local).';
                try { if (typeof showToast === 'function') showToast(toastMsg, { autohide: true, delay: 2000 }); } catch (e) {}
            } else {
                const errMsg = (result && typeof result.error === 'string' && result.error.trim()) ? result.error.trim() : 'Save failed';
                setParticipantUrlFeedback(sidx, `Save failed: ${errMsg}`, 'error');
                try {
                    if (typeof showToast === 'function') {
                        showToast(`Participant UI link save failed: ${errMsg}`, { autohide: false });
                    }
                } catch (e) {}
            }
            btn.disabled = false;
            btn.innerHTML = originalHtml;
        });
    });
    document.querySelectorAll('[data-hitl-participant-clear]').forEach(btn => {
        btn.addEventListener('click', async () => {
            if (btn.disabled) return;
            const sidx = parseInt(btn.getAttribute('data-scen-idx'));
            if (Number.isNaN(sidx)) return;
            const input = document.getElementById(`participantProxmoxUrl_${sidx}`);
            const originalHtml = btn.innerHTML;
            btn.disabled = true;
            btn.innerHTML = '<span class="spinner-border spinner-border-sm me-1" role="status" aria-hidden="true"></span>Clearing';
            setParticipantUrlFeedback(sidx, 'Saving…', 'neutral');
            if (input) input.value = '';
            persistParticipantProxmoxUrl(sidx, '');
            syncParticipantProxmoxControls(sidx);
            // Refresh the CORE/Participant setup summary table (Participant UI row) immediately.
            try { renderMain(); } catch (e) {}
            const result = await persistParticipantUrlToServerNow();
            if (result && result.ok) {
                setParticipantUrlFeedback(sidx, 'Cleared locally.', 'success');
                try { if (typeof showToast === 'function') showToast('Participant UI link cleared locally.', { autohide: true, delay: 1800 }); } catch (e) {}
            } else {
                const errMsg = (result && typeof result.error === 'string' && result.error.trim()) ? result.error.trim() : 'Clear failed';
                setParticipantUrlFeedback(sidx, `Clear failed: ${errMsg}`, 'error');
                try {
                    if (typeof showToast === 'function') {
                        showToast(`Participant UI link clear failed: ${errMsg}`, { autohide: false });
                    }
                } catch (e) {}
            }
            btn.disabled = false;
            btn.innerHTML = originalHtml;
        });
    });
    document.querySelectorAll('[data-hitl-remove]').forEach(btn => {
        btn.addEventListener('click', () => {
            const sidx = parseInt(btn.getAttribute('data-scen-idx'));
            const ifaceName = btn.getAttribute('data-iface');
            if (isNaN(sidx) || !state.scenarios[sidx] || !ifaceName) return;
            const hitlState = ensureHitlStateForScenario(state.scenarios[sidx]);
            const idx = hitlState.interfaces.findIndex(entry => entry.name === ifaceName);
            if (idx === -1) return;
            hitlState.interfaces.splice(idx, 1);
            logInfo(`Removed HITL interface ${ifaceName}`);
            persistEditorState();
            const hidden = document.getElementById('scenarios_json');
            if (hidden) hidden.value = JSON.stringify({ scenarios: state.scenarios, active_index: activeIdx });
            renderMain();
        });
    });
    document.querySelectorAll('[data-proxmox-refresh]').forEach(btn => {
        btn.addEventListener('click', async () => {
            if (IS_BUILDER_VIEW) {
                try { showToast('Builder view is read-only. Ask an admin to refresh Proxmox inventory.', { autohide: true, delay: 3000 }); } catch (e) {}
                return;
            }
            if (btn.disabled) return;
            const sidx = parseInt(btn.getAttribute('data-scen-idx'));
            if (Number.isNaN(sidx)) return;
            const originalHtml = btn.innerHTML;
            btn.disabled = true;
            btn.innerHTML = '<span class="spinner-border spinner-border-sm me-1" role="status" aria-hidden="true"></span>Refreshing VMs';
            try {
                await fetchProxmoxInventory(sidx, { force: true });
            } finally {
                if (document.body.contains(btn)) {
                    btn.disabled = false;
                    btn.innerHTML = originalHtml;
                }
            }
        });
    });
    if (!IS_BUILDER_VIEW) {
        document.querySelectorAll('[data-hitl-core-vm-select]').forEach(select => {
            select.addEventListener('change', () => {
                const sidx = parseInt(select.getAttribute('data-scen-idx'));
                if (isNaN(sidx) || !state.scenarios?.[sidx]) return;
                const hitlState = ensureHitlStateForScenario(state.scenarios[sidx]);
                const coreState = hitlState.core || (hitlState.core = {});
                const prevVmKey = (coreState.vm_key || '').toString();
                const rawValue = select.value || '';
                const resetCoreSelection = () => {
                    coreState.vm_key = '';
                    coreState.vm_name = '';
                    coreState.vm_node = '';
                    coreState.last_tested_status = null;
                    coreState.last_tested_message = null;
                    coreState.last_tested_at = null;
                    coreState.last_tested_host = null;
                    coreState.last_tested_port = null;
                    coreState.core_secret_id = null;
                    coreState.validated = false;
                    coreState.last_validated_at = null;
                    coreState.stored_summary = null;
                    coreState.internal_bridge = '';
                    coreState.internal_bridge_owner = '';
                    coreState.cached_vm_interface_count = null;
                    coreState.cached_vm_status = null;
                    coreState.cached_host_interfaces = [];
                    coreState.cached_host_interfaces_vm_key = '';
                    coreState.cached_host_interfaces_source = null;
                    coreState.cached_host_interfaces_metadata = null;
                    coreState.cached_host_interfaces_fetched_at = null;
                };
                if (!rawValue) {
                    resetCoreSelection();
                    if (prevVmKey && (state.host_interfaces_vm_key || '').toString() === prevVmKey) {
                        state.host_interfaces = [];
                        state.host_interfaces_vm_key = '';
                        state.host_interfaces_source = null;
                        state.host_interfaces_metadata = null;
                        state.host_interfaces_fetched_at = null;
                    }
                    persistEditorState();
                    const pwdInput = document.querySelector(`[data-hitl-core-field="ssh_password"][data-scen-idx="${sidx}"]`);
                    if (pwdInput) pwdInput.removeAttribute('placeholder');
                    const hidden = document.getElementById('scenarios_json');
                    if (hidden) hidden.value = JSON.stringify({ scenarios: state.scenarios, active_index: activeIdx });
                    renderMain();
                    return;
                }
                const proxState = hitlState.proxmox || {};
                const inventory = proxState.inventory && Array.isArray(proxState.inventory.vms) ? proxState.inventory.vms : [];
                const selectedVm = inventory.find(vm => `${vm.node ?? ''}::${vm.vmid ?? ''}` === rawValue) || null;
                const [nodePart, vmidPartRaw] = rawValue.split('::');
                resetCoreSelection();
                coreState.vm_key = rawValue;
                coreState.vm_name = selectedVm && selectedVm.name ? String(selectedVm.name) : '';
                coreState.vm_node = selectedVm && selectedVm.node !== undefined && selectedVm.node !== null
                    ? String(selectedVm.node)
                    : (nodePart || '').trim();
                if (!coreState.vm_name && coreState.vm_node && vmidPartRaw && vmidPartRaw.trim()) {
                    coreState.vm_name = `${coreState.vm_node}::${vmidPartRaw.trim()}`;
                }
                coreState.cached_vm_interface_count = Array.isArray(selectedVm?.interfaces) ? selectedVm.interfaces.length : null;
                coreState.cached_vm_status = selectedVm && selectedVm.status ? String(selectedVm.status) : null;
                if (prevVmKey && (state.host_interfaces_vm_key || '').toString() === prevVmKey) {
                    state.host_interfaces = [];
                    state.host_interfaces_vm_key = '';
                    state.host_interfaces_source = null;
                    state.host_interfaces_metadata = null;
                    state.host_interfaces_fetched_at = null;
                }
                persistEditorState();
                const pwdInput = document.querySelector(`[data-hitl-core-field="ssh_password"][data-scen-idx="${sidx}"]`);
                if (pwdInput) pwdInput.removeAttribute('placeholder');
                const hidden = document.getElementById('scenarios_json');
                if (hidden) hidden.value = JSON.stringify({ scenarios: state.scenarios, active_index: activeIdx });
                renderMain();
            });
        });
    }
    if (!IS_BUILDER_VIEW) {
        document.querySelectorAll('[data-hitl-core-field]').forEach(input => {
            if (input.closest('#coreConnectionModal')) return;
            input.addEventListener('input', () => handleCoreFieldUpdate(input, { rerender: false }));
            input.addEventListener('change', () => handleCoreFieldUpdate(input, { rerender: true }));
        });
        document.querySelectorAll('[data-hitl-core-test]').forEach(btn => {
            btn.addEventListener('click', async () => {
                if (btn.disabled) return;
                const sidx = parseInt(btn.getAttribute('data-scen-idx'));
                await validateCoreConnection(sidx, {
                    triggerButton: btn,
                    workingLabel: 'Testing…',
                });
            });
        });
        document.querySelectorAll('[data-hitl-core-clear]').forEach(btn => {
            btn.addEventListener('click', () => {
                const sidx = parseInt(btn.getAttribute('data-scen-idx'));
                if (isNaN(sidx) || !state.scenarios?.[sidx]) return;
                const hitlState = ensureHitlStateForScenario(state.scenarios[sidx]);
                const existingSecretId = hitlState.core && typeof hitlState.core.core_secret_id === 'string' ? hitlState.core.core_secret_id : null;
                if (existingSecretId) {
                    try {
                        const payload = {
                            core_secret_id: existingSecretId,
                            scenario_index: sidx,
                            scenario_name: state.scenarios?.[sidx]?.name || '',
                        };
                        fetch('/api/core/credentials/clear', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            credentials: 'same-origin',
                            body: JSON.stringify(payload),
                        }).catch(err => logError(`Failed to clear stored CORE credentials: ${err}`));
                    } catch (err) {
                        logError(`Exception during CORE credential clear: ${err}`);
                    }
                }
                hitlState.core = {
                    vm_key: '',
                    vm_name: '',
                    vm_node: '',
                    grpc_host: '',
                    grpc_port: 50051,
                    ssh_host: '',
                    ssh_port: 22,
                    ssh_username: '',
                    ssh_password: '',
                    core_secret_id: null,
                    validated: false,
                    last_validated_at: null,
                    stored_summary: null,
                    last_tested_at: null,
                    last_tested_status: null,
                    last_tested_message: null,
                    last_tested_host: null,
                    last_tested_port: null,
                    internal_bridge: '',
                    internal_bridge_owner: '',
                    last_interfaces_refresh: null,
                    last_interfaces_attempt: null,
                    interfaces_refresh_inflight: false,
                    last_interfaces_error: null,
                };
                persistEditorState();
                const hidden = document.getElementById('scenarios_json');
                if (hidden) hidden.value = JSON.stringify({ scenarios: state.scenarios, active_index: activeIdx });
                const pwdInput = document.querySelector(`[data-hitl-core-field="ssh_password"][data-scen-idx="${sidx}"]`);
                if (pwdInput) pwdInput.removeAttribute('placeholder');
                renderMain();
            });
        });
    }
    document.querySelectorAll('[data-hitl-refresh]').forEach(btn => {
        btn.addEventListener('click', async () => {
            const sidx = parseInt(btn.getAttribute('data-scen-idx'));
            if (Number.isNaN(sidx)) return;
            const originalHtml = btn.innerHTML;
            btn.disabled = true;
            btn.setAttribute('data-refresh-busy', '1');
            btn.innerHTML = '<span class="spinner-border spinner-border-sm me-2" role="status" aria-hidden="true"></span>Refreshing…';
            try {
                await refreshHostInterfacesForScenario(sidx, { reason: 'manual' });
            } finally {
                if (document.body.contains(btn)) {
                    btn.disabled = false;
                    btn.innerHTML = originalHtml;
                    btn.removeAttribute('data-refresh-busy');
                }
            }
        });
    });
    const proxAssignModal = document.getElementById('proxmoxAssignModal');
    const proxAssignHint = document.getElementById('proxmoxAssignHint');
    const proxAssignError = document.getElementById('proxmoxAssignError');
    const proxAssignForm = document.getElementById('proxmoxAssignForm');
    const proxUrlInput = document.getElementById('proxmoxUrl');
    const proxPortInput = document.getElementById('proxmoxPort');
    const proxUserInput = document.getElementById('proxmoxUsername');
    const proxPassInput = document.getElementById('proxmoxPassword');
    const proxRememberInput = document.getElementById('proxmoxRememberCreds');
    const proxVerifyInput = document.getElementById('proxmoxVerifySsl');
    const setProxAssignHint = (message, tone = 'info') => {
        if (!proxAssignHint) return;
        proxAssignHint.textContent = message || '';
        proxAssignHint.style.display = message ? '' : 'none';
        proxAssignHint.classList.remove('alert-info', 'alert-success', 'alert-danger');
        const klass = tone === 'success' ? 'alert-success' : tone === 'danger' ? 'alert-danger' : 'alert-info';
        proxAssignHint.classList.add(klass);
    };
    window.setProxAssignHint = setProxAssignHint;
    // Do not persist passwords until validation succeeds.
    if (proxRememberInput && !proxRememberInput.dataset.prefBound) {
        proxRememberInput.addEventListener('change', () => {
            if (!proxAssignModal) return;
            const sidx = parseInt(proxAssignModal.getAttribute('data-scen-idx') || '', 10);
            if (isNaN(sidx) || !state.scenarios?.[sidx]) return;
            const hitlState = ensureHitlStateForScenario(state.scenarios[sidx]);
            hitlState.proxmox.remember_credentials = !!proxRememberInput.checked;
            persistEditorState();
        });
        proxRememberInput.dataset.prefBound = '1';
    }
    coreConnectionModal = document.getElementById('coreConnectionModal');
    coreConnectionForm = document.getElementById('coreConnectionForm');
    coreConnectionHint = document.getElementById('coreConnectionHint');
    coreConnectionSaveBtn = document.getElementById('coreConnectionSaveBtn');
    coreModalInputs.grpc_host = document.getElementById('coreGrpcHost');
    coreModalInputs.grpc_port = document.getElementById('coreGrpcPort');
    coreModalInputs.ssh_host = document.getElementById('coreSshHost');
    coreModalInputs.ssh_port = document.getElementById('coreSshPort');
    coreModalInputs.ssh_username = document.getElementById('coreSshUsername');
    coreModalInputs.ssh_password = document.getElementById('coreSshPassword');
    coreRememberInput = document.getElementById('coreRememberCreds');
    coreAutoStartInput = document.getElementById('coreAutoStartDaemon');
    coreAdvFixDockerDaemonInput = document.getElementById('coreAdvFixDockerDaemon');
    coreAdvRunCoreCleanupInput = document.getElementById('coreAdvRunCoreCleanup');
    coreAdvCheckCoreVersionInput = document.getElementById('coreAdvCheckCoreVersion');
    coreAdvRestartCoreDaemonInput = document.getElementById('coreAdvRestartCoreDaemon');
    coreAdvAutoKillSessionsInput = document.getElementById('coreAdvAutoKillSessions');
    setCoreConnectionHint = (message, tone = 'info') => {
        if (!coreConnectionHint) return;
        coreConnectionHint.textContent = message || '';
        coreConnectionHint.style.display = message ? '' : 'none';
        coreConnectionHint.classList.toggle('d-none', !message);
        coreConnectionHint.classList.remove('alert-info', 'alert-success', 'alert-warning', 'alert-danger');
        const klass = tone === 'success'
            ? 'alert-success'
            : tone === 'warning'
                ? 'alert-warning'
                : tone === 'danger'
                    ? 'alert-danger'
                    : 'alert-info';
        coreConnectionHint.classList.add(klass);
    };
    window.setCoreConnectionHint = setCoreConnectionHint;
    wireCoreConnectionSaveButton();
    // Do not persist passwords until validation succeeds.
    if (coreRememberInput && !coreRememberInput.dataset.prefBound) {
        coreRememberInput.addEventListener('change', () => {
            if (IS_BUILDER_VIEW) return;
            if (!coreConnectionModal) return;
            const sidx = parseInt(coreConnectionModal.getAttribute('data-scen-idx') || '', 10);
            if (isNaN(sidx) || !state.scenarios?.[sidx]) return;
            const hitlState = ensureHitlStateForScenario(state.scenarios[sidx]);
            hitlState.core.remember_credentials = !!coreRememberInput.checked;
            persistEditorState();
        });
        coreRememberInput.dataset.prefBound = '1';
    }
    if (coreAutoStartInput && !coreAutoStartInput.dataset.prefBound) {
        coreAutoStartInput.addEventListener('change', () => {
            if (IS_BUILDER_VIEW) return;
            if (!coreConnectionModal) return;
            const sidx = parseInt(coreConnectionModal.getAttribute('data-scen-idx') || '', 10);
            if (isNaN(sidx) || !state.scenarios?.[sidx]) return;
            const hitlState = ensureHitlStateForScenario(state.scenarios[sidx]);
            hitlState.core.auto_start_daemon = !!coreAutoStartInput.checked;
            persistEditorState();
        });
        coreAutoStartInput.dataset.prefBound = '1';
    }

    const bindCoreAdvToggle = (inputEl, fieldName) => {
        if (!inputEl || inputEl.dataset.prefBound) return;
        inputEl.addEventListener('change', () => {
            if (IS_BUILDER_VIEW) return;
            if (!coreConnectionModal) return;
            const sidx = parseInt(coreConnectionModal.getAttribute('data-scen-idx') || '', 10);
            if (isNaN(sidx) || !state.scenarios?.[sidx]) return;
            const hitlState = ensureHitlStateForScenario(state.scenarios[sidx]);
            hitlState.core[fieldName] = !!inputEl.checked;
            persistEditorState();
        });
        inputEl.dataset.prefBound = '1';
    };
    bindCoreAdvToggle(coreAdvFixDockerDaemonInput, 'adv_fix_docker_daemon');
    bindCoreAdvToggle(coreAdvRunCoreCleanupInput, 'adv_run_core_cleanup');
    bindCoreAdvToggle(coreAdvCheckCoreVersionInput, 'adv_check_core_version');
    bindCoreAdvToggle(coreAdvRestartCoreDaemonInput, 'adv_restart_core_daemon');
    bindCoreAdvToggle(coreAdvAutoKillSessionsInput, 'adv_auto_kill_sessions');
    document.querySelectorAll('[data-proxmox-assign]').forEach(btn => {
        btn.addEventListener('click', async () => {
            const sidx = parseInt(btn.getAttribute('data-scen-idx'));
            if (isNaN(sidx) || !state.scenarios?.[sidx]) return;
            if (!proxAssignModal || !window.bootstrap) {
                console.warn('Proxmox modal not available');
                return;
            }
            const scenario = state.scenarios[sidx];
            const hitlState = ensureHitlStateForScenario(scenario);
            const prox = hitlState.proxmox || { url: '', port: 8006, username: '' };
            const rememberCreds = shouldRememberProxmox(hitlState);
            proxAssignModal.setAttribute('data-scen-idx', String(sidx));
            const scenName = (scenario?.name || '').trim() || `Scenario ${sidx + 1}`;
            if (proxAssignError) {
                proxAssignError.textContent = '';
                proxAssignError.classList.add('d-none');
            }
            if (proxAssignForm) {
                proxAssignForm.classList.remove('was-validated');
            }
            if (proxVerifyInput) {
                if (typeof prox.verify_ssl === 'boolean') {
                    proxVerifyInput.checked = prox.verify_ssl;
                } else if (prox.url) {
                    proxVerifyInput.checked = /^https:/i.test(prox.url);
                } else {
                    proxVerifyInput.checked = true;
                }
            }
            const savedDefaults = getSavedProxmoxDefaults();
            const prefillUrl = prox.url || savedDefaults.url || '';
            const prefillPort = prox.port ?? savedDefaults.port ?? 8006;
            const prefillUsername = prox.username || savedDefaults.username || '';
            const prefillVerify = typeof prox.verify_ssl === 'boolean'
                ? prox.verify_ssl
                : (typeof savedDefaults.verify_ssl === 'boolean'
                    ? savedDefaults.verify_ssl
                    : (prefillUrl ? /^https:/i.test(prefillUrl) : true));
            if (proxUrlInput) proxUrlInput.value = prefillUrl;
            if (proxPortInput) proxPortInput.value = prefillPort;
            if (proxUserInput) proxUserInput.value = prefillUsername;
            if (proxPassInput) proxPassInput.value = '';
            if (proxVerifyInput) proxVerifyInput.checked = prefillVerify;
            if (proxRememberInput) {
                proxRememberInput.checked = rememberCreds;
            }
            let validatedStamp = 'a previous run';
            if (prox.last_validated_at) {
                try {
                    const dtTemp = new Date(prox.last_validated_at);
                    if (!Number.isNaN(dtTemp.getTime())) {
                        validatedStamp = dtTemp.toLocaleString();
                    }
                } catch (err) {
                    validatedStamp = 'a previous run';
                }
            }
            const msg = prox.validated && prox.secret_id
                ? `Validated on ${validatedStamp}. Re-enter password to re-validate.`
                : 'Enter credentials to validate and store securely.';
            const baseHintText = `Configure Proxmox resources for ${scenName}. ${msg}`;
            const baseHintTone = prox.validated && prox.secret_id ? 'success' : 'info';
            setProxAssignHint(baseHintText, baseHintTone);
            const modalObj = bootstrap.Modal.getInstance(proxAssignModal) || new bootstrap.Modal(proxAssignModal, { backdrop: true, keyboard: true });
            modalObj.show();
            setTimeout(() => {
                try {
                    proxUrlInput?.focus();
                    proxUrlInput?.select?.();
                } catch(e){}
            }, 150);
            const secretId = typeof prox.secret_id === 'string' ? prox.secret_id.trim() : '';
            if (secretId && rememberCreds) {
                setProxAssignHint(`Restoring saved Proxmox credentials for ${scenName}…`, 'info');
                try {
                    const storedCreds = await fetchStoredProxmoxCredentials(secretId);
                    if (storedCreds) {
                        if (proxUrlInput && typeof storedCreds.url === 'string') {
                            proxUrlInput.value = storedCreds.url;
                        }
                        if (proxPortInput && storedCreds.port !== undefined && storedCreds.port !== null) {
                            proxPortInput.value = storedCreds.port;
                        }
                        if (proxUserInput && typeof storedCreds.username === 'string') {
                            proxUserInput.value = storedCreds.username;
                        }
                        if (proxPassInput) {
                            proxPassInput.value = storedCreds.password || '';
                            proxPassInput.removeAttribute('placeholder');
                        }
                        if (proxVerifyInput && typeof storedCreds.verify_ssl === 'boolean') {
                            proxVerifyInput.checked = storedCreds.verify_ssl;
                        }
                        setProxAssignHint(`${baseHintText} Saved credentials loaded.`, 'success');
                    } else {
                        setProxAssignHint(`${baseHintText} Stored credentials unavailable; please re-enter`, 'warning');
                    }
                } catch (err) {
                    console.error('Failed to load stored Proxmox credentials', err);
                    setProxAssignHint(`${baseHintText} Failed to load stored credentials; please re-enter.`, 'warning');
                    if (proxPassInput) {
                        proxPassInput.value = '';
                        proxPassInput.placeholder = 'Enter password';
                    }
                }
            }
        });
    });
    document.querySelectorAll('[data-proxmox-clear]').forEach(btn => {
        btn.addEventListener('click', async () => {
            const sidx = parseInt(btn.getAttribute('data-scen-idx'));
            if (isNaN(sidx) || !state.scenarios?.[sidx]) return;
            const scenario = state.scenarios[sidx];
            const hitlState = ensureHitlStateForScenario(scenario);
            const prox = hitlState.proxmox || {};
            const hasAny = !!(prox.secret_id || prox.url || prox.username);
            if (!hasAny) {
                try { showToast('No Proxmox credentials to clear', { autohide: true, delay: 2000 }); } catch(e) {}
                return;
            }
            const confirmClear = window.confirm('Clear saved Proxmox credentials for this scenario?');
            if (!confirmClear) return;
            const originalLabel = btn.textContent;
            btn.disabled = true;
            btn.dataset.busy = 'true';
            btn.textContent = 'Clearing…';
            try {
                const resp = await fetch('/api/proxmox/clear', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    credentials: 'same-origin',
                    body: JSON.stringify({
                        scenario_index: sidx,
                        scenario_name: scenario?.name || '',
                        secret_id: prox.secret_id || null,
                    }),
                });
                let data = null;
                try { data = await resp.json(); } catch(err) { data = null; }
                if (!resp.ok || (data && data.success === false)) {
                    const message = (data && (data.error || data.message)) || `Failed to clear credentials (HTTP ${resp.status})`;
                    throw new Error(message);
                }
                hitlState.proxmox = {
                    url: '',
                    port: 8006,
                    username: '',
                    verify_ssl: true,
                    secret_id: null,
                    validated: false,
                    last_validated_at: null,
                    last_message: 'Proxmox credentials cleared.',
                };
                if (Array.isArray(hitlState.interfaces)) {
                    hitlState.interfaces = hitlState.interfaces.map(entry => {
                        if (!entry || typeof entry !== 'object') return entry;
                        if ('proxmox_target' in entry) {
                            delete entry.proxmox_target;
                        }
                        const attachment = entry.attachment ? normalizeHitlAttachment(entry.attachment) : '';
                        if (attachment === 'proxmox_vm') {
                            entry.attachment = DEFAULT_HITL_ATTACHMENT;
                        }
                        return entry;
                    });
                }
                persistEditorState();
                const hidden = document.getElementById('scenarios_json');
                if (hidden) hidden.value = JSON.stringify({ scenarios: state.scenarios, active_index: activeIdx });
                updateProxmoxSummary(sidx);
                renderMain();
                try { showToast('Proxmox credentials cleared', { autohide: true, delay: 2500 }); } catch(e) {}
                logInfo('Cleared Proxmox credentials for scenario');
            } catch (err) {
                const message = err instanceof Error ? err.message : 'Failed to clear Proxmox credentials';
                logError(message);
                try { showToast(message, { autohide: false }); } catch(e) {}
            } finally {
                btn.disabled = false;
                btn.textContent = originalLabel || 'Clear Proxmox Resource';
                delete btn.dataset.busy;
            }
        });
    });
    // Export preview handler
    const previewBtn = document.querySelector('[data-action="preview-plan"]');
    if (previewBtn) {
        previewBtn.onclick = () => {
            const scen = state.scenarios[activeIdx];
            if (!scen) return;
            const ni = scen.sections['Node Information'] || { items: [], total_nodes:0 };
            const weightRows = (ni.items||[]).filter(it => (it.v_metric || (it.selected==='Specific'? 'Count':'Weight'))==='Weight');
            const countRows = (ni.items||[]).filter(it => (it.v_metric || (it.selected==='Specific'? 'Count':'Weight'))==='Count');
            const base = weightRows.length ? (parseInt(scen.density_count || 0) || 0) : 0;
            const addHosts = countRows.reduce((a,it)=> a + (parseInt(it.v_count,10)||0),0);
            const totalHosts = base + addHosts;
            let allocTable = [];
            if (base>0 && weightRows.length) {
                const sumW = weightRows.reduce((a,it)=> a + (parseFloat(it.factor)||0),0) || 1;
                const temp = weightRows.map(it => {
                    const f = parseFloat(it.factor)||0; const share = sumW? f/sumW:0; const raw = base*share; const alloc = Math.floor(raw);
                    return { it, share, raw, alloc, frac: raw - alloc };
                });
                let assigned = temp.reduce((a,r)=> a + r.alloc,0);
                let remain = base - assigned;
                temp.sort((a,b)=> b.frac - a.frac);
                for (let i=0;i<temp.length && remain>0;i++) { temp[i].alloc += 1; remain--; }
                allocTable = temp.sort((a,b)=> (ni.items.indexOf(a.it) - ni.items.indexOf(b.it))).map(r => ({ label: r.it.selected || 'Row', weight: (parseFloat(r.it.factor)||0), percent: (r.share*100), alloc: r.alloc }));
            }
            const routing = scen.sections['Routing'] || { items: [], density: 0 };
            const rWeight = (routing.items||[]).filter(it => (it.v_metric||'Weight')==='Weight');
            const rCount = (routing.items||[]).filter(it => (it.v_metric||'Weight')==='Count');
            const rExplicit = rCount.reduce((a,it)=> a + (parseInt(it.v_count,10)||0),0);
            let rDerived = 0; if (rWeight.length) { const d = parseFloat(routing.density)||0; rDerived = (d>=1)? d : Math.round((totalHosts - addHosts) * d); }
            const totalRouters = rExplicit + rDerived;
            const vulns = scen.sections['Vulnerabilities'] || { items: [], density: 0 };
            const vWeight = (vulns.items||[]).filter(it => (it.v_metric || (it.selected==='Specific'?'Count':'Weight'))==='Weight');
            const vCount = (vulns.items||[]).filter(it => (it.v_metric || (it.selected==='Specific'?'Count':'Weight'))==='Count');
            const vExplicit = vCount.reduce((a,it)=> a + (parseInt(it.v_count,10)||0),0);
            let vDerived = 0; if (vWeight.length) { const d = Math.min(1, Math.max(0, parseFloat(vulns.density)||0)); vDerived = Math.round((totalHosts - addHosts) * d); }
            const totalVulns = vExplicit + vDerived;
            const rowsHtml = allocTable.length ? allocTable.map(r => `<tr><td>${r.label}</td><td>${r.weight.toFixed(3)}</td><td>${r.percent.toFixed(1)}%</td><td>${r.alloc}</td></tr>`).join('') : '<tr><td colspan="4" class="text-muted">No weight allocation</td></tr>';
            const modalHtml = `
<div class=\"modal fade\" id=\"previewModal\" tabindex=\"-1\" aria-hidden=\"true\">\n  <div class=\"modal-dialog modal-lg modal-dialog-scrollable\">\n    <div class=\"modal-content\">\n      <div class=\"modal-header\">\n        <h5 class=\"modal-title\">Plan Preview: ${scen.name}</h5>\n        <button type=\"button\" class=\"btn-close\" data-bs-dismiss=\"modal\" aria-label=\"Close\"></button>\n      </div>\n      <div class=\"modal-body\">\n        <div class=\"progress mb-3 d-none\" id=\"previewExecuteProgress\">\n          <div class=\"progress-bar progress-bar-striped progress-bar-animated\" id=\"previewExecuteProgressBar\" style=\"width:100%\">Running…</div>\n        </div>\n        <div class=\"row mb-3\">\n          <div class=\"col-md-4\"><div class=\"card card-body p-2\"><small class=\"text-muted\">Hosts Total</small><div class=\"fs-5\">${totalHosts}</div><div class=\"small text-muted\">Base ${base} + Add ${addHosts}</div></div></div>\n          <div class=\"col-md-4\"><div class=\"card card-body p-2\"><small class=\"text-muted\">Routers</small><div class=\"fs-5\">${totalRouters}</div><div class=\"small text-muted\">Explicit ${rExplicit} + Derived ${rDerived}</div></div></div>\n          <div class=\"col-md-4\"><div class=\"card card-body p-2\"><small class=\"text-muted\">Vulns</small><div class=\"fs-5\">${totalVulns}</div><div class=\"small text-muted\">Explicit ${vExplicit} + Derived ${vDerived}</div></div></div>\n        </div>\n        <h6>Host Weight Allocation</h6>\n        <div class=\"table-responsive\">\n          <table class=\"table table-sm\">\n            <thead><tr><th>Row</th><th>Weight</th><th>%</th><th>Alloc</th></tr></thead>\n            <tbody>${rowsHtml}</tbody>\n          </table>\n        </div>\n      </div>\n      <div class=\"modal-footer\">\n        <button type=\"button\" class=\"btn btn-sm btn-warning\" id=\"previewModalExecuteBtn\">Execute</button>\n        <button type=\"button\" class=\"btn btn-sm btn-outline-secondary\" data-bs-dismiss=\"modal\">Close</button>\n      </div>\n    </div>\n  </div>\n</div>`;
            let container = document.getElementById('previewModalContainer');
            if (!container) { container = document.createElement('div'); container.id = 'previewModalContainer'; document.body.appendChild(container); }
            container.innerHTML = modalHtml;
            const modalEl = container.querySelector('#previewModal');
            let modalInstance = null;
            if (window.bootstrap) {
                try {
                    modalInstance = new bootstrap.Modal(modalEl);
                } catch(e) {
                    alert('Bootstrap modal failed; see console');
                    console.error(e);
                }
            } else {
                alert('Bootstrap not loaded.');
            }
            setupPreviewModalExecute(modalEl, modalInstance);
            try { modalInstance?.show(); } catch(e) {}
        };
    }
    // Initialize popovers & tooltips (Bootstrap 5)
    if (window.bootstrap) {
        document.querySelectorAll('[data-bs-toggle="popover"]').forEach(el => { try { new bootstrap.Popover(el); } catch(e) {} });
        document.querySelectorAll('[data-bs-toggle="tooltip"]').forEach(el => { try { new bootstrap.Tooltip(el); } catch(e) {} });
    }
    // Flash animation on Base input change
    document.querySelectorAll('.base-input').forEach(inp => {
        inp.addEventListener('change', () => {
            const badge = document.querySelector('.host-total-badge');
            if (!badge) return;
            badge.classList.add('pulse-change');
            setTimeout(()=> badge.classList.remove('pulse-change'), 900);
        });
    });
    document.querySelectorAll('[data-action="remove-scenario"]').forEach(btn => {
        btn.onclick = async (ev) => {
            if (ev && typeof ev.preventDefault === 'function') ev.preventDefault();
            if (ev && typeof ev.stopPropagation === 'function') ev.stopPropagation();
            const sidx = parseInt(btn.getAttribute('data-scen-idx'));
            const scen = state.scenarios[sidx];
            if (!scen) { return; }
            let runCount = 0;
            try {
                const resp = await fetch('/reports_data');
                if (resp.ok) {
                    const data = await resp.json();
                    runCount = (data.history || []).filter(r => (r.scenario_names || []).includes(scen.name)).length;
                }
            } catch (e) {}
            const lines = [];
            lines.push(`Delete scenario "${scen.name}"?`);
            if (runCount > 0) {
                lines.push("");
                lines.push(`WARNING: ${runCount} run history entr${runCount===1?'y':'ies'} and their artifact files (XML, report, pre-session XML) will be permanently deleted.`);
            }
            lines.push("");
            lines.push("This action cannot be undone.");
            lines.push("");
            lines.push("Proceed?");
            const msg = lines.join('\n');
            if (!window.confirm(msg)) { return; }

            const deletedName = (scen.name && String(scen.name).trim()) ? String(scen.name).trim() : `Scenario ${sidx+1}`;
            const deletedSid = (scen && scen._sid !== undefined && scen._sid !== null) ? String(scen._sid) : '';

            try {
                rememberDeletedScenarioMarks({
                    ids: deletedSid ? [deletedSid] : [],
                    names: deletedName ? [deletedName] : [],
                });
                logInfo(`Marked deleted tombstone: ${deletedName}`);
            } catch (e) {}

            // Remove scenario
            state.scenarios.splice(sidx, 1);
            // Leave list empty if last scenario removed
            activeIdx = state.scenarios.length === 0 ? 0 : Math.min(sidx, state.scenarios.length - 1);
            // Persist immediately before re-render so state survives any navigation
            const hidden = document.getElementById('scenarios_json');
            if (hidden) hidden.value = JSON.stringify({ scenarios: state.scenarios });
            persistEditorState();
            logInfo(`Deleted scenario: ${scen.name}`);
            // Ensure server-side editor snapshot is updated immediately so a quick refresh
            // cannot resurrect deleted scenarios.
            try {
                if (typeof flushServerSnapshotPersistNow === 'function') {
                    const snapRes = await flushServerSnapshotPersistNow();
                    if (snapRes && snapRes.ok === false) {
                        try { showToast(`Warning: server snapshot not updated (${snapRes.error || 'unknown error'}). Deleted scenarios may reappear on refresh.`, { autohide: true, delay: 5000 }); } catch (_) {}
                    }
                }
            } catch (e) {
                try { showToast('Warning: failed to flush server snapshot; deleted scenarios may reappear on refresh.', { autohide: true, delay: 5000 }); } catch (_) {}
            }
            // Re-render UI
            render();
            try { showToast(`Scenario "${scen.name}" deleted`); } catch(e){}

            // Persist deletion across refresh.
            try {
                if (deletedName) {
                    const res = await fetch('/delete_scenarios', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        credentials: 'same-origin',
                        body: JSON.stringify({ names: [deletedName] })
                    });
                    let payload = null;
                    try { payload = await res.clone().json(); } catch (e) { payload = null; }
                    if (!res.ok || (payload && payload.ok === false)) {
                        const detail = (payload && (payload.error || payload.message))
                            ? String(payload.error || payload.message)
                            : (() => { try { return res.status ? ('HTTP ' + res.status) : 'HTTP error'; } catch (_) { return 'HTTP error'; } })();
                        try { showToast(`Warning: delete_scenarios failed (${detail}).`, { autohide: true, delay: 6000 }); } catch (_) {}
                    } else if (payload && typeof payload === 'object') {
                        const artifacts = Number(payload.artifacts_removed) || 0;
                        const snapRemoved = Number(payload.snapshot_scenarios_removed) || 0;
                        const snapUpdated = Number(payload.snapshots_updated) || 0;
                        const snapDeleted = Number(payload.snapshots_deleted) || 0;
                        const historyRemoved = Number(payload.history_removed) || 0;
                        const msg = `Server delete persisted: artifacts_removed=${artifacts}, snapshot_scenarios_removed=${snapRemoved}, snapshots_updated=${snapUpdated}, snapshots_deleted=${snapDeleted}, history_removed=${historyRemoved}`;
                        try { logInfo(msg); } catch (e) {}
                        try { showToast(msg, { autohide: true, delay: 6000 }); } catch (_) {}
                    }
                }
            } catch (e) {
                try { showToast('Warning: server catalog delete failed. Deleted scenarios may reappear on refresh.', { autohide: true, delay: 5000 }); } catch (_) {}
            }
            try {
                await autoSaveXml();
            } catch (e) {
                try { showToast('Warning: delete was not persisted (save failed).', { autohide: true, delay: 5000 }); } catch (_) {}
            }

            // Purge matching run history and artifacts in background
            if (runCount > 0) {
                try {
                    await fetch('/purge_history_for_scenario', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ name: scen.name })
                    });
                } catch (e) {}
            }
        };
    });
    // keep hidden JSON synced
    const aiHidden = document.getElementById('active_index'); if(aiHidden) aiHidden.value = String(activeIdx);
    document.getElementById('scenarios_json').value = JSON.stringify({ scenarios: state.scenarios, active_index: activeIdx });
    persistEditorState();
        // Initialize warnings per section
        const scen = state.scenarios[activeIdx];
        if (scen) {
            ['Node Information','Routing','Services','Traffic','Events','Vulnerabilities','Segmentation'].forEach(sec => updateWeightWarning(activeIdx, sec));
        }
}
// Routing edges validation utilities
function validateRoutingEdges(){
    const scen = state.scenarios[activeIdx]; if(!scen) return;
    const routing = (scen.sections && scen.sections['Routing'] && scen.sections['Routing'].items) || [];
    const warn = [];
    routing.forEach((r,i)=>{ const m = r.r2r_mode; if(m==='Exact' && !(r.edges>=1)) warn.push(`Row ${i+1}: Exact mode requires a degree ≥ 1`); });
    routing.forEach((r,i)=>{ if(r.r2s_mode==='Exact' && !(r.r2s_edges>=1)) warn.push(`Row ${i+1}: R-to-S Exact requires a value ≥ 1`); });
    // Highlight inputs
    document.querySelectorAll('.edges-degree-input').forEach(inp => {
        const v = parseInt(inp.value,10); const tr = inp.closest('tr');
    const sel = tr ? tr.querySelector('[data-field="r2r_mode"]') : null;
        const mode = sel ? sel.value : '';
        if(mode==='Exact' && !(v>=1)) inp.classList.add('is-invalid'); else inp.classList.remove('is-invalid');
    });
    document.querySelectorAll('.r2s-degree-input').forEach(inp => {
        const v = parseInt(inp.value,10); const tr = inp.closest('tr');
        const sel = tr ? tr.querySelector('[data-field="r2s_mode"]') : null;
        const mode = sel ? sel.value : '';
        if(mode==='Exact' && !(v>=1)) inp.classList.add('is-invalid'); else inp.classList.remove('is-invalid');
    });
    // If a separate warning container existed we could populate it here later.
    computeRoutingEdgePolicyPreview();
}
setTimeout(validateRoutingEdges, 500);

// Derive a lightweight preview (pre-generation) of intended policy and an estimated degree band
function computeRoutingEdgePolicyPreview(){
    const scen = state.scenarios[activeIdx]; if(!scen) return;
    const routing = (scen.sections && scen.sections['Routing'] && scen.sections['Routing'].items) || [];
    const summaryEl = document.getElementById('routingEdgesSummary');
    if(!summaryEl) return;
    if(!routing.length){ summaryEl.style.display='none'; return; }
    // Make sure the preview is visible once we have routing rows.
    summaryEl.style.display = 'flex';
    // Determine target policy: Exact avg > Max > Min > Random (mirrors backend)
    const exactVals = routing.filter(r=> r.r2r_mode==='Exact' && r.edges>=1).map(r=>r.edges);
    let mode='Random'; let target=0;
    if(exactVals.length){
        target = Math.round(exactVals.reduce((a,b)=>a+b,0)/exactVals.length);
        if(target<1) target=1; mode='Exact';
    } else {
    const modes = routing.map(r=> r.r2r_mode).filter(Boolean);
    if(modes.includes('Uniform')) mode='Uniform';
        else if(modes.includes('Min')) mode='Min';
        else if(modes.includes('NonUniform')) mode='NonUniform';
        else mode='Random';
    }
    // Determine predominant R-to-S mode (simple precedence similar to R-to-R)
    let r2sMode = 'Random';
    const r2sExactVals = routing.filter(r=>r.r2s_mode==='Exact' && r.r2s_edges>=1).map(r=>r.r2s_edges);
    if(r2sExactVals.length){
        r2sMode = 'Exact';
    } else {
        const r2sModes = routing.map(r=>r.r2s_mode).filter(Boolean);
    if(r2sModes.includes('Uniform')) r2sMode='Uniform';
        else if(r2sModes.includes('Min')) r2sMode='Min';
        else if(r2sModes.includes('NonUniform')) r2sMode='NonUniform';
        else r2sMode='Random';
    }
    const policySpan = summaryEl.querySelector('[data-role="edges-policy"]');
    if(policySpan){ policySpan.textContent = `R-R: ${mode}${mode==='Exact'?`(≈${target})`:''} | R-S: ${r2sMode}`; }
    // Estimate degree distribution preview (pure heuristic):
    let minD=0, avgD=0, maxD=0;
    if(mode==='Exact'){ minD=target; avgD=target+1; maxD=target+2; }
    else if(mode==='Uniform'){ minD=4; avgD=4; maxD=5; }
    else if(mode==='NonUniform'){ minD=1; avgD=3; maxD=8; }
    else if(mode==='Min'){ minD=2; avgD=3; maxD=4; }
    else { minD=1; avgD=2; maxD=4; }
    // Removed Min/Avg/Max and sparkline visualization per request
    // Resource warning for Uniform (previously Max) mode – still warn if near-dense
	const warnEl = document.getElementById('routingEdgesWarnings');
	if(warnEl){
	    warnEl.classList.add('d-none');
	    warnEl.innerHTML='';
        if(mode==='Uniform'){
	        // Approximate router count: we don't know exact until build; use routing item count as lower bound
	        let approxRouters = routing.length || 0;
	        // If scenario embeds an explicit router count in future, prefer it; attempt common field names
	        if(typeof scen.router_count === 'number' && scen.router_count > approxRouters) approxRouters = scen.router_count;
	        if(typeof scen.routers_total === 'number' && scen.routers_total > approxRouters) approxRouters = scen.routers_total;
	        // Compute full mesh edges estimate
	        const estEdges = approxRouters > 1 ? (approxRouters * (approxRouters - 1) / 2) : 0;
	        // Thresholds: warn if routers >= 25 OR estimated edges >= 300
	        if(approxRouters >= 25 || estEdges >= 300){
	            const edgesFmt = estEdges.toLocaleString();
                warnEl.innerHTML = `<strong>Uniform Mode:</strong> balanced high degree connectivity can grow ~O(n²). With ~${approxRouters} routers this implies about ${edgesFmt} potential links. This may increase session startup time and resource usage.`;
	            warnEl.classList.remove('d-none');
	        } else {
	            // Light advisory (still show something so users understand cost) for smaller counts
	            if(approxRouters >= 10){
                    warnEl.innerHTML = `<strong>Heads up:</strong> Uniform mode aims for evenly high degrees (approaches dense graph). Routers: ~${approxRouters}.`;
	                warnEl.classList.remove('d-none');
	            }
	        }
	    }
	}
    summaryEl.style.display='flex';
}

function prepareRunCli() {
    // prefer the last saved XML path or result_path if it's XML
    const rp = state.result_path || '';
    if (!rp.endsWith('.xml')) {
        alert('Please save XML first.');
        logWarn('Run CLI blocked: no saved XML');
        return false;
    }
    // confirmation dialog warning user a CORE scenario will be created and started
    const confirmMsg = 'This action will generate a new CORE scenario and attempt to start it using the provided daemon connection.\n\nProceed?';
    if (!window.confirm(confirmMsg)) {
        logInfo('Run CLI cancelled by user at confirmation');
        return false;
    }
    document.getElementById('xml_path').value = rp;
    logInfo('Running CLI sync');
    // Preserve scroll so after the round trip we land where we were
    try { saveScrollBeforeNav(); } catch(e){}
    return true;
}

let coreConnectionModal = null;
let coreConnectionForm = null;
let coreConnectionHint = null;
let coreConnectionSaveBtn = null;
let coreRememberInput = null;
let coreAutoStartInput = null;
let coreAdvFixDockerDaemonInput = null;
let coreAdvRunCoreCleanupInput = null;
let coreAdvCheckCoreVersionInput = null;
let coreAdvRestartCoreDaemonInput = null;
let coreAdvAutoKillSessionsInput = null;
let coreTestVenvBtn = null;
let coreVenvTestStatus = null;
const coreModalInputs = {
    grpc_host: null,
    grpc_port: null,
    ssh_host: null,
    ssh_port: null,
    ssh_username: null,
    ssh_password: null,
    venv_bin: null,
};
let executeConfirmModalEl = null;
let executeConfirmMessageEl = null;
let executeConfirmAlertEl = null;
let executeConfirmRunBtn = null;
let executeConfirmCancelBtn = null;
let executeCoreStatusEl = null;
let executeCoreTestBtn = null;
let executeRemoteTestRow = null;
let executeCoreNotConfiguredRow = null;
let executeSelectCoreVmBtn = null;
let executeConfirmPushUpdateToggle = null;
let executePushUpdateWrap = null;
let executeConfirmPushUpdateHelpEl = null;
let executeAdvancedWrap = null;
let executeAdvFixDockerDaemon = null;
let executeAdvRunCoreCleanup = null;
let executeAdvCheckCoreVersion = null;
let executeAdvRestartCoreDaemon = null;
let executeAdvStartCoreDaemon = null;
let executeAdvAutoKillSessions = null;
let executeAdvDockerCleanupBeforeRun = null;
let executeAdvDockerNukeAll = null;
let executeAdvUploadOnlyInjectedArtifacts = null;
const EXECUTE_CONFIRM_PREFS_STORAGE_KEY = 'coretg_execute_confirm_prefs';

function loadExecuteConfirmPrefs() {
    if (typeof window === 'undefined' || !window.localStorage) {
        return {};
    }
    try {
        const raw = localStorage.getItem(EXECUTE_CONFIRM_PREFS_STORAGE_KEY);
        if (!raw) {
            return {};
        }
        const parsed = JSON.parse(raw);
        return parsed && typeof parsed === 'object' ? parsed : {};
    } catch (err) {
        return {};
    }
}

let executeConfirmPrefs = loadExecuteConfirmPrefs();

function persistExecuteConfirmPrefs() {
    if (typeof window === 'undefined' || !window.localStorage) {
        return;
    }
    try {
        localStorage.setItem(EXECUTE_CONFIRM_PREFS_STORAGE_KEY, JSON.stringify(executeConfirmPrefs || {}));
    } catch (err) { /* ignore */ }
}

function getExecuteConfirmUpdateRemotePref() {
    return !!(executeConfirmPrefs && executeConfirmPrefs.updateRemoteRepo);
}

function setExecuteConfirmUpdateRemotePref(value) {
    if (!executeConfirmPrefs || typeof executeConfirmPrefs !== 'object') {
        executeConfirmPrefs = {};
    }
    executeConfirmPrefs.updateRemoteRepo = !!value;
    persistExecuteConfirmPrefs();
}

function getExecuteConfirmUploadOnlyInjectedArtifactsPref() {
    // Default to true to minimize remote uploads.
    if (!executeConfirmPrefs || typeof executeConfirmPrefs !== 'object') {
        return true;
    }
    if (executeConfirmPrefs.uploadOnlyInjectedArtifacts === undefined) {
        return true;
    }
    return !!executeConfirmPrefs.uploadOnlyInjectedArtifacts;
}

function setExecuteConfirmUploadOnlyInjectedArtifactsPref(value) {
    if (!executeConfirmPrefs || typeof executeConfirmPrefs !== 'object') {
        executeConfirmPrefs = {};
    }
    executeConfirmPrefs.uploadOnlyInjectedArtifacts = !!value;
    persistExecuteConfirmPrefs();
}

function isRemoteExecutionSelected() {
    // Execute Confirm modal no longer provides a remote/local toggle.
    // Executions from this dialog always target the configured remote CORE VM.
    return true;
}

function getExecuteConfirmSelections() {
    const remoteExecution = true;
    const pushAllowed = !IS_BUILDER_VIEW;
    const pushEnabled = pushAllowed && (
        executeConfirmPushUpdateToggle
            ? !!executeConfirmPushUpdateToggle.checked
            : getExecuteConfirmUpdateRemotePref()
    );
    const advanced = {
        fixDockerDaemon: remoteExecution && !!(executeAdvFixDockerDaemon && executeAdvFixDockerDaemon.checked),
        runCoreCleanup: remoteExecution && !!(executeAdvRunCoreCleanup && executeAdvRunCoreCleanup.checked),
        dockerCleanupBeforeRun: remoteExecution && !!(executeAdvDockerCleanupBeforeRun && executeAdvDockerCleanupBeforeRun.checked),
        dockerNukeAll: remoteExecution && !!(executeAdvDockerNukeAll && executeAdvDockerNukeAll.checked),
        checkCoreVersion: remoteExecution && !!(executeAdvCheckCoreVersion && executeAdvCheckCoreVersion.checked),
        restartCoreDaemon: remoteExecution && !!(executeAdvRestartCoreDaemon && executeAdvRestartCoreDaemon.checked),
        startCoreDaemon: remoteExecution && !!(executeAdvStartCoreDaemon && executeAdvStartCoreDaemon.checked),
        autoKillSessions: remoteExecution && !!(executeAdvAutoKillSessions && executeAdvAutoKillSessions.checked),
        uploadOnlyInjectedArtifacts: remoteExecution && (
            executeAdvUploadOnlyInjectedArtifacts
                ? !!executeAdvUploadOnlyInjectedArtifacts.checked
                : getExecuteConfirmUploadOnlyInjectedArtifactsPref()
        ),
    };
    return {
        remoteExecution,
        pushPreference: pushAllowed ? pushEnabled : false,
        updateRemote: pushAllowed && pushEnabled,
        advanced,
    };
}

const executeConfirmState = {
    pending: false,
    resolve: null,
    scenarioIndex: null,
    keepOpenOnConfirm: false,
    autoLabel: true,
    coreTestFailed: false,
};
let executeProgressWrap = null;
let executeProgressStatusEl = null;
let executeProgressMetaEl = null;
let executeProgressBarEl = null;
let executeProgressLogEl = null;
let executeProgressSpinnerEl = null;
let executeProgressPopoutBtn = null;
let executeProgressCancelBtn = null;
let executePhaseHeaderEl = null;
const executeProgressState = {
    active: false,
    logLines: [],
    maxLines: 300,
    runId: null,
    heartbeatTimer: null,
    heartbeatIndex: 0,
    cancelRequested: false,
    done: false,
    cancelHandlers: [],
};
let setCoreConnectionHint = null;

// If the browser throws during execution flow, surface it in the Execute progress panel
// so users aren't left with only heartbeat messages.
if (!window.__coretg_exec_error_hooked) {
    window.__coretg_exec_error_hooked = true;
    window.addEventListener('error', (ev) => {
        try {
            if (!executeProgressState || !executeProgressState.active) return;
            const msg = ev?.message || 'Unknown error';
            appendExecuteProgressLog(`[ui] JS error: ${msg}`);
        } catch (e) {}
    });
    window.addEventListener('unhandledrejection', (ev) => {
        try {
            if (!executeProgressState || !executeProgressState.active) return;
            const reason = ev?.reason;
            const msg = (reason && (reason.message || String(reason))) || 'Unhandled promise rejection';
            appendExecuteProgressLog(`[ui] JS unhandled rejection: ${msg}`);
        } catch (e) {}
    });
}

function ensureExecuteConfirmElements() {
    if (!executeConfirmModalEl) {
        executeConfirmModalEl = document.getElementById('executeConfirmModal');
    }
    if (!executeConfirmMessageEl) {
        executeConfirmMessageEl = document.getElementById('executeConfirmMessage');
    }
    if (!executeConfirmAlertEl) {
        executeConfirmAlertEl = document.getElementById('executeConfirmAlert');
    }
    if (!executeConfirmRunBtn) {
        executeConfirmRunBtn = document.getElementById('executeConfirmRunBtn');
    }
    if (!executeConfirmCancelBtn) {
        executeConfirmCancelBtn = document.getElementById('executeConfirmCancelBtn');
    }
    if (!executePhaseHeaderEl) {
        executePhaseHeaderEl = document.getElementById('executePhaseHeader');
    }
    if (!executeCoreStatusEl) {
        executeCoreStatusEl = document.getElementById('executeCoreStatus');
    }
    if (!executeCoreTestBtn) {
        executeCoreTestBtn = document.getElementById('executeCoreTestBtn');
    }
    if (!executeRemoteTestRow) {
        executeRemoteTestRow = document.getElementById('executeCoreTestRow');
    }
    if (!executeCoreNotConfiguredRow) {
        executeCoreNotConfiguredRow = document.getElementById('executeCoreNotConfiguredRow');
    }
    if (!executeSelectCoreVmBtn) {
        executeSelectCoreVmBtn = document.getElementById('executeSelectCoreVmBtn');
    }
    if (!executePushUpdateWrap) {
        executePushUpdateWrap = document.getElementById('executePushUpdateToggleWrap');
    }
    if (!executeConfirmPushUpdateToggle) {
        executeConfirmPushUpdateToggle = document.getElementById('executeConfirmPushUpdateToggle');
    }
    if (!executeConfirmPushUpdateHelpEl) {
        executeConfirmPushUpdateHelpEl = document.getElementById('executeConfirmPushUpdateHelp');
    }
    if (!executeAdvancedWrap) {
        executeAdvancedWrap = document.getElementById('executeAdvancedWrap');
    }
    if (!executeAdvFixDockerDaemon) {
        executeAdvFixDockerDaemon = document.getElementById('executeAdvFixDockerDaemon');
    }
    if (!executeAdvRunCoreCleanup) {
        executeAdvRunCoreCleanup = document.getElementById('executeAdvRunCoreCleanup');
    }
    if (!executeAdvDockerCleanupBeforeRun) {
        executeAdvDockerCleanupBeforeRun = document.getElementById('executeAdvDockerCleanupBeforeRun');
    }
    if (!executeAdvDockerNukeAll) {
        executeAdvDockerNukeAll = document.getElementById('executeAdvDockerNukeAll');
    }
    if (!executeAdvCheckCoreVersion) {
        executeAdvCheckCoreVersion = document.getElementById('executeAdvCheckCoreVersion');
    }
    if (!executeAdvRestartCoreDaemon) {
        executeAdvRestartCoreDaemon = document.getElementById('executeAdvRestartCoreDaemon');
    }
    if (!executeAdvStartCoreDaemon) {
        executeAdvStartCoreDaemon = document.getElementById('executeAdvStartCoreDaemon');
    }
    if (!executeAdvAutoKillSessions) {
        executeAdvAutoKillSessions = document.getElementById('executeAdvAutoKillSessions');
    }
    if (!executeAdvUploadOnlyInjectedArtifacts) {
        executeAdvUploadOnlyInjectedArtifacts = document.getElementById('executeAdvUploadOnlyInjectedArtifacts');
    }
    // Make dialog controls togglable (global function)
    if (typeof window.setExecuteDialogControlsEnabled !== 'function') {
        window.setExecuteDialogControlsEnabled = function(enabled) {
            try {
                const disable = !enabled;
                const controls = [
                    executeCoreTestBtn,
                    executeSelectCoreVmBtn,
                    executeConfirmPushUpdateToggle,
                    executeAdvFixDockerDaemon,
                    executeAdvRunCoreCleanup,
                    executeAdvDockerCleanupBeforeRun,
                    executeAdvDockerNukeAll,
                    executeAdvCheckCoreVersion,
                    executeAdvRestartCoreDaemon,
                    executeAdvStartCoreDaemon,
                    executeAdvAutoKillSessions,
                    executeAdvUploadOnlyInjectedArtifacts,
                ];
                controls.forEach(el => { if (el) { el.disabled = disable; } });
                ['executeCoreTestRow', 'executeCoreNotConfiguredRow', 'executeAdvancedWrap', 'executePushUpdateToggleWrap']
                    .forEach(id => {
                        const container = document.getElementById(id);
                        if (container) {
                            container.querySelectorAll('input, button, select, textarea').forEach(el => { el.disabled = disable; });
                        }
                    });
            } catch (e) { /* ignore */ }
        };
    }
    if (executeConfirmRunBtn && !executeConfirmRunBtn.dataset.execBound) {
        executeConfirmRunBtn.addEventListener('click', async () => {
            if (executeConfirmRunBtn.disabled) {
                return;
            }
            const ready = await ensureBuilderCoreReadyForExecute();
            if (!ready) {
                return;
            }
            // Make Remote CORE Connection and Advanced sections read-only during execution.
            try { window.setExecuteDialogControlsEnabled(false); } catch(e){}
            const stayOpen = !!executeConfirmState.keepOpenOnConfirm;
            settleExecuteConfirm({ confirmed: true });
            if (!stayOpen) {
                try {
                    if (executeConfirmModalEl && window.bootstrap) {
                        bootstrap.Modal.getOrCreateInstance(executeConfirmModalEl).hide();
                    }
                } catch (err) { /* ignore */ }
            }
        });
        executeConfirmRunBtn.dataset.execBound = '1';
    }
    if (executeConfirmCancelBtn && !executeConfirmCancelBtn.dataset.execBound) {
        executeConfirmCancelBtn.addEventListener('click', () => {
            settleExecuteConfirm({ confirmed: false });
        });
        executeConfirmCancelBtn.dataset.execBound = '1';
    }
    if (executeConfirmPushUpdateToggle && !executeConfirmPushUpdateToggle.dataset.execBound) {
        executeConfirmPushUpdateToggle.checked = getExecuteConfirmUpdateRemotePref();
        executeConfirmPushUpdateToggle.addEventListener('change', () => {
            setExecuteConfirmUpdateRemotePref(executeConfirmPushUpdateToggle.checked);
            refreshExecuteRemoteToggleState();
        });
        executeConfirmPushUpdateToggle.dataset.execBound = '1';
    }
    if (executeAdvUploadOnlyInjectedArtifacts && !executeAdvUploadOnlyInjectedArtifacts.dataset.execBound) {
        executeAdvUploadOnlyInjectedArtifacts.checked = getExecuteConfirmUploadOnlyInjectedArtifactsPref();
        executeAdvUploadOnlyInjectedArtifacts.addEventListener('change', () => {
            setExecuteConfirmUploadOnlyInjectedArtifactsPref(executeAdvUploadOnlyInjectedArtifacts.checked);
        });
        executeAdvUploadOnlyInjectedArtifacts.dataset.execBound = '1';
    }
    if (executeCoreTestBtn && !executeCoreTestBtn.dataset.execBound) {
        executeCoreTestBtn.addEventListener('click', () => {
            handleExecuteCoreTestClick();
        });
        executeCoreTestBtn.dataset.execBound = '1';
    }
    if (executeSelectCoreVmBtn && !executeSelectCoreVmBtn.dataset.execBound) {
        executeSelectCoreVmBtn.addEventListener('click', () => {
            try {
                if (executeConfirmModalEl && window.bootstrap) {
                    bootstrap.Modal.getOrCreateInstance(executeConfirmModalEl).hide();
                }
                if (typeof window.openCoreVmSelectModal === 'function') {
                    window.openCoreVmSelectModal();
                }
            } catch (err) { /* ignore */ }
        });
        executeSelectCoreVmBtn.dataset.execBound = '1';
    }
    if (executeConfirmModalEl && !executeConfirmModalEl.dataset.execHiddenBound) {
        executeConfirmModalEl.addEventListener('hidden.bs.modal', () => {
            // If the modal is closed while a run is in progress, treat it as a cancel.
            // Otherwise there is no way to cancel after closing.
            try {
                if (executeProgressState && executeProgressState.active && !executeProgressState.done) {
                    requestExecuteCancel('Modal closed');
                }
            } catch (e) {}
            settleExecuteConfirm({ confirmed: false });
            // Clear any per-open error messaging so reopening the modal starts clean.
            executeConfirmState.coreTestFailed = false;
            resetExecuteProgressUI();
            // Do not re-enable controls here; they stay disabled until run completion.
        });
        executeConfirmModalEl.dataset.execHiddenBound = '1';
    }
    if (executeConfirmModalEl && !executeConfirmModalEl.dataset.execShowBound) {
        executeConfirmModalEl.addEventListener('show.bs.modal', () => {
            resetExecuteProgressUI();
            executeConfirmState.coreTestFailed = false;
            refreshExecuteRemoteToggleState();
        });
        executeConfirmModalEl.dataset.execShowBound = '1';
    }
}

function isExecuteCoreVmConfigured() {
    if (IS_BUILDER_VIEW) return true;
    try {
        const scenarioIdx = Number.isInteger(executeConfirmState?.scenarioIndex)
            ? executeConfirmState.scenarioIndex
            : getActiveScenarioContext().idx;
        if (!Number.isInteger(scenarioIdx)) return false;
        const scen = state?.scenarios?.[scenarioIdx];
        if (!scen) return false;
        const hitl = typeof ensureHitlStateForScenario === 'function' ? ensureHitlStateForScenario(scen) : (scen.hitl || {});
        const core = (hitl && typeof hitl === 'object' && hitl.core && typeof hitl.core === 'object') ? hitl.core : (scen.hitl?.core || {});
        const vmKey = (core?.vm_key ?? '').toString().trim();
        return !!vmKey;
    } catch (err) {
        return false;
    }
}

function formatCoreTestTimestamp(isoString) {
    try {
        if (!isoString) return '';
        const dt = new Date(String(isoString));
        if (Number.isNaN(dt.getTime())) return String(isoString);
        return dt.toLocaleString();
    } catch (err) {
        return isoString ? String(isoString) : '';
    }
}

function getLastCoreTestSummary() {
    try {
        const status = (state?.core_last_test_status ?? '').toString().trim().toLowerCase();
        const at = (state?.core_last_test_at ?? '').toString().trim();
        const msg = (state?.core_last_test_message ?? '').toString().trim();
        if (!status && !at && !msg) return '';
        const atText = formatCoreTestTimestamp(at);
        if (status === 'success') {
            return atText ? `Last test succeeded at ${atText}` : 'Last test succeeded';
        }
        if (status === 'failure') {
            const base = atText ? `Last test failed at ${atText}` : 'Last test failed';
            return msg ? `${base} (${msg})` : base;
        }
        // Unknown status
        return atText ? `Last test at ${atText}` : '';
    } catch (err) {
        return '';
    }
}

function updateExecuteCoreStatus(info = null) {
    if (!executeCoreStatusEl) return;
    const statusInfo = info || detectLocalEmulation();
    const classes = ['text-muted', 'text-success', 'text-warning', 'text-danger'];
    executeCoreStatusEl.classList.remove(...classes);
    const lastTestSummary = getLastCoreTestSummary();

    // Builder view: avoid misleading live-test prompts. Show the last known admin test result
    // (green/red) if available; otherwise keep an "unknown" hint.
    if (IS_BUILDER_VIEW) {
        const lastStatus = (state?.core_last_test_status ?? '').toString().trim().toLowerCase();
        if (lastStatus === 'success') {
            executeCoreStatusEl.textContent = lastTestSummary ? `Succeeded • ${lastTestSummary}` : 'Succeeded';
            executeCoreStatusEl.classList.add('text-success');
            return;
        }
        if (lastStatus === 'failure') {
            executeCoreStatusEl.textContent = lastTestSummary ? `Failed • ${lastTestSummary}` : 'Failed';
            executeCoreStatusEl.classList.add('text-danger');
            return;
        }

        // If no last test is recorded, try to show an admin validation timestamp.
        try {
            const scenarioIdx = Number.isInteger(executeConfirmState?.scenarioIndex)
                ? executeConfirmState.scenarioIndex
                : getActiveScenarioContext().idx;
            const scen = Number.isInteger(scenarioIdx) ? state?.scenarios?.[scenarioIdx] : null;
            const hitl = (scen && scen.hitl && typeof scen.hitl === 'object') ? scen.hitl : null;
            const core = (hitl && hitl.core && typeof hitl.core === 'object') ? hitl.core : null;
            const valAt = core ? (core.last_validated_at ?? '') : '';
            const valText = formatCoreTestTimestamp(valAt);
            if (valText) {
                executeCoreStatusEl.textContent = `Verified by admin • ${valText}`;
                executeCoreStatusEl.classList.add('text-muted');
                return;
            }
        } catch (e) {}

        executeCoreStatusEl.textContent = lastTestSummary
            ? `CORE status unknown • ${lastTestSummary}`
            : 'CORE backend status unknown. Ask an admin to validate the connection.';
        executeCoreStatusEl.classList.add('text-warning');
        return;
    }
    if (statusInfo.verified) {
        const base = IS_BUILDER_VIEW
            ? 'CORE backend validated and ready.'
            : `Connected to CORE ${statusInfo.host}:${statusInfo.port}`;
        executeCoreStatusEl.textContent = lastTestSummary ? `${base} • ${lastTestSummary}` : base;
        executeCoreStatusEl.classList.add('text-success');
    } else if (!IS_BUILDER_VIEW && executeConfirmState && executeConfirmState.coreTestFailed) {
        const base = 'CORE connection failed, please check your settings and try again.';
        executeCoreStatusEl.textContent = lastTestSummary ? `${base} • ${lastTestSummary}` : base;
        executeCoreStatusEl.classList.add('text-danger');
    } else if (statusInfo.shouldFake) {
        const base = IS_BUILDER_VIEW
            ? 'Please test the connection. If it fails, contact your administrator.'
            : 'Please test the connection to proceed.';
        executeCoreStatusEl.textContent = lastTestSummary ? `${base} • ${lastTestSummary}` : base;
        executeCoreStatusEl.classList.add(IS_BUILDER_VIEW ? 'text-danger' : 'text-warning');
    } else {
        const base = IS_BUILDER_VIEW
            ? 'CORE backend status unknown. Ask an admin to validate the connection.'
            : 'Please test the connection to proceed.';
        executeCoreStatusEl.textContent = lastTestSummary ? `${base} • ${lastTestSummary}` : base;
        executeCoreStatusEl.classList.add('text-warning');
    }
}

function refreshExecuteRemoteToggleState() {
    const info = detectLocalEmulation();
    updateExecuteCoreStatus(info);
    const remoteSelected = isRemoteExecutionSelected();
    const coreVmConfigured = isExecuteCoreVmConfigured();
    const pushPref = getExecuteConfirmUpdateRemotePref();
    const showNotConfigured = remoteSelected && !coreVmConfigured && !IS_BUILDER_VIEW;

    const isBuilderCoreVmVerified = (() => {
        if (!IS_BUILDER_VIEW) return true;
        try {
            const scenarioIdx = Number.isInteger(executeConfirmState?.scenarioIndex)
                ? executeConfirmState.scenarioIndex
                : getActiveScenarioContext().idx;
            if (!Number.isInteger(scenarioIdx)) return false;
            const scen = state?.scenarios?.[scenarioIdx];
            if (!scen || typeof scen !== 'object') return false;
            const hitl = (typeof ensureHitlStateForScenario === 'function') ? ensureHitlStateForScenario(scen) : (scen.hitl || {});
            const prox = (hitl && typeof hitl === 'object' && hitl.proxmox && typeof hitl.proxmox === 'object') ? hitl.proxmox : {};
            const core = (hitl && typeof hitl === 'object' && hitl.core && typeof hitl.core === 'object') ? hitl.core : {};
            const vmKey = (core?.vm_key ?? '').toString().trim();
            const proxSecret = (prox?.secret_id ?? '').toString().trim();
            const coreSecret = (core?.core_secret_id ?? '').toString().trim();
            const proxValidated = !!prox?.validated;
            const coreValidated = !!core?.validated;
            return !!(vmKey && proxSecret && coreSecret && proxValidated && coreValidated);
        } catch (err) {
            return false;
        }
    })();

    if (executeCoreNotConfiguredRow) {
        executeCoreNotConfiguredRow.classList.toggle('d-none', !showNotConfigured);
    }
    if (executeRemoteTestRow) {
        executeRemoteTestRow.classList.toggle('d-none', !remoteSelected || showNotConfigured);
    }

    // If we're explicitly in the "CORE not connected; local emulation fallback" state,
    // never show push controls (there is no usable remote target).
    const hidePushControls = !remoteSelected || IS_BUILDER_VIEW || !!info.shouldFake || showNotConfigured;
    if (executePushUpdateWrap) {
        executePushUpdateWrap.classList.toggle('d-none', hidePushControls);
    }
    if (executeConfirmPushUpdateToggle) {
        if (IS_BUILDER_VIEW) {
            executeConfirmPushUpdateToggle.checked = false;
        } else if (hidePushControls) {
            executeConfirmPushUpdateToggle.checked = false;
        } else if (remoteSelected) {
            executeConfirmPushUpdateToggle.checked = pushPref;
        }
        executeConfirmPushUpdateToggle.disabled = hidePushControls;
    }
    if (executeConfirmPushUpdateHelpEl) {
        executeConfirmPushUpdateHelpEl.classList.remove('text-success', 'text-warning');
        if (IS_BUILDER_VIEW) {
            executeConfirmPushUpdateHelpEl.textContent = 'Repository uploads are managed by an admin.';
            executeConfirmPushUpdateHelpEl.classList.add('text-muted');
        } else {
            executeConfirmPushUpdateHelpEl.classList.toggle('text-muted', !remoteSelected);
            executeConfirmPushUpdateHelpEl.textContent = remoteSelected
                ? 'Sync the current repository snapshot to your CORE VM before execution.'
                : 'Enable remote execution to push the latest backend before running.';
            if (remoteSelected) {
                executeConfirmPushUpdateHelpEl.classList.add('text-success');
            }
        }
    }

    if (executeConfirmRunBtn) {
        const shouldDisable = showNotConfigured
            || (remoteSelected && !info.verified && !IS_BUILDER_VIEW)
            || (IS_BUILDER_VIEW && !isBuilderCoreVmVerified);
        executeConfirmRunBtn.disabled = shouldDisable;

        // Only auto-adjust the label for the default Execute flow.
        // Some callers (e.g., seeded runs) supply custom labels like "Run with seed".
        if (!executeProgressState.active && executeConfirmState.autoLabel) {
            const label = remoteSelected ? 'Execute' : 'Generate preview';
            executeConfirmRunBtn.textContent = label;
            if (!executeConfirmRunBtn.dataset.defaultLabel) {
                executeConfirmRunBtn.dataset.defaultLabel = label;
            } else {
                executeConfirmRunBtn.dataset.defaultLabel = label;
            }
        }

        if (shouldDisable) {
            if (IS_BUILDER_VIEW && !isBuilderCoreVmVerified) {
                executeConfirmRunBtn.setAttribute('title', 'Ask an admin to verify Select CORE VM (Proxmox + CORE) before executing.');
            } else {
                executeConfirmRunBtn.setAttribute('title', showNotConfigured
                    ? 'Select a CORE VM to enable remote execution.'
                    : 'Test the CORE connection to enable remote execution.');
            }
        } else {
            executeConfirmRunBtn.removeAttribute('title');
        }
    }

    // Advanced: only relevant for remote execution with a configured CORE VM.
    if (executeAdvancedWrap) {
        const showAdvanced = remoteSelected && !showNotConfigured && !IS_BUILDER_VIEW && !info.shouldFake;
        executeAdvancedWrap.classList.toggle('d-none', !showAdvanced);
    }
}

function isActiveScenarioCoreVmVerifiedForProject() {
    try {
        const scenarioIdx = Number.isInteger(executeConfirmState?.scenarioIndex)
            ? executeConfirmState.scenarioIndex
            : getActiveScenarioContext().idx;
        if (!Number.isInteger(scenarioIdx)) return false;
        const scen = state?.scenarios?.[scenarioIdx];
        if (!scen || typeof scen !== 'object') return false;
        const hitl = (typeof ensureHitlStateForScenario === 'function')
            ? ensureHitlStateForScenario(scen)
            : (scen.hitl || {});
        const prox = (hitl && typeof hitl === 'object' && hitl.proxmox && typeof hitl.proxmox === 'object') ? hitl.proxmox : {};
        const core = (hitl && typeof hitl === 'object' && hitl.core && typeof hitl.core === 'object') ? hitl.core : {};
        const vmKey = (core?.vm_key ?? '').toString().trim();
        const proxSecretId = (prox?.secret_id ?? '').toString().trim();
        const coreSecretId = (core?.core_secret_id ?? core?.secret_id ?? '').toString().trim();
        const proxValidated = !!prox?.validated;
        const coreValidated = !!core?.validated;
        return !!(vmKey && proxSecretId && coreSecretId && proxValidated && coreValidated);
    } catch (err) {
        return false;
    }
}

function refreshScenariosExecuteButtonState() {
    const btn = document.getElementById('scenariosExecuteBtn');
    if (!btn) return;
    const verified = isActiveScenarioCoreVmVerifiedForProject();
    btn.disabled = !verified;
    if (!verified) {
        btn.setAttribute('title', 'Verify a CORE VM in VM / Access to enable Execute.');
    } else {
        btn.removeAttribute('title');
    }
}

async function handleExecuteCoreTestClick() {
    const button = executeCoreTestBtn;
    const statusEl = executeCoreStatusEl;
    const { idx: scenarioIdx } = getActiveScenarioContext();
    if (!Number.isInteger(scenarioIdx)) {
        if (statusEl) {
            statusEl.textContent = 'Select a scenario before testing the CORE connection.';
            statusEl.classList.remove('text-success');
            statusEl.classList.add('text-danger');
        }
        return;
    }
    try {
        const result = await validateCoreConnection(scenarioIdx, {
            triggerButton: button || undefined,
            statusEl: statusEl || undefined,
            workingLabel: 'Testing…',
            hintOnStart: 'Validating CORE connection…',
            hintOnSuccess: 'CORE connection validated for remote execution.',
            hintOnFailure: 'CORE connection test failed',
            suppressToasts: false,
        });
        // Builder view cannot run live tests; don't treat this as a failure.
        executeConfirmState.coreTestFailed = IS_BUILDER_VIEW ? false : !(result && result.ok);
    } catch (err) {
        console.warn('CORE connection test from execute modal failed', err);
        executeConfirmState.coreTestFailed = IS_BUILDER_VIEW ? false : true;
    } finally {
        refreshExecuteRemoteToggleState();
    }
}

async function ensureBuilderCoreReadyForExecute() {
    if (!IS_BUILDER_VIEW) {
        return true;
    }
    const scenarioIndex = Number.isInteger(executeConfirmState.scenarioIndex)
        ? executeConfirmState.scenarioIndex
        : getActiveScenarioContext().idx;
    if (!Number.isInteger(scenarioIndex)) {
        updateExecuteConfirmAlert('Select a scenario before executing.', 'warning');
        return false;
    }

    // Builder view is read-only and cannot run live validation (`validateCoreConnection` hard-fails).
    // Gate execution based on admin-provided safe hints merged into `scenario.hitl`.
    const scenario = state?.scenarios?.[scenarioIndex];
    if (!scenario) {
        updateExecuteConfirmAlert('Scenario unavailable.', 'danger');
        return false;
    }
    const hitl = (scenario.hitl && typeof scenario.hitl === 'object') ? scenario.hitl : {};
    const prox = (hitl.proxmox && typeof hitl.proxmox === 'object') ? hitl.proxmox : {};
    const core = (hitl.core && typeof hitl.core === 'object') ? hitl.core : {};

    const vmKey = (core.vm_key ?? '').toString().trim();
    const coreSecretId = (core.core_secret_id ?? '').toString().trim();
    const proxSecretId = (prox.secret_id ?? '').toString().trim();
    const proxValidated = !!prox.validated;
    const coreValidated = !!core.validated;
    const hasDirectHost = !!((core.ssh_host || core.grpc_host || '').toString().trim());

    // Ready if we have the core secret id + selected VM key and either:
    // - direct host details (ssh/grpc), or
    // - validated proxmox creds (so backend can resolve VM details).
    // Builder requirement: only allow execute once the admin has verified Select CORE VM.
    // Treat verification as: proxmox+core validated flags present, secrets present, and vm_key selected.
    const coreVmVerifiedByAdmin = !!(vmKey && proxSecretId && coreSecretId && proxValidated && coreValidated);
    const ready = coreVmVerifiedByAdmin && (hasDirectHost || proxSecretId);

    if (!ready) {
        const message = coreVmVerifiedByAdmin
            ? 'CORE is configured but not ready to execute. Please ask an admin.'
            : 'Select CORE VM has not been verified by an admin yet. Please ask an admin.';
        updateExecuteConfirmAlert(message, 'danger');
        if (executeCoreStatusEl) {
            executeCoreStatusEl.textContent = message;
            executeCoreStatusEl.classList.remove('text-success', 'text-warning', 'text-muted');
            executeCoreStatusEl.classList.add('text-danger');
        }
        return false;
    }

    updateExecuteConfirmAlert('', 'info');
    if (executeCoreStatusEl) {
        executeCoreStatusEl.textContent = 'CORE backend configured by admin.';
        executeCoreStatusEl.classList.remove('text-warning', 'text-danger', 'text-muted');
        executeCoreStatusEl.classList.add('text-success');
    }
    refreshExecuteRemoteToggleState();
    return true;
}

function handleBuilderBackendUnavailable() {
    updateExecuteConfirmAlert(BUILDER_BACKEND_UNAVAILABLE_MESSAGE, 'danger');
    if (executeCoreStatusEl) {
        executeCoreStatusEl.textContent = BUILDER_BACKEND_UNAVAILABLE_MESSAGE;
        executeCoreStatusEl.classList.remove('text-success', 'text-warning', 'text-muted');
        executeCoreStatusEl.classList.add('text-danger');
    }
}

function ensureExecuteProgressElements() {
    if (!executeProgressWrap) executeProgressWrap = document.getElementById('executeProgressWrap');
    if (!executeProgressStatusEl) executeProgressStatusEl = document.getElementById('executeProgressStatus');
    if (!executeProgressMetaEl) executeProgressMetaEl = document.getElementById('executeProgressMeta');
    if (!executeProgressBarEl) executeProgressBarEl = document.getElementById('executeProgressBar');
    if (!executeProgressLogEl) executeProgressLogEl = document.getElementById('executeProgressLog');
    if (!executeProgressSpinnerEl) executeProgressSpinnerEl = document.getElementById('executeProgressSpinner');
    if (!executeProgressPopoutBtn) executeProgressPopoutBtn = document.getElementById('executeProgressPopoutBtn');
    if (!executeProgressCancelBtn) executeProgressCancelBtn = document.getElementById('executeProgressCancelBtn');
    if (!executePhaseHeaderEl) executePhaseHeaderEl = document.getElementById('executePhaseHeader');
    if (executeProgressCancelBtn && !executeProgressCancelBtn.dataset.execBound) {
        executeProgressCancelBtn.addEventListener('click', () => {
            requestExecuteCancel('Cancelled by user');
        });
        executeProgressCancelBtn.dataset.execBound = '1';
    }
    if (executeProgressPopoutBtn && !executeProgressPopoutBtn.dataset.execBound) {
        executeProgressPopoutBtn.addEventListener('click', () => {
            try {
                if (executeConfirmModalEl && window.bootstrap) {
                    bootstrap.Modal.getOrCreateInstance(executeConfirmModalEl).hide();
                }
            } catch (err) { /* ignore */ }
            openRunProgress('Run logs');
            maybeShowLocalEmulationHint();
            executeProgressPopoutBtn.classList.add('d-none');
        });
        executeProgressPopoutBtn.dataset.execBound = '1';
    }
}

function registerExecuteCancelHandler(handler) {
    if (typeof handler !== 'function') return () => {};
    try {
        if (!executeProgressState || typeof executeProgressState !== 'object') return () => {};
        if (!Array.isArray(executeProgressState.cancelHandlers)) executeProgressState.cancelHandlers = [];
        executeProgressState.cancelHandlers.push(handler);
        return () => {
            try {
                const idx = executeProgressState.cancelHandlers.indexOf(handler);
                if (idx >= 0) executeProgressState.cancelHandlers.splice(idx, 1);
            } catch (e) {}
        };
    } catch (e) {
        return () => {};
    }
}

async function requestExecuteCancel(reason = 'Cancelled') {
    try {
        if (!executeProgressState || !executeProgressState.active || executeProgressState.done) return;
        if (executeProgressState.cancelRequested) return;
        executeProgressState.cancelRequested = true;
        try {
            appendExecuteProgressLog(`[ui] Cancel requested${reason ? `: ${reason}` : ''}`);
        } catch (e) {}
        try {
            setExecuteProgressStatus('Cancelling…', reason || 'Stopping…');
        } catch (e) {}
        try {
            const handlers = Array.isArray(executeProgressState.cancelHandlers) ? [...executeProgressState.cancelHandlers] : [];
            executeProgressState.cancelHandlers = [];
            const promises = [];
            handlers.forEach((fn) => {
                try {
                    const res = fn();
                    if (res && typeof res.then === 'function') {
                        promises.push(res);
                    }
                } catch (e) {}
            });
            if (promises.length) {
                const sleep = (ms) => new Promise((resolve) => setTimeout(resolve, ms));
                // Don't block cancellation indefinitely; just wait briefly for best-effort feedback.
                await Promise.race([
                    Promise.allSettled(promises),
                    sleep(900),
                ]);
            }
        } catch (e) {}
        try { if (runProgressEvtSrc) runProgressEvtSrc.close(); } catch (e) {}
        try {
            if (executeProgressState.runId) {
                await fetch('/cancel_run/' + encodeURIComponent(executeProgressState.runId), { method: 'POST' });
            }
        } catch (e) {}
        try {
            completeExecuteProgressPanel(false, 'Cancelled', reason || 'Cancelled by user');
        } catch (e) {}
    } catch (e) {}
}

const EXECUTE_PROGRESS_HEARTBEAT_MESSAGES = [
    'Establishing SSH tunnel to CORE host…',
    'Validating remote CORE environment…',
    'Syncing XML and preparing remote workspace…',
    'Starting CORE services on remote host…',
];
const EXECUTE_PROGRESS_HEARTBEAT_INTERVAL_MS = 4500;

function buildExecuteAdvancedPreflightSuffix() {
    try {
        if (!isRemoteExecutionSelected()) return '';
        const selections = (typeof getExecuteConfirmSelections === 'function') ? getExecuteConfirmSelections() : null;
        const adv = selections && selections.advanced && typeof selections.advanced === 'object' ? selections.advanced : null;
        if (!adv) return '';
        const enabled = [];
        if (adv.fixDockerDaemon) enabled.push('fix docker daemon');
        if (adv.runCoreCleanup) enabled.push('run core cleanup');
        if (adv.checkCoreVersion) enabled.push('check CORE version');
        if (adv.restartCoreDaemon) enabled.push('restart core-daemon');
        if (adv.autoKillSessions) enabled.push('auto-kill sessions');
        if (!enabled.length) return '';
        return ` (Advanced: ${enabled.join(', ')})`;
    } catch (_) {
        return '';
    }
}

function buildExecuteProgressDiagnosticsLines(){
    const lines = [];
    try {
        const info = detectLocalEmulation();
        const remoteSelected = isRemoteExecutionSelected();
        const selections = (typeof getExecuteConfirmSelections === 'function') ? getExecuteConfirmSelections() : null;
        const pushPref = selections && typeof selections.pushPreference !== 'undefined'
            ? !!selections.pushPreference
            : (typeof getExecuteConfirmUpdateRemotePref === 'function' ? !!getExecuteConfirmUpdateRemotePref() : false);
        const remoteMode = remoteSelected ? 'REMOTE' : 'LOCAL';
        lines.push(`[ui] Mode: ${remoteMode}${remoteSelected ? (info.verified ? ' (verified)' : ' (not verified)') : ''}`);
        if (remoteSelected) {
            lines.push(`[ui] Push updated backend: ${pushPref ? 'enabled' : 'disabled'}`);
            try {
                const adv = selections && selections.advanced && typeof selections.advanced === 'object' ? selections.advanced : null;
                if (adv) {
                    const enabled = [];
                    if (adv.fixDockerDaemon) enabled.push('fix docker daemon');
                    if (adv.runCoreCleanup) enabled.push('run core cleanup');
                    if (adv.checkCoreVersion) enabled.push('check CORE version');
                    if (adv.restartCoreDaemon) enabled.push('restart core-daemon');
                    if (adv.autoKillSessions) enabled.push('auto-kill sessions');
                    if (enabled.length) {
                        lines.push(`[ui] Advanced pre-flight: ${enabled.join(', ')}`);
                    }
                }
            } catch (_) {}
        }
        const core = (typeof getCoreConfig === 'function') ? getCoreConfig(false) : (state?.core || {});
        const sshHost = (core?.ssh_host || core?.host || 'localhost').toString().trim() || 'localhost';
        const sshPort = Number.isFinite(Number(core?.ssh_port)) && Number(core.ssh_port) > 0 ? Number(core.ssh_port) : 22;
        const sshUser = (core?.ssh_username || '').toString().trim();
        const grpcHost = (core?.grpc_host || core?.host || 'localhost').toString().trim() || 'localhost';
        const grpcPort = Number.isFinite(Number(core?.grpc_port)) && Number(core.grpc_port) > 0
            ? Number(core.grpc_port)
            : (Number.isFinite(Number(core?.port)) && Number(core.port) > 0 ? Number(core.port) : 50051);
        const venv = (core?.venv_bin || '').toString().trim();
        const daemonAuto = !!(core?.auto_start_daemon);
        const sshPrefix = sshUser ? `${sshUser}@` : '';
        lines.push(`[ui] SSH target: ${sshPrefix}${sshHost}:${sshPort}`);
        lines.push(`[ui] gRPC target: ${grpcHost}:${grpcPort}`);
        if (venv) lines.push(`[ui] Remote venv bin: ${venv}`);
        lines.push(`[ui] core-daemon auto-start: ${daemonAuto ? 'enabled' : 'disabled'}`);
        try {
            const testedHost = state?.core_tested_host || null;
            const testedPort = state?.core_tested_port || null;
            if (testedHost || testedPort) {
                lines.push(`[ui] Last validated: ${testedHost || '?'}:${testedPort || '?'}`);
            }
        } catch (_) {}
    } catch (e) {
        // best-effort; no throw
    }
    return lines;
}

function buildExecuteStartCoreServicesMessage(){
    try {
        const core = (typeof getCoreConfig === 'function') ? getCoreConfig(false) : (state?.core || {});
        const sshHost = (core?.ssh_host || core?.host || 'localhost').toString().trim() || 'localhost';
        const sshPort = Number.isFinite(Number(core?.ssh_port)) && Number(core.ssh_port) > 0 ? Number(core.ssh_port) : 22;
        const sshUser = (core?.ssh_username || '').toString().trim();
        const grpcHost = (core?.grpc_host || core?.host || 'localhost').toString().trim() || 'localhost';
        const grpcPort = Number.isFinite(Number(core?.grpc_port)) && Number(core.grpc_port) > 0
            ? Number(core.grpc_port)
            : (Number.isFinite(Number(core?.port)) && Number(core.port) > 0 ? Number(core.port) : 50051);
        const venv = (core?.venv_bin || '').toString().trim();
        const daemonAuto = !!(core?.auto_start_daemon);
        const sshPrefix = sshUser ? `${sshUser}@` : '';
        const venvSuffix = venv ? `, venv ${venv}` : '';
        const daemonSuffix = daemonAuto ? ', daemon auto-start enabled' : '';
        const advSuffix = buildExecuteAdvancedPreflightSuffix();
        return `Starting CORE services via SSH ${sshPrefix}${sshHost}:${sshPort} (gRPC ${grpcHost}:${grpcPort}${venvSuffix}${daemonSuffix})…${advSuffix}`;
    } catch (e) {
        return 'Starting CORE services on remote host…';
    }
}

function buildExecuteProgressStepMessage(stepIndex){
    try {
        const core = (typeof getCoreConfig === 'function') ? getCoreConfig(false) : (state?.core || {});
        const sshHost = (core?.ssh_host || core?.host || 'localhost').toString().trim() || 'localhost';
        const sshPort = Number.isFinite(Number(core?.ssh_port)) && Number(core.ssh_port) > 0 ? Number(core.ssh_port) : 22;
        const sshUser = (core?.ssh_username || '').toString().trim();
        const grpcHost = (core?.grpc_host || core?.host || 'localhost').toString().trim() || 'localhost';
        const grpcPort = Number.isFinite(Number(core?.grpc_port)) && Number(core.grpc_port) > 0
            ? Number(core.grpc_port)
            : (Number.isFinite(Number(core?.port)) && Number(core.port) > 0 ? Number(core.port) : 50051);
        const sshPrefix = sshUser ? `${sshUser}@` : '';
        const advSuffix = buildExecuteAdvancedPreflightSuffix();

        if (stepIndex === 0) {
            return `Establishing SSH tunnel to ${sshPrefix}${sshHost}:${sshPort}…${advSuffix}`;
        }
        if (stepIndex === 1) {
            return `Validating CORE backend (gRPC ${grpcHost}:${grpcPort})…${advSuffix}`;
        }
        if (stepIndex === 2) {
            const rp = (state?.result_path || '').toString().trim();
            const suffix = rp ? ` (XML ${rp.split(/[/\\]/).pop() || rp})` : '';
            return `Preparing remote workspace and syncing inputs${suffix}…${advSuffix}`;
        }
        return buildExecuteStartCoreServicesMessage();
    } catch (_) {
        return EXECUTE_PROGRESS_HEARTBEAT_MESSAGES[Math.min(stepIndex, EXECUTE_PROGRESS_HEARTBEAT_MESSAGES.length - 1)] || 'Working…';
    }
}

function emitExecuteProgressHeartbeatMessage() {
    if (!executeProgressState.active) return;
    const idx = Math.min(
        executeProgressState.heartbeatIndex,
        EXECUTE_PROGRESS_HEARTBEAT_MESSAGES.length - 1
    );
    const msg = buildExecuteProgressStepMessage(idx);
    appendExecuteProgressLog(`[ui] ${msg}`);
    setExecuteProgressStatus('Preparing CORE run…', msg);
    if (executeProgressState.heartbeatIndex < EXECUTE_PROGRESS_HEARTBEAT_MESSAGES.length - 1) {
        executeProgressState.heartbeatIndex += 1;
    }
}

function startExecuteProgressHeartbeat() {
    stopExecuteProgressHeartbeat();
    executeProgressState.heartbeatIndex = 0;
    emitExecuteProgressHeartbeatMessage();
    executeProgressState.heartbeatTimer = window.setInterval(() => {
        emitExecuteProgressHeartbeatMessage();
    }, EXECUTE_PROGRESS_HEARTBEAT_INTERVAL_MS);
}

function stopExecuteProgressHeartbeat() {
    if (executeProgressState.heartbeatTimer) {
        clearInterval(executeProgressState.heartbeatTimer);
        executeProgressState.heartbeatTimer = null;
    }
}

function resetExecuteProgressUI() {
    ensureExecuteProgressElements();
    stopExecuteProgressHeartbeat();
    executeProgressState.active = false;
    executeProgressState.done = false;
    executeProgressState.cancelRequested = false;
    executeProgressState.cancelHandlers = [];
    executeProgressState.logLines = [];
    executeProgressState.runId = null;
    executeProgressState.heartbeatIndex = 0;
    if (executeProgressWrap) executeProgressWrap.classList.add('d-none');
    if (executeProgressStatusEl) executeProgressStatusEl.textContent = '';
    if (executeProgressMetaEl) executeProgressMetaEl.textContent = '';
    if (executeProgressBarEl) {
        executeProgressBarEl.style.width = '0%';
        executeProgressBarEl.textContent = '0%';
        executeProgressBarEl.classList.remove('bg-success', 'bg-danger', 'progress-bar-animated');
        executeProgressBarEl.classList.add('progress-bar-striped');
    }
    if (executeProgressLogEl) executeProgressLogEl.textContent = '';
    if (executeProgressSpinnerEl) executeProgressSpinnerEl.classList.remove('d-none');
    if (executeProgressPopoutBtn) executeProgressPopoutBtn.classList.add('d-none');
    if (executeProgressCancelBtn) executeProgressCancelBtn.classList.add('d-none');
    if (executePhaseHeaderEl) executePhaseHeaderEl.textContent = 'Phase: —';
    if (executeConfirmRunBtn) {
        if (!executeConfirmRunBtn.dataset.defaultLabel) {
            executeConfirmRunBtn.dataset.defaultLabel = executeConfirmRunBtn.textContent || 'Execute';
        }
        executeConfirmRunBtn.disabled = false;
        executeConfirmRunBtn.textContent = executeConfirmRunBtn.dataset.defaultLabel;
        executeConfirmRunBtn.removeAttribute('title');
    }
    if (executeConfirmCancelBtn) {
        if (!executeConfirmCancelBtn.dataset.cancelLabel) {
            executeConfirmCancelBtn.dataset.cancelLabel = executeConfirmCancelBtn.textContent || 'Cancel';
        }
        executeConfirmCancelBtn.disabled = false;
        executeConfirmCancelBtn.textContent = executeConfirmCancelBtn.dataset.cancelLabel;
    }
}

function showExecuteProgressPanel(status, meta) {
    ensureExecuteProgressElements();
    stopExecuteProgressHeartbeat();
    executeProgressState.active = true;
    executeProgressState.done = false;
    executeProgressState.cancelRequested = false;
    executeProgressState.cancelHandlers = [];
    executeProgressState.logLines = [];
    if (executeProgressWrap) executeProgressWrap.classList.remove('d-none');
    if (executeProgressSpinnerEl) executeProgressSpinnerEl.classList.remove('d-none');
    if (executeProgressBarEl) executeProgressBarEl.classList.add('progress-bar-animated');
    if (executeConfirmRunBtn) {
        if (!executeConfirmRunBtn.dataset.defaultLabel) {
            executeConfirmRunBtn.dataset.defaultLabel = executeConfirmRunBtn.textContent || 'Execute';
        }
        executeConfirmRunBtn.disabled = true;
        executeConfirmRunBtn.textContent = 'Executing…';
    }
    if (executeConfirmCancelBtn) {
        if (!executeConfirmCancelBtn.dataset.cancelLabel) {
            executeConfirmCancelBtn.dataset.cancelLabel = executeConfirmCancelBtn.textContent || 'Cancel';
        }
        executeConfirmCancelBtn.textContent = 'Hide';
        executeConfirmCancelBtn.disabled = false;
    }
    if (executeProgressCancelBtn) {
        executeProgressCancelBtn.disabled = false;
        executeProgressCancelBtn.classList.remove('d-none');
    }
    try {
        const diag = buildExecuteProgressDiagnosticsLines();
        if (Array.isArray(diag) && diag.length) {
            diag.forEach(line => { appendExecuteProgressLog(line); });
        }
    } catch (_) {}
    if (executePhaseHeaderEl) executePhaseHeaderEl.textContent = 'Phase: Preparing…';
    setExecuteProgressStatus(status || 'Preparing run…', meta || '');
    setExecuteProgressPercent(0, '0%');
    startExecuteProgressHeartbeat();
}

function setExecuteProgressStatus(main, meta) {
    if (!executeProgressState.active) return;
    if (executeProgressStatusEl && main !== undefined) {
        executeProgressStatusEl.textContent = main || '';
    }
    if (executeProgressMetaEl && meta !== undefined) {
        executeProgressMetaEl.textContent = meta || '';
    }
}

function setExecuteProgressPercent(percent, label) {
    if (!executeProgressState.active) return;
    if (!executeProgressBarEl) return;
    const clamped = Math.max(0, Math.min(100, Number(percent) || 0));
    executeProgressBarEl.style.width = clamped.toFixed(1).replace(/\.0$/, '') + '%';
    executeProgressBarEl.textContent = label || clamped.toFixed(0) + '%';
}

function appendExecuteProgressLog(line, options = {}) {
    if (!executeProgressState.active || !executeProgressLogEl) return;
    const normalized = (line || '').trimEnd();
    executeProgressState.logLines.push(normalized);
    if (executeProgressState.logLines.length > executeProgressState.maxLines) {
        executeProgressState.logLines.shift();
    }
    executeProgressLogEl.textContent = executeProgressState.logLines.join('\n');
    executeProgressLogEl.scrollTop = executeProgressLogEl.scrollHeight;
    try {
        const mirror = (options && typeof options === 'object' && Object.prototype.hasOwnProperty.call(options, 'mirrorToDock'))
            ? !!options.mirrorToDock
            : true;
        if (mirror && typeof dockLog === 'function') {
            let lvl = 'INFO';
            try {
                if (/\bERROR\b/.test(normalized)) lvl = 'ERROR';
                else if (/\bWARN(ING)?\b/.test(normalized)) lvl = 'WARN';
                else if (/\bDEBUG\b/.test(normalized)) lvl = 'DEBUG';
            } catch (e) {}
            dockLog(normalized, lvl);
        }
    } catch (e) {}
}

function bindExecuteProgressToRun(runId) {
    executeProgressState.runId = runId || null;
    stopExecuteProgressHeartbeat();
    if (executeProgressPopoutBtn) executeProgressPopoutBtn.classList.remove('d-none');
    setExecuteProgressStatus('Running CLI…', 'Streaming logs…');
}

function completeExecuteProgressPanel(success, message, meta) {
    if (!executeProgressState.active) return;
    if (executeProgressState.done) return;
    executeProgressState.done = true;
    stopExecuteProgressHeartbeat();
    if (executeProgressSpinnerEl) executeProgressSpinnerEl.classList.add('d-none');
    if (executeProgressBarEl) {
        executeProgressBarEl.classList.remove('progress-bar-striped', 'progress-bar-animated');
        executeProgressBarEl.classList.remove('bg-danger', 'bg-success');
        executeProgressBarEl.classList.add(success ? 'bg-success' : 'bg-danger');
        executeProgressBarEl.style.width = success ? '100%' : executeProgressBarEl.style.width || '100%';
        executeProgressBarEl.textContent = success ? 'Done' : 'Error';
    }
    setExecuteProgressStatus(message || (success ? 'Scenario started' : 'Failed to start'), meta || '');
    if (executePhaseHeaderEl) executePhaseHeaderEl.textContent = success ? 'Phase: Complete' : 'Phase: Error';
    if (executeConfirmCancelBtn) {
        executeConfirmCancelBtn.textContent = 'Close';
        executeConfirmCancelBtn.disabled = false;
    }
    if (executeConfirmRunBtn) {
        executeConfirmRunBtn.disabled = true;
    }
    if (executeProgressCancelBtn) {
        executeProgressCancelBtn.classList.add('d-none');
        executeProgressCancelBtn.disabled = true;
    }
    // Re-enable connection & advanced controls only after run completes.
    try { if (typeof setExecuteDialogControlsEnabled === 'function') setExecuteDialogControlsEnabled(true); } catch(e){}
}

function handleExecuteProgressLog(line) {
    if (!executeProgressState.active) return;
    stopExecuteProgressHeartbeat();
    appendExecuteProgressLog(line);
    if (!line) return;
    if (/\[remote\]\s+Repo upload starting/i.test(line)) {
        setExecuteProgressStatus('Copying repository…', line.replace('[remote]', '').trim());
        setExecuteProgressPercent(1, 'Starting…');
        return;
    }
    const repoMatch = /\[remote\]\s+Repo upload\s+(\d+(?:\.\d+)?)%.*\((\d+)\/(\d+)\s*KiB/i.exec(line);
    if (repoMatch) {
        const pct = parseFloat(repoMatch[1]) || 0;
        const cur = repoMatch[2];
        const total = repoMatch[3];
        setExecuteProgressStatus('Copying repository…', `${cur} / ${total} KiB`);
        setExecuteProgressPercent(pct, `${pct.toFixed(1)}%`);
        return;
    }
    if (/\[remote\]\s+Repo upload complete/i.test(line)) {
        setExecuteProgressStatus('Repository copied', 'Preparing workspace…');
        setExecuteProgressPercent(100, '100%');
        return;
    }
    if (/\[remote\]\s+Workspace:/i.test(line)) {
        setExecuteProgressStatus('Remote workspace ready', line.replace('[remote]', '').trim());
        setExecuteProgressPercent(100, 'Workspace ready');
        return;
    }
}

function handleExecuteProgressPhase(payload) {
    if (!executeProgressState.active) return;
    const stage = (payload && payload.stage) ? String(payload.stage) : 'phase';
    const detail = (payload && payload.detail) ? String(payload.detail) : '';
    const meta = [];
    if (payload && payload.local && payload.remote) meta.push(`${payload.local} → ${payload.remote}`);
    if (payload && payload.exit !== undefined && payload.exit !== null) meta.push(`exit=${payload.exit}`);
    const metaText = meta.filter(Boolean).join(' · ');

    // Do not append synthetic "[phase]" lines here.
    // The backend already streams detailed logs for these phases, and duplicating them
    // makes the Execute log noisy (especially around repo push/finalize).

    if (executePhaseHeaderEl) executePhaseHeaderEl.textContent = `Phase: ${stage}`;

    if (stage === 'ssh.tunnel') {
        setExecuteProgressStatus('SSH tunnel established', metaText);
        setExecuteProgressPercent(2, 'Tunnel');
        return;
    }
    if (stage === 'core-daemon.startup') {
        setExecuteProgressStatus('Checking core-daemon…', detail || '');
        setExecuteProgressPercent(5, 'Daemon');
        return;
    }
    if (stage === 'core-daemon.start') {
        setExecuteProgressStatus('Starting core-daemon…', metaText);
        setExecuteProgressPercent(8, 'Starting');
        return;
    }
    if (stage === 'core-daemon.systemctl.is-active') {
        setExecuteProgressStatus('Validating core-daemon…', metaText);
        setExecuteProgressPercent(10, 'Validating');
        return;
    }
    if (stage === 'remote.workspace') {
        setExecuteProgressStatus('Remote workspace ready', (payload && payload.repo_dir) ? `repo=${payload.repo_dir}` : '');
        setExecuteProgressPercent(15, 'Workspace');
        return;
    }
    if (stage === 'remote.cli.launch') {
        setExecuteProgressStatus('Launching CLI…', (payload && payload.work_dir) ? `cwd=${payload.work_dir}` : '');
        setExecuteProgressPercent(20, 'Launching');
        return;
    }
    // If there's structured output, append a short excerpt.
    try {
        const out = (payload && payload.stdout) ? String(payload.stdout).trim() : '';
        const err = (payload && payload.stderr) ? String(payload.stderr).trim() : '';
        if (out) appendExecuteProgressLog(out);
        if (err) appendExecuteProgressLog(err);
    } catch (e) {}
}

function settleExecuteConfirm(result) {
    if (!executeConfirmState.pending) {
        return;
    }
    executeConfirmState.pending = false;
    executeConfirmState.keepOpenOnConfirm = false;
    const resolver = executeConfirmState.resolve;
    executeConfirmState.resolve = null;
    const scenarioIndex = executeConfirmState.scenarioIndex;
    executeConfirmState.scenarioIndex = null;
    let payload = {};
    if (typeof result === 'object' && result !== null) {
        payload = { ...result };
    } else {
        payload = { confirmed: false };
    }
    const selections = getExecuteConfirmSelections();
    if (selections) {
        if (typeof selections.updateRemote !== 'undefined' && typeof payload.updateRemote === 'undefined') {
            payload.updateRemote = selections.updateRemote;
        }
        if (typeof selections.remoteExecution !== 'undefined' && typeof payload.remoteExecution === 'undefined') {
            payload.remoteExecution = selections.remoteExecution;
        }
        if (typeof selections.pushPreference !== 'undefined' && typeof payload.pushPreference === 'undefined') {
            payload.pushPreference = selections.pushPreference;
        }
        if (typeof selections.advanced !== 'undefined' && typeof payload.advanced === 'undefined') {
            payload.advanced = selections.advanced;
        }
        if (typeof selections.pushPreference !== 'undefined') {
            setExecuteConfirmUpdateRemotePref(selections.pushPreference);
        } else if (typeof selections.updateRemote !== 'undefined') {
            setExecuteConfirmUpdateRemotePref(selections.updateRemote);
        }
    }
    resolver?.({ ...payload, scenarioIndex });
}

function updateExecuteConfirmAlert(message, tone = 'warning') {
    if (!executeConfirmAlertEl) {
        return;
    }
    const toneClasses = ['alert-warning', 'alert-info', 'alert-danger', 'alert-success'];
    executeConfirmAlertEl.classList.remove(...toneClasses);
    if (!message) {
        executeConfirmAlertEl.textContent = '';
        executeConfirmAlertEl.classList.add('d-none');
        return;
    }
    executeConfirmAlertEl.textContent = message;
    const toneClass = tone === 'danger' ? 'alert-danger'
        : tone === 'info' ? 'alert-info'
        : tone === 'success' ? 'alert-success'
        : 'alert-warning';
    executeConfirmAlertEl.classList.remove('d-none');
    executeConfirmAlertEl.classList.add(toneClass);
}

async function promptExecuteConfirmation(options = {}) {
    const { idx: activeScenarioIdx } = getActiveScenarioContext();
    const scenarioIndex = Number.isInteger(options.scenarioIndex) ? options.scenarioIndex : activeScenarioIdx;
    const message = options.message || 'Execute this scenario now? This will start a CORE session.';
    const alertMessage = options.alertMessage || '';
    const alertTone = options.alertTone || 'warning';
    const keepOpenOnConfirm = !!options.keepOpenOnConfirm;
    ensureExecuteConfirmElements();
    const hasCustomConfirmLabel = Object.prototype.hasOwnProperty.call(options, 'confirmLabel');
    const confirmLabel = hasCustomConfirmLabel ? (options.confirmLabel || 'Execute') : 'Execute';
    const updateRemoteDefault = typeof options.updateRemoteDefault === 'boolean'
        ? options.updateRemoteDefault
        : getExecuteConfirmUpdateRemotePref();
    if (executeConfirmPushUpdateToggle) {
        executeConfirmPushUpdateToggle.checked = !!updateRemoteDefault;
    } else if (typeof updateRemoteDefault === 'boolean') {
        setExecuteConfirmUpdateRemotePref(updateRemoteDefault);
    }
    if (!executeConfirmModalEl || !window.bootstrap) {
        const confirmed = window.confirm(message);
        const remoteExecution = true;
        const pushPreference = !!updateRemoteDefault;
        return {
            confirmed,
            scenarioIndex,
            updateRemote: pushPreference,
            remoteExecution,
            pushPreference,
        };
    }
    executeConfirmState.pending = true;
    executeConfirmState.scenarioIndex = Number.isInteger(scenarioIndex) ? scenarioIndex : null;
    executeConfirmState.keepOpenOnConfirm = keepOpenOnConfirm;
    executeConfirmState.autoLabel = !hasCustomConfirmLabel;
    if (executeConfirmMessageEl) {
        executeConfirmMessageEl.textContent = message;
    }
    updateExecuteConfirmAlert(alertMessage, alertTone);
    resetExecuteProgressUI();
    if (executeConfirmRunBtn) {
        executeConfirmRunBtn.textContent = confirmLabel;
        // Keep the reset/execute progress helpers consistent with the current label.
        executeConfirmRunBtn.dataset.defaultLabel = confirmLabel;
    }
    refreshExecuteRemoteToggleState();
    const modalInstance = bootstrap.Modal.getOrCreateInstance(executeConfirmModalEl);
    return new Promise((resolve) => {
        executeConfirmState.resolve = resolve;
        modalInstance.show();
    });
}

render();
// Populate the dock XML preview even before the first Save.
try { refreshXmlDockPreview({ force: true }); } catch (e) {}

// Restore scroll position if previously saved before a Save XML navigation
function restoreScrollIfAny() {
    try {
        const y = parseInt(sessionStorage.getItem('coretg_saved_scroll_y') || '', 10);
        if (!isNaN(y)) {
            window.scrollTo(0, y);
            sessionStorage.removeItem('coretg_saved_scroll_y');
        }
    } catch (e) { /* ignore */ }
}
// Use load to ensure layout (including dock sizing) has been applied
window.addEventListener('load', restoreScrollIfAny);

// Small helper to persist current scroll position prior to any navigation (form post or link)
function saveScrollBeforeNav(){
    try { sessionStorage.setItem('coretg_saved_scroll_y', String(window.scrollY || window.pageYOffset || 0)); } catch (e) { /* ignore */ }
}

// Always serialize state just before submitting the Save XML form
const editorForm = document.getElementById('editorForm');
const saveXmlBtn = document.getElementById('saveXmlBtn');
let saveXmlToastHandle = null;
let saveXmlToastStartedAt = 0;
let saveXmlToastToken = 0;

// Builder view cannot save XML (admin-only). Prevent accidental submits.
try {
    if (IS_BUILDER_VIEW && saveXmlBtn) {
        saveXmlBtn.disabled = true;
        saveXmlBtn.setAttribute('title', 'Builder view cannot Save XML (admin-only).');
    }
} catch (e) {}

function setSaveXmlBusy(busy) {
    if (!saveXmlBtn) return;
    if (!saveXmlBtn.dataset.defaultLabel) {
        saveXmlBtn.dataset.defaultLabel = saveXmlBtn.innerHTML;
    }
    if (busy) {
        saveXmlBtn.disabled = true;
        saveXmlBtn.innerHTML = '<span class="spinner-border spinner-border-sm me-1" role="status" aria-hidden="true"></span>Saving…';
    } else {
        saveXmlBtn.disabled = false;
        saveXmlBtn.innerHTML = saveXmlBtn.dataset.defaultLabel;
    }
}

function flashSaveXmlSaved() {
    if (!saveXmlBtn) return;
    if (!saveXmlBtn.dataset.defaultLabel) {
        saveXmlBtn.dataset.defaultLabel = saveXmlBtn.innerHTML;
    }
    const token = String(Date.now());
    saveXmlBtn.dataset.flashToken = token;
    saveXmlBtn.innerHTML = 'Saved';
    window.setTimeout(() => {
        try {
            if (!saveXmlBtn) return;
            if (saveXmlBtn.dataset.flashToken !== token) return;
            saveXmlBtn.innerHTML = saveXmlBtn.dataset.defaultLabel;
        } catch (e) { /* ignore */ }
    }, 1200);
}

function setSaveXmlToastBusy(busy) {
    const MIN_TOAST_MS = 650;
    try {
        if (!busy && saveXmlToastHandle && saveXmlToastHandle.toast && typeof saveXmlToastHandle.toast.hide === 'function') {
            const now = Date.now();
            const elapsed = saveXmlToastStartedAt ? (now - saveXmlToastStartedAt) : MIN_TOAST_MS;
            const remaining = Math.max(0, MIN_TOAST_MS - elapsed);
            const token = saveXmlToastToken;
            if (remaining > 0) {
                window.setTimeout(() => {
                    try {
                        // Avoid hiding a newer toast if a second save started.
                        if (token !== saveXmlToastToken) return;
                        if (saveXmlToastHandle && saveXmlToastHandle.toast && typeof saveXmlToastHandle.toast.hide === 'function') {
                            saveXmlToastHandle.toast.hide();
                        }
                    } catch (e) { /* ignore */ }
                }, remaining);
                return;
            }
            saveXmlToastHandle.toast.hide();
        }
    } catch (e) { /* ignore */ }
    saveXmlToastHandle = null;
    saveXmlToastStartedAt = 0;
    if (!busy) return;
    try {
        // Keep it visible until the save completes.
        saveXmlToastToken += 1;
        saveXmlToastStartedAt = Date.now();
        saveXmlToastHandle = showToast('Saving XML…', { autohide: false });
    } catch (e) { /* ignore */ }
}

if (editorForm) {
    const handleEditorFormSubmit = async (event) => {
        if (event) {
            event.preventDefault();
        }

        // Builder view is read-only for Save XML; do not attempt auto-save or fallback form POST.
        if (IS_BUILDER_VIEW) {
            try { showToast('Builder view cannot Save XML (admin-only).', { autohide: true, delay: 2600 }); } catch (_) {}
            return;
        }

        const scrollYBeforeSave = (typeof window !== 'undefined')
            ? (window.scrollY || window.pageYOffset || 0)
            : 0;
        setSaveXmlBusy(true);
        setSaveXmlToastBusy(true);
        // Yield a frame so the toast/spinner can paint before heavy work.
        try { await new Promise(requestAnimationFrame); } catch (_) {}
        try { sessionStorage.setItem('coretg_saved_scroll_y', String(window.scrollY || window.pageYOffset || 0)); } catch (e) { /* ignore */ }
        const scenariosInput = document.getElementById('scenarios_json');
        if (scenariosInput) {
            scenariosInput.value = JSON.stringify({ scenarios: state.scenarios, active_index: activeIdx });
        }
        const coreJsonInput = document.getElementById('core_json');
        if (coreJsonInput) {
            coreJsonInput.value = JSON.stringify(getCoreConfig(true));
        }
        const projectKeyInput = document.getElementById('project_key_hint');
        if (projectKeyInput) {
            projectKeyInput.value = currentProjectKey || DEFAULT_PROJECT_KEY;
        }
        const scenarioQueryInput = document.getElementById('scenario_query_input');
        if (scenarioQueryInput) {
            scenarioQueryInput.value = resolveScenarioQueryHint();
        }
        persistEditorState();
        if (typeof autoSaveXml === 'function') {
            try {
                await autoSaveXml();
                setSaveXmlBusy(false);
                setSaveXmlToastBusy(false);
                flashSaveXmlSaved();
                // Auto-save updates dock preview + layout; restore viewport to where the user was.
                try {
                    await new Promise(requestAnimationFrame);
                    window.scrollTo({ top: scrollYBeforeSave, left: 0, behavior: 'auto' });
                } catch (_) {
                    try { window.scrollTo(0, scrollYBeforeSave); } catch (_) {}
                }
                try { showToast('XML saved.', { autohide: true, delay: 2200 }); } catch (_) {}
                return;
            } catch (err) {
                console.warn('Auto Save XML failed, falling back to full form submit', err);
                setSaveXmlToastBusy(false);
                try { showToast('Auto-save failed; submitting form…', { autohide: true, delay: 2600 }); } catch (_) {}
            }
        }
        editorForm.removeEventListener('submit', handleEditorFormSubmit);
        try {
            editorForm.submit();
        } finally {
            editorForm.addEventListener('submit', handleEditorFormSubmit);
        }
    };
    editorForm.addEventListener('submit', handleEditorFormSubmit);
}

// Shared bottom-bar Save XML should save and stay on this page.
document.addEventListener('DOMContentLoaded', () => {
    try {
        const saveBtn = document.getElementById('saveXmlBtn');
        if (!saveBtn) return;
        saveBtn.addEventListener('click', async (ev) => {
            try {
                ev.preventDefault();
                if (IS_BUILDER_VIEW) {
                    try { showToast('Builder view cannot Save XML (admin-only).', { autohide: true, delay: 2600 }); } catch (_) {}
                    return;
                }
                // Topology tab: warn that saving invalidates Flag Sequencing.
                try {
                    if (typeof SCENARIOS_ACTIVE_TAB === 'string' && SCENARIOS_ACTIVE_TAB === 'topology') {
                        let scenName = '';
                        try {
                            scenName = (state && Array.isArray(state.scenarios) && state.scenarios[activeIdx])
                                ? String(state.scenarios[activeIdx].name || '').trim()
                                : '';
                        } catch (e) {}
                        const msg = scenName
                            ? ('Saving XML from the Topology page will invalidate Flag Sequencing for scenario "' + scenName + '".\n\nYou may need to re-run Generate on the Flag Sequencing page.\n\nContinue?')
                            : 'Saving XML from the Topology page will invalidate Flag Sequencing for this project.\n\nYou may need to re-run Generate on the Flag Sequencing page.\n\nContinue?';
                        const proceed = window.confirm(msg);
                        if (!proceed) return;
                    }
                } catch (e) {}
                if (typeof window.coretgSaveXmlViaApi !== 'function') {
                    alert('Save helper unavailable; refresh and try again.');
                    return;
                }
                // Mirror existing UX: show busy indicator while saving.
                try { setSaveXmlBusy(true); } catch (e) {}
                try { setSaveXmlToastBusy(true); } catch (e) {}
                const scrollYBeforeSave = (typeof window !== 'undefined')
                    ? (window.scrollY || window.pageYOffset || 0)
                    : 0;
                const xmlPath = await window.coretgSaveXmlViaApi();
                try { setSaveXmlBusy(false); } catch (e) {}
                try { setSaveXmlToastBusy(false); } catch (e) {}
                try { flashSaveXmlSaved(); } catch (e) {}
                try { showToast('XML saved.', { autohide: true, delay: 2200 }); } catch (_) {}
                // Keep viewport stable.
                try {
                    await new Promise(requestAnimationFrame);
                    window.scrollTo({ top: scrollYBeforeSave, left: 0, behavior: 'auto' });
                } catch (_) {
                    try { window.scrollTo(0, scrollYBeforeSave); } catch (_) {}
                }
                // Ensure download button + preview tab have the latest path.
                try {
                    if (xmlPath && typeof xmlPath === 'string') {
                        state.result_path = xmlPath;
                        try { updateDownloadButtonState(); } catch (e) {}
                        try { persistEditorState(); } catch (e) {}
                    }
                } catch (e) {}
            } catch (e) {
                try { setSaveXmlToastBusy(false); } catch (_e) {}
                try { setSaveXmlBusy(false); } catch (_e) {}
                try { alert('Save failed: ' + (e && e.message ? e.message : e)); } catch (_e) {}
            }
        });
    } catch (e) {}
});

// Enable Bootstrap tooltips globally
document.addEventListener('DOMContentLoaded', () => {
    const tooltipTriggerList = [].slice.call(document.querySelectorAll('[data-bs-toggle="tooltip"]'));
    tooltipTriggerList.forEach(el => {
        // Bootstrap 5 throws if title option resolves to null; normalize to empty string
        const dt = el.getAttribute('data-bs-title') || el.getAttribute('title');
        if (dt === null) {
            // skip creating tooltip entirely if no title is present
            return;
        }
        if (dt.trim() === '') {
            el.setAttribute('data-bs-title', '');
        }
        try { new bootstrap.Tooltip(el); } catch (e) { /* ignore */ }
    });
    const proxAssignModal = document.getElementById('proxmoxAssignModal');
    const proxAssignSave = document.getElementById('proxmoxAssignSave');
    const proxAssignError = document.getElementById('proxmoxAssignError');
    const proxAssignHint = document.getElementById('proxmoxAssignHint');
    const proxAssignForm = document.getElementById('proxmoxAssignForm');
    const proxUrlInput = document.getElementById('proxmoxUrl');
    const proxPortInput = document.getElementById('proxmoxPort');
    const proxUserInput = document.getElementById('proxmoxUsername');
    const proxPassInput = document.getElementById('proxmoxPassword');
    const proxRememberInput = document.getElementById('proxmoxRememberCreds');
    const clearProxError = () => {
        if (!proxAssignError) return;
        proxAssignError.textContent = '';
        proxAssignError.classList.add('d-none');
    };
    const showProxError = (message) => {
        if (!proxAssignError) return;
        proxAssignError.textContent = message;
        proxAssignError.classList.remove('d-none');
    };
    const setProxAssignBusy = (busy) => {
        if (!proxAssignSave) return;
        if (!proxAssignSave.dataset.defaultLabel) {
            proxAssignSave.dataset.defaultLabel = proxAssignSave.innerHTML;
        }
        if (busy) {
            proxAssignSave.disabled = true;
            proxAssignSave.innerHTML = '<span class="spinner-border spinner-border-sm me-1" role="status" aria-hidden="true"></span>Validating…';
        } else {
            proxAssignSave.disabled = false;
            proxAssignSave.innerHTML = proxAssignSave.dataset.defaultLabel;
        }
        if (proxAssignForm) {
            proxAssignForm.querySelectorAll('input').forEach(inp => {
                if (busy) {
                    inp.setAttribute('data-prox-disabled-prev', inp.disabled ? '1' : '0');
                    inp.disabled = true;
                } else {
                    const prev = inp.getAttribute('data-prox-disabled-prev');
                    inp.disabled = prev === '1';
                    inp.removeAttribute('data-prox-disabled-prev');
                }
            });
        }
    };
    const setProxAssignHint = window.setProxAssignHint || ((message, tone = 'info') => {
        if (!proxAssignHint) return;
        proxAssignHint.textContent = message || '';
        proxAssignHint.style.display = message ? '' : 'none';
        proxAssignHint.classList.remove('alert-info', 'alert-success', 'alert-danger');
        const klass = tone === 'success' ? 'alert-success' : tone === 'danger' ? 'alert-danger' : 'alert-info';
        proxAssignHint.classList.add(klass);
    });
    if (!window.setProxAssignHint) {
        window.setProxAssignHint = setProxAssignHint;
    }
    proxAssignSave?.addEventListener('click', async () => {
        if (!proxAssignModal) return;
        const sidx = parseInt(proxAssignModal.getAttribute('data-scen-idx') || '', 10);
        if (isNaN(sidx) || !state.scenarios?.[sidx]) {
            showProxError('Scenario context unavailable.');
            return;
        }
    if (!proxAssignForm) return;
        if (!proxAssignForm.checkValidity()) {
            proxAssignForm.reportValidity();
            return;
        }
        clearProxError();
        const urlVal = (proxUrlInput?.value || '').trim();
        if (!/^https?:\/\//i.test(urlVal)) {
            showProxError('URL must start with http:// or https://');
            proxUrlInput?.focus();
            return;
        }
        const portVal = parseInt(proxPortInput?.value || '8006', 10);
        if (!Number.isFinite(portVal) || portVal < 1 || portVal > 65535) {
            showProxError('Port must be between 1 and 65535');
            proxPortInput?.focus();
            return;
        }
        const userVal = (proxUserInput?.value || '').trim();
        if (!userVal) {
            showProxError('Username is required.');
            proxUserInput?.focus();
            return;
        }
        const scenario = state.scenarios[sidx];
        const hitlState = ensureHitlStateForScenario(scenario);
        const prox = hitlState.proxmox || {};
        const rememberCreds = proxRememberInput ? !!proxRememberInput.checked : true;
        hitlState.proxmox.remember_credentials = rememberCreds;
        const passVal = proxPassInput?.value ?? '';
        if (!passVal && !prox.secret_id) {
            showProxError('Password is required.');
            proxPassInput?.focus();
            return;
        }
        const verifyInput = document.getElementById('proxmoxVerifySsl');
        const verifySsl = verifyInput ? !!verifyInput.checked : /^https:/i.test(urlVal);
        persistSavedProxmoxDefaults({ url: urlVal, port: portVal, username: userVal, verify_ssl: verifySsl });

        setProxAssignBusy(true);
        setProxAssignHint('Validating credentials with Proxmox…', 'info');
        let data = null;
        const requestPayload = {
            url: urlVal,
            port: portVal,
            username: userVal,
            password: passVal,
            verify_ssl: verifySsl,
            scenario_index: sidx,
            scenario_name: scenario?.name || '',
            timeout: 8.0,
            remember_credentials: rememberCreds,
        };
        if (rememberCreds && !passVal && prox.secret_id) {
            requestPayload.reuse_secret_id = prox.secret_id;
        }
        try {
            const resp = await fetch('/api/proxmox/validate', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                credentials: 'same-origin',
                body: JSON.stringify(requestPayload),
            });
            try {
                data = await resp.json();
            } catch (err) {
                data = null;
            }
            if (!resp.ok || !data || data.success === false) {
                const errMsg = (data && data.error) ? data.error : `Validation failed (HTTP ${resp.status})`;
                throw new Error(errMsg);
            }
        } catch (err) {
            const message = err instanceof Error ? err.message : 'Unknown error during validation';
            showProxError(message);
            setProxAssignHint('', 'info');
            setProxAssignBusy(false);
            return;
        }
        try {
            const summary = data?.summary || {};
            const previousSecretId = hitlState.proxmox?.secret_id || null;
            const nowIso = new Date().toISOString();
            const updatedProx = {
                ...hitlState.proxmox,
                url: urlVal,
                port: summary.port ?? portVal,
                username: summary.username ?? userVal,
                verify_ssl: summary.verify_ssl ?? verifySsl,
                last_message: data?.message || 'Credentials validated and stored securely.',
            };
            if (rememberCreds) {
                const newSecretId = data?.secret_id || summary.identifier || null;
                updatedProx.secret_id = newSecretId;
                updatedProx.validated = !!newSecretId;
                updatedProx.last_validated_at = summary.stored_at || nowIso;
            } else {
                updatedProx.secret_id = previousSecretId;
                if (!previousSecretId) {
                    updatedProx.validated = false;
                    updatedProx.last_validated_at = null;
                }
            }
            hitlState.proxmox = updatedProx;
            if ('password' in hitlState.proxmox) {
                delete hitlState.proxmox.password;
            }
            updateProxmoxSummary(sidx);
            persistEditorState();
            const hidden = document.getElementById('scenarios_json');
            if (hidden) hidden.value = JSON.stringify({ scenarios: state.scenarios, active_index: activeIdx });
            if (rememberCreds && hitlState.proxmox.secret_id) {
                try { showToast('Refreshing Proxmox VM inventory…', { autohide: true, delay: 1500 }); } catch (e) {}
                await fetchProxmoxInventory(sidx, { force: true });
            }
            if (proxPassInput) proxPassInput.value = '';
            const successMessage = data?.message || 'Proxmox credentials validated and stored securely.';
            const successTone = rememberCreds ? 'success' : 'warning';
            setProxAssignHint(successMessage, successTone);
            try { showToast(successMessage, { autohide: true, delay: 2500 }); } catch(e) {}
            const modalInstance = window.bootstrap ? bootstrap.Modal.getInstance(proxAssignModal) : null;
            setTimeout(() => { modalInstance?.hide(); }, 400);
        } catch (err) {
            const message = err instanceof Error ? err.message : 'Failed to persist Proxmox state locally';
            showProxError(message);
            setProxAssignHint('', 'info');
        } finally {
            setProxAssignBusy(false);
        }
    });
    if (proxAssignModal && window.bootstrap) {
        proxAssignModal.addEventListener('hidden.bs.modal', () => {
            proxAssignModal.removeAttribute('data-scen-idx');
            clearProxError();
            setProxAssignHint('', 'info');
            if (proxPassInput) proxPassInput.value = '';
            const verifyInput = document.getElementById('proxmoxVerifySsl');
            if (verifyInput) verifyInput.checked = true;
        });
    }
    if (coreConnectionModal && window.bootstrap) {
        coreConnectionModal.addEventListener('hidden.bs.modal', () => {
            coreConnectionModal.removeAttribute('data-scen-idx');
            if (coreConnectionForm) {
                coreConnectionForm.classList.remove('was-validated');
            }
            if (coreModalInputs.ssh_password) {
                coreModalInputs.ssh_password.value = '';
                coreModalInputs.ssh_password.removeAttribute('placeholder');
            }
            if (typeof setCoreConnectionHint === 'function') {
                setCoreConnectionHint('', 'info');
            }
        });
    }
    const externalIfxModal = document.getElementById('externalIfxModal');
    if (externalIfxModal) {
        externalIfxModal.addEventListener('hide.bs.modal', () => {
            const active = document.activeElement;
            if (active && externalIfxModal.contains(active) && typeof active.blur === 'function') {
                active.blur();
            }
        });
        externalIfxModal.addEventListener('hidden.bs.modal', () => {
            clearExternalIfxStatus();
            setExternalIfxApplyBusy(false);
            const triggerBtn = document.querySelector('[data-bs-target="\#externalIfxModal"]');
            if (triggerBtn && typeof triggerBtn.focus === 'function') {
                triggerBtn.focus();
            }
        });
    }
    // Wire Download XML button
    const dlBtn = document.getElementById('downloadXmlBtn');
    if (dlBtn) {
        dlBtn.addEventListener('click', () => {
            const rp = state.result_path || '';
            if (!rp || !rp.endsWith('.xml')) { alert('Please Save XML first.'); return; }
            window.location.href = window.location.origin + '/download_report?path=' + encodeURIComponent(rp);
        });
        // Initial state based on state.result_path
        const rp0 = state.result_path || '';
        if (rp0 && rp0.endsWith('.xml')) { dlBtn.removeAttribute('disabled'); dlBtn.classList.remove('pe-none'); dlBtn.setAttribute('title',''); }
    }
    // Capture any server-rendered logs before we render from storage
    let __serverLogsAtLoad = '';
    try { __serverLogsAtLoad = (document.getElementById('logsPre')?.textContent || '').trim(); } catch(e){}
    setupVulnCatalog();
});

// Vulnerability catalog and UI helpers
async function setupVulnCatalog(){
        try {
                const res = await fetch('/vuln_catalog');
        if(res.ok){ window.VULN_CATALOG = await res.json(); }
    } catch(e) { window.VULN_CATALOG = { types: [], vectors: [], items: [] }; }
}

function populateVulnSelects() {
        document.querySelectorAll('.vuln-type').forEach(sel => {
                const sidx = parseInt(sel.getAttribute('data-scen-idx'));
                const sec = sel.getAttribute('data-sec');
                const iidx = parseInt(sel.getAttribute('data-item-idx'));
                const cur = (state.scenarios[sidx].sections[sec].items[iidx].v_type) || 'Random';
                const opts = ['Random', ...(window.VULN_CATALOG?.types || [])];
                sel.innerHTML = opts.map(o => `<option ${o===cur?'selected':''}>${o}</option>`).join('');
        });
        document.querySelectorAll('.vuln-vector').forEach(sel => {
                const sidx = parseInt(sel.getAttribute('data-scen-idx'));
                const sec = sel.getAttribute('data-sec');
                const iidx = parseInt(sel.getAttribute('data-item-idx'));
                const cur = (state.scenarios[sidx].sections[sec].items[iidx].v_vector) || 'Random';
                const opts = ['Random', ...(window.VULN_CATALOG?.vectors || [])];
                sel.innerHTML = opts.map(o => `<option ${o===cur?'selected':''}>${o}</option>`).join('');
        });
}

// Modal for Specific selection
function ensureVulnModal(){
        if(document.getElementById('vulnModal')) return;
        const modal = document.createElement('div');
        modal.className = 'modal fade';
        modal.id = 'vulnModal';
        modal.innerHTML = `
        <div class="modal-dialog modal-lg">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title">Select Vulnerability</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
                </div>
                <div class="modal-body">
                    <div id="vulnLoadingWrap" class="mb-3" style="display:none;">
                        <div class="d-flex align-items-center gap-2 mb-2 text-muted small">
                            <div class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></div>
                            <span id="vulnLoadMeta">Loading eligible items…</span>
                        </div>
                        <div class="progress" style="height: 14px;">
                            <div class="progress-bar" id="vulnLoadProgressBar" role="progressbar" style="width:0%" aria-valuenow="0" aria-valuemin="0" aria-valuemax="100">0%</div>
                        </div>
                    </div>
                    <div class="d-flex align-items-start gap-2 mb-2">
                        <div class="flex-grow-1">
                            <input class="form-control" placeholder="Filter (string or /regex/)" id="vulnFilter">
                            <div class="invalid-feedback" id="vulnFilterError">Invalid regex</div>
                        </div>
                        <button class="btn btn-outline-secondary" type="button" id="vulnFilterClear" title="Clear filter">Clear</button>
                    </div>
                    <div class="text-muted small mb-2" id="vulnFilterMeta"></div>
                    <div class="table-responsive" id="vulnTableWrap" style="max-height:50vh; overflow:auto; display:none;">
                        <table class="table table-sm">
                            <thead><tr><th>Name</th><th>Type</th><th>Vector</th><th>Status</th><th>Actions</th><th>Path</th></tr></thead>
                            <tbody id="vulnList"></tbody>
                        </table>
                    </div>
                </div>
                <div class="modal-footer">
                    <button class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
                </div>
            </div>
        </div>`;
        document.body.appendChild(modal);
}

function ensureVulnProgressModal(){
        if(document.getElementById('vulnProgressModal')) return;
        const m = document.createElement('div');
        m.className = 'modal fade';
        m.id = 'vulnProgressModal';
        m.setAttribute('tabindex', '-1');
        m.innerHTML = `
        <div class="modal-dialog modal-dialog-centered modal-lg">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title">Vulnerability Download/Pull</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <div class="d-flex justify-content-between align-items-center mb-2 small text-muted">
                        <div id="vulnProgressStatus">Starting…</div>
                        <div id="vulnProgressMeta"></div>
                    </div>
                    <div class="progress mb-2">
                        <div class="progress-bar progress-bar-striped progress-bar-animated" id="vulnProgressBar" role="progressbar" style="width:0%" aria-valuenow="0" aria-valuemin="0" aria-valuemax="100">0%</div>
                    </div>
                    <div class="border rounded" style="max-height: 220px; overflow: auto;">
                        <pre class="m-0 p-2 small" id="vulnProgressLog" style="white-space: pre-wrap;"></pre>
                    </div>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Hide</button>
                </div>
            </div>
        </div>`;
        document.body.appendChild(m);
}

function showVulnProgressModal(){
        ensureVulnProgressModal();
        const el = document.getElementById('vulnProgressModal');
        if(!el) return null;
        try {
            if(window.bootstrap){
                const modal = bootstrap.Modal.getOrCreateInstance(el, { backdrop: 'static', keyboard: false, focus: true });
                modal.show();
                // Keep this above other modals/backdrops.
                el.style.zIndex = '20050';
                setTimeout(() => {
                    try {
                        const backs = document.querySelectorAll('.modal-backdrop');
                        const back = backs && backs.length ? backs[backs.length - 1] : null;
                        if(back) back.style.zIndex = '20040';
                    } catch (e) {}
                }, 0);
                return modal;
            }
        } catch (e) {}
        return null;
}

function setVulnProgress(pct, label){
        try {
            const bar = document.getElementById('vulnProgressBar');
            const status = document.getElementById('vulnProgressStatus');
            const meta = document.getElementById('vulnProgressMeta');
            const clamped = Math.max(0, Math.min(100, Number(pct) || 0));
            if(bar){
                bar.style.width = clamped.toFixed(0) + '%';
                bar.setAttribute('aria-valuenow', String(clamped));
                bar.textContent = clamped.toFixed(0) + '%';
            }
            if(status && label) status.textContent = label;
            if(meta) meta.textContent = '';
        } catch (e) {}
}

function clearVulnProgressLog(){
        try {
            const pre = document.getElementById('vulnProgressLog');
            if(pre) pre.textContent = '';
        } catch (e) {}
}

function vulnProgressLogLine(line){
        try {
            const pre = document.getElementById('vulnProgressLog');
            if(!pre) return;
            const text = String(line ?? '');
            pre.textContent += (pre.textContent ? '\n' : '') + text;
            // Keep scrolled to bottom
            const parent = pre.parentElement;
            if(parent) parent.scrollTop = parent.scrollHeight;
        } catch (e) {}
}

function hideVulnProgressModal(){
        try {
            const el = document.getElementById('vulnProgressModal');
            if(!el || !window.bootstrap) return;
            const modal = bootstrap.Modal.getInstance(el);
            modal?.hide();
        } catch (e) {}
}

async function openVulnPicker(sidx, secName, iidx){
    ensureVulnModal();
    const modalEl = document.getElementById('vulnModal');
    if (!modalEl) {
        logError('Vulnerability modal element not found');
        return;
    }
    const modalObj = window.bootstrap ? (bootstrap.Modal.getInstance(modalEl) || new bootstrap.Modal(modalEl, { backdrop: true, keyboard: true })) : null;
    const filterInput = modalEl.querySelector('#vulnFilter');
    const filterClearBtn = modalEl.querySelector('#vulnFilterClear');
    const filterMeta = modalEl.querySelector('#vulnFilterMeta');
    const filterError = modalEl.querySelector('#vulnFilterError');
    const tbody = modalEl.querySelector('#vulnList');
    const tblWrap = modalEl.querySelector('#vulnTableWrap');
    const loadWrap = modalEl.querySelector('#vulnLoadingWrap');
    const loadBar = modalEl.querySelector('#vulnLoadProgressBar');
    const loadMeta = modalEl.querySelector('#vulnLoadMeta');
    const row = state.scenarios[sidx].sections[secName].items[iidx] || {};
    const selVector = (row.v_vector || 'Random');
    // Base: docker-compose only
    const all = (window.VULN_CATALOG?.items || []);
    let base = all.filter(it => (it.Type||'').toLowerCase() === 'docker-compose');
    if (selVector && selVector !== 'Random') {
        const vv = selVector.toLowerCase();
        base = base.filter(it => (it.Vector||'').toLowerCase() === vv);
    }
    // Status cache keyed by Path (stable) or Name fallback
    const statusByKey = new Map();
    const itemKey = (it) => String((it && (it.Path || it.Name)) || '');

    const setProgress = (pct, label) => {
        try {
            const clamped = Math.max(0, Math.min(100, Number(pct) || 0));
            if (loadBar) {
                loadBar.style.width = clamped.toFixed(0) + '%';
                loadBar.setAttribute('aria-valuenow', String(clamped));
                loadBar.textContent = clamped.toFixed(0) + '%';
            }
            if (loadMeta && label) loadMeta.textContent = label;
        } catch (e) {}
    };

    const fetchStatuses = async (items, phaseLabel = 'Checking images…') => {
        const list = Array.isArray(items) ? items : [];
        if (!list.length) return;
        const chunkSize = 25;
        const total = list.length;
        let done = 0;
        for (let i = 0; i < total; i += chunkSize) {
            const chunk = list.slice(i, i + chunkSize);
            setProgress(total ? (done / total) * 100 : 0, `${phaseLabel} (${Math.min(done + chunk.length, total)}/${total})`);
            let payload = null;
            try {
                const res = await fetch('/vuln_compose/status_images', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    credentials: 'same-origin',
                    body: JSON.stringify({
                        items: chunk.map(it => ({
                            Name: it.Name,
                            Path: it.Path,
                            compose: it.compose || 'docker-compose.yml',
                        }))
                    }),
                });
                payload = res.ok ? await res.json().catch(() => null) : null;
            } catch (e) {
                payload = null;
            }
            const got = payload && Array.isArray(payload.items) ? payload.items : [];
            got.forEach(st => {
                try {
                    const key = String((st && (st.Path || st.Name)) || '');
                    if (key) statusByKey.set(key, st);
                } catch (e) {}
            });
            done += chunk.length;
        }
        setProgress(100, 'Done');
    };

    // Show modal and kick off status check
    let eligible = base;
    let current = eligible;
    try {
        if (modalObj) modalObj.show();
    } catch(e){}
    try {
        if (tblWrap) tblWrap.style.display = 'none';
        if (loadWrap) loadWrap.style.display = '';
        setProgress(0, 'Checking downloaded/pulled status…');
    } catch (e) {}
    try {
        await fetchStatuses(eligible, 'Checking images…');
    } catch (e) {}
    try {
        if (loadWrap) loadWrap.style.display = 'none';
        if (tblWrap) tblWrap.style.display = '';
    } catch (e) {}

    const statusBadgeHtml = (st) => {
        try {
            if (!st) return '<span class="badge text-bg-secondary">Unknown</span>';
            if (st.docker_available === false) return '<span class="badge text-bg-secondary" title="Docker not available">No docker</span>';
            if (!st.exists) return '<span class="badge text-bg-warning" title="Compose not downloaded">Not downloaded</span>';
            if (!st.pulled) {
                const missing = Array.isArray(st.missing_images) ? st.missing_images.length : 0;
                return `<span class="badge text-bg-warning" title="Missing images">Missing ${missing}</span>`;
            }
            return '<span class="badge text-bg-success">Ready</span>';
        } catch (e) {
            return '<span class="badge text-bg-secondary">Unknown</span>';
        }
    };

    const isPickable = (st) => {
        try {
            if (!st) return false;
            if (st.docker_available === false) return false;
            return !!(st.exists && st.pulled);
        } catch (e) {
            return false;
        }
    };

    const canDownloadPull = (st) => {
        try {
            if (!st) return true;
            if (st.docker_available === false) return false;
            return !(st.exists && st.pulled);
        } catch (e) {
            return false;
        }
    };

    const downloadPullOne = async (it) => {
        const key = itemKey(it);
        const payloadItem = { Name: it.Name, Path: it.Path, compose: it.compose || 'docker-compose.yml' };
        const pm = showVulnProgressModal();
        try { clearVulnProgressLog(); } catch (e) {}
        try { vulnProgressLogLine(`Target: ${it.Name}`); } catch (e) {}
        try { setVulnProgress(0, `Downloading ${it.Name}…`); } catch (e) {}

        // Download best-effort (some may already exist)
        try {
            const resDl = await fetch('/vuln_compose/download', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                credentials: 'same-origin',
                body: JSON.stringify({ items: [payloadItem] }),
            });
            try {
                const data = resDl.ok ? await resDl.json().catch(() => null) : null;
                if (!resDl.ok) {
                    vulnProgressLogLine(`Download failed (HTTP ${resDl.status}).`);
                }
                if (data && Array.isArray(data.logs)) {
                    data.logs.forEach(l => vulnProgressLogLine(l));
                }
                if (data && Array.isArray(data.items) && data.items.length) {
                    vulnProgressLogLine(`Download result: ${JSON.stringify(data.items[0])}`);
                }
            } catch (e) {}
        } catch (e) {}

        try { setVulnProgress(45, `Pulling images for ${it.Name}…`); } catch (e) {}
        try {
            const resPull = await fetch('/vuln_compose/pull', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                credentials: 'same-origin',
                body: JSON.stringify({ items: [payloadItem] }),
            });
            try {
                const data = resPull.ok ? await resPull.json().catch(() => null) : null;
                if (!resPull.ok) {
                    vulnProgressLogLine(`Pull failed (HTTP ${resPull.status}).`);
                }
                if (data && Array.isArray(data.logs)) {
                    data.logs.forEach(l => vulnProgressLogLine(l));
                }
                if (data && Array.isArray(data.items) && data.items.length) {
                    vulnProgressLogLine(`Pull result: ${JSON.stringify(data.items[0])}`);
                }
            } catch (e) {}
        } catch (e) {}

        try { setVulnProgress(80, `Refreshing status for ${it.Name}…`); } catch (e) {}
        try {
            await fetchStatuses([it], 'Refreshing…');
        } catch (e) {}

        try {
            // If status endpoint returned Name key but itemKey used Path, reconcile
            if (!statusByKey.has(key)) {
                const altKey = String(it.Name || '');
                if (altKey && statusByKey.has(altKey)) {
                    statusByKey.set(key, statusByKey.get(altKey));
                }
            }
        } catch (e) {}

        try { setVulnProgress(100, 'Done'); } catch (e) {}
        try { await new Promise(r => setTimeout(r, 300)); } catch (e) {}
        try { hideVulnProgressModal(); } catch (e) {}
        try { pm?.hide?.(); } catch (e) {}
    };

    const allowDownloadPullActions = (IS_ADMIN_USER && !IS_BUILDER_VIEW);

    const renderRows = () => {
        tbody.innerHTML = '';
        if (!current || current.length === 0) {
            const tr = document.createElement('tr');
            const td = document.createElement('td');
            td.colSpan = 6;
            td.className = 'text-center text-muted py-3';
            td.textContent = 'No results';
            tr.appendChild(td);
            tbody.appendChild(tr);
            return;
        }
        current.forEach((it) => {
            const st = statusByKey.get(itemKey(it)) || null;
            const tr = document.createElement('tr');
            tr.innerHTML = `<td>${it.Name}</td><td>${it.Type}</td><td>${it.Vector}</td><td>${statusBadgeHtml(st)}</td><td></td><td>${it.Path}</td>`;
            const pickable = isPickable(st);
            tr.style.cursor = pickable ? 'pointer' : 'not-allowed';
            if (!pickable) tr.classList.add('text-muted');

            // Action button (Download/Pull) when not ready
            try {
                const actionTd = tr.children[4];
                if (actionTd) {
                    const needs = canDownloadPull(st);
                    if (needs) {
                        const btn = document.createElement('button');
                        btn.type = 'button';
                        btn.className = 'btn btn-sm btn-outline-primary';
                        btn.textContent = 'Download/Pull';
                        if (st && st.docker_available === false) {
                            btn.disabled = true;
                            btn.title = 'Docker not available';
                        }
                        if (!allowDownloadPullActions) {
                            btn.disabled = true;
                            btn.className = 'btn btn-sm btn-outline-secondary';
                            btn.textContent = 'Admin required';
                            btn.title = 'Download/Pull requires admin access.';
                        }
                        btn.onclick = async (ev) => {
                            try { ev.preventDefault(); ev.stopPropagation(); } catch (e) {}
                            if (!allowDownloadPullActions) {
                                try { alert('Download/Pull requires admin access.'); } catch (e) {}
                                return;
                            }
                            try {
                                const confirmMsg = `Download compose and pull images for “${it.Name}”?`;
                                if (!confirm(confirmMsg)) return;
                                btn.disabled = true;
                                await downloadPullOne(it);
                                applyFilter();
                            } catch (e) {
                                console.warn('Download/Pull failed', e);
                                alert('Download/Pull failed. Check server logs.');
                            } finally {
                                try { btn.disabled = false; } catch (e) {}
                            }
                        };
                        actionTd.appendChild(btn);
                    } else {
                        actionTd.innerHTML = '<span class="text-muted small">—</span>';
                    }
                }
            } catch (e) {}

            tr.onclick = async () => {
                if (!pickable) {
                    try {
                        const msg = (!st || st.docker_available === false)
                            ? 'Docker not available; cannot select this vulnerability.'
                            : (!st.exists ? 'Compose not downloaded; use Download/Pull.' : 'Images not pulled; use Download/Pull.');
                        logWarn(msg);
                        alert(msg);
                    } catch (e) {}
                    return;
                }
                const item = state.scenarios[sidx].sections[secName].items[iidx];
                item.v_name = it.Name;
                item.v_path = it.Path;
                item.v_type = it.Type;
                item.v_vector = it.Vector;
                if (it.Description) item.v_desc = it.Description;
                // also set selected to Specific defensively
                item.selected = 'Specific';
                try { persistEditorState(); } catch (e) {}
                try {
                    if (typeof flushServerSnapshotPersistNow === 'function') {
                        const res = await flushServerSnapshotPersistNow();
                        if (res && res.ok === false) {
                            try { console.warn('Snapshot flush failed', res.error); } catch (_) {}
                        }
                    }
                } catch (e) {}
                document.getElementById('scenarios_json').value = JSON.stringify({ scenarios: state.scenarios, active_index: activeIdx });
                try { if(window.bootstrap){ bootstrap.Modal.getInstance(modalEl)?.hide(); } } catch(e) {}
                renderMain();
            };
            tbody.appendChild(tr);
        });
    };
    const applyFilter = () => {
        const raw = (filterInput.value||'').trim();
        try { localStorage.setItem('vulnPickerFilter', raw); } catch(e){}
        filterInput.classList.remove('is-invalid');
        if (filterError) filterError.style.display = '';
        if(!raw){
            current = eligible;
            renderRows();
            if (filterMeta) filterMeta.textContent = `${current.length}/${eligible.length} shown`;
            return;
        }
        let matcher = null;
        if (raw.startsWith('/') && raw.endsWith('/') && raw.length >= 2) {
            try { matcher = new RegExp(raw.slice(1, -1), 'i'); } catch(e){ matcher = null; }
            if (!matcher) {
                filterInput.classList.add('is-invalid');
                if (filterMeta) filterMeta.textContent = `Invalid regex`;
                return;
            }
            current = eligible.filter((it) => {
                const haystack = `${it.Name||''} ${it.Type||''} ${it.Vector||''} ${it.Path||''}`;
                return matcher.test(haystack);
            });
        } else {
            const needle = raw.toLowerCase();
            current = eligible.filter((it) => {
                return [it.Name, it.Type, it.Vector, it.Path].some(val => (val||'').toLowerCase().includes(needle));
            });
        }
        renderRows();
        try {
            const ready = eligible.filter(it => {
                const st = statusByKey.get(itemKey(it)) || null;
                return isPickable(st);
            }).length;
            if (filterMeta) filterMeta.textContent = `${current.length}/${eligible.length} shown (ready: ${ready})`;
        } catch (e) {
            if (filterMeta) filterMeta.textContent = `${current.length}/${eligible.length} shown`;
        }
    };
    filterInput.oninput = applyFilter;
    filterClearBtn.onclick = () => { filterInput.value = ''; applyFilter(); };
    // Load last-used filter, if any
    try {
        const saved = localStorage.getItem('vulnPickerFilter');
        if (saved) filterInput.value = saved;
    } catch(e){}
    // Render immediately and show counts
    try {
        renderRows();
        applyFilter();
    } catch(e){}
}

const RUN_CLI_URL = "{{ url_for('run_cli_async') }}";
const PUSH_REPO_URL = "{{ url_for('core_push_repo_route') }}";
const PUSH_REPO_STATUS_BASE = "{{ url_for('core_push_repo_status', progress_id='__PROGRESS__') }}";

function buildRunFormData(xmlPath, options = {}) {
    const form = new FormData();
    if (xmlPath) {
        form.append('xml_path', xmlPath);
    }
    appendScenarioContextToFormData(form, options);
    try {
        form.append('core_json', JSON.stringify(getCoreConfig(true)));
    } catch (err) {
        form.append('core_json', '{}');
    }
    if (options && options.updateRemoteRepo) {
        form.append('update_remote_repo', '1');
    }
    try {
        const adv = options && typeof options.advanced === 'object' ? options.advanced : null;
        if (adv && adv.fixDockerDaemon) form.append('adv_fix_docker_daemon', '1');
        if (adv && adv.runCoreCleanup) form.append('adv_run_core_cleanup', '1');
        if (adv && adv.dockerCleanupBeforeRun) form.append('docker_cleanup_before_run', '1');
        if (adv && adv.dockerNukeAll) form.append('docker_remove_all_containers', '1');
        if (adv && adv.checkCoreVersion) form.append('adv_check_core_version', '1');
        if (adv && adv.restartCoreDaemon) form.append('adv_restart_core_daemon', '1');
        if (adv && adv.autoKillSessions) form.append('adv_auto_kill_sessions', '1');
        if (adv && adv.uploadOnlyInjectedArtifacts) form.append('upload_only_injected_artifacts', '1');
    } catch (err) { /* ignore */ }
    return form;
}

async function parseResponseJson(response) {
    if (!response || typeof response.clone !== 'function') {
        return null;
    }
    try {
        const text = await response.clone().text();
        if (!text) {
            return null;
        }
        return JSON.parse(text);
    } catch (err) {
        return null;
    }
}

async function extractResponseDetail(response) {
    if (!response) {
        return '';
    }
    const jsonData = await parseResponseJson(response);
    if (jsonData && typeof jsonData === 'object') {
        if (typeof jsonData.error === 'string' && jsonData.error.trim()) {
            return jsonData.error.trim();
        }
        try {
            return JSON.stringify(jsonData);
        } catch (err) {
            return '';
        }
    }
    try {
        const text = await response.clone().text();
        if (text && text.trim()) {
            return text.trim();
        }
    } catch (err) {
        return '';
    }
    const statusText = response.statusText ? ` ${response.statusText}` : '';
    return `HTTP ${response.status}${statusText}`.trim();
}

async function pushRepoToRemote(xmlPath, options = {}) {
    const formOptions = { ...options };
    const onProgress = typeof formOptions.onProgress === 'function' ? formOptions.onProgress : null;
    const onResponseProgress = typeof formOptions.onResponseProgress === 'function' ? formOptions.onResponseProgress : null;
    const onFinalizeProgress = typeof formOptions.onFinalizeProgress === 'function' ? formOptions.onFinalizeProgress : null;
    delete formOptions.onProgress;
    delete formOptions.onResponseProgress;
    delete formOptions.onFinalizeProgress;
    formOptions.updateRemoteRepo = false;
    const form = buildRunFormData(xmlPath, formOptions);
    logInfo('Uploading repository to CORE host…');
    if (typeof XMLHttpRequest === 'undefined') {
        // Fallback to fetch without rich progress reporting
        try {
            const res = await fetch(PUSH_REPO_URL, { method: 'POST', body: form });
            if (!res.ok) {
                const detail = await extractResponseDetail(res);
                const message = detail ? `Repo upload failed: ${detail}` : `Repo upload failed (HTTP ${res.status})`;
                logError(message);
                alert(message);
                return false;
            }
            const data = await parseResponseJson(res);
            const repoPath = data && typeof data === 'object' ? data.repo_path : null;
            const progressId = data && typeof data.progress_id === 'string' ? data.progress_id : null;
            logInfo(`Repository uploaded${repoPath ? ` to ${repoPath}` : ''}.`);
            if (progressId) {
                const unregister = registerExecuteCancelHandler(() => {
                    try {
                        return fetch('/core/push_repo/cancel/' + encodeURIComponent(progressId), { method: 'POST' })
                            .then(r => r.json().catch(() => null))
                            .then(j => {
                                try {
                                    const info = j && j.remote ? j.remote : null;
                                    const pid = info && info.pid ? String(info.pid) : '';
                                    const found = info && info.pidfile_found ? 'found' : 'not found';
                                    const killed = (info && (info.kill_sent || info.term_sent)) ? 'kill sent' : 'kill not confirmed';
                                    const archive = (info && info.archive_existed_before !== null)
                                        ? (info.archive_existed_before ? 'archive existed' : 'archive missing')
                                        : '';
                                    const suffix = [killed, pid ? `pid=${pid}` : null, archive].filter(Boolean).join(', ');
                                    const line = `[ui] Remote finalize cancel: pidfile ${found}${suffix ? ` (${suffix})` : ''}`;
                                    if (executeProgressState && executeProgressState.active) appendExecuteProgressLog(line);
                                    else logInfo(line);

                                    // Update status/meta with a clearer message.
                                    try {
                                        if (executeProgressState && executeProgressState.active && !executeProgressState.done) {
                                            let meta = 'Remote extract stop requested.';
                                            if (info) {
                                                const pidPart = pid ? ` (pid=${pid})` : '';
                                                if (info.pidfile_found) {
                                                    meta = (info.kill_sent || info.term_sent)
                                                        ? `Stop signal sent to remote extract${pidPart}.`
                                                        : 'Remote extract stop not confirmed (no signal sent).';
                                                } else {
                                                    meta = 'Remote extract PID not found (may have already finished).';
                                                }
                                            }
                                            setExecuteProgressStatus('Cancelling…', meta);
                                        }
                                    } catch (e) {}
                                } catch (e) {}
                            })
                            .catch(() => {});
                    } catch (e) {}
                });
                const finalized = await waitForRepoFinalize(progressId, { onProgress: onFinalizeProgress });
                try { unregister?.(); } catch (e) {}
                if (!finalized) {
                    return false;
                }
            }
            return true;
        } catch (err) {
            const message = `Repo upload exception: ${err?.message || err}`;
            logError(message);
            alert(message);
            return false;
        }
    }
    const extractDetailFromXhr = (xhr) => {
        if (!xhr) {
            return '';
        }
        const response = xhr.response;
        if (response && typeof response === 'object') {
            if (typeof response.error === 'string' && response.error.trim()) {
                return response.error.trim();
            }
            try {
                return JSON.stringify(response);
            } catch (err) {
                return '';
            }
        }
        // NOTE: Some browsers throw if you read responseText when responseType !== ''/'text'.
        let text = '';
        try {
            if (!xhr.responseType || xhr.responseType === '' || xhr.responseType === 'text') {
                text = xhr.responseText || '';
            }
        } catch (err) {
            text = '';
        }
        if (text) {
            try {
                const parsed = JSON.parse(text);
                if (parsed && typeof parsed.error === 'string' && parsed.error.trim()) {
                    return parsed.error.trim();
                }
                return JSON.stringify(parsed);
            } catch (err) {
                return text.trim();
            }
        }
        return '';
    };
    return await new Promise((resolve) => {
        const xhr = new XMLHttpRequest();
        let settled = false;
        const settle = (value) => {
            if (settled) return;
            settled = true;
            try { unregisterCancel?.(); } catch (e) {}
            resolve(value);
        };
        const unregisterCancel = registerExecuteCancelHandler(() => {
            try { xhr.abort(); } catch (e) {}
            try {
                if (onFinalizeProgress) {
                    onFinalizeProgress({ status: 'cancelled', stage: 'cancelled', detail: 'Cancelled by user.' });
                }
            } catch (e) {}
            settle(false);
        });
        xhr.open('POST', PUSH_REPO_URL, true);
        xhr.responseType = 'json';
        if (xhr.upload && onProgress) {
            xhr.upload.onprogress = (event) => {
                if (!onProgress) {
                    return;
                }
                const loaded = event.loaded || 0;
                const total = event.lengthComputable ? event.total : null;
                const percent = total ? (loaded / total) * 100 : null;
                onProgress({ loaded, total, percent });
            };
        }
        if (onResponseProgress) {
            xhr.onprogress = (event) => {
                if (!onResponseProgress) {
                    return;
                }
                const loaded = event.loaded || 0;
                const total = event.lengthComputable ? event.total : null;
                const percent = total ? (loaded / total) * 100 : null;
                onResponseProgress({ loaded, total, percent });
            };
        }
        xhr.onerror = () => {
            const message = 'Repo upload exception: network error';
            logError(message);
            alert(message);
            settle(false);
        };
        xhr.onabort = () => {
            // Cancellation should not alert; it is user-driven.
            try { logInfo('Repo upload cancelled by user.'); } catch (e) {}
            settle(false);
        };
        xhr.onreadystatechange = async () => {
            if (xhr.readyState !== XMLHttpRequest.DONE) {
                return;
            }
            if (xhr.status >= 200 && xhr.status < 300) {
                const data = xhr.response && typeof xhr.response === 'object' ? xhr.response : null;
                const repoPath = data && typeof data.repo_path === 'string' ? data.repo_path : null;
                const progressId = data && typeof data.progress_id === 'string' ? data.progress_id : null;
                logInfo(`Repository uploaded${repoPath ? ` to ${repoPath}` : ''}.`);
                if (progressId) {
                    const unregister = registerExecuteCancelHandler(() => {
                        try {
                            return fetch('/core/push_repo/cancel/' + encodeURIComponent(progressId), { method: 'POST' })
                                .then(r => r.json().catch(() => null))
                                .then(j => {
                                    try {
                                        const info = j && j.remote ? j.remote : null;
                                        const pid = info && info.pid ? String(info.pid) : '';
                                        const found = info && info.pidfile_found ? 'found' : 'not found';
                                        const killed = (info && (info.kill_sent || info.term_sent)) ? 'kill sent' : 'kill not confirmed';
                                        const archive = (info && info.archive_existed_before !== null)
                                            ? (info.archive_existed_before ? 'archive existed' : 'archive missing')
                                            : '';
                                        const suffix = [killed, pid ? `pid=${pid}` : null, archive].filter(Boolean).join(', ');
                                        const line = `[ui] Remote finalize cancel: pidfile ${found}${suffix ? ` (${suffix})` : ''}`;
                                        if (executeProgressState && executeProgressState.active) appendExecuteProgressLog(line);
                                        else logInfo(line);

                                        // Update status/meta with a clearer message.
                                        try {
                                            if (executeProgressState && executeProgressState.active && !executeProgressState.done) {
                                                let meta = 'Remote extract stop requested.';
                                                if (info) {
                                                    const pidPart = pid ? ` (pid=${pid})` : '';
                                                    if (info.pidfile_found) {
                                                        meta = (info.kill_sent || info.term_sent)
                                                            ? `Stop signal sent to remote extract${pidPart}.`
                                                            : 'Remote extract stop not confirmed (no signal sent).';
                                                    } else {
                                                        meta = 'Remote extract PID not found (may have already finished).';
                                                    }
                                                }
                                                setExecuteProgressStatus('Cancelling…', meta);
                                            }
                                        } catch (e) {}
                                    } catch (e) {}
                                })
                                .catch(() => {});
                        } catch (e) {}
                    });
                    const finalized = await waitForRepoFinalize(progressId, { onProgress: onFinalizeProgress });
                    try { unregister?.(); } catch (e) {}
                    if (!finalized) {
                        settle(false);
                        return;
                    }
                }
                settle(true);
                return;
            }
            const detail = extractDetailFromXhr(xhr);
            const message = detail ? `Repo upload failed: ${detail}` : `Repo upload failed (HTTP ${xhr.status})`;
            logError(message);
            alert(message);
            settle(false);
        };
        try {
            xhr.send(form);
        } catch (err) {
            const message = `Repo upload exception: ${err?.message || err}`;
            logError(message);
            alert(message);
            settle(false);
        }
    });
}

function buildRepoFinalizeStatusUrl(progressId) {
    if (!progressId || !PUSH_REPO_STATUS_BASE) {
        return null;
    }
    return PUSH_REPO_STATUS_BASE.replace('__PROGRESS__', encodeURIComponent(progressId));
}

async function waitForRepoFinalize(progressId, options = {}) {
    if (!progressId) {
        return true;
    }
    const onProgress = typeof options.onProgress === 'function' ? options.onProgress : null;
    const pollInterval = Math.max(500, options.intervalMs || 1500);
    let consecutiveUnknown = 0;
    let lastProgressKey = '';
    const statusUrl = buildRepoFinalizeStatusUrl(progressId);
    if (!statusUrl) {
        onProgress?.({ status: 'error', detail: 'Missing finalize status endpoint.' });
        return false;
    }
    while (true) {
        try {
            if (executeProgressState && executeProgressState.cancelRequested) {
                onProgress?.({ status: 'cancelled', stage: 'cancelled', detail: 'Cancelled by user.' });
                return false;
            }
        } catch (e) {}
        let response = null;
        try {
            response = await fetch(statusUrl, { method: 'GET', cache: 'no-store' });
        } catch (err) {
            onProgress?.({ status: 'pending', stage: 'waiting', detail: `Finalize poll failed: ${err?.message || err}` });
            await new Promise((resolve) => setTimeout(resolve, pollInterval));
            continue;
        }
        if (response.status === 200) {
            const info = (await parseResponseJson(response)) || {};
            consecutiveUnknown = 0;
            try {
                const key = JSON.stringify({
                    status: info?.status || null,
                    stage: info?.stage || null,
                    detail: info?.detail || null,
                    percent: (info?.percent !== undefined && info?.percent !== null) ? Number(info.percent) : null,
                });
                if (key != lastProgressKey) {
                    lastProgressKey = key;
                    onProgress?.(info);
                }
            } catch (e) {
                onProgress?.(info);
            }
            if (info.status === 'complete') {
                return true;
            }
            if (info.status === 'error') {
                return false;
            }
            if (info.status === 'cancelled') {
                return false;
            }
        } else if (response.status === 404) {
            consecutiveUnknown += 1;
            // Avoid spamming the same waiting message every poll.
            if (consecutiveUnknown === 1) {
                onProgress?.({ status: 'pending', stage: 'waiting', detail: 'Waiting for remote finalize tracker…' });
            }
            if (consecutiveUnknown === 5) {
                onProgress?.({ status: 'pending', stage: 'waiting', detail: 'Remote finalize tracker unavailable; still waiting…' });
            }
        } else {
            const detail = await extractResponseDetail(response);
            onProgress?.({ status: 'error', detail: detail || `Finalize status failed (HTTP ${response.status})` });
            return false;
        }
        await new Promise((resolve) => setTimeout(resolve, pollInterval));
    }
}

async function handleMissingRepoResponse(response, context = {}) {
    const info = await parseResponseJson(response);
    const repoPath = info?.missing_repo || context.repoPath || 'remote CORE workspace';
    const reason = info?.error || 'Remote repository missing on CORE host.';
    const canPush = info?.can_push_repo !== false;
    if (!canPush) {
        alert(reason);
        return false;
    }
    const message = `${reason}\n\nRemote path: ${repoPath}\n\nUpload the current repository snapshot now?`;
    const confirmed = window.confirm(message);
    if (!confirmed) {
        logInfo('Remote repo upload declined; run aborted.');
        return false;
    }
    const pushed = await pushRepoToRemote(context.xmlPath || info?.xml_path || null, {
        scenarioIndex: context.scenarioIndex,
        onFinalizeProgress: (progressInfo) => {
            if (progressInfo && progressInfo.detail) {
                logInfo(`Remote finalize: ${progressInfo.detail}`);
            }
        },
    });
    if (!pushed) {
        return false;
    }
    logInfo('Remote repository uploaded; retrying run start.');
    return true;
}

async function submitRunCliRequest(buildRequest, options = {}) {
    const logRunRequestDebug = (message) => {
        const line = `[ui] ${message}`;
        try {
            if (typeof executeProgressState !== 'undefined' && executeProgressState && executeProgressState.active) {
                appendExecuteProgressLog(line);
            } else if (typeof runProgressLogLine === 'function') {
                runProgressLogLine(line);
            } else {
                logInfo(line);
            }
        } catch (e) {}
    };
    const setAbortReason = (reason, details = {}) => {
        try {
            window.__lastRunStartAbort = {
                ts: Date.now(),
                reason: String(reason || 'Run start aborted'),
                ...((details && typeof details === 'object') ? details : {}),
            };
        } catch (e) {}
    };
    const attempts = Math.max(1, options.maxAttempts || 2);
    let overwriteExistingImages = options && options.overwriteExistingImages === true;
    for (let attempt = 0; attempt < attempts; attempt += 1) {
        let request = null;
        try {
            request = typeof buildRequest === 'function' ? buildRequest() : null;
        } catch (err) {
            logRunRequestDebug(`Run request build failed: ${err?.message || err}`);
            throw err;
        }
        if (!request || !request.body) {
            throw new Error('buildRequest must return an object with a body property');
        }

        // If the user confirmed overwrite of existing scenario-scoped images, inject the flag.
        try {
            if (overwriteExistingImages) {
                if (request.body instanceof FormData) {
                    // Avoid duplicating values on retries.
                    if (typeof request.body.set === 'function') {
                        request.body.set('overwrite_existing_images', '1');
                    } else {
                        request.body.append('overwrite_existing_images', '1');
                    }
                } else if (typeof request.body === 'string') {
                    const ct = (request.headers && (request.headers['Content-Type'] || request.headers['content-type'])) || '';
                    if (String(ct).toLowerCase().includes('application/json')) {
                        const obj = JSON.parse(request.body);
                        if (obj && typeof obj === 'object') {
                            obj.overwrite_existing_images = true;
                            request.body = JSON.stringify(obj);
                        }
                    }
                }
            }
        } catch (e) {}
        const init = { method: 'POST', body: request.body };
        if (request.headers) {
            init.headers = request.headers;
        }
        logRunRequestDebug(`Submitting run request: POST ${RUN_CLI_URL || '(missing URL)'} (attempt ${attempt + 1}/${attempts})`);
        let slowTimer = null;
        try {
            slowTimer = window.setTimeout(() => {
                logRunRequestDebug(`Still waiting for run start response from ${RUN_CLI_URL || '(missing URL)'}…`);
            }, 5000);
        } catch (e) {}
        let res;
        try {
            res = await fetch(RUN_CLI_URL, init);
        } catch (err) {
            logRunRequestDebug(`Run request fetch failed: ${err?.message || err}`);
            throw err;
        } finally {
            try { if (slowTimer) window.clearTimeout(slowTimer); } catch (e) {}
        }
        // Handle daemon-missing prompt (backend returns 428 with can_auto_start hint)
        if (res.status === 428) {
            const info = await parseResponseJson(res);
            const canAuto = !!(info && info.can_auto_start);
            const startCommand = (info && info.start_command) || 'sudo systemctl start core-daemon';
            const msg = (info && info.error) || 'core-daemon is not running on the CORE host.';
            logRunRequestDebug(`Run start blocked (HTTP 428): ${msg}`);
            const prompt = canAuto
                ? `${msg}\n\nEnable auto-start (runs "${startCommand}") and retry now?`
                : `${msg}\n\nAuto-start is unavailable. Start core-daemon on the CORE host, then retry.`;
            if (typeof runProgressLogLine === 'function') {
                runProgressLogLine(`Daemon check: ${msg}. Attempted command: ${startCommand}`);
            } else {
                logInfo(`Daemon check: ${msg}. Attempted command: ${startCommand}`);
            }
            const proceed = canAuto ? window.confirm(prompt) : (alert(prompt), false);
            if (proceed) {
                enableAutoStartDaemonPreference();
                try { logInfo(`Auto-start permission enabled; retrying run launch with ${startCommand}.`); } catch (e) {}
                // Do not consume an attempt when auto-start was just enabled
                if (attempt > 0) {
                    attempt -= 1;
                } else {
                    attempt = -1;
                }
                continue;
            }
            try { logWarn(`Daemon check aborted: ${msg}`); } catch (e) {}
            setAbortReason(msg, { status: 428, kind: 'daemon_missing' });
            return null;
        }

        // Handle existing scenario-scoped images on CORE VM (412 precondition).
        if (res.status === 412) {
            const info = await parseResponseJson(res);
            if (info && info.kind === 'existing_images') {
                const tag = info.scenario_tag ? String(info.scenario_tag) : '(unknown)';
                const imgs = Array.isArray(info.existing_images) ? info.existing_images.map(x => String(x)).filter(Boolean) : [];
                const preview = imgs.slice(0, 10).map(x => `• ${x}`).join('\n');
                const msg = `Existing scenario-scoped Docker images were found on the CORE VM for tag: ${tag}`
                    + (preview ? `\n\nImages:\n${preview}${imgs.length > 10 ? `\n… (+${imgs.length - 10} more)` : ''}` : '')
                    + `\n\nOverwrite will remove these images (and any containers using them) before starting the run.\n\nOverwrite and continue?`;
                const proceed = await promptRunProgressConfirm(msg, {
                    title: 'Existing scenario images detected',
                    confirmLabel: 'Overwrite & retry',
                    cancelLabel: 'Abort',
                });
                if (!proceed) {
                    logRunRequestDebug('Run start aborted: user declined overwriting existing scenario images.');
                    setAbortReason('Existing scenario images detected; overwrite declined.', { status: 412, kind: 'existing_images', scenario_tag: tag });
                    return null;
                }
                overwriteExistingImages = true;
                logRunRequestDebug('Overwrite confirmed; retrying run launch with overwrite_existing_images=1.');
                // Do not consume an attempt for the confirmation round-trip.
                if (attempt > 0) {
                    attempt -= 1;
                } else {
                    attempt = -1;
                }
                continue;
            }
        }
        if (res.status === 423) {
            const info = await parseResponseJson(res);
            const sessionCount = Number(info?.session_count) || 0;
            const hostPart = info && info.core_host ? String(info.core_host) : 'CORE host';
            const portPart = info && (info.core_port || info.core_port === 0)
                ? `:${info.core_port}`
                : '';
            const sessions = Array.isArray(info?.active_sessions) ? info.active_sessions : [];
            const detailLines = sessions.slice(0, 3).map((entry) => {
                const sid = entry && entry.id !== undefined ? `#${entry.id}` : '#?';
                const state = entry && entry.state ? String(entry.state) : 'UNKNOWN';
                const file = entry && entry.file ? String(entry.file) : '';
                return `• Session ${sid} (${state}${file ? ` • ${file}` : ''})`;
            }).join('\n');
            const messageParts = [info?.error || `A run is already active on ${hostPart}${portPart}. Finish the active CORE session before starting another.`];
            if (detailLines) {
                messageParts.push('', 'Active sessions:', detailLines);
            }
            const promptText = messageParts.join('\n') + `\n\nKill the active CORE session(s) and retry now?`;
            const autoKillSessions = options && options.autoKillSessions === true;
            let proceed = true;
            if (!autoKillSessions) {
                proceed = await promptRunProgressConfirm(promptText, {
                    title: 'Active CORE session(s) detected',
                    confirmLabel: 'Kill sessions & retry',
                    cancelLabel: 'Cancel',
                });
            } else {
                logRunRequestDebug(`Active CORE session(s) detected; auto-kill enabled (${sessionCount}).`);
            }
            if (!proceed) {
                try { logWarn(`Active CORE session detected; kill was not confirmed (${sessionCount}).`); } catch (e) {}
                logRunRequestDebug(`Run start aborted: active CORE session(s) detected and kill was not confirmed (${sessionCount}).`);
                setAbortReason('Active CORE session(s) detected; start was cancelled.', { status: 423, kind: 'active_sessions', session_count: sessionCount });
                return null;
            }
            try {
                const killRes = await fetch('/core/kill_active_sessions_api', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ kill_all: true })
                });
                const killInfo = await parseResponseJson(killRes);
                if (!killRes.ok || !killInfo || killInfo.ok === false) {
                    const errs = Array.isArray(killInfo?.errors) ? killInfo.errors.join('; ') : (killInfo?.error || 'Unknown error');
                    window.alert(`Failed to kill active CORE session(s): ${errs}`);
                    return null;
                }
                try {
                    const deleted = Array.isArray(killInfo?.deleted) ? killInfo.deleted.length : 0;
                    logInfo(`Killed ${deleted} active CORE session(s); retrying run launch.`);
                } catch (e) {}
                // Do not consume an attempt when we killed sessions to unblock the run.
                if (attempt > 0) {
                    attempt -= 1;
                } else {
                    attempt = -1;
                }
                continue;
            } catch (e) {
                window.alert('Failed to kill active CORE session(s).');
                logRunRequestDebug('Run start aborted: failed to kill active CORE session(s).');
                setAbortReason('Failed to kill active CORE session(s).', { status: 423, kind: 'active_sessions_kill_failed', session_count: sessionCount });
                return null;
            }
        }
        // Handle multiple daemons detected (409 with daemon_conflict)
        if (res.status === 409) {
            const info = await parseResponseJson(res);
            if (info && info.daemon_conflict) {
                const pidList = Array.isArray(info.daemon_pids) ? info.daemon_pids.map(v => String(v)).filter(Boolean) : [];
                const pids = pidList.join(', ');
                const baseMsg = info.error || 'Multiple core-daemon processes are running on the CORE VM.';
                logRunRequestDebug(`Run start aborted (daemon conflict): ${baseMsg}${pids ? ` (pids: ${pids})` : ''}`);
                const promptText = `${baseMsg}${pids ? `\n\nPIDs: ${pids}` : ''}\n\nKill all core-daemon processes and start fresh, then retry the run?`;

                const proceed = await promptRunProgressConfirm(promptText, {
                    title: 'core-daemon conflict detected',
                    confirmLabel: 'Kill & retry',
                    cancelLabel: 'Cancel',
                });
                if (!proceed) {
                    setAbortReason(baseMsg, { status: 409, kind: 'daemon_conflict', daemon_pids: Array.isArray(info.daemon_pids) ? info.daemon_pids : [] });
                    return null;
                }
                try {
                    const fixRes = await fetch('/core/stop_duplicate_daemons_api', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ pids: Array.isArray(info.daemon_pids) ? info.daemon_pids : [] }),
                    });
                    const fixInfo = await parseResponseJson(fixRes);
                    if (!fixRes.ok || !fixInfo || fixInfo.ok === false) {
                        const errText = (fixInfo && (fixInfo.error || fixInfo.message)) ? String(fixInfo.error || fixInfo.message) : `HTTP ${fixRes.status}`;
                        window.alert(`Failed to stop duplicate core-daemon processes: ${errText}`);
                        setAbortReason(baseMsg, { status: 409, kind: 'daemon_conflict_fix_failed', daemon_pids: Array.isArray(info.daemon_pids) ? info.daemon_pids : [] });
                        return null;
                    }
                    logRunRequestDebug('Stopped duplicate core-daemon processes; retrying run start.');
                    // Do not consume an attempt when we fixed the daemon conflict.
                    if (attempt > 0) {
                        attempt -= 1;
                    } else {
                        attempt = -1;
                    }
                    continue;
                } catch (e) {
                    window.alert('Failed to stop duplicate core-daemon processes.');
                    setAbortReason(baseMsg, { status: 409, kind: 'daemon_conflict_fix_failed', daemon_pids: Array.isArray(info.daemon_pids) ? info.daemon_pids : [] });
                    return null;
                }
            }
        }
        if (res.status === 409) {
            const retry = await handleMissingRepoResponse(res, {
                xmlPath: request.xmlPath || options.xmlPath || null,
                repoPath: request.repoPath,
                scenarioIndex: request.scenarioIndex ?? options.scenarioIndex ?? null,
            });
            if (retry) {
                continue;
            }
            try {
                const info = await parseResponseJson(res);
                const msg = info?.error || 'Remote repository missing on CORE host.';
                logRunRequestDebug(`Run start aborted (missing repo): ${msg}`);
                setAbortReason(msg, { status: 409, kind: 'missing_repo', missing_repo: info?.missing_repo || request.repoPath || null });
            } catch (e) {
                setAbortReason('Remote repository missing on CORE host.', { status: 409, kind: 'missing_repo' });
            }
            return null;
        }
        return res;
    }
    logWarn('Exceeded automatic repository sync attempts; aborting run.');
    alert('Unable to start run until the repository is uploaded to the CORE host.');
    setAbortReason('Exceeded automatic repository sync attempts.', { kind: 'repo_sync_exhausted' });
    return null;
}


async function runAsync() {
    let rp = state.result_path || '';
    if (IS_BUILDER_VIEW) {
        rp = '';
    } else if (!rp.endsWith('.xml')) {
        const go = window.confirm('Your XML has not been saved. Save now and then run?');
        if (!go) { logInfo('Async run cancelled by user (declined save)'); return; }
        try {
            const ok = await saveXmlAjax();
            if (!ok) { logWarn('Save failed; aborting async run'); return; }
            rp = state.result_path || '';
            if (!rp.endsWith('.xml')) { logWarn('Save did not produce an XML path; aborting async run'); return; }
        } catch(e){ logError('Exception during auto-save; aborting async run'); return; }
    }
    const confirmMsg = 'This action will generate a new CORE scenario and attempt to start it asynchronously using the daemon connection.\n\nProceed?';
    if (!window.confirm(confirmMsg)) { logInfo('Async run cancelled by user at confirmation'); return; }
    // Default to prompting when active CORE sessions exist (historical behavior).
    // Auto-kill is only enabled when explicitly chosen in the Execute flow.
    let autoKillSessions = false;
    const res = await submitRunCliRequest(() => {
        if (IS_BUILDER_VIEW) {
            const payload = enrichPayloadWithScenarioContext({
                scenarios: state.scenarios,
                core: getCoreConfig(true),
            });
            return {
                body: JSON.stringify(payload),
                headers: { 'Content-Type': 'application/json' },
                xmlPath: null,
            };
        }
        return { body: buildRunFormData(rp), xmlPath: rp };
    }, { autoKillSessions });
    if (!res) { logWarn('Async run aborted before launch'); return; }
    if (!res.ok) {
        const detail = await extractResponseDetail(res);
        alert(detail ? `Failed to start run: ${detail}` : 'Failed to start run');
        return;
    }
    const { run_id } = await res.json();
    logInfo(`Async run started id=${run_id}`);
    startLogStream(run_id);
    pollRunStatus(run_id);
}

// Save XML via JSON API without navigation
async function saveXmlAjax(){
    try {
        const payload = { scenarios: state.scenarios, core: getCoreConfig(true), active_index: activeIdx };
        if (state.base_upload) {
            payload.base_upload = state.base_upload;
        }
        const res = await fetch('/save_xml_api', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload)
        });
        if (!res.ok) { try { const err = await res.json(); logWarn('Save failed: ' + (err?.error || res.status)); } catch(e){ logWarn('Save failed'); } return false; }
        const data = await res.json();
        if (data && data.ok) {
            if (data.core) {
                state.core = normalizeCoreState(data.core, true);
                storeCorePasswordInSession();
            }
            if (data.result_path) {
                state.result_path = data.result_path;
            }
            try { updateDownloadButtonState(); } catch (err) {}
            persistEditorState();
            if (data.result_path) {
                logInfo('Scenarios saved to ' + data.result_path);
            } else {
                logInfo('Scenarios saved');
            }
            // Refresh XML preview lazily
            try {
                await refreshXmlDockPreview({ force: true, preferSavedPath: true });
            } catch(e){}
            return true;
        }
        logWarn('Save did not return a valid path');
        return false;
    } catch(e) { logError('Save threw an exception'); return false; }
}

async function refreshXmlDockPreview({ force = false, preferSavedPath = false } = {}) {
    const xmlPre = document.getElementById('xmlPre');
    if (!xmlPre) return;

    if (typeof window.__xmlDockPreviewReq !== 'number') window.__xmlDockPreviewReq = 0;
    const reqId = ++window.__xmlDockPreviewReq;
    const applyIfLatest = (txt, meta = {}) => {
        if (reqId !== window.__xmlDockPreviewReq) return;
        try {
            xmlPre.textContent = txt || '';
            if (meta.path !== undefined) {
                xmlPre.dataset.xmlPreviewPath = meta.path || '';
            }
        } catch (e) {}
    };

    const rp = String(state?.result_path || '');
    const hasSaved = rp && rp.endsWith('.xml');
    const lastPath = xmlPre.dataset.xmlPreviewPath || '';

    // Prefer showing the persisted XML when available (except in builder view, where the
    // preview should always reflect the current unsaved configuration).
    if (!IS_BUILDER_VIEW && hasSaved && (preferSavedPath || force || !xmlPre.textContent.trim() || lastPath !== rp)) {
        try {
            const txt = await (await fetch('/download_report?path=' + encodeURIComponent(rp), { credentials: 'same-origin' })).text();
            applyIfLatest(txt, { path: rp });
            return;
        } catch (e) {
            // fall through to render API
        }
    }

    // No saved XML yet (or download failed): render a preview from current editor state.
    if (!force && xmlPre.textContent.trim()) return;
    try {
        const res = await fetch('/render_xml_api', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            credentials: 'same-origin',
            body: JSON.stringify({
                scenarios: state.scenarios,
                core: getCoreConfig(true),
                active_index: activeIdx,
            }),
        });
        if (!res.ok) return;
        const txt = await res.text();
        applyIfLatest(txt, { path: '' });
    } catch (e) {}
}

let __xmlDockPreviewDebounceTimer = null;
function scheduleXmlDockPreviewRefresh() {
    try {
        // Only refresh live when the dock is visible (avoid background spam).
        const dock = document.getElementById('dockPanel');
        if (dock && dock.classList.contains('d-none')) return;
    } catch (e) {}
    try {
        if (__xmlDockPreviewDebounceTimer) {
            clearTimeout(__xmlDockPreviewDebounceTimer);
        }
        __xmlDockPreviewDebounceTimer = setTimeout(() => {
            try { refreshXmlDockPreview({ force: true }); } catch (e) {}
        }, 5000);
    } catch (e) {}
}

// Live-update XML preview as the user edits fields.
document.addEventListener('DOMContentLoaded', () => {
    const root = document.getElementById('editorRoot');
    if (!root) return;
    const handler = (ev) => {
        try {
            const t = ev.target;
            if (!t) return;
            // Ignore dock controls if they bubble here (defensive)
            if (t.closest && (t.closest('#dockPanel') || t.closest('#dockShowBtn'))) return;
        } catch (e) {}
        scheduleXmlDockPreviewRefresh();
    };
    // input covers typing; change covers selects/checkboxes
    root.addEventListener('input', handler, true);
    root.addEventListener('change', handler, true);
});

// Some flows historically used appendLog(level,msg) while the dock exposes logLine/logInfo/etc.
// Provide a compatibility shim so execution flows never crash on missing appendLog.

function dockLog(message, level = 'INFO') {
    const lvl = String(level || 'INFO').toUpperCase();
    const msg = String(message ?? '');
    try {
        if (typeof window.logLine === 'function') {
            window.logLine(lvl, msg);
            return;
        }
        if (lvl === 'ERROR' && typeof window.logError === 'function') {
            window.logError(msg);
            return;
        }
        if (lvl === 'WARN' && typeof window.logWarn === 'function') {
            window.logWarn(msg);
            return;
        }
        if (lvl === 'DEBUG' && typeof window.logDebug === 'function') {
            window.logDebug(msg);
            return;
        }
        if (typeof window.logInfo === 'function') {
            window.logInfo(msg);
            return;
        }
        if (typeof window.dispatchEvent === 'function' && typeof window.CustomEvent === 'function') {
            window.dispatchEvent(new CustomEvent('dock-log', { detail: { level: lvl, message: msg } }));
            return;
        }
    } catch (e) {}
    try {
        console.log(msg);
    } catch (e) {}
}

if (typeof window.appendLog !== 'function') {
    window.appendLog = dockLog;
}

let evtSrc = null;
function startLogStream(runId) {
    if (evtSrc) { try { evtSrc.close(); } catch(e){} }
    evtSrc = new EventSource('/stream/' + runId);
    try { localStorage.setItem('coretg_active_run_id', String(runId||'')); } catch(e) {}
    // keep existing logs; do not auto-clear
    // Ensure dock is visible so users can see live logs
    try {
        const showBtn = document.getElementById('dockShowBtn');
        if (showBtn && !showBtn.classList.contains('d-none')) { showBtn.click(); }
    } catch(e){}
    // Toggle buttons
    try { document.getElementById('runAsyncBtn')?.classList.add('d-none'); } catch(e){}
    try { document.getElementById('runSyncBtn')?.classList.add('disabled'); } catch(e){}
    try { document.getElementById('cancelRunBtn')?.classList.remove('d-none'); } catch(e){}
    evtSrc.onmessage = (ev) => {
        const raw = ev.data || '';
        let lvl = 'INFO';
        if (/\bERROR\b/.test(raw)) lvl = 'ERROR';
        else if (/\bWARN(ING)?\b/.test(raw)) lvl = 'WARN';
        else if (/\bDEBUG\b/.test(raw)) lvl = 'DEBUG';
        dockLog(raw, lvl);
    };
    evtSrc.addEventListener('phase', (ev) => {
        try {
            const payload = JSON.parse(ev.data || '{}');
            // Only show phases if execute progress panel is open.
            handleExecuteProgressPhase(payload);
        } catch (e) {}
    });
    evtSrc.addEventListener('end', () => {
        evtSrc.close();
        try { localStorage.removeItem('coretg_active_run_id'); } catch(e) {}
        try { document.getElementById('runAsyncBtn')?.classList.remove('d-none'); } catch(e){}
        try { document.getElementById('runSyncBtn')?.classList.remove('disabled'); } catch(e){}
        try { document.getElementById('cancelRunBtn')?.classList.add('d-none'); } catch(e){}
        logInfo('Async run ended');
    });
}

async function pollRunStatus(runId) {
    const xmlPre = document.getElementById('xmlPre');
    try {
    const res = await fetch('/run_status/' + runId);
        if (!res.ok) return;
        const data = await res.json();
        // Update download link
        const rp = data.report_path || data.xml_path;
        if (rp) { state.result_path = rp; persistEditorState(); }
        // Refresh XML preview if we have the xml path and it's changed
        if (data.xml_path && xmlPre && !xmlPre.textContent.trim()) {
                    try {
                        const txt = await (await fetch('/download_report?path=' + encodeURIComponent(data.xml_path))).text();
                        xmlPre.textContent = txt;
                    } catch(e){}
        }
        if (!data.done) {
            setTimeout(() => pollRunStatus(runId), 1000);
        } else {
            if (data.returncode === 0) {
                scheduleScenarioRedirect("{{ url_for('reports_page') }}", { delay: 500 });
            }
        }
    } catch(e) {
        // ignore transient errors
        setTimeout(() => pollRunStatus(runId), 1500);
    }
}

    async function cancelRun() {
        if (!evtSrc) return;
        // Extract runId from the EventSource URL
        const url = evtSrc.url;
        const runId = url.split('/').pop();
        try {
            await fetch('/cancel_run/' + runId, { method: 'POST' });
        } catch(e) {}
    try { evtSrc.close(); } catch(e){}
        try { document.getElementById('runAsyncBtn')?.classList.remove('d-none'); } catch(e){}
        try { document.getElementById('runSyncBtn')?.classList.remove('disabled'); } catch(e){}
        try { document.getElementById('cancelRunBtn')?.classList.add('d-none'); } catch(e){}
        // Re-enable Execute dialog controls on cancel
        try { if (typeof window.setExecuteDialogControlsEnabled === 'function') window.setExecuteDialogControlsEnabled(true); } catch(e){}
    logInfo('Run cancelled by user');
    }

// --- Run CLI via modal (async under the hood) ---
function ensureRunProgressModal(){
    if(!runProgressModalInst){
        const el = document.getElementById('runProgressModal');
        if(el){ runProgressModalInst = new bootstrap.Modal(el, { backdrop: 'static', keyboard: false }); }
    }
    return runProgressModalInst;
}

function markRunProgressComplete(){
    try {
        const hideBtn = document.getElementById('runProgressHideBtn');
        if (hideBtn) {
            hideBtn.textContent = 'Close';
            hideBtn.onclick = null;
        }
    } catch(e) {}
    // Also re-enable dialog controls when progress modal completes/finishes.
    try { if (typeof window.setExecuteDialogControlsEnabled === 'function') window.setExecuteDialogControlsEnabled(true); } catch(e){}
}
function runProgressLogLine(s){
    const pre = document.getElementById('runProgressLog');
    if(!pre) return;
    const line = (s||'');
    // Level detection first so we only log once with correct level
    let lvl = 'INFO';
    try {
        if(/\bERROR\b/.test(line)) lvl='ERROR';
        else if(/\bWARN(ING)?\b/.test(line)) lvl='WARN';
        else if(/\bDEBUG\b/.test(line)) lvl='DEBUG';
    } catch(e){}
    try {
        const text = line + '\n';
        if(typeof pre.append === 'function'){ pre.append(text); }
        else { pre.appendChild(document.createTextNode(text)); }
    } catch(e){}
    dockLog(line, lvl);
    pre.parentElement?.scrollTo({ top: pre.parentElement.scrollHeight });
    handleExecuteProgressLog(line);
}

async function promptRunProgressConfirm(message, { title = 'Active CORE session(s) detected', confirmLabel = 'Kill sessions & retry', cancelLabel = 'Cancel' } = {}) {
    // Do not open a second modal/dialog here; keep whatever progress UI is already shown,
    // and prompt via a toast with explicit actions.
    try {
        if (!window.bootstrap || !bootstrap.Toast) {
            return window.confirm(String(message || 'Proceed?'));
        }
        const container = document.getElementById('coretgToastContainer');
        if (!container) {
            return window.confirm(String(message || 'Proceed?'));
        }

        return await new Promise((resolve) => {
            let resolved = false;
            const el = document.createElement('div');
            el.className = 'toast';
            el.setAttribute('role','alert');
            el.setAttribute('aria-live','assertive');
            el.setAttribute('aria-atomic','true');
            el.innerHTML = `
              <div class="toast-header">
                <strong class="me-auto">${String(title || 'Action required')}</strong>
                <button type="button" class="btn-close" data-bs-dismiss="toast" aria-label="Close"></button>
              </div>
              <div class="toast-body">
                <div style="white-space: pre-wrap;">${String(message || '')}</div>
                <div class="d-flex gap-2 mt-2">
                  <button type="button" class="btn btn-sm btn-primary" data-role="confirm">${String(confirmLabel || 'OK')}</button>
                  <button type="button" class="btn btn-sm btn-outline-secondary" data-role="cancel">${String(cancelLabel || 'Cancel')}</button>
                </div>
              </div>
            `;
            container.appendChild(el);

            const inst = new bootstrap.Toast(el, { autohide: false });
            const cleanup = (result) => {
                if (resolved) return;
                resolved = true;
                try { inst.hide(); } catch(e) {}
                resolve(!!result);
            };
            const confirmBtn = el.querySelector('[data-role="confirm"]');
            const cancelBtn = el.querySelector('[data-role="cancel"]');
            try { confirmBtn?.addEventListener('click', ()=> cleanup(true)); } catch(e) {}
            try { cancelBtn?.addEventListener('click', ()=> cleanup(false)); } catch(e) {}
            el.addEventListener('hidden.bs.toast', ()=>{
                try { el.remove(); } catch(e) {}
                if(!resolved){
                    resolved = true;
                    resolve(false);
                }
            });
            inst.show();
        });
    } catch (e) {
        return window.confirm(String(message || 'Proceed?'));
    }
}
function detectLocalEmulation(){
    const normalizeHost = (raw) => {
        if(raw === null || raw === undefined) return '';
        let h = String(raw).trim().toLowerCase();
        if(!h) return '';
        if(h.startsWith('[') && h.endsWith(']')){
            h = h.slice(1, -1);
        }
        if(h.startsWith('::ffff:') && /^::ffff:\d+\.\d+\.\d+\.\d+$/.test(h)){
            h = h.replace('::ffff:', '');
        }
        return h;
    };
    try {
        const hostRaw = (state?.core && state.core.host !== undefined) ? state.core.host : (initialPayload?.core?.host ?? 'localhost');
        let hostStr = (typeof hostRaw === 'string' && hostRaw.trim()) ? hostRaw.trim() : String(hostRaw ?? 'localhost');
        if(!hostStr) hostStr = 'localhost';
        const normHost = normalizeHost(hostStr);
        const isLoopback = !normHost || normHost === 'localhost' || normHost === '::1' || normHost === '0:0:0:0:0:0:0:1' || /^127(?:\.\d{1,3}){3}$/.test(normHost);
        const portRaw = (state?.core && state.core.port !== undefined) ? state.core.port : (initialPayload?.core?.port ?? 50051);
        const portNum = parseInt(portRaw, 10);
        const port = Number.isFinite(portNum) && portNum > 0 ? portNum : 50051;
        const testedHostRaw = (state?.core_tested_host !== undefined && state.core_tested_host !== null)
            ? state.core_tested_host
            : (initialPayload?.core_tested_host ?? null);
        const testedPortRaw = (state?.core_tested_port !== undefined && state.core_tested_port !== null)
            ? state.core_tested_port
            : (initialPayload?.core_tested_port ?? null);
        const normTestedHost = normalizeHost(testedHostRaw);
        const testedPortNum = parseInt(testedPortRaw ?? '', 10);
        const testedPort = Number.isFinite(testedPortNum) && testedPortNum > 0 ? testedPortNum : port;
        const testedMatches = !!normTestedHost && normTestedHost === normHost && testedPort === port;
        const hasVerifiedCore = !!state?.core_ok && testedMatches;
        const shouldFake = isLoopback && !hasVerifiedCore;
        return {
            shouldFake,
            isLoopback: !!isLoopback,
            verified: hasVerifiedCore,
            host: hostStr,
            port
        };
    } catch(e){
        return { shouldFake: false, isLoopback: false, verified: false, host: 'localhost', port: 50051 };
    }
}
function setRunProgressModeHint(message){
    const hintEl = document.getElementById('runProgressModeHint');
    if(!hintEl) return;
    if(message){
        hintEl.textContent = message;
        hintEl.classList.remove('d-none');
    } else {
        hintEl.textContent = '';
        hintEl.classList.add('d-none');
    }
}
function maybeShowLocalEmulationHint(){
    const info = detectLocalEmulation();
    if(info.shouldFake){
        setRunProgressModeHint(`LOCAL EMULATION • NO CONNECTED CORE SESSION`);
    } else if(info.verified){
        setRunProgressModeHint(`CONNECTED • CORE ${info.host}:${info.port}`);
    } else {
        setRunProgressModeHint('');
    }
}
function openRunProgress(title){
    const modalEl = document.getElementById('runProgressModal');
    ensureRunProgressModal();
    try {
        if(title) document.querySelector('#runProgressModal .modal-title').textContent = title;
        document.getElementById('runProgressStatus').textContent = 'Starting…';
        document.getElementById('runProgressMeta').textContent = '';
        document.getElementById('runProgressBar').classList.add('progress-bar-animated');
        setRunProgressModeHint('');
        const logEl = document.getElementById('runProgressLog');
        if(logEl) logEl.textContent = '';
    // Do NOT clear persistent log buffer; just re-render existing lines
    if(typeof renderDockLog === 'function'){ renderDockLog(); }
        // Reset footer buttons to default state
        const hideBtn = document.getElementById('runProgressHideBtn');
        if (hideBtn) {
            hideBtn.textContent = 'Hide';
            hideBtn.onclick = null; // remove any prior navigation handler
        }
        runProgressModalInst?.show();
    } catch(e){}
    try {
        if(modalEl && !modalEl.classList.contains('show')){
            modalEl.style.display = 'block';
            modalEl.removeAttribute('aria-hidden');
            modalEl.classList.add('show');
            if(!document.body.classList.contains('modal-open')){
                document.body.classList.add('modal-open');
                document.body.style.removeProperty('paddingRight');
                document.body.style.removeProperty('overflow');
            }
            if(!document.querySelector('.modal-backdrop')){
                const backdrop = document.createElement('div');
                backdrop.className = 'modal-backdrop fade show';
                document.body.appendChild(backdrop);
            }
        }
    } catch(e){}
}
function closeRunProgress(){
    try { if(runProgressEvtSrc) runProgressEvtSrc.close(); } catch(e){}
    runProgressEvtSrc = null;
    runProgressRunId = null;
    try { runProgressModalInst?.hide(); } catch(e){}
    try {
        const modalEl = document.getElementById('runProgressModal');
        if(modalEl){
            modalEl.classList.remove('show');
            modalEl.style.removeProperty('display');
            modalEl.setAttribute('aria-hidden','true');
        }
        const openModals = document.querySelectorAll('.modal.show');
        if(openModals.length === 0){
            document.querySelectorAll('.modal-backdrop').forEach(b => {
                try { b.remove(); } catch(_e){}
            });
            document.body.classList.remove('modal-open');
            document.body.style.removeProperty('paddingRight');
            document.body.style.removeProperty('overflow');
        }
    } catch(e){}
}
async function runSyncWithModal(arg){
    let opts = {};
    if(arg && typeof arg === 'object' && typeof arg.preventDefault === 'function'){
        arg.preventDefault();
    } else if(arg && typeof arg === 'object'){
        opts = arg;
    }
    const showProgressModal = opts.showProgressModal !== false;
    const skipConfirm = opts.skipConfirm === true;
    const activeScenarioCtx = getActiveScenarioContext();
    let scenarioIndexForRun = Number.isInteger(opts.scenarioIndex) ? opts.scenarioIndex : activeScenarioCtx.idx;
    let updateRemoteRepo = opts.updateRemoteRepo === true;
    // Some entrypoints perform confirmation externally and call with skipConfirm=true.
    // In that case, advanced selections must be passed in via opts.confirmResult or opts.advanced.
    let confirmResult = (opts && typeof opts === 'object' && opts.confirmResult) ? opts.confirmResult : null;
    const advancedFromOpts = (opts && typeof opts === 'object' && opts.advanced) ? opts.advanced : null;
    let waitingForRemoteLogs = false;
    let uploadHeartbeatTimer = null;
    let uploadStartTime = null;
    let uploadFinalizeStart = null;
    let lastUploadStats = null;
    let lastResponseStats = null;
    let lastLoggedUploadPercent = null;
    let lastLoggedUploadBytes = null;
    let lastLoggedResponsePercent = null;
    let lastLoggedResponseBytes = null;
    let uploadDelivered = false;
    let uploadRequestComplete = false;
    let lastFinalizeLogTs = null;
    let lastProgressPercent = 0;
    let lastFinalizeDetail = null;
    let finalizeAnnounced = false;
    let lastFinalizeInfo = null;
    const updateRunStatus = (status, meta) => {
        if (executeProgressState.active) {
            setExecuteProgressStatus(status, meta);
        } else if (showProgressModal) {
            const statusEl = document.getElementById('runProgressStatus');
            if (statusEl) statusEl.textContent = status || '';
            const metaEl = document.getElementById('runProgressMeta');
            if (metaEl) metaEl.textContent = meta || '';
        }
    };
    const appendExecuteDialogLog = (message) => {
        const line = `[ui] ${message}`;
        appendExecuteProgressLog(line, { mirrorToDock: !showProgressModal });
        if (showProgressModal) {
            runProgressLogLine(line);
        }
    };
    appendExecuteDialogLog('runSyncWithModal() entered.');
    const stopUploadHeartbeat = () => {
        if (uploadHeartbeatTimer) {
            clearInterval(uploadHeartbeatTimer);
            uploadHeartbeatTimer = null;
        }
        lastFinalizeLogTs = null;
    };
    const startUploadHeartbeat = () => {
        if (uploadHeartbeatTimer) {
            return;
        }
        uploadStartTime = Date.now();
        uploadHeartbeatTimer = window.setInterval(() => {
            const now = Date.now();
            const elapsedSec = Math.round((now - (uploadStartTime || now)) / 1000);
            if (uploadDelivered) {
                const finalizeElapsed = uploadFinalizeStart ? Math.round((now - uploadFinalizeStart) / 1000) : elapsedSec;
                if (!lastFinalizeLogTs || (now - lastFinalizeLogTs) >= 12000) {
                    lastFinalizeLogTs = now;
                    const suffix = lastFinalizeDetail ? ` (${lastFinalizeDetail})` : '';
                    const percent = lastFinalizeInfo && typeof lastFinalizeInfo.percent === 'number'
                        ? Math.max(0, Math.min(100, lastFinalizeInfo.percent))
                        : null;
                    const percentSuffix = percent !== null ? ` [server: ${percent.toFixed(0)}%]` : '';
                    let staleSuffix = '';
                    try {
                        const updatedAt = lastFinalizeInfo && typeof lastFinalizeInfo.updated_at === 'number' ? lastFinalizeInfo.updated_at : null;
                        if (updatedAt) {
                            const ageSec = Math.max(0, Math.round(now / 1000 - updatedAt));
                            staleSuffix = ` [last update: ${ageSec}s ago]`;
                        }
                    } catch (e) {}
                    appendExecuteDialogLog(`Waiting for CORE host to finalize (${finalizeElapsed}s)${suffix}${percentSuffix}${staleSuffix}.`);
                }
                // Keep the status/meta line accurate while waiting.
                try {
                    const parts = [];
                    if (lastFinalizeDetail) parts.push(lastFinalizeDetail);
                    if (lastUploadStats) {
                        const loaded = lastUploadStats.loaded || 0;
                        const total = lastUploadStats.total || null;
                        if (total) parts.push(`upload: ${formatBytes(loaded)} / ${formatBytes(total)}`);
                        else if (loaded) parts.push(`upload: ${formatBytes(loaded)} transferred`);
                    }
                    if (lastResponseStats) {
                        const loaded = lastResponseStats.loaded || 0;
                        const total = lastResponseStats.total || null;
                        if (total) parts.push(`response: ${formatBytes(loaded)} / ${formatBytes(total)}`);
                        else if (loaded) parts.push(`response: ${formatBytes(loaded)} received`);
                    }
                    updateRunStatus('Finishing repository sync… (this may take a few minutes)', parts.length ? parts.join(' | ') : 'Remote finalize in progress…');
                } catch (e) {}
                return;
            }
            if (uploadRequestComplete) {
                // Browser finished sending bytes, but the server is still packaging/uploading to CORE host.
                // This can take a while, so keep the log and status line honest.
                const phaseElapsed = uploadFinalizeStart ? Math.round((now - uploadFinalizeStart) / 1000) : elapsedSec;
                let uploadDetail = '';
                if (lastUploadStats) {
                    const loaded = lastUploadStats.loaded || 0;
                    const total = lastUploadStats.total || null;
                    if (total) {
                        uploadDetail = `${formatBytes(loaded)} / ${formatBytes(total)}`;
                    } else if (loaded) {
                        uploadDetail = `${formatBytes(loaded)} transferred`;
                    }
                }
                let responseDetail = '';
                if (lastResponseStats) {
                    const loaded = lastResponseStats.loaded || 0;
                    const total = lastResponseStats.total || null;
                    if (total) {
                        responseDetail = `${formatBytes(loaded)} / ${formatBytes(total)}`;
                    } else if (loaded) {
                        responseDetail = `${formatBytes(loaded)} received`;
                    }
                }
                const uploadSuffix = uploadDetail ? ` [upload: ${uploadDetail}]` : '';
                const responseSuffix = responseDetail ? ` [response: ${responseDetail}]` : '';
                appendExecuteDialogLog(`Repository upload request complete; server preparing snapshot (${phaseElapsed}s)${uploadSuffix}${responseSuffix}.`);
                try {
                    const parts = [];
                    if (lastUploadStats) parts.push(uploadDetail ? `upload: ${uploadDetail}` : 'upload: complete');
                    if (responseDetail) parts.push(`response: ${responseDetail}`);
                    updateRunStatus('Preparing repository snapshot…', parts.filter(Boolean).join(' | ') || 'Server preparing snapshot…');
                } catch (e) {}
                return;
            }
            let detail = 'transferring…';
            if (lastUploadStats) {
                const loaded = lastUploadStats.loaded || 0;
                if (lastUploadStats.total) {
                    detail = `${formatBytes(loaded)} / ${formatBytes(lastUploadStats.total)}`;
                } else if (loaded) {
                    detail = `${formatBytes(loaded)} transferred`;
                }
                if (typeof lastUploadStats.percent === 'number') {
                    detail += ` (${lastUploadStats.percent.toFixed(1)}%)`;
                }
            }
            appendExecuteDialogLog(`Repository upload still running (${elapsedSec}s): ${detail}`);
        }, 4000);
    };
    const logUploadSnapshot = (info) => {
        if (!info) {
            return;
        }
        const loaded = info.loaded || 0;
        const total = info.total || null;
        const percent = typeof info.percent === 'number' ? Math.max(0, Math.min(100, info.percent)) : null;
        if (percent !== null) {
            if (lastLoggedUploadPercent === null || Math.abs(percent - lastLoggedUploadPercent) >= 5) {
                const detail = total ? `${formatBytes(loaded)} / ${formatBytes(total)}` : `${formatBytes(loaded)} transferred`;
                appendExecuteDialogLog(`Repository upload ${percent.toFixed(1)}% (${detail})`);
                lastLoggedUploadPercent = percent;
            }
        } else if (loaded) {
            if (lastLoggedUploadBytes === null || (loaded - lastLoggedUploadBytes) >= (5 * 1024 * 1024)) {
                appendExecuteDialogLog(`Repository upload transferred ${formatBytes(loaded)}…`);
                lastLoggedUploadBytes = loaded;
            }
        }
    };
    const setUploadProgressValue = (percent, label) => {
        if (typeof percent !== 'number' || Number.isNaN(percent)) {
            return;
        }
        const clamped = Math.max(0, Math.min(100, percent));
        const pctValue = Math.max(clamped, lastProgressPercent || 0);
        lastProgressPercent = pctValue;
        if (executeProgressState.active) {
            setExecuteProgressPercent(pctValue, label || `${pctValue.toFixed(1)}%`);
        } else if (showProgressModal) {
            const bar = document.getElementById('runProgressBar');
            if (bar) {
                const pctText = pctValue.toFixed(1).replace(/\.0$/, '');
                bar.style.width = `${pctValue.toFixed(1)}%`;
                bar.textContent = label || `${pctText}%`;
            }
        }
    };
    const handleRepoUploadProgress = (info) => {
        if (!info) return;
        lastUploadStats = info;
        startUploadHeartbeat();
        const loaded = info.loaded || 0;
        const total = info.total || null;
        const percentRaw = typeof info.percent === 'number' ? info.percent : null;
        const percent = percentRaw !== null ? Math.max(0, Math.min(100, percentRaw)) : null;
        try {
            const totalComplete = total && loaded >= total;
            const percentComplete = percent !== null && percent >= 99.9;
            if (totalComplete || percentComplete) {
                uploadRequestComplete = true;
                if (!uploadFinalizeStart) {
                    uploadFinalizeStart = Date.now();
                }
            }
        } catch (e) {}
        let meta = `${formatBytes(loaded)} transferred`;
        if (total) {
            meta = `${formatBytes(loaded)} / ${formatBytes(total)}`;
            if (percent !== null) {
                meta += ` (${percent.toFixed(1)}%)`;
            }
        }
        updateRunStatus('Copying repository…', meta);
        if (percent !== null) {
            setUploadProgressValue(percent, `${percent.toFixed(1)}%`);
        }
        logUploadSnapshot(info);
    };

    const handleRepoResponseProgress = (info) => {
        if (!info) return;
        lastResponseStats = info;
        // Only log occasionally to avoid spamming.
        const percentRaw = typeof info.percent === 'number' ? info.percent : null;
        const percent = percentRaw !== null ? Math.max(0, Math.min(100, percentRaw)) : null;
        const loaded = info.loaded || 0;
        const total = info.total || null;
        if (percent !== null) {
            if (lastLoggedResponsePercent === null || Math.abs(percent - lastLoggedResponsePercent) >= 10) {
                const detail = total ? `${formatBytes(loaded)} / ${formatBytes(total)}` : `${formatBytes(loaded)} received`;
                appendExecuteDialogLog(`Repository response ${percent.toFixed(1)}% (${detail})`);
                lastLoggedResponsePercent = percent;
            }
        } else if (loaded) {
            if (lastLoggedResponseBytes === null || (loaded - lastLoggedResponseBytes) >= (2 * 1024 * 1024)) {
                appendExecuteDialogLog(`Repository response received ${formatBytes(loaded)}…`);
                lastLoggedResponseBytes = loaded;
            }
        }
    };
    const handleFinalizeProgress = (info) => {
        if (!info || typeof info !== 'object') {
            return;
        }
        lastFinalizeInfo = info;
        // Finalize polling only starts after the server has received the upload and returned a progress id.
        // This is the most reliable moment to switch the UI from "uploading" to "finalizing".
        if (!uploadDelivered) {
            uploadDelivered = true;
            uploadFinalizeStart = Date.now();
            lastFinalizeLogTs = Date.now();
        }
        const status = info.status || 'pending';
        const detail = info.detail || info.stage || 'Remote finalize in progress…';
        const percent = typeof info.percent === 'number' ? Math.max(0, Math.min(100, info.percent)) : null;
        if (!finalizeAnnounced) {
            finalizeAnnounced = true;
            let uploadDetail = '';
            if (lastUploadStats) {
                const loaded = lastUploadStats.loaded || 0;
                const total = lastUploadStats.total || null;
                if (total) uploadDetail = `${formatBytes(loaded)} / ${formatBytes(total)}`;
                else if (loaded) uploadDetail = `${formatBytes(loaded)} transferred`;
            }
            const suffix = uploadDetail ? ` (${uploadDetail})` : '';
            appendExecuteDialogLog(`Remote host is finalizing${suffix}.`);
        }
        if (detail && detail !== lastFinalizeDetail) {
            lastFinalizeDetail = detail;
            const pctText = percent !== null ? ` (${percent.toFixed(0)}%)` : '';
            appendExecuteDialogLog(`Remote finalize: ${detail}${pctText}`);
        }
        if (detail) {
            updateRunStatus('Finishing repository sync… (this may take a few minutes)', detail);
        }
        if (percent !== null) {
            setUploadProgressValue(percent, `${percent.toFixed(0)}%`);
        }
        if (status === 'error') {
            logError('Remote finalize reported an error; check server logs for details.');
        }
        if (status === 'complete') {
            stopUploadHeartbeat();
        }
    };
    // Validate saved XML (admin view). Builder view runs from current editor state.
    let rp = state.result_path || '';
    if (IS_BUILDER_VIEW) {
        rp = '';
    } else if (!rp.endsWith('.xml')) {
        const go = window.confirm('Your XML has not been saved. Save now and then run?');
        if (!go) { logInfo('Run CLI cancelled by user (declined save)'); return false; }
        try {
            const ok = await saveXmlAjax();
            if (!ok) { logWarn('Save failed; aborting run'); return false; }
            rp = state.result_path || '';
            if (!rp.endsWith('.xml')) { logWarn('Save did not produce an XML path; aborting run'); return false; }
        } catch(e){ logError('Exception during auto-save; aborting run'); return false; }
    }
    const execInfo = detectLocalEmulation();
    const confirmMsg = 'This will generate a CORE scenario and attempt to start it. Proceed?';
    if (!skipConfirm) {
        confirmResult = await promptExecuteConfirmation({
            message: confirmMsg,
            scenarioIndex: scenarioIndexForRun,
            alertMessage: '',
            alertTone: 'info',
        });
        if (!confirmResult?.confirmed) {
            logInfo('Run CLI cancelled by user at confirmation');
            return false;
        }
        if (Number.isInteger(confirmResult.scenarioIndex)) {
            scenarioIndexForRun = confirmResult.scenarioIndex;
        }
        if (confirmResult.updateRemote) {
            updateRemoteRepo = true;
        }
    }
    if(showProgressModal){
        openRunProgress('Running CLI…');
        maybeShowLocalEmulationHint();
    }
    if(updateRemoteRepo){
        appendExecuteDialogLog('Repository sync requested by user.');
        updateRunStatus('Copying repository…', 'Uploading repository snapshot to CORE host…');
        if (executeProgressState.active) {
            stopExecuteProgressHeartbeat();
            setExecuteProgressPercent(0, '0%');
        } else if (showProgressModal) {
            const bar = document.getElementById('runProgressBar');
            if (bar) {
                bar.classList.add('progress-bar-animated');
                bar.classList.add('progress-bar-striped');
                bar.style.width = '0%';
                bar.textContent = '0%';
            }
        }
        startUploadHeartbeat();
        try {
            const pushed = await pushRepoToRemote(rp, {
                scenarioIndex: scenarioIndexForRun,
                onProgress: handleRepoUploadProgress,
                onResponseProgress: handleRepoResponseProgress,
                onFinalizeProgress: handleFinalizeProgress,
            });
            if(!pushed){
                appendExecuteDialogLog('Repository upload failed; aborting run.');
                updateRunStatus('Repository sync failed', 'Upload failed; canceling run.');
                stopUploadHeartbeat();
                if(executeProgressState.active){
                    completeExecuteProgressPanel(false, 'Repository sync failed', 'Upload failed; canceling run.');
                } else if(showProgressModal){
                    const bar = document.getElementById('runProgressBar');
                    if(bar){
                        bar.classList.remove('progress-bar-animated');
                        bar.textContent = 'Error';
                    }
                }
                return false;
            }
            stopUploadHeartbeat();
            const elapsedSec = uploadStartTime ? Math.round((Date.now() - uploadStartTime) / 1000) : null;
            let summaryDetail = 'Repository upload complete.';
            if (lastUploadStats) {
                const loaded = lastUploadStats.loaded || 0;
                const total = lastUploadStats.total || null;
                const portion = total ? `${formatBytes(loaded)} / ${formatBytes(total)}` : `${formatBytes(loaded)} transferred`;
                summaryDetail = `Repository upload complete (${portion}${elapsedSec ? ` in ${elapsedSec}s` : ''}).`;
            } else if (elapsedSec) {
                summaryDetail = `Repository upload complete in ${elapsedSec}s.`;
            }
            appendExecuteDialogLog(summaryDetail);
            updateRunStatus('Repository copied', 'Preparing remote workspace…');
            setUploadProgressValue(100, 'Upload complete');
            updateRemoteRepo = false;
        } catch(err) {
            appendExecuteDialogLog(`Repository upload exception: ${err?.message || err}`);
            updateRunStatus('Repository sync failed', 'Exception during upload.');
            stopUploadHeartbeat();
            if(executeProgressState.active){
                completeExecuteProgressPanel(false, 'Repository sync failed', 'Exception during upload.');
            } else if(showProgressModal){
                const bar = document.getElementById('runProgressBar');
                if(bar){
                    bar.classList.remove('progress-bar-animated');
                    bar.textContent = 'Error';
                }
            }
            return false;
        }
    }
    try {
        // Ensure dock is visible
        try {
            const showBtn = document.getElementById('dockShowBtn');
            if (showBtn && !showBtn.classList.contains('d-none')) { showBtn.click(); }
        } catch(e){}
        appendExecuteDialogLog('Requesting remote CLI run…');
        appendExecuteDialogLog(`RUN_CLI_URL=${RUN_CLI_URL || '(missing)'}`);
        updateRunStatus('Preparing remote workspace…', 'Submitting run request to CORE host…');
        const formOptions = { updateRemoteRepo };
        if (Number.isInteger(scenarioIndexForRun)) {
            formOptions.scenarioIndex = scenarioIndexForRun;
        }
        if (confirmResult && typeof confirmResult === 'object' && confirmResult.advanced) {
            formOptions.advanced = confirmResult.advanced;
        } else if (advancedFromOpts && typeof advancedFromOpts === 'object') {
            formOptions.advanced = advancedFromOpts;
        }
        try {
            const injectedOnly = !!formOptions?.advanced?.uploadOnlyInjectedArtifacts;
            appendExecuteDialogLog(`Remote upload mode: ${injectedOnly ? 'injected-only (mount_dir)' : 'full artifacts_dir'}`);
        } catch (e) {}
        const autoKillSessions = !!formOptions?.advanced?.autoKillSessions;
        const res = await submitRunCliRequest(
            () => {
                if (IS_BUILDER_VIEW) {
                    const payload = enrichPayloadWithScenarioContext({
                        scenarios: state.scenarios,
                        core: getCoreConfig(true),
                    }, { scenarioIndex: scenarioIndexForRun });
                    if (updateRemoteRepo) {
                        payload.update_remote_repo = true;
                    }
                    try {
                        const adv = formOptions && typeof formOptions.advanced === 'object' ? formOptions.advanced : null;
                        if (adv && adv.fixDockerDaemon) payload.adv_fix_docker_daemon = true;
                        if (adv && adv.runCoreCleanup) payload.adv_run_core_cleanup = true;
                        if (adv && adv.checkCoreVersion) payload.adv_check_core_version = true;
                        if (adv && adv.restartCoreDaemon) payload.adv_restart_core_daemon = true;
                        if (adv && adv.startCoreDaemon) payload.adv_start_core_daemon = true;
                        if (adv && adv.autoKillSessions) payload.adv_auto_kill_sessions = true;
                        if (adv && adv.uploadOnlyInjectedArtifacts) payload.upload_only_injected_artifacts = true;
                    } catch (e) {}
                    return {
                        body: JSON.stringify(payload),
                        headers: { 'Content-Type': 'application/json' },
                        xmlPath: null,
                        scenarioIndex: scenarioIndexForRun,
                    };
                }
                return { body: buildRunFormData(rp, formOptions), xmlPath: rp, scenarioIndex: scenarioIndexForRun };
            },
            { autoKillSessions }
        );
        if (res) {
            appendExecuteDialogLog(`Remote CLI request completed (HTTP ${res.status}).`);
        }
        if(!res){
            runProgressLogLine('Run start aborted.');
            if(showProgressModal){
                try {
                    const statusEl = document.getElementById('runProgressStatus');
                    if(statusEl) statusEl.textContent = 'Aborted';
                    const metaEl = document.getElementById('runProgressMeta');
                    let abortReason = 'Run start aborted.';
                    try {
                        const last = window.__lastRunStartAbort;
                        if (last && typeof last === 'object' && last.reason) {
                            abortReason = String(last.reason);
                        }
                    } catch (e) {}
                    if(metaEl) metaEl.textContent = abortReason;
                    const bar = document.getElementById('runProgressBar');
                    if(bar){ bar.classList.remove('progress-bar-animated'); bar.textContent = 'Aborted'; }
                    markRunProgressComplete();
                } catch(e){}
            }
            try { opts.onError?.(new Error('Run aborted before launch')); } catch(e){}
            return false;
        }
        if(!res.ok){
            const detail = await extractResponseDetail(res);
            const message = detail || `HTTP ${res.status}`;
            runProgressLogLine('Failed to start CLI' + (detail ? `: ${detail}` : ''));
            if(showProgressModal){
                try {
                    const statusEl = document.getElementById('runProgressStatus');
                    if(statusEl) statusEl.textContent = 'Failed to start';
                    const metaEl = document.getElementById('runProgressMeta');
                    if(metaEl) metaEl.textContent = message;
                    const bar = document.getElementById('runProgressBar');
                    if(bar){ bar.classList.remove('progress-bar-animated'); bar.textContent = 'Error'; }
                    markRunProgressComplete();
                } catch(e){}
            }
            try { opts.onError?.(new Error(message)); } catch(e){}
            return false;
        }
        const dataInit = await res.json();
        const run_id = dataInit?.run_id;
        if(run_id){
            runProgressRunId = run_id;
            waitingForRemoteLogs = true;
            appendExecuteDialogLog(`Remote CLI run id ${run_id} acknowledged; waiting for logs…`);
            updateRunStatus('Remote CLI starting…', 'Waiting for remote logs…');
            try { opts.onRunId?.(run_id); } catch(e){}
        }
        if(!run_id){
            runProgressLogLine('Execution start response missing run_id');
            if(showProgressModal){
                try {
                    const statusEl = document.getElementById('runProgressStatus');
                    if(statusEl) statusEl.textContent = 'Failed to start';
                    const metaEl = document.getElementById('runProgressMeta');
                    if(metaEl) metaEl.textContent = 'Missing run id';
                    const bar = document.getElementById('runProgressBar');
                    if(bar){ bar.classList.remove('progress-bar-animated'); bar.textContent = 'Error'; }
                    markRunProgressComplete();
                } catch(e){}
            }
            try { opts.onError?.(new Error('Missing run id')); } catch(e){}
            return false;
        }
        // No Cancel button in modal; runs cannot be cancelled here
        // Start SSE stream into modal
        try { if(runProgressEvtSrc) runProgressEvtSrc.close(); } catch(e){}
        try { localStorage.setItem('coretg_active_run_id', String(run_id||'')); } catch(e) {}
        runProgressEvtSrc = new EventSource('/stream/' + run_id);
        appendExecuteDialogLog('Subscribed to remote log stream. Awaiting first line…');
        runProgressEvtSrc.addEventListener('phase', (ev) => {
            try {
                const payload = JSON.parse(ev.data || '{}');
                handleExecuteProgressPhase(payload);
            } catch (e) {}
        });
        runProgressEvtSrc.onmessage = (ev)=>{
            if (waitingForRemoteLogs) {
                waitingForRemoteLogs = false;
                appendExecuteDialogLog('First remote log line received.');
                updateRunStatus('Running CLI…', 'Streaming remote logs…');
            }
            runProgressLogLine(ev.data||'');
        };
        runProgressEvtSrc.addEventListener('end', ()=>{
            waitingForRemoteLogs = false;
            try { runProgressEvtSrc.close(); } catch(e){}
            try { localStorage.removeItem('coretg_active_run_id'); } catch(e) {}
            logInfo('Run (modal) ended');
        });
        // Poll for completion and update meta
        return await new Promise((resolve) => {
            (async function poll(){
                try{
                    const r = await fetch('/run_status/' + run_id);
                    if(!r.ok){ setTimeout(poll, 1200); return; }
                    const data = await r.json();
                    if(data.report_path || data.xml_path){
                        state.result_path = data.report_path || data.xml_path;
                        persistEditorState();
                    }
                    if(showProgressModal){
                        const metaEl = document.getElementById('runProgressMeta');
                        if(metaEl){ metaEl.textContent = data.done ? (data.returncode===0 ? 'Completed' : 'Failed') : 'Running…'; }
                    } else {
                        try { opts.onTick?.(data); } catch(e){}
                    }
                    if(!data.done){ setTimeout(poll, 1000); return; }
                    if(showProgressModal){
                        document.getElementById('runProgressStatus').textContent = (data.returncode===0) ? 'Scenario started' : 'Finished with errors';
                        document.getElementById('runProgressBar').classList.remove('progress-bar-animated');
                        markRunProgressComplete();
                    }
                    try { opts.onComplete?.(data); } catch(e){}
                    try {
                        if (data.returncode === 0) {
                            scheduleScenarioRedirect("{{ url_for('reports_page') }}", { delay: 500 });
                        }
                    } catch(e){}
                    resolve(data);
                } catch(e){ setTimeout(poll, 1500); }
            })();
        });
    } catch(e){
        runProgressLogLine('Exception starting CLI');
        try { if(!showProgressModal) opts.onError?.(e); } catch(_){}
        throw e;
    }
}

// Run deterministically with a seed (preview seed or input)
async function runWithSeedBuild(){
    // Ensure XML is saved
    let rp = state.result_path || '';
    if(!rp.endsWith('.xml')){
        const go = window.confirm('XML not saved yet. Save now?');
        if(!go) return;
        const saved = await saveXmlAjax();
        if(!saved){ alert('Auto-save failed; cannot run.'); return; }
        rp = state.result_path || '';
        if(!rp.endsWith('.xml')){ alert('Saved XML path unresolved.'); return; }
    }
    // Derive seed: prefer explicit input, else current preview seed
    // seedInputEl removed
    let seedVal = null;
    if(seedInputEl && seedInputEl.value.trim()){
        const num = parseInt(seedInputEl.value.trim(),10); if(!isNaN(num) && num>0) seedVal = num;
    } else if(previewState.fullPreview && previewState.fullPreview.seed){
        seedVal = previewState.fullPreview.seed;
    }
    if(seedVal===null){
        alert('Enter a seed or generate a Full Preview (which records a seed) first.');
        return;
    }
    const execInfo = detectLocalEmulation();
    const confirmMsg = `Run CLI with seed=${seedVal}? This will start a CORE session.`;
    const { idx: scenarioIdx } = getActiveScenarioContext();
    const confirmResult = await promptExecuteConfirmation({
        message: confirmMsg,
        scenarioIndex: scenarioIdx,
        alertMessage: '',
        alertTone: 'info',
        confirmLabel: 'Run with seed',
    });
    if(!confirmResult?.confirmed) return;

    const updateRemoteRepo = !!confirmResult?.updateRemote;
    const advancedSelections = (confirmResult && typeof confirmResult === 'object' && confirmResult.advanced) ? confirmResult.advanced : null;
    let sendUpdateRemoteFlag = updateRemoteRepo;
    let waitingForSeedLogs = false;
    openRunProgress('Running CLI (seed='+seedVal+')…');
    maybeShowLocalEmulationHint();
    const updateSeedUploadProgress = (info) => {
        if (!info) return;
        const loaded = info.loaded || 0;
        const total = info.total || null;
        const percent = typeof info.percent === 'number' ? info.percent : null;
        const statusEl = document.getElementById('runProgressStatus');
        if(statusEl) statusEl.textContent = 'Copying repository…';
        const metaEl = document.getElementById('runProgressMeta');
        if(metaEl){
            if(total){
                const base = `${formatBytes(loaded)} / ${formatBytes(total)}`;
                metaEl.textContent = percent !== null ? `${base} (${percent.toFixed(1)}%)` : base;
            } else {
                metaEl.textContent = `${formatBytes(loaded)} transferred`;
            }
        }
        const bar = document.getElementById('runProgressBar');
        if(bar && percent !== null){
            const clamped = Math.max(0, Math.min(100, percent));
            bar.style.width = `${clamped.toFixed(1)}%`;
            bar.textContent = `${clamped.toFixed(1)}%`;
        }
    };
    let lastSeedFinalizeDetail = null;
    const handleSeedFinalizeProgress = (info) => {
        if (!info || typeof info !== 'object') {
            return;
        }
        const detail = info.detail || info.stage || 'Remote finalize in progress…';
        const percent = typeof info.percent === 'number' ? Math.max(0, Math.min(100, info.percent)) : null;
        if (detail && detail !== lastSeedFinalizeDetail) {
            lastSeedFinalizeDetail = detail;
            runProgressLogLine(`[ui] Remote finalize: ${detail}${percent !== null ? ` (${percent.toFixed(0)}%)` : ''}`);
        }
        const metaEl = document.getElementById('runProgressMeta');
        if (metaEl && detail) {
            metaEl.textContent = detail;
        }
        if (percent !== null) {
            const bar = document.getElementById('runProgressBar');
            if (bar) {
                const pct = percent.toFixed(1);
                bar.style.width = `${pct}%`;
                bar.textContent = `${pct}%`;
            }
        }
    };
    if(updateRemoteRepo){
        runProgressLogLine('[ui] Repository sync requested by user.');
        const statusEl = document.getElementById('runProgressStatus');
        if(statusEl) statusEl.textContent = 'Copying repository…';
        const metaEl = document.getElementById('runProgressMeta');
        if(metaEl) metaEl.textContent = 'Uploading repository snapshot to CORE host…';
        const bar = document.getElementById('runProgressBar');
        if(bar){
            bar.classList.add('progress-bar-animated');
            bar.classList.add('progress-bar-striped');
            bar.style.width = '0%';
            bar.textContent = '0%';
        }
        const pushed = await pushRepoToRemote(rp, {
            scenarioIndex: scenarioIdx,
            onProgress: updateSeedUploadProgress,
            onFinalizeProgress: handleSeedFinalizeProgress,
        });
        if(!pushed){
            runProgressLogLine('[ui] Repository upload failed; aborting seeded run.');
            if(statusEl) statusEl.textContent = 'Repository sync failed';
            if(metaEl) metaEl.textContent = 'Upload failed; canceling run.';
            if(bar){
                bar.classList.remove('progress-bar-animated');
                bar.textContent = 'Error';
            }
            markRunProgressComplete();
            return;
        }
        runProgressLogLine('[ui] Repository upload complete.');
        if(statusEl) statusEl.textContent = 'Repository copied';
        if(metaEl) metaEl.textContent = 'Preparing remote workspace…';
        if(bar){
            bar.style.width = '100%';
            bar.textContent = 'Upload complete';
        }
        sendUpdateRemoteFlag = false;
    }
    try {
        // Show dock logs
        try { const showBtn=document.getElementById('dockShowBtn'); if(showBtn && !showBtn.classList.contains('d-none')) showBtn.click(); } catch(e){}
        runProgressLogLine('[ui] Requesting remote CLI run…');
        try {
            const injectedOnly = !!advancedSelections?.uploadOnlyInjectedArtifacts;
            runProgressLogLine(`[ui] Remote upload mode: ${injectedOnly ? 'injected-only (mount_dir)' : 'full artifacts_dir'}`);
        } catch (e) {}
        const seededStatusEl = document.getElementById('runProgressStatus');
        if(seededStatusEl) seededStatusEl.textContent = 'Preparing remote workspace…';
        const statusMetaEl = document.getElementById('runProgressMeta');
        if(statusMetaEl) statusMetaEl.textContent = 'Submitting run request to CORE host…';
        const buildRequest = () => {
            const payload = enrichPayloadWithScenarioContext({ xml_path: rp, seed: seedVal, core: getCoreConfig(true) });
            if (sendUpdateRemoteFlag) {
                payload.update_remote_repo = true;
            }
            try {
                if (advancedSelections && typeof advancedSelections === 'object') {
                    if (advancedSelections.fixDockerDaemon) payload.adv_fix_docker_daemon = true;
                    if (advancedSelections.runCoreCleanup) payload.adv_run_core_cleanup = true;
                    if (advancedSelections.checkCoreVersion) payload.adv_check_core_version = true;
                    if (advancedSelections.restartCoreDaemon) payload.adv_restart_core_daemon = true;
                    if (advancedSelections.startCoreDaemon) payload.adv_start_core_daemon = true;
                    if (advancedSelections.autoKillSessions) payload.adv_auto_kill_sessions = true;
                    if (advancedSelections.uploadOnlyInjectedArtifacts) payload.upload_only_injected_artifacts = true;
                }
            } catch (e) {}
            return {
                body: JSON.stringify(payload),
                headers: { 'Content-Type': 'application/json' },
                xmlPath: rp,
                scenarioIndex: scenarioIdx,
            };
        };
        const autoKillSessions = !!advancedSelections?.autoKillSessions;
        const res = await submitRunCliRequest(buildRequest, { autoKillSessions });
        if(res){
            runProgressLogLine(`[ui] Remote CLI request completed (HTTP ${res.status}).`);
        }
        if(!res){ runProgressLogLine('Seeded run aborted before launch'); return; }
        if(!res.ok){
            const detail = await extractResponseDetail(res);
            runProgressLogLine('Failed to start seeded run' + (detail ? `: ${detail}` : ''));
            markRunProgressComplete();
            return;
        }
        const { run_id } = await res.json();
        runProgressRunId = run_id;
        waitingForSeedLogs = true;
        runProgressLogLine(`[ui] Remote CLI run id ${run_id}; waiting for logs…`);
        if(seededStatusEl) seededStatusEl.textContent = 'Remote CLI starting…';
        if(statusMetaEl) statusMetaEl.textContent = 'Waiting for remote logs…';
        // Stream logs
        try { if(runProgressEvtSrc) runProgressEvtSrc.close(); } catch(e){}
        try { localStorage.setItem('coretg_active_run_id', String(run_id||'')); } catch(e) {}
        runProgressEvtSrc = new EventSource('/stream/' + run_id);
        runProgressLogLine('[ui] Subscribed to remote log stream. Awaiting first line…');
        runProgressEvtSrc.addEventListener('phase', (ev) => {
            try {
                const payload = JSON.parse(ev.data || '{}');
                handleExecuteProgressPhase(payload);
            } catch (e) {}
        });
        runProgressEvtSrc.onmessage = (ev)=> {
            if(waitingForSeedLogs){
                waitingForSeedLogs = false;
                runProgressLogLine('[ui] First remote log line received.');
                (document.getElementById('runProgressStatus')||{}).textContent = 'Running CLI…';
                const meta = document.getElementById('runProgressMeta');
                if(meta) meta.textContent = 'Streaming remote logs…';
            }
            runProgressLogLine(ev.data||'');
        };
        runProgressEvtSrc.addEventListener('end', ()=>{ waitingForSeedLogs = false; try { runProgressEvtSrc.close(); } catch(e){} try { localStorage.removeItem('coretg_active_run_id'); } catch(e) {} });
        // Poll status similar to runSyncWithModal
        (async function poll(){
            try{
                const r = await fetch('/run_status/' + run_id);
                if(!r.ok){ setTimeout(poll, 1200); return; }
                const data = await r.json();
                if(data.report_path || data.xml_path){ state.result_path = data.report_path || data.xml_path; persistEditorState(); }
                const metaEl = document.getElementById('runProgressMeta'); if(metaEl) metaEl.textContent = data.done ? (data.returncode===0 ? 'Completed' : 'Failed') : 'Running…';
                if(!data.done){ setTimeout(poll, 1000); return; }
                document.getElementById('runProgressStatus').textContent = (data.returncode===0) ? 'Scenario started' : 'Finished with errors';
                document.getElementById('runProgressBar').classList.remove('progress-bar-animated');
                markRunProgressComplete();
                if(data.returncode===0){ scheduleScenarioRedirect("{{ url_for('reports_page') }}", { delay: 600 }); }
            } catch(e){ setTimeout(poll, 1500); }
        })();
    } catch(e){ runProgressLogLine('Exception starting seeded run'); }
}

    function redistributeEven(sidx, secName) {
        const items = state.scenarios[sidx].sections[secName].items;
        const n = items.length;
        if (n === 0) return;
    const weightIdxs = items.map((it,i) => ({i,it})).filter(x => ((x.it.v_metric|| (x.it.selected==='Specific'?'Count':'Weight')) === 'Weight')).map(x => x.i);
    const m = weightIdxs.length;
    if (m === 0) { return; }
    const even = Math.round((1.0 / m) * 1000) / 1000;
    weightIdxs.slice(0, -1).forEach(i => { items[i].factor = even; });
        // last item gets the residual to hit 1.0
    const sumOther = weightIdxs.slice(0, -1).reduce((a, i) => a + (parseFloat(items[i].factor)||0), 0);
    const lastIdx = weightIdxs[weightIdxs.length - 1];
    items[lastIdx].factor = Math.max(0, Math.round((1.0 - sumOther) * 1000) / 1000);
        updateWeightWarning(sidx, secName);
    }

    function adjustWeightsProportionally(sidx, secName, changedIdx) {
        const items = state.scenarios[sidx].sections[secName].items;
        const n = items.length;
    const weightIdxs = items.map((it,i) => ({i,it})).filter(x => ((x.it.v_metric|| (x.it.selected==='Specific'?'Count':'Weight')) === 'Weight')).map(x => x.i);
        const m = weightIdxs.length;
        if (m <= 1) { if (m === 1) items[weightIdxs[0]].factor = 1.0; return; }
        // clamp changed value
        items[changedIdx].factor = Math.max(0, Math.min(1, parseFloat(items[changedIdx].factor)||0));
        const targetSum = 1.0;
        const changed = parseFloat(items[changedIdx].factor)||0;
        const others = weightIdxs.map(i => i !== changedIdx ? (parseFloat(items[i].factor)||0) : 0);
        const sumOthers = others.reduce((a,b) => a + b, 0);
        const residual = Math.max(0, targetSum - changed);
        if (sumOthers <= 0) {
            // Distribute evenly across others
            const even = residual / (m - 1);
            weightIdxs.forEach(i => { if (i !== changedIdx) items[i].factor = Math.round(even * 1000) / 1000; });
        } else {
            // Scale others proportionally to keep overall sum 1.0
            weightIdxs.forEach((i, idx) => {
                if (i === changedIdx) return;
                const ratio = others[idx] / sumOthers;
                items[i].factor = Math.round((residual * ratio) * 1000) / 1000;
            });
        }
        // Final normalization to exact 1.000 with 3 decimals
        normalizeToThousandths(sidx, secName);
    }

    function updateWeightWarning(sidx, secName) {
        const items = state.scenarios[sidx].sections[secName].items;
    // Exempt Node Information from weight validation (single Random item default)
    if (secName === 'Node Information') return;
    if (!items || items.length === 0) return;
        const sum = Math.round(items.reduce((a,b) => {
            const metric = b.v_metric || (b.selected==='Specific'?'Count':'Weight');
            return a + (metric==='Weight' ? (parseFloat(b.factor)||0) : 0);
        }, 0) * 1000) / 1000;
    const warn = document.querySelector(".section-warning[data-scen-idx='" + sidx + "'][data-sec='" + secName + "']");
        if (warn) {
            const density = parseFloat((state.scenarios[sidx].sections[secName]||{}).density);
            const weightCount = items.filter(b => (b.v_metric || (b.selected==='Specific'?'Count':'Weight')) === 'Weight').length;
            const badWeights = weightCount > 0 ? (Math.abs(sum - 1.0) > 0.005) : false;
            // Routing density: allow any density >= 0 (>=1 means absolute router count)
            // Other sections: keep 0..1 constraint
            const badDensity = isNaN(density) ? false : (
                secName === 'Routing' ? (density < 0) : (density < 0 || density > 1)
            );
            warn.style.display = (badWeights || badDensity) ? 'block' : 'none';
            let msgs = [];
            if (badWeights) msgs.push('Weights must sum to 1.000 (current: ' + sum.toFixed(3) + ')');
            if (badDensity) {
                if (secName === 'Routing') {
                    msgs.push('Routing density must be >= 0 (current: ' + density.toFixed(2) + '). Tip: < 1 = fraction of hosts; ≥ 1 = absolute router count.');
                } else {
                    msgs.push('Density must be between 0 and 1 (current: ' + density.toFixed(2) + ')');
                }
            }
            warn.textContent = msgs.join(' • ');
        }
    }

    function normalizeToThousandths(sidx, secName) {
        const items = state.scenarios[sidx].sections[secName].items;
        if (!items || items.length === 0) return;
        const vals = items.map(it => {
            const metric = it.v_metric || (it.selected==='Specific'?'Count':'Weight');
            const v = Math.max(0, Math.min(1, parseFloat(it.factor)||0));
            return metric==='Weight' ? v : 0;
        });
        // Convert to thousandths without rounding first
        const thousandthsRaw = vals.map(v => v * 1000);
        const floors = thousandthsRaw.map(v => Math.floor(v));
        let sumFloors = floors.reduce((a,b) => a + b, 0);
        let remainder = 1000 - sumFloors;
        if (remainder > 0) {
            // Distribute +1 to largest fractional parts
            const remainders = thousandthsRaw.map((v, i) => ({ idx: i, frac: v - floors[i] }));
            remainders.sort((a,b) => b.frac - a.frac);
            for (let k = 0; k < remainders.length && remainder > 0; k++) {
                floors[remainders[k].idx] += 1; remainder -= 1;
            }
        } else if (remainder < 0) {
            // Remove -1 from largest values to reduce sum to 1000
            const order = floors.map((v,i) => ({ idx: i, v }));
            order.sort((a,b) => b.v - a.v);
            while (remainder < 0) {
                for (let k = 0; k < order.length && remainder < 0; k++) {
                    const i = order[k].idx;
                    if (floors[i] > 0) { floors[i] -= 1; remainder += 1; }
                }
                if (order.length === 0) break;
            }
        }
        for (let i = 0; i < items.length; i++) {
            const metric = items[i].v_metric || (items[i].selected==='Specific'?'Count':'Weight');
            items[i].factor = (metric==='Weight') ? (floors[i] / 1000.0) : (items[i].factor||0);
        }
    }

    function updateWeightInputsDisplay(sidx, secName) {
        const items = state.scenarios[sidx].sections[secName].items;
    document.querySelectorAll("input.weight-input[data-scen-idx='" + sidx + "'][data-sec='" + secName + "']").forEach(input => {
            const iidx = parseInt(input.getAttribute('data-item-idx'));
            if (!isNaN(iidx) && items[iidx]) {
                input.value = (parseFloat(items[iidx].factor) || 0).toFixed(3);
            }
        });
    }

    // Dock setup handled by partial
</script>
 </body>
<!-- Success Modal -->
<div class="modal fade" id="runSuccessModal" tabindex="-1" aria-hidden="true">
    <div class="modal-dialog modal-dialog-centered">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title">Run Completed</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <p class="mb-1" id="runSuccessBody">Generation complete.</p>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
            </div>
        </div>
    </div>
</div>
<script>
function showRunSuccessModal(msg){
    try { if(msg) document.getElementById('runSuccessBody').textContent = msg; new bootstrap.Modal(document.getElementById('runSuccessModal')).show(); } catch(e){}
}
document.addEventListener('DOMContentLoaded', () => {
    if (window.runSuccessFlag) {
        scheduleScenarioRedirect("{{ url_for('reports_page') }}", { delay: 300 });
    }
});
// Capture server-provided flag (injected if present)
// Inject run success flag
window.runSuccessFlag = ("{{ '1' if (run_success is defined and run_success) else '0' }}" === '1');
// Wrap pollRunStatus to detect async completion success
function installRunSuccessHook(){
    const original = window.pollRunStatus;
    if (typeof original !== 'function') {
        console.warn('pollRunStatus hook skipped: function unavailable');
        return;
    }
    if (original.__runSuccessWrapped) {
        return;
    }
    const wrapped = async function(runId){
        await original(runId);
        try {
            const res = await fetch('/run_status/' + runId);
            if(!res.ok) return;
            const data = await res.json();
            if(data.done && data.returncode === 0){
                showRunSuccessModal('Asynchronous run completed successfully.');
            } else if(!data.done) {
                setTimeout(() => pollRunStatus(runId), 800);
            }
        } catch(e){}
    };
    wrapped.__runSuccessWrapped = true;
    window.pollRunStatus = wrapped;
}
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', installRunSuccessHook);
} else {
    installRunSuccessHook();
}
</script>
{% endblock %}
