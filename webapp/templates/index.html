{% extends 'layout.html' %}
{% block title %}Scenarios - CORE TopoGen{% endblock %}
{% block active_page %}{% set active_page = 'scenarios' %}{% endblock %}
{% block extra_head %}
<style>
    body { padding-bottom: 42vh; }
    .pulse-change { animation: pulseHighlight .9s ease-in-out; }
    @keyframes pulseHighlight { 0% { box-shadow:0 0 0 0 rgba(13,110,253,.7); transform:scale(1);} 40% { box-shadow:0 0 0 6px rgba(13,110,253,.0); transform:scale(1.03);} 100% { box-shadow:0 0 0 0 rgba(13,110,253,0); transform:scale(1); } }
    .popover { max-width: 420px; }
    .host-total-badge + .badge, .host-total-badge + button { margin-left: .25rem; }
</style>
{% endblock %}
/* Hide H/S bounds by default; JS adds .hs-show to display them */
.hs-bounds-wrapper { display: none; }
.hs-bounds-wrapper.hs-show { display: flex; }
{% block content %}
    <div class="row">
        <div class="col-md-3 mb-3">
                <div class="card shadow-sm h-100 d-flex flex-column">
                            <div class="card-header d-flex justify-content-between align-items-center">
                                <span class="fw-bold">Scenarios</span>
                                <div class="btn-toolbar gap-2">
                                    <button type="button" class="btn btn-sm btn-outline-secondary" id="importBtn">Import</button>
                                    <button type="button" class="btn btn-sm btn-outline-info" id="exportBtn">Export</button>
                                </div>
                            </div>
                    <div class="list-group list-group-flush flex-grow-1 overflow-auto" id="scenarioList" style="min-height:0;"></div>
                    <form id="hiddenLoadForm" class="d-none" action="{{ url_for('load_xml') }}" method="post" enctype="multipart/form-data">
                        <input type="file" name="scenarios_xml" id="hiddenLoadInput" accept=".xml">
                    </form>
                    <div class="card-footer" style="position: sticky; bottom: 0; background: #fff; z-index: 1;">
                        <button type="button" class="btn btn-sm btn-primary w-100" id="appendScenarioBtn">New Scenario</button>
                    </div>
                </div>
            </div>
    <div class="col-md-9">

            <div class="card shadow mt-3">
                <div class="card-body">
                    {% with messages = get_flashed_messages() %}
                        {% if messages %}
                            <div class="alert alert-info">{{ messages[0] }}</div>
                        {% endif %}
                    {% endwith %}

                    <div class="card mb-3" id="baseCoreScenarioCard">
                        <div class="card-header d-flex justify-content-between align-items-center">
                            <strong>Base CORE Scenario</strong>
                            <div class="d-flex align-items-center gap-2">
                                {% if payload.base_upload %}
                                    {% if payload.base_upload.valid %}
                                        <span class="badge text-bg-success">VALID</span>
                                    {% else %}
                                        <span class="badge text-bg-danger">INVALID</span>
                                    {% endif %}
                                    <a class="btn btn-sm btn-outline-secondary" href="{{ url_for('core_details') }}?path={{ payload.base_upload.path | urlencode }}" target="_blank">Details</a>
                                    <form action="{{ url_for('remove_base') }}" method="post" class="d-inline" onsubmit="saveScrollBeforeNav(); document.getElementById('scenarios_json').value = JSON.stringify({ scenarios: state.scenarios });">
                                        <button type="submit" class="btn btn-sm btn-outline-danger">Remove</button>
                                    </form>
                                {% endif %}
                            </div>
                        </div>
                        <div class="card-body">
                            <div class="mb-3">
                                <label class="form-label d-flex align-items-center justify-content-between">
                                    <span>Base Scenario File</span>
                                </label>
                                <input class="form-control" id="baseFileInput" readonly>
                                <div class="form-text">Shows the uploaded file name; full path is stored internally.</div>
                            </div>
                            <form class="d-flex gap-2" action="{{ url_for('upload_base') }}" method="post" enctype="multipart/form-data" onsubmit="saveScrollBeforeNav()">
                                <input type="file" class="form-control" name="base_xml" accept=".xml" required>
                                <button type="submit" class="btn btn-primary">{% if payload.base_upload %}Update{% else %}Upload{% endif %}</button>
                            </form>
                            {% if payload.base_upload and not payload.base_upload.valid and logs %}
                                <div class="alert alert-danger mt-3 mb-0" style="white-space: pre-wrap;">{{ logs }}</div>
                            {% endif %}
                        </div>
                    </div>

                    <form id="editorForm" action="{{ url_for('save_xml') }}" method="post">
                        <input type="hidden" name="scenarios_json" id="scenarios_json">
                        <div id="editorRoot"></div>
                        <div class="d-flex gap-2 mt-3">
                            <button type="submit" class="btn btn-success">Save XML</button>
                            <button type="button" class="btn btn-outline-info" id="downloadXmlBtn" disabled title="Save XML first">Download XML</button>
                        </div>
                    </form>

                    <div class="card mt-3" id="coreConnectionCard">
                        <div class="card-header d-flex justify-content-between align-items-center">
                            <strong>CORE Connection</strong>
                            <button class="btn btn-sm btn-outline-secondary" type="button" data-bs-toggle="collapse" data-bs-target="#coreAdvancedCollapse" aria-expanded="false" aria-controls="coreAdvancedCollapse">Advanced</button>
                        </div>
                        <div class="card-body">
                            <div class="row g-2 align-items-end mb-1">
                                <div class="col-auto">
                                    <label for="coreHost" class="form-label mb-0">IP</label>
                                    <input type="text" class="form-control" id="coreHost" placeholder="localhost" value="{{ (payload.core.host if payload.core else 'localhost') | e }}">
                                </div>
                                <div class="col-auto">
                                    <label for="corePort" class="form-label mb-0">Port</label>
                                    <input type="number" class="form-control" id="corePort" placeholder="50051" value="{{ (payload.core.port if payload.core else 50051) }}">
                                </div>
                            </div>
                            <div class="collapse" id="coreAdvancedCollapse">
                                <hr class="my-2"/>
                                <div class="d-flex flex-wrap gap-2 align-items-center mb-2">
                                    <button class="btn btn-sm btn-outline-secondary" type="button" id="testCoreBtn">Test CORE Connection</button>
                                    <span id="coreStatus" class="small text-muted">Not tested </span>
                                </div>
                                <div class="form-text">Testing is optional; if you skip it the run will still attempt to connect using the provided host and port.</div>
                            </div>
                        </div>
                    </div>

                    

                    <!-- Planning Workflow card visually removed but retained (d-none) for underlying JS functionality -->
                    <div class="card mt-3 d-none" id="planWorkflowCard">
                        <div class="card-header d-flex justify-content-between align-items-center">
                            <strong>Planning Workflow</strong>
                            <div id="planStatusBadge" class="badge text-bg-secondary">No Preview</div>
                        </div>
                        <div class="card-body">
                            <div class="d-flex flex-wrap gap-2 align-items-center mb-2">
                                                                <button class="btn btn-sm btn-outline-primary" type="button" id="planPreviewBtn" title="Generate full preview (routers, IPs, services)" disabled>Full Preview</button>
                                                                <!-- Run (Seed) workflow removed: deterministic seed input and run button eliminated -->
                                <!-- Single Full Preview button (above) is authoritative; secondary button and strict checkbox removed -->
                            </div>
                            <div class="small text-muted" id="planHint">Save XML and test CORE connection to enable planning.</div>
                            <pre id="planPreviewJson" class="small bg-light p-2 border rounded d-none" style="max-height:260px;overflow:auto;font-size:0.65rem;"></pre>
                            <div id="fullPreviewStructured" class="mt-2 d-none">
                                <div class="d-flex flex-wrap gap-2 align-items-center mb-2">
                                    <div class="btn-group btn-group-sm" role="group" aria-label="Full preview sections" id="fullPreviewSectionTabs"></div>
                                    <button type="button" class="btn btn-sm btn-outline-secondary" id="toggleRawFullPreviewBtn" title="Toggle raw JSON / structured view">Raw JSON</button>
                                    <!-- Copy seed button removed -->
                                </div>
                                <div id="fullPreviewSectionContent" class="border rounded p-2 bg-white small" style="max-height:300px; overflow:auto; font-size:.7rem;"></div>
                            </div>
                            <div id="planViolationsWrap" class="d-none mt-2">
                                <div class="alert alert-warning py-2 mb-0"><strong>Violations</strong><ul id="planViolationsList" class="mb-0 small"></ul></div>
                            </div>
                        </div>
                    </div>
                    <!-- Run form repurposed: Run CLI now triggers Full Preview (no direct execution here) -->
                    <form class="d-flex gap-2 mt-3 align-items-center" action="javascript:void(0)" id="runLegacyForm">
                        <input type="hidden" name="xml_path" id="xml_path">
                        <span class="d-inline-block" tabindex="0" id="runSyncWrap" data-bs-toggle="tooltip" data-bs-title="Runs CLI using current XML">
                            <button class="btn btn-warning" type="button" id="runSyncBtn" disabled title="Generates a Full Preview (no execution)">Generate</button>
                        </span>
                        <button class="btn btn-outline-danger d-none" type="button" id="cancelRunBtn" onclick="cancelRun()">Cancel</button>
                    </form>
                </div>
            </div>
            
        </div>
    </div>
<!-- Run Progress Modal -->
<div class="modal fade" id="runProgressModal" tabindex="-1" aria-hidden="true">
    <div class="modal-dialog modal-dialog-centered modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title">Running CLI…</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <div class="d-flex justify-content-between align-items-center mb-2 small text-muted">
                    <div id="runProgressStatus">Starting…</div>
                    <div id="runProgressMeta"></div>
                </div>
                <div class="progress mb-3" role="progressbar" aria-label="Progress" aria-valuemin="0" aria-valuemax="100">
                    <div class="progress-bar progress-bar-striped progress-bar-animated" id="runProgressBar" style="width: 100%">Working…</div>
                </div>
                <div class="border rounded" style="max-height: 260px; overflow: auto;">
                    <pre class="m-0 p-2 small" id="runProgressLog" style="white-space: pre-wrap;"></pre>
                </div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" id="runProgressHideBtn" data-bs-dismiss="modal">Hide</button>
            </div>
        </div>
    </div>
    </div>
{% set xml_preview_enabled = True %}
{% set xml_preview_text = xml_preview %}
{% include 'partials/dock.html' %}

<!-- Graph libraries for Full Preview Modal -->
<script src="https://cdn.jsdelivr.net/npm/d3@7/dist/d3.min.js"></script>
<script src="{{ url_for('static', filename='core_graph.js') }}"></script>

<!-- Toast container -->
<div aria-live="polite" aria-atomic="true" class="position-fixed" style="z-index: 1080; right: 12px; bottom: 12px;">
    <div id="toastContainer" class="toast-container"></div>
    <template id="toastTemplate">
        <div class="toast align-items-center text-bg-dark border-0" role="alert" aria-live="assertive" aria-atomic="true">
            <div class="d-flex">
                <div class="toast-body">Action completed.</div>
                <button type="button" class="btn-close btn-close-white me-2 m-auto" data-bs-dismiss="toast" aria-label="Close"></button>
            </div>
        </div>
    </template>
</div>
<!-- Success Modal -->
<div class="modal fade" id="runSuccessModal" tabindex="-1" aria-hidden="true">
    <div class="modal-dialog modal-dialog-centered">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title">Run Completed</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <p class="mb-1" id="runSuccessBody">Generation complete.</p>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
            </div>
        </div>
    </div>
</div>
<!-- Full Preview Modal -->
<div class="modal fade" id="fullPreviewModal" tabindex="-1" aria-hidden="true">
    <div class="modal-dialog modal-fullscreen-lg-down modal-xl modal-dialog-scrollable">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title">Full Preview <span class="text-muted small" id="fpModalSeed"></span></h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <div class="row g-3">
                    <div class="col-lg-8">
                        <div class="card" id="fpGraphCard">
                            <div class="card-header d-flex justify-content-between align-items-center">
                                <strong>Graph</strong>
                                <div class="btn-group btn-group-sm">
                                    <button class="btn btn-outline-secondary" type="button" id="fpGraphResetBtn">Reset</button>
                                    <button class="btn btn-outline-secondary" type="button" id="fpGraphPngBtn">PNG</button>
                                </div>
                            </div>
                            <div class="card-body p-2">
                                <div id="fpGraph" style="height:480px; position:relative; background:#fafafa; border:1px solid #e0e0e0; border-radius:4px; overflow:hidden;">
                                    <div class="position-absolute top-50 start-50 translate-middle text-muted" id="fpGraphLoading">Rendering...</div>
                                </div>
                                <div class="form-text mt-1">Drag to reposition nodes. Hover for details. PNG exports current view.</div>
                            </div>
                        </div>
                        <div class="card mt-3">
                            <div class="card-header"><strong>Routers</strong></div>
                            <div class="card-body p-2" id="fpRoutersWrap"><div class="text-muted small">No data</div></div>
                        </div>
                        <div class="card mt-3">
                            <div class="card-header"><strong>Hosts</strong></div>
                            <div class="card-body p-2" id="fpHostsWrap"><div class="text-muted small">No data</div></div>
                        </div>
                        <div class="card mt-3">
                            <div class="card-header"><strong>Switches</strong></div>
                            <div class="card-body p-2" id="fpSwitchesWrap"><div class="text-muted small">No data</div></div>
                        </div>
                    </div>
                    <div class="col-lg-4">
                        <div class="card mb-3">
                            <div class="card-header"><strong>Counts</strong></div>
                            <div class="card-body p-2" id="fpCounts"></div>
                        </div>
                        <div class="card mb-3">
                            <div class="card-header"><strong>R2R Policy</strong></div>
                            <div class="card-body p-2"><pre class="small mb-0" id="fpR2RPolicy" style="max-height:160px; overflow:auto;"></pre></div>
                        </div>
                        <div class="card mb-3">
                            <div class="card-header"><strong>R2S Policy</strong></div>
                            <div class="card-body p-2"><pre class="small mb-0" id="fpR2SPolicy" style="max-height:160px; overflow:auto;"></pre></div>
                        </div>
                        <div class="card mb-3">
                            <div class="card-header"><strong>Segmentation</strong></div>
                            <div class="card-body p-2"><pre class="small mb-0" id="fpSegmentation" style="max-height:220px; overflow:auto;"></pre></div>
                        </div>
                        <!-- Actions card removed: export / open handled elsewhere or deferred; Execute moved to modal footer -->
                                    <div class="card mb-3" id="fpHistoryCard">
                                        <div class="card-header"><strong>History</strong></div>
                                        <div class="card-body p-2" id="fpHistoryWrap">
                                            <div class="text-muted small">No history</div>
                                        </div>
                                    </div>
                                    <div class="card mb-3" id="fpRoleDistCard">
                                        <div class="card-header"><strong>Role Distribution</strong></div>
                                        <div class="card-body p-2" id="fpRoleDist"><div class="text-muted small">No data</div></div>
                                    </div>
                                    <div class="card mb-3" id="fpServiceDistCard">
                                        <div class="card-header"><strong>Service Distribution</strong></div>
                                        <div class="card-body p-2" id="fpServiceDist"><div class="text-muted small">No data</div></div>
                                    </div>
                                    <!-- Drift card removed (no approved plan concept) -->
                    </div>
                </div>
            </div>
            <div class="modal-footer d-flex justify-content-between align-items-center">
                <div class="d-flex gap-2">
                    <button class="btn btn-warning" type="button" id="fpExecuteBtn" title="Execute scenario now">Execute</button>
                </div>
                <button class="btn btn-secondary" data-bs-dismiss="modal" type="button">Close</button>
            </div>
        </div>
    </div>
</div>
<!-- Planning Semantics Modal -->
<div class="modal fade" id="planningSemanticsModal" tabindex="-1" aria-hidden="true">
    <div class="modal-dialog modal-lg modal-dialog-scrollable">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title" data-i18n="modal.planningSemantics.title">Planning Semantics</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <div class="spinner-border text-primary d-none" id="planningSemanticsSpinner" role="status"><span class="visually-hidden">Loading...</span></div>
                <div id="planningSemanticsContent" class="small"></div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal" data-i18n="common.close">Close</button>
            </div>
        </div>
    </div>
</div>
{% endblock %}
{% block extra_scripts %}
<script id="payload-data" type="application/json">{{ payload | tojson }}</script>
<script>
// --- BEGIN PAGE JS ---
const payloadDataEl = document.getElementById('payload-data');
// Prevent TDZ: define catalog early on window
window.VULN_CATALOG = window.VULN_CATALOG || { types: [], vectors: [], items: [] };
// Prevent TDZ: define catalog early on window
window.VULN_CATALOG = window.VULN_CATALOG || { types: [], vectors: [], items: [] };
// ---------------- Logging (buffer + level filter) -----------------
// Logging helpers now provided globally by dock partial
logInfo('UI initialized');
try {
    initialPayload = JSON.parse(payloadDataEl?.textContent || 'null');
} catch (e) {
    initialPayload = null;
}
// If server provides a fresh result_path (e.g., after Save XML), reflect it in localStorage early
try {
    if (initialPayload && initialPayload.result_path) {
        const persisted = JSON.parse(localStorage.getItem('coretg_editor_state') || 'null') || {};
        persisted.result_path = initialPayload.result_path;
        if (initialPayload.core) persisted.core = initialPayload.core;
        localStorage.setItem('coretg_editor_state', JSON.stringify(persisted));
    }
} catch(e){}

function defaultScenario(name) {
    return {
        name: name || `Scenario ${document.querySelectorAll('.scenario-card').length + 1}`,
        base: { filepath: '' },
        density_count: 10,
        sections: {
            // Default: one Count-based row; weight-based nodes/density start at 0
            'Node Information': { total_nodes: 0, density: 0, items: [ { selected: 'Random', factor: 1.0, v_metric: 'Count', v_count: 1 } ] },
            'Routing': { density: 0.5, items: [] },
            'Services': { density: 0.5, items: [] },
            'Traffic': { density: 0.5, items: [] },
            'Events': { density: 0.5, items: [] },
            'Vulnerabilities': { density: 0.5, items: [] },
            'Segmentation': { density: 0.5, items: [] }
        },
        notes: ''
    };
}

// Restore persisted editor state (scenarios and last saved xml) and active index from localStorage
let persistedState = null;
try { persistedState = JSON.parse(localStorage.getItem('coretg_editor_state') || 'null'); } catch(e){ persistedState = null; }
let persistedActiveIdx = 0;
try { const v = parseInt(localStorage.getItem('coretg_active_idx')||'0',10); if(!isNaN(v)) persistedActiveIdx = v; } catch(e){}
// Base state is from server payload or default
let state = initialPayload ?? { scenarios: [ defaultScenario('Scenario 1') ], result_path: null };
// If server provided a concrete result_path (save/load/run), prefer server scenarios; else, restore from localStorage if available
const serverHasResult = !!(initialPayload && initialPayload.result_path);
if (!serverHasResult && persistedState && Array.isArray(persistedState.scenarios) && persistedState.scenarios.length) {
    state.scenarios = persistedState.scenarios;
    if (persistedState.result_path) state.result_path = persistedState.result_path;
}
// Preview workflow state (in-memory only; persisted history handled separately)
let previewState = {
    fullPreview: null,
    fullPreviewHistory: [],
    xmlSaved: !!(state.result_path),
    dirty: false,
    coreTested: false
};
// Core settings: prefer server-provided if present; otherwise restore from persisted
// ---------------- Plan Workflow State -----------------
// (Legacy alias cleanup left intentionally blank. Using previewState below.)

// ---------- Full Preview History Persistence ----------
function loadFullPreviewHistory(){
    try { previewState.fullPreviewHistory = JSON.parse(localStorage.getItem('coretg_full_preview_history')||'[]'); } catch(e){ previewState.fullPreviewHistory = []; }
    if(!Array.isArray(previewState.fullPreviewHistory)) previewState.fullPreviewHistory = [];
}
function saveFullPreviewHistory(){
    try { localStorage.setItem('coretg_full_preview_history', JSON.stringify(previewState.fullPreviewHistory.slice(-25))); } catch(e){}
}
loadFullPreviewHistory();

function updatePlanButtons(){
    const previewBtn = document.getElementById('planPreviewBtn');
    const statusBadge = document.getElementById('planStatusBadge');
    const hint = document.getElementById('planHint');
    const genBtn = document.getElementById('runSyncBtn');
    const xmlPathVal = (state.result_path || '').trim();
    previewState.xmlSaved = !!xmlPathVal;
    const canPreview = previewState.xmlSaved || previewState.dirty;
    if(previewBtn) previewBtn.disabled = !canPreview;
    if(genBtn) genBtn.disabled = !canPreview;
    if(hint){
    if(!previewState.xmlSaved) hint.textContent = 'Save XML to enable planning.';
    else hint.textContent = previewState.fullPreview ? 'Full preview ready.' : 'Generate a full preview.';
    }
    if(statusBadge){
    statusBadge.className = 'badge ' + (previewState.fullPreview ? 'text-bg-info' : 'text-bg-secondary');
    statusBadge.textContent = previewState.fullPreview ? 'Preview' : 'No Preview';
    }
}


function showPlanSummary(summary){
    const pre = document.getElementById('planPreviewJson');
    if(!pre) return;
    pre.classList.remove('d-none');
    try{ pre.textContent = JSON.stringify(summary, null, 2); }catch(e){ pre.textContent='(error displaying plan)'; }
}

async function computePlanPreview(){
    // Deprecated lightweight preview replaced by full preview; delegate
    return computeFullPlanPreview();
}

// Approval functions removed

function onCoreTestedSuccess(){ previewState.coreTested = true; updatePlanButtons(); }

// Hook into existing CORE test result update
const originalUpdateCoreStatus = window.updateCoreStatus; // if defined later, we patch after definition
window.updateCoreStatus = function(success, msg){
    if(typeof originalUpdateCoreStatus === 'function') originalUpdateCoreStatus(success, msg);
    if(success) onCoreTestedSuccess();
};

document.addEventListener('DOMContentLoaded', () => {
    document.getElementById('planPreviewBtn')?.addEventListener('click', computePlanPreview);
    // Repurpose Run CLI button to invoke Full Preview logic
    document.getElementById('runSyncBtn')?.addEventListener('click', ()=>{
        // Mirror enablement guard from preview button
        if(document.getElementById('planPreviewBtn')?.disabled){
            logWarn('Full Preview disabled; cannot run');
            return;
        }
        computePlanPreview();
    });
    try { updatePlanButtons(); } catch(e){}
});

async function computeFullPlanPreview(){
    const xmlPathVal = (state.result_path || '').trim();
    if(!xmlPathVal){
        try { await autoSaveXml(); } catch(e){ alert('Auto-save failed: '+e); return; }
    }
    const newXmlPath = (state.result_path || '').trim();
    if(!newXmlPath){ alert('XML path still unavailable after save.'); return; }
    const btn = document.getElementById('planPreviewBtn');
    const pre = document.getElementById('planPreviewJson');
    btn.disabled = true; btn.dataset.prevLabel = btn.textContent; btn.textContent='Full preview...';
    pre.classList.remove('d-none'); pre.textContent='Computing full preview...';
    try {
    // Collect routing row host-per-switch overrides (min/max)
    let r2sHostsMinList = [];
    let r2sHostsMaxList = [];
    try {
        const scen = state.scenarios[0];
        if (scen && scen.sections && scen.sections['Routing']) {
            (scen.sections['Routing'].items || []).forEach(it => {
                if (it) {
                    r2sHostsMinList.push(typeof it.r2s_hosts_min === 'number' ? it.r2s_hosts_min : null);
                    r2sHostsMaxList.push(typeof it.r2s_hosts_max === 'number' ? it.r2s_hosts_max : null);
                }
            });
        }
    } catch(e) { /* ignore */ }
    const body = { xml_path: newXmlPath, r2s_hosts_min_list: r2sHostsMinList, r2s_hosts_max_list: r2sHostsMaxList };
        const res = await fetch('/api/plan/preview_full', { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(body) });
        const data = await res.json();
    if(!data.ok){ pre.textContent='Full preview failed: '+(data.error||''); previewState.fullPreview=null; document.getElementById('fullPreviewStructured')?.classList.add('d-none'); }
        else {
            previewState.fullPreview = data.full_preview;
            pre.textContent = JSON.stringify(previewState.fullPreview, null, 2);
            renderFullPreviewStructured();
            try { showFullPreviewModal(previewState.fullPreview); } catch(e){ console.warn('Modal render failed', e); }
            // Append to history
            try {
                const fp = previewState.fullPreview;
                previewState.fullPreviewHistory.push({
                    ts: Date.now(),
                    seed: fp.seed,
                    seed_generated: fp.seed_generated,
                    stats: {
                        routers: (fp.routers||[]).length,
                        hosts: (fp.hosts||[]).length,
                        switches: (fp.switches||[]).length,
                        r2r_edges: (fp.r2r_edges_preview||[]).length,
                        seg_rules: (fp.segmentation_preview && fp.segmentation_preview.rules ? fp.segmentation_preview.rules.length : 0)
                    },
                    preview: fp
                });
                saveFullPreviewHistory();
            } catch(e){}
        }
    } catch(e){ pre.textContent='Error: '+e; previewState.fullPreview=null; }
    btn.disabled = false; btn.textContent = btn.dataset.prevLabel || 'Full Preview';
}

function renderFullPreviewStructured(){
    const wrap = document.getElementById('fullPreviewStructured');
    if(!wrap) return;
    const full = previewState.fullPreview;
    if(!full){ wrap.classList.add('d-none'); return; }
    wrap.classList.remove('d-none');
    const tabsEl = document.getElementById('fullPreviewSectionTabs');
    const contentEl = document.getElementById('fullPreviewSectionContent');
    if(!tabsEl || !contentEl) return;
    const sections = [
        { id:'overview', label:'Overview' },
        { id:'routers', label:`Routers (${(full.routers||[]).length})` },
        { id:'hosts', label:`Hosts (${(full.hosts||[]).length})` },
        { id:'switches', label:`Switches (${(full.switches||[]).length})` },
        { id:'subnets', label:'Subnets' },
        { id:'r2r', label:`R2R Edges (${(full.r2r_edges_preview||[]).length})` },
        { id:'seg', label:`Seg Rules (${(full.segmentation_preview && full.segmentation_preview.rules ? full.segmentation_preview.rules.length : 0)})` },
        { id:'history', label:'History' },
    ];
    // Build tabs
    tabsEl.innerHTML = '';
    sections.forEach((s, idx) => {
        const b = document.createElement('button');
        b.type='button'; b.className='btn btn-outline-primary' + (idx===0?' active':'');
        b.textContent = s.label;
        b.dataset.section = s.id;
        b.onclick = () => { tabsEl.querySelectorAll('button').forEach(x=>x.classList.remove('active')); b.classList.add('active'); renderSectionContent(s.id); };
        tabsEl.appendChild(b);
    });
    function esc(x){ return (''+x).replace(/[&<>]/g,c=>({'&':'&amp;','<':'&lt;','>':'&gt;'}[c])); }
    function renderSectionContent(id){
        if(id==='overview'){
            const stats = [
                ['Routers', (full.routers||[]).length],
                ['Hosts', (full.hosts||[]).length],
                ['Switches', (full.switches||[]).length],
                ['R2R Edges', (full.r2r_edges_preview||[]).length],
                ['Avg R2R Deg', full.r2r_stats_preview && full.r2r_stats_preview.avg],
                ['Seg Rules', full.segmentation_preview && full.segmentation_preview.rules ? full.segmentation_preview.rules.length : 0],
                ['P2P /30', (full.ptp_subnets||[]).length],
                ['Router-Sw /30', (full.router_switch_subnets||[]).length],
                ['LAN /28', (full.lan_subnets||[]).length],
                // Seed removed from UI summary
            ];
            contentEl.innerHTML = '<div class="row g-2">' + stats.map(s=>`<div class="col-auto"><span class="badge text-bg-secondary">${esc(s[0])}: ${esc(s[1]??'-')}</span></div>`).join('') + '</div>';
            return;
        }
        if(id==='routers'){
            contentEl.innerHTML = tableFromObjects(full.routers || [], ['node_id','name','ip4']); return;
        }
        if(id==='hosts'){
            contentEl.innerHTML = tableFromObjects(full.hosts || [], ['node_id','name','role','ip4']); return;
        }
        if(id==='switches'){
            const rows = full.switches_detail || [];
            contentEl.innerHTML = tableFromObjects(rows, ['switch_id','router_id','hosts','rsw_subnet','lan_subnet']); return;
        }
        if(id==='subnets'){
            const p2p = (full.ptp_subnets||[]).map(s=>`<li>${esc(s)}</li>`).join('');
            const rs = (full.router_switch_subnets||[]).map(s=>`<li>${esc(s)}</li>`).join('');
            const lan = (full.lan_subnets||[]).map(s=>`<li>${esc(s)}</li>`).join('');
            contentEl.innerHTML = `<div class="row small g-3"><div class="col"><h6 class="fw-bold">Host P2P (/30)</h6><ul class="mb-0">${p2p||'<li>(none)</li>'}</ul></div><div class="col"><h6 class="fw-bold">Router-Switch (/30)</h6><ul class="mb-0">${rs||'<li>(none)</li>'}</ul></div><div class="col"><h6 class="fw-bold">LAN (/28)</h6><ul class="mb-0">${lan||'<li>(none)</li>'}</ul></div></div>`; return;
        }
        if(id==='r2r'){
            const edges = full.r2r_edges_preview || [];
            const deg = full.r2r_degree_preview || {};
            const degList = Object.entries(deg).map(([k,v])=>`r${k}:${v}`).join(', ');
            const spark = Object.values(deg).join(' ');
            const edgesSample = edges.slice(0,200).map(e=>`(${e[0]}-${e[1]})`).join(' ');
            contentEl.innerHTML = `<div><div class="mb-2"><strong>Degree Stats:</strong> ${esc(JSON.stringify(full.r2r_stats_preview||{}))}</div><div class="mb-2"><strong>Degrees:</strong> ${esc(degList||'(none)')}</div><div class="mb-2"><strong>Edges (${edges.length}):</strong> ${esc(edgesSample||'(none)')} ${edges.length>200?'...':''}</div><div><strong>Spark:</strong> ${esc(spark)}</div></div>`; return;
        }
        if(id==='seg'){
            const rules = (full.segmentation_preview && full.segmentation_preview.rules) || [];
            contentEl.innerHTML = tableFromObjects(rules.map(r=>({ node_id:r.node_id, type:r.rule.type, summary: ruleSummary(r.rule) })), ['node_id','type','summary']);
            return;
        }
        if(id==='history'){
            renderPreviewHistory(contentEl, full);
            return;
        }
        contentEl.textContent='Unknown section';
    }
    function ruleSummary(rule){
        if(!rule) return ''; const t = rule.type;
        if(t==='nat') return `${rule.mode||''} ${rule.internal||''} -> ${rule.external||''}`.trim();
        if(t==='host_block') return `${rule.src} X ${rule.dst}`;
        if(t==='custom') return rule.description || 'custom';
        return t;
    }
    function tableFromObjects(arr, cols){
        if(!arr.length) return '<div class="text-muted fst-italic">(none)</div>';
        const head = '<thead><tr>' + cols.map(c=>`<th>${esc(c)}</th>`).join('') + '</tr></thead>';
        const body = '<tbody>' + arr.map(o=>'<tr>'+cols.map(c=>`<td>${esc((o[c]!==undefined && o[c]!==null)? (Array.isArray(o[c])? o[c].join(','): o[c]): '')}</td>`).join('')+'</tr>').join('') + '</tbody>';
        return `<div class="table-responsive"><table class="table table-sm table-bordered mb-0">${head}${body}</table></div>`;
    }
    // Initial load
    renderSectionContent('overview');
    // Wire toggle button
    const toggleBtn = document.getElementById('toggleRawFullPreviewBtn');
    if(toggleBtn){
        toggleBtn.onclick = () => {
            const raw = document.getElementById('planPreviewJson');
            const struct = document.getElementById('fullPreviewStructured');
            if(raw.classList.contains('d-none')){ raw.classList.remove('d-none'); toggleBtn.textContent='Structured'; }
            else { raw.classList.add('d-none'); toggleBtn.textContent='Raw JSON'; }
        };
    }
    // Seed copy button removed
}

function renderPreviewHistory(contentEl, currentFull){
    loadFullPreviewHistory();
    if(!previewState.fullPreviewHistory.length){ contentEl.innerHTML = '<div class="text-muted fst-italic">No previous full previews</div>'; return; }
    function esc(x){ return (''+x).replace(/[&<>]/g,c=>({'&':'&amp;','<':'&lt;','>':'&gt;'}[c])); }
    const rows = previewState.fullPreviewHistory.slice().reverse().map((rec,idx) => {
        const dt = new Date(rec.ts).toLocaleTimeString();
        const diffBtn = `<button class="btn btn-sm btn-outline-primary" data-action="diff" data-seed="${esc(rec.seed)}">Diff</button>`;
        return `<tr><td>${idx+1}</td><td>${esc(rec.seed)}</td><td>${esc(rec.stats.routers)}/${esc(rec.stats.hosts)}/${esc(rec.stats.switches)}</td><td>${esc(rec.stats.r2r_edges)}</td><td>${esc(rec.stats.seg_rules)}</td><td>${dt}</td><td class="text-nowrap">${diffBtn}</td></tr>`;
    }).join('');
    contentEl.innerHTML = `<div class="table-responsive"><table class="table table-sm table-bordered mb-2"><thead><tr><th>#</th><th>Seed</th><th>R/H/S</th><th>R2R</th><th>Seg</th><th>Time</th><th></th></tr></thead><tbody>${rows}</tbody></table></div><div id="previewDiffOutput" class="small"></div>`;
    // Seed load buttons removed
    contentEl.querySelectorAll('button[data-action="diff"]').forEach(btn => {
        btn.addEventListener('click', () => { const seed = btn.getAttribute('data-seed'); const rec = previewState.fullPreviewHistory.find(r=> String(r.seed)===seed); if(!rec){ return; } const diffHtml = buildPreviewDiff(rec.preview, currentFull); document.getElementById('previewDiffOutput').innerHTML = diffHtml; });
    });
}

function buildPreviewDiff(a,b){
    const metrics = [
        ['Routers', (a.routers||[]).length, (b.routers||[]).length],
        ['Hosts', (a.hosts||[]).length, (b.hosts||[]).length],
        ['Switches', (a.switches||[]).length, (b.switches||[]).length],
        ['R2R Edges', (a.r2r_edges_preview||[]).length, (b.r2r_edges_preview||[]).length],
        ['Seg Rules', (a.segmentation_preview && a.segmentation_preview.rules ? a.segmentation_preview.rules.length : 0), (b.segmentation_preview && b.segmentation_preview.rules ? b.segmentation_preview.rules.length : 0)]
    ];
    function esc(x){ return (''+x).replace(/[&<>]/g,c=>({'&':'&amp;','<':'&lt;','>':'&gt;'}[c])); }
    const rows = metrics.map(m => { const delta = m[2]-m[1]; const cls = delta===0?'text-secondary':(delta>0?'text-success':'text-danger'); return `<tr><td>${esc(m[0])}</td><td>${esc(m[1])}</td><td>${esc(m[2])}</td><td class="${cls}">${delta>0?'+':''}${esc(delta)}</td></tr>`; }).join('');
    return `<div class="card border-info"><div class="card-header py-1 small">Diff vs current preview</div><div class="card-body p-2"><div class="table-responsive"><table class="table table-sm table-bordered mb-0"><thead><tr><th>Metric</th><th>Old</th><th>Current</th><th>Δ</th></tr></thead><tbody>${rows}</tbody></table></div></div></div>`;
}

// ---------- Full Preview Modal Rendering ----------
function showFullPreviewModal(full){
    if(!full) return;
    const modalEl = document.getElementById('fullPreviewModal');
    if(!modalEl) return;
    document.getElementById('fpModalSeed').textContent = `seed=${full.seed}`;
    // Counts
    const countsEl = document.getElementById('fpCounts');
    const stats = [
        ['Routers',(full.routers||[]).length],
        ['Hosts',(full.hosts||[]).length],
        ['Switches',(full.switches||[]).length],
        ['R2R Edges',(full.r2r_edges_preview||[]).length],
        ['Seg Rules', (full.segmentation_preview && full.segmentation_preview.rules ? full.segmentation_preview.rules.length:0)],
        ['P2P /30',(full.ptp_subnets||[]).length],
        ['R-Sw /30',(full.router_switch_subnets||[]).length],
        ['LAN /28',(full.lan_subnets||[]).length],
    ];
    countsEl.innerHTML = '<div class="row g-1">' + stats.map(s=>`<div class="col-auto"><span class="badge text-bg-secondary">${s[0]}: ${s[1]}</span></div>`).join('') + '</div>';
    // Policies & segmentation
    function setJson(id, obj){ const el=document.getElementById(id); if(el) el.textContent = JSON.stringify(obj||{}, null, 2); }
    setJson('fpR2RPolicy', full.r2r_policy_preview);
    setJson('fpR2SPolicy', full.r2s_policy_preview);
    setJson('fpSegmentation', full.segmentation_preview);
    // Tables
    function tableHtml(arr, cols){ if(!arr||!arr.length) return '<div class="text-muted small">(none)</div>'; const head='<thead><tr>'+cols.map(c=>`<th>${c}</th>`).join('')+'</tr></thead>'; const body='<tbody>'+arr.map(o=>'<tr>'+cols.map(c=>`<td>${(o[c]!==undefined&&o[c]!==null)? (Array.isArray(o[c])? o[c].join(','): o[c]): ''}</td>`).join('')+'</tr>').join('')+'</tbody>'; return `<div class="table-responsive"><table class="table table-sm table-bordered mb-0">${head}${body}</table></div>`; }
    const routersWrap = document.getElementById('fpRoutersWrap'); if(routersWrap) routersWrap.innerHTML = tableHtml(full.routers,['node_id','name','ip4']);
    const hostsWrap = document.getElementById('fpHostsWrap'); if(hostsWrap) hostsWrap.innerHTML = tableHtml(full.hosts,['node_id','name','role','ip4']);
    const switchesWrap = document.getElementById('fpSwitchesWrap'); if(switchesWrap) switchesWrap.innerHTML = tableHtml(full.switches_detail,['switch_id','router_id','hosts','rsw_subnet','lan_subnet']);
    // Graph
    buildFullPreviewModalGraph(full);
        // History & Diff
    try { renderFullPreviewHistoryInModal(); } catch(e){ console.warn('History render failed', e); }
        // Roles & services distribution
        try { renderRoleDistribution(full); } catch(e){ console.warn('Role dist failed', e); }
        try { renderServiceDistribution(full); } catch(e){ console.warn('Service dist failed', e); }
    // Approval & drift removed
    document.getElementById('fpExportJsonBtn')?.addEventListener('click', ()=>{ try { const blob=new Blob([JSON.stringify(full,null,2)],{type:'application/json'}); const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download='full_preview_seed_'+(full.seed||'na')+'.json'; document.body.appendChild(a); a.click(); a.remove(); setTimeout(()=>URL.revokeObjectURL(a.href),4000);} catch(e){} });
    // Open standalone full preview page via POST (original GET caused 405 Method Not Allowed)
    document.getElementById('fpOpenStandaloneBtn')?.addEventListener('click', ()=>{
        const xmlPath = state.result_path || '';
        if(!xmlPath.endsWith('.xml')){ alert('Save XML first to open standalone preview.'); return; }
        const scen = state.scenarios && state.scenarios[activeIdx] ? state.scenarios[activeIdx].name : '';
        const form = document.createElement('form');
        form.method='POST';
        form.action='/plan/full_preview_page';
        form.target='_blank';
        const inXml = document.createElement('input'); inXml.type='hidden'; inXml.name='xml_path'; inXml.value=xmlPath; form.appendChild(inXml);
        if(scen){ const inSc = document.createElement('input'); inSc.type='hidden'; inSc.name='scenario'; inSc.value=scen; form.appendChild(inSc); }
        document.body.appendChild(form);
        form.submit();
        setTimeout(()=>{ try { form.remove(); } catch(e){} }, 1000);
    });
    (new bootstrap.Modal(modalEl)).show();
}

function renderFullPreviewHistoryInModal(){
    const wrap = document.getElementById('fpHistoryWrap'); if(!wrap) return;
    loadFullPreviewHistory();
    const histAll = previewState.fullPreviewHistory || [];
    if(!histAll.length){ wrap.innerHTML='<div class="text-muted small">No history</div>'; return; }
    const hist = histAll.slice(-10); // last 10
    function esc(x){ return (''+x).replace(/[&<>]/g,c=>({'&':'&amp;','<':'&lt;','>':'&gt;'}[c])); }
    const rows = hist.slice().reverse().map((rec,i)=>{
        return `<tr><td>${i+1}</td><td>${esc(rec.seed)}</td><td>${esc(rec.stats.routers)}/${esc(rec.stats.hosts)}/${esc(rec.stats.switches)}</td><td>${esc(rec.stats.r2r_edges)}</td><td>${esc(rec.stats.seg_rules)}</td></tr>`;
    }).join('');
    wrap.innerHTML = `<div class='table-responsive'><table class='table table-sm table-bordered mb-0'><thead><tr><th>#</th><th>Seed</th><th>R/H/S</th><th>R2R</th><th>Seg</th></tr></thead><tbody>${rows}</tbody></table></div>`;
}

function renderRoleDistribution(full){
    const wrap = document.getElementById('fpRoleDist'); if(!wrap) return;
    const hosts = full.hosts || [];
    const counts = {};
    hosts.forEach(h => { const r = h.role || 'unknown'; counts[r] = (counts[r]||0)+1; });
    const roles = Object.entries(counts).sort((a,b)=> b[1]-a[1]);
    if(!roles.length){ wrap.innerHTML='<div class="text-muted small">No hosts</div>'; return; }
    const total = hosts.length || 1;
    const bars = roles.map(([role,c])=>{
        const pct = ((c/total)*100).toFixed(1);
        return `<div class='mb-1'><div class='d-flex justify-content-between small'><span>${role}</span><span>${c} (${pct}%)</span></div><div class='progress' style='height:6px;'><div class='progress-bar bg-info' style='width:${pct}%;'></div></div></div>`;
    }).join('');
    wrap.innerHTML = bars;
}

function renderServiceDistribution(full){
    const wrap = document.getElementById('fpServiceDist'); if(!wrap) return;
    const svcCounts = {};
    const nodes = [...(full.routers||[]), ...(full.hosts||[])];
    nodes.forEach(n => { (n.services||[]).forEach(s => { svcCounts[s] = (svcCounts[s]||0)+1; }); });
    const entries = Object.entries(svcCounts).sort((a,b)=> b[1]-a[1]);
    if(!entries.length){ wrap.innerHTML='<div class="text-muted small">No services</div>'; return; }
    const total = entries.reduce((sum,e)=> sum+e[1],0) || 1;
    wrap.innerHTML = `<div style='max-height:180px; overflow:auto;'>` + entries.map(([svc,c])=>{
        const pct = ((c/total)*100).toFixed(1);
        return `<div class='mb-1'><div class='d-flex justify-content-between small'><span>${svc}</span><span>${c} (${pct}%)</span></div><div class='progress' style='height:5px;'><div class='progress-bar bg-secondary' style='width:${pct}%;'></div></div></div>`;
    }).join('') + '</div>';
}

// Drift function removed

function buildFullPreviewModalGraph(full){
    if(!window.d3){ const g=document.getElementById('fpGraphLoading'); if(g) g.textContent='d3 not loaded'; return; }
    const container = d3.select('#fpGraph');
    container.selectAll('*').remove();
    const w = container.node().clientWidth || 800; const h = container.node().clientHeight || 480;
    const svg = container.append('svg').attr('width', w).attr('height', h).style('cursor','grab');
    const zoomLayer = svg.append('g').attr('class','zoom-layer');
    let currentTransform = d3.zoomIdentity;
    const zoom = d3.zoom().scaleExtent([0.2,4]).on('zoom', (ev)=>{
        currentTransform = ev.transform; zoomLayer.attr('transform', currentTransform);
    });
    svg.call(zoom).on('dblclick.zoom', null);
    const nodes=[]; const links=[];
    (full.routers||[]).forEach(r=>nodes.push({id:r.node_id, label:r.name, type:'router'}));
    (full.hosts||[]).forEach(hn=>nodes.push({id:hn.node_id, label:hn.name, type:'host'}));
    (full.switches_detail||[]).forEach(sw=>nodes.push({id:sw.switch_id, label:'sw-'+sw.switch_id, type:'switch'}));
    (full.r2r_edges_preview||[]).forEach(e=>links.push({source:e[0], target:e[1], kind:'r2r'}));
    (full.switches_detail||[]).forEach(sw=>{ (sw.hosts||[]).forEach(hid=>links.push({source:sw.switch_id, target:hid, kind:'sw-host'})); links.push({source:sw.router_id, target:sw.switch_id, kind:'r-sw'}); });
    const hr = full.host_router_map || {}; Object.entries(hr).forEach(([hid,rid])=>{ const hIdNum=parseInt(hid,10); if(!links.find(l=>l.kind==='sw-host' && l.target===hIdNum)){ links.push({source:rid, target:hIdNum, kind:'r-host'}); }});
    const sim = d3.forceSimulation(nodes).force('link', d3.forceLink(links).id(d=>d.id).distance(l=> l.kind==='r2r'? 80 : (l.kind==='r-sw'? 60 : 40))).force('charge', d3.forceManyBody().strength(-220)).force('center', d3.forceCenter(w/2,h/2));
    const link = zoomLayer.selectAll('line').data(links).enter().append('line').attr('stroke', l=> l.kind==='r2r'? '#0d6efd': (l.kind==='r-sw'? '#198754':'#999')).attr('stroke-width', l=> l.kind==='r2r'? 2:1.2).attr('stroke-dasharray', l=> l.kind==='r-host'? '3,3': null).attr('opacity', .9);
    const node = zoomLayer.selectAll('g').data(nodes).enter().append('g').call(d3.drag().on('start', dragstarted).on('drag', dragged).on('end', dragended));
    node.append('circle').attr('r', d=> d.type==='router'? 11: (d.type==='switch'? 8:5)).attr('fill', d=> d.type==='router'? '#ff7043': (d.type==='switch'? '#17a2b8': '#ffc107')).attr('stroke','#333').attr('stroke-width',1.1);
    node.append('text').text(d=>d.label).attr('x',12).attr('y',4).attr('font-size','10px');
    node.append('title').text(d=> `${d.label} (${d.type})`);
    sim.on('tick', ()=>{ link.attr('x1', d=>d.source.x).attr('y1', d=>d.source.y).attr('x2', d=>d.target.x).attr('y2', d=>d.target.y); node.attr('transform', d=>`translate(${d.x},${d.y})`); });
    function dragstarted(event,d){ if(!event.active) sim.alphaTarget(.3).restart(); d.fx=d.x; d.fy=d.y; }
    function dragged(event,d){ d.fx=event.x; d.fy=event.y; }
    function dragended(event,d){ if(!event.active) sim.alphaTarget(0); }
    document.getElementById('fpGraphLoading')?.remove();
    document.getElementById('fpGraphResetBtn')?.addEventListener('click', ()=>{ sim.alpha(1).restart(); nodes.forEach(n=>{ n.fx=null; n.fy=null; }); svg.transition().duration(250).call(zoom.transform, d3.zoomIdentity); });
    // Provide wheel zoom hint tooltip (optional) - minimal
    try { container.append('title').text('Scroll / pinch to zoom, drag background to pan, drag nodes to reposition'); } catch(e){}
    svg.on('mousedown', ()=> svg.style('cursor','grabbing'));
    window.addEventListener('mouseup', ()=> svg.style('cursor','grab'));
    document.getElementById('fpGraphPngBtn')?.addEventListener('click', ()=>{ try { const serializer=new XMLSerializer(); const svgStr=serializer.serializeToString(svg.node()); const canvas=document.createElement('canvas'); canvas.width=w*2; canvas.height=h*2; const ctx=canvas.getContext('2d'); const img=new Image(); img.onload=function(){ ctx.fillStyle='#fff'; ctx.fillRect(0,0,canvas.width,canvas.height); ctx.drawImage(img,0,0,canvas.width,canvas.height); canvas.toBlob(b=>{ const a=document.createElement('a'); a.href=URL.createObjectURL(b); a.download='full_preview_graph_'+(full.seed||'na')+'.png'; document.body.appendChild(a); a.click(); a.remove(); setTimeout(()=>URL.revokeObjectURL(a.href),4000); }); }; img.src='data:image/svg+xml;base64,'+btoa(unescape(encodeURIComponent(svgStr))); } catch(e){ console.error('PNG export failed', e); } });
}

// Execute button in Full Preview modal
document.addEventListener('DOMContentLoaded', ()=>{
    const execBtn = document.getElementById('fpExecuteBtn');
    if(execBtn){
        execBtn.addEventListener('click', async ()=>{
            if(!state.result_path || !state.result_path.endsWith('.xml')){
                alert('Save XML before executing.'); return;
            }
            if(!window.confirm('Execute this scenario now? This will start a CORE session.')) return;
            try {
                const form = new FormData(); form.append('xml_path', state.result_path);
                const res = await fetch("{{ url_for('run_cli_async') }}", { method: 'POST', body: form });
                if(!res.ok){ alert('Failed to start execution'); return; }
                const { run_id } = await res.json();
                const logWin = window.open('', '_blank');
                if(logWin){ logWin.document.write('<pre id="log" style="font:11px monospace;white-space:pre-wrap;">Starting...\n</pre>'); }
                const evt = new EventSource('/stream/' + run_id);
                evt.onmessage = ev => { if(logWin && !logWin.closed){ logWin.document.getElementById('log').textContent += (ev.data||'') + '\n'; } };
                evt.addEventListener('end', ()=>{ try{ evt.close(); }catch(e){} });
                (async function poll(){
                    try {
                        const r = await fetch('/run_status/' + run_id);
                        if(!r.ok){ setTimeout(poll, 1200); return; }
                        const data = await r.json();
                        if(!data.done){ setTimeout(poll, 1000); return; }
                        if(data.returncode===0){
                            if(logWin && !logWin.closed){ logWin.document.getElementById('log').textContent += '\nRun complete; redirecting to Reports...'; }
                            setTimeout(()=>{ window.location.href = "{{ url_for('reports_page') }}"; }, 600);
                        } else {
                            if(logWin && !logWin.closed){ logWin.document.getElementById('log').textContent += '\nRun finished with errors (code '+data.returncode+').'; }
                        }
                    } catch(e){ setTimeout(poll, 1500); }
                })();
            } catch(e){ alert('Execution error: '+e); }
        });
    }
});

// Seed clear button
document.addEventListener('DOMContentLoaded', () => {
  const scb = document.getElementById('seedClearBtn');
    // seed clear button removed
});

// ------------- Auto-Save Support for Planning -------------
async function autoSaveXml(){
    return new Promise((resolve, reject) => {
        try {
            // Mirror logic from manual Save XML submission but use fetch
            const scenariosJsonInput = document.getElementById('scenarios_json');
            if(!scenariosJsonInput){ reject('Editor form missing'); return; }
            try { scenariosJsonInput.value = JSON.stringify({ scenarios: state.scenarios }); } catch(e){ reject('Serialize failed'); return; }
            const formData = new FormData();
            formData.append('scenarios_json', scenariosJsonInput.value);
            fetch('/save_xml', { method:'POST', body: formData })
                .then(r=>r.text())
                .then(html => {
                    // Parse returned HTML for updated payload JSON script tag
                    try {
                        const parser = new DOMParser();
                        const doc = parser.parseFromString(html, 'text/html');
                        const payloadScript = doc.querySelector('#payload-data');
                        if(payloadScript){
                            const newPayload = JSON.parse(payloadScript.textContent || 'null');
                            if(newPayload && newPayload.result_path){
                                state.result_path = newPayload.result_path;
                                try { const persisted = JSON.parse(localStorage.getItem('coretg_editor_state')||'{}'); persisted.result_path = state.result_path; localStorage.setItem('coretg_editor_state', JSON.stringify(persisted)); } catch(e){}
                                previewState.xmlSaved = true;
                                updatePlanButtons();
                                resolve();
                                return;
                            }
                        }
                        reject('Could not detect saved XML path in response');
                    } catch(e){ reject(e); }
                })
                .catch(err => reject(err));
        } catch(e){ reject(e); }
    });
}

if (persistedState && !initialPayload?.core && persistedState.core) {
    state.core = persistedState.core;
}
if (persistedState) {
    if (persistedState.core_ok !== undefined) state.core_ok = persistedState.core_ok;
    if (persistedState.core_tested_host !== undefined) state.core_tested_host = persistedState.core_tested_host;
    if (persistedState.core_tested_port !== undefined) state.core_tested_port = persistedState.core_tested_port;
}
let activeIdx = Math.min(Math.max(0, persistedActiveIdx), (state.scenarios.length||1)-1);

function persistEditorState(){
    try {
        localStorage.setItem('coretg_editor_state', JSON.stringify({
            scenarios: state.scenarios,
            result_path: state.result_path || null,
            core: state.core || null,
            core_ok: !!state.core_ok,
            core_tested_host: state.core_tested_host || null,
            core_tested_port: state.core_tested_port || null
        }));
        localStorage.setItem('coretg_active_idx', String(activeIdx||0));
    } catch(e){}
}
// Persist initial merged state so it survives cross-page navigation immediately
persistEditorState();

const dropdownsBySection = {
    'Node Information': ['Server','Workstation','PC','Random'],
    // Added 'Random' entry so user can explicitly request a random routing protocol.
    'Routing': ['RIP','RIPv2','BGP','OSPFv2','OSPFv3','Random'],
    'Services': ['SSH','HTTP','DHCPClient','Random'],
    'Traffic': ['Random','TCP','UDP','CUSTOM'],
    'Events': ['Script Path'],
    'Vulnerabilities': ['Category','Specific','Random'],
    'Segmentation': ['Random','Firewall','NAT','CUSTOM']
};

function render() {
    renderSidebar();
    renderMain();
    // Download link visibility if provided
    // Enable/disable Download XML button based on saved xml path
    const dlBtn = document.getElementById('downloadXmlBtn');
    if (dlBtn) {
        const rp = state.result_path || '';
        if (rp && rp.endsWith('.xml')) { dlBtn.removeAttribute('disabled'); dlBtn.classList.remove('pe-none'); dlBtn.setAttribute('title',''); }
        else { dlBtn.setAttribute('disabled','disabled'); dlBtn.classList.add('pe-none'); dlBtn.setAttribute('title','Save XML first'); }
    }
    // Sync Base Scenario File input with active scenario
    const baseIn = document.getElementById('baseFileInput');
    if (baseIn && state.scenarios.length) {
        const full = state.scenarios[activeIdx]?.base?.filepath || '';
        const baseName = full.split(/[/\\]/).pop();
        if (baseIn.value !== baseName) baseIn.value = baseName;
        // Read-only display: no input handler needed to modify state
    }
}

function renderSidebar() {
    const list = document.getElementById('scenarioList');
    list.innerHTML = '';
    state.scenarios.forEach((scen, idx) => {
        const a = document.createElement('a');
    a.href = '#';
    a.className = 'list-group-item list-group-item-action' + (idx === activeIdx ? ' active bg-primary text-white' : '');
        a.textContent = scen.name || `Scenario ${idx+1}`;
    a.onclick = (e) => { e.preventDefault(); activeIdx = idx; persistEditorState(); render(); };
        list.appendChild(a);
    });
            const appendScenarioBtn = document.getElementById('appendScenarioBtn');
            const importBtn = document.getElementById('importBtn');
            const exportBtn = document.getElementById('exportBtn');
        const hiddenLoadInput = document.getElementById('hiddenLoadInput');
        const hiddenLoadForm = document.getElementById('hiddenLoadForm');
            if (appendScenarioBtn) appendScenarioBtn.onclick = (e) => { e.preventDefault(); logInfo('New scenario created'); state.scenarios.push(defaultScenario()); activeIdx = state.scenarios.length - 1; persistEditorState(); try { previewState.dirty = true; updatePlanButtons(); } catch(e){} render(); };
            if (importBtn) importBtn.onclick = (e) => { e.preventDefault(); logInfo('Import scenarios clicked'); hiddenLoadInput.click(); };
    if (hiddenLoadInput) hiddenLoadInput.onchange = () => { if (hiddenLoadInput.files && hiddenLoadInput.files.length > 0) { saveScrollBeforeNav(); hiddenLoadForm.submit(); } };
            if (exportBtn) exportBtn.onclick = (e) => {
                e.preventDefault();
                logInfo('Export clicked');
                const rp = state.result_path || '';
                if (!rp.endsWith('.xml')) {
                    logWarn('Export blocked: no saved XML');
                    alert('Please Save XML first (middle panel) to export the current scenarios.');
                    return;
                }
                window.location.href = window.location.origin + '/download_report?path=' + encodeURIComponent(rp);
            };
}

function renderMain() {
    const root = document.getElementById('editorRoot');
    root.innerHTML = '';
    if (!state.scenarios.length) { return; }
    const scen = state.scenarios[activeIdx] || state.scenarios[0];
    // --- Host density normalization for Node Information ---
    try {
        const ni = scen.sections && scen.sections['Node Information'];
        if (ni) {
            ni.items = ni.items || [];
            // Ensure at least one weight row (Random) exists for fallback if all removed
            let randomRow = ni.items.find(it => !(it.v_metric==='Count') && (it.selected||'').toLowerCase()==='random');
            if (!randomRow) {
                // Add with temporary factor 0 (will be set if needed)
                ni.items.unshift({ selected:'Random', factor: 0.0 });
                randomRow = ni.items[0];
            }
            // Mark the first Random weight row as protected residual; unmark any other Random weight rows
            randomRow._protected_random = true;
            ni.items.forEach(it => {
                if (it !== randomRow && (it.v_metric !== 'Count') && ((it.selected||'').toLowerCase()==='random')) {
                    if (it._protected_random) delete it._protected_random;
                }
            });
            const weightRows = ni.items.filter(it => !(it.v_metric==='Count'));
            weightRows.forEach(it => { let f = parseFloat(it.factor); if (isNaN(f) || f < 0) f = 0; it.factor = f; });
            // Sum excluding Random for decision
            const nonRandom = weightRows.filter(it => (it.selected||'').toLowerCase()!=='random');
            let nonRandomSum = nonRandom.reduce((a,b)=> a + (parseFloat(b.factor)||0), 0);
            if (nonRandom.length === 0) {
                // Only Random exists; set to 1.0
                randomRow.factor = 1.0; nonRandomSum = 0;
            } else {
                if (nonRandomSum >= 1.0) {
                    randomRow.factor = 0.0; // others define full density
                } else {
                    randomRow.factor = 1.0 - nonRandomSum;
                }
            }
            // Final normalization (should already sum to 1.0)
            const finalSum = weightRows.reduce((a,b)=> a + (parseFloat(b.factor)||0), 0);
            if (Math.abs(finalSum - 1.0) > 1e-6 && finalSum > 0) {
                // scale all
                weightRows.forEach(it => { it.factor = (parseFloat(it.factor)||0)/finalSum; });
            }
        }
    } catch(e) { console.warn('Normalization error', e); }
    // Load persisted section collapse state (per scenario + section)
    let collapseState = {};
    try { collapseState = JSON.parse(localStorage.getItem('sectionCollapseState') || '{}'); } catch(e) { collapseState = {}; }
    // No auto-insertion of Count rows for Node Information; totals should only include user-added Count rows
    // Scenario header with Count for Density (base host pool) restored
    const niSec = scen.sections['Node Information'] || { items: [] };
    const niItems = niSec.items || [];
    const niWeightRows = niItems.filter(it => (it.v_metric || (it.selected==='Specific'?'Count':'Weight')) === 'Weight');
    const niCountRows = niItems.filter(it => (it.v_metric || (it.selected==='Specific'?'Count':'Weight')) === 'Count');
    // Base removed: host total now purely additive Count rows when no base; or proportional part is implied but base count is scenario-level (not editable here)
    let densityCountVal = 10;
    try {
        if (scen.density_count !== undefined && scen.density_count !== null && scen.density_count !== '') {
            const parsed = parseInt(scen.density_count, 10);
            if (!isNaN(parsed)) densityCountVal = parsed;
        }
    } catch(e) { densityCountVal = 10; }
    if (densityCountVal < 0) densityCountVal = 0;
    const niBase = densityCountVal;
    const niAdd = niCountRows.reduce((a,it)=> a + (parseInt(it.v_count,10)||0), 0);
    const niTotal = niBase + niAdd;
    const niTitle = 'Hosts = Base (Count for Density) allocated by weight rows + additive Count rows';
    // Build allocation breakdown tooltip for weight rows
    let allocTip = niTitle;
    if (niWeightRows.length) {
        const wTotal = niWeightRows.reduce((a,it)=> a + (parseFloat(it.factor)||0), 0) || 0;
        if (wTotal > 0) {
            const parts = niWeightRows.map(it => {
                const f = parseFloat(it.factor)||0;
                const pct = wTotal ? ((f / wTotal) * 100).toFixed(1) : '0.0';
                const label = (it.selected || 'Row');
                return `${label}:${f}(${pct}%)`;
            });
            allocTip += ' | Weights: ' + parts.join(', ');
        }
    }
    const hostBadgeClass = (niWeightRows.length && niBase === 0 && niAdd > 0) ? 'text-bg-warning' : 'text-bg-primary';
    // Simplified host summary: remove ΣW badge, allocation popover, and auto-scale functionality
    const hostSummaryHtml = `<span class=\"badge rounded-pill ${hostBadgeClass} host-total-badge\" data-bs-toggle=\"tooltip\" title=\"${allocTip.replace(/"/g,'&quot;')}\">Hosts: ${niWeightRows.length ? (niBase + ' + ' + niAdd + ' = ' + niTotal) : (niAdd)}</span>`;
    const densityBaseHtml = `<div class=\"d-flex align-items-center gap-1\" title=\"Base host pool used only for weight-based density calculations; Count rows are additive beyond this.\"><label class=\"form-label mb-0\">Count for Density</label><input type=\"number\" min=\"0\" max=\"5000\" step=\"1\" class=\"form-control form-control-sm\" style=\"width:120px\" value=\"${densityCountVal}\" data-scen-idx=\"${activeIdx}\" data-field=\"scenario_density_count\" /></div>`;
    const headerRow = document.createElement('div');
    headerRow.className = 'mb-3 d-flex flex-wrap gap-3 align-items-center';
    headerRow.innerHTML = `
        <div class=\"d-flex align-items-center gap-2\">
            <strong>Scenario:</strong>
            <input class=\"form-control form-control-sm\" style=\"width:260px\" value=\"${scen.name}\" data-scen-idx=\"${activeIdx}\" data-field=\"name\" />
        </div>
        <div class=\"d-flex align-items-center gap-2 flex-wrap\">
            ${densityBaseHtml}
            ${hostSummaryHtml}
        </div>
        <div class=\"ms-auto d-flex gap-2\">
            <button type=\"button\" class=\"btn btn-sm btn-outline-secondary\" data-action=\"preview-plan\">Export Preview</button>
            <button type=\"button\" class=\"btn btn-sm btn-outline-danger\" data-action=\"remove-scenario\" data-scen-idx=\"${activeIdx}\">Remove</button>
        </div>`;
    root.appendChild(headerRow);

    // Section cards (Node Information first)
    const secNames = ['Node Information','Routing','Services','Traffic','Events','Vulnerabilities','Segmentation'];
    // Compute base host pool (non-router/docker). Routers/Docker added later should not change this base count.
    const baseNodeSec = scen.sections['Node Information'] || { items: [] };
    const baseNodeItems = baseNodeSec.items || [];
    const baseNodeRows = baseNodeItems.map(it => ({ metric: (it.v_metric || (it.selected==='Specific'?'Count':'Weight')), it }));
    const baseWeightRows = baseNodeRows.filter(r => r.metric === 'Weight');
    const baseCountRows = baseNodeRows.filter(r => r.metric === 'Count');
    const baseCountSum = baseCountRows.reduce((a,r)=> a + (parseInt(r.it.v_count,10)||0), 0);
    // Base host pool for density-driven (weight) allocations comes from scenario.density_count
    const baseHostPool = (scen.density_count !== undefined && scen.density_count !== null && scen.density_count !== '' ? (parseInt(scen.density_count,10)||0) : 10);
    secNames.forEach(name => {
        const sec = scen.sections[name] || { items: [] };
    const hasNodes = (name === 'Node Information');
        const itemCount = (sec.items || []).length;
        // Determine if any weight rows exist in this section (used for Node Information behavior)
        const hasWeightRowsPre = hasNodes ? ((sec.items || []).some(it => ((it.v_metric || (it.selected==='Specific'? 'Count' : 'Weight')) === 'Weight'))) : false;
        // Always ensure density has a sensible default value
        if (!hasNodes) {
            if (sec.density === undefined || sec.density === null || isNaN(sec.density)) {
                sec.density = 0.5;
            }
        }
        const densVal = sec.density;
        const nodesVal = '';
        const extraNodeCount = hasNodes ? ((sec.items || []).reduce((acc, it) => {
            const metric = it.v_metric || (it.selected==='Specific'?'Count':'Weight');
            return acc + (metric === 'Count' ? (parseInt(it.v_count) || 0) : 0);
        }, 0)) : 0;
    const hasWeightRows = hasNodes ? hasWeightRowsPre : false;
    const totalNodeCount = hasNodes ? extraNodeCount : 0;
    const totalNodesLabel = hasNodes ? (totalNodeCount === 1 ? 'Total Node' : 'Total Nodes') : '';
    // Define totalPlanned (was previously referenced but never declared, causing a ReferenceError that prevented section rendering)
    const totalPlanned = hasNodes ? totalNodeCount : 0;
        // Improved initial collapse behavior:
        // - Always expand Node Information (primary planning surface)
        // - Other sections start collapsed only if empty
        let collapsed;
        if (name === 'Node Information') collapsed = false; else collapsed = (itemCount === 0);
        // Override with persisted state if present
        const collapseKey = `${activeIdx}::${name}`;
        if (collapseState.hasOwnProperty(collapseKey)) {
            collapsed = !!collapseState[collapseKey];
        }
        const card = document.createElement('div');
        card.className = 'card mb-3';
        const collapseId = `collapse-${name.replace(/\s+/g,'-')}`;
        const iconHtml = itemCount > 0
            ? `<i class='bi bi-collection-fill text-success' data-bs-toggle="tooltip" data-bs-title="${itemCount} item(s)"></i>`
            : `<i class='bi bi-collection text-muted' data-bs-toggle="tooltip" data-bs-title="No items"></i>`;
        // Enhanced tooltip text clarifying how combined total is derived.
        const totalNodesTooltip = hasNodes ? 'Combined total = (sum of all Count-based row counts) + (Total Nodes if any Weight-based rows exist). Weight rows allocate Total Nodes by their weights; Count rows are absolute and do not affect weights.' : '';
        // Compute planned badges (hosts / routers / vulns) for this section
        let hostBadge = '';
        if (name === 'Node Information') {
            const basePart = hasWeightRows ? (parseInt(nodesVal) || 0) : 0;
            const additivePart = extraNodeCount;
            const title = hasWeightRows
                ? 'Hosts total = Base (Total Nodes) allocated across weight rows + additive Count rows'
                : 'Hosts total = Sum of Count rows (no weight rows present)';
            if ((basePart + additivePart) > 0) {
                if (hasWeightRows) {
                    hostBadge = `<span class=\"badge rounded-pill text-bg-primary ms-2\" title=\"${title.replace(/"/g,'&quot;')}\">Hosts: ${basePart} + ${additivePart} = ${totalNodeCount}</span>`;
                } else {
                    hostBadge = `<span class=\"badge rounded-pill text-bg-primary ms-2\" title=\"${title.replace(/"/g,'&quot;')}\">Hosts: ${additivePart}</span>`;
                }
            }
        }
        let routingBadge = '';
        if (name === 'Routing') {
            const rItems = sec.items || [];
            const rRows = rItems.map(it => ({ metric: (it.v_metric || 'Weight'), it }));
            const rCountRows = rRows.filter(r => r.metric === 'Count');
            const rWeightRows = rRows.filter(r => r.metric === 'Weight');
            const densR = (typeof sec.density === 'number') ? sec.density : 0;
            const explicit = rCountRows.reduce((a,r)=> a + (parseInt(r.it.v_count,10)||0), 0);
            let derived = 0;
            if (rWeightRows.length && densR > 0) {
                const frac = Math.max(0, Math.min(1, densR));
                derived = Math.round(baseHostPool * frac);
            }
            const total = explicit + derived;
            if (total > 0) routingBadge = `<span class=\"badge rounded-pill text-bg-secondary ms-2\" title=\"Routers planned additively: Count rows + (Density * Base Hosts). Density constrained 0..1.\">Routers: ${total}</span>`;
        }
        let vulnBadge = '';
        if (name === 'Vulnerabilities') {
            const vItems = sec.items || [];
            const vRows = vItems.map(it => ({ metric: (it.v_metric || (it.selected==='Specific'?'Count':'Weight')), it }));
            const vCountRows = vRows.filter(r => r.metric === 'Count');
            const vWeightRows = vRows.filter(r => r.metric === 'Weight');
            const densV = (typeof sec.density === 'number') ? sec.density : 0;
            const explicit = vCountRows.reduce((a,r)=> a + (parseInt(r.it.v_count,10)||0), 0);
            let derived = 0;
            if (vWeightRows.length && densV > 0) derived = Math.round(baseHostPool * Math.min(1, densV));
            const total = explicit + derived;
            if (total > 0) vulnBadge = `<span class=\"badge rounded-pill text-bg-info ms-2\" title=\"Vulnerability assignments additive: Count rows + (Density * Base Hosts). Density clipped to 1.0 when fractional.\">Vulns: ${total}</span>`;
        }
    const badgeSpan = hostBadge + routingBadge + vulnBadge;
        card.innerHTML = `
            <div class=\"card-header d-flex align-items-center gap-2\">
                ${iconHtml}
                <strong>${name}</strong>${badgeSpan}
                <div class=\"ms-auto d-flex gap-2\">
                    <button class=\"btn btn-sm btn-outline-primary\" data-action=\"add-item\" data-scen-idx=\"${activeIdx}\" data-sec=\"${name}\">Add</button>
                    <button class=\"btn btn-sm btn-outline-secondary\" type=\"button\" data-action=\"toggle-collapse\" data-target=\"#${collapseId}\">${collapsed ? 'Expand' : 'Collapse'}</button>
                </div>
            </div>
            <div id=\"${collapseId}\" class=\"card-body\" style=\"display:${collapsed ? 'none':'block'};\">
                                <div class="table-responsive">
                                                                                <table class="table table-sm align-middle">
                                                                                        <thead>
                                                                                            <tr>
                                                                                                <th style="width:280px"></th>
                                                                                                <th></th>
                                                                                                <th style="width:160px"></th>
                                                                                                <th style="width:80px"></th>
                                                                                            </tr>
                                                                                        </thead>
                                                                    <tbody>
                                                                                ${(() => {
                                                                                const items = sec.items || [];
                                                                                const rowsByMetric = items.map((it, iidx) => ({ it, iidx, metric: (it.v_metric || (name==='Vulnerabilities' && (it.selected||'Category')==='Specific' ? 'Count' : 'Weight')) }));
                                                                                const weights = rowsByMetric.filter(x => x.metric === 'Weight');
                                                                                const counts = rowsByMetric.filter(x => x.metric === 'Count');
                                                                                // If there are no remaining weight rows but a stale total_nodes exists, clear it (frontend-only cleanup)
                                                                                if (name === 'Node Information' && weights.length === 0) {
                                                                                    const secRef = state.scenarios[activeIdx].sections[name];
                                                                                    if (secRef && secRef.total_nodes) { secRef.total_nodes = 0; }
                                                                                }
                                                                                const parts = [];
                                                                                const showWeightHeader = (weights.length > 0);
                                        if (showWeightHeader) {
                                                                                    const densCtrl = (
                                                                                        name === 'Node Information'
                                                                                            ? `<div class=\"d-flex align-items-center justify-content-end gap-2 small text-muted\"><span>Density</span><input disabled class=\"form-control form-control-sm\" style=\"width:80px\" value=\"1.0\"></div>`
                                                                                                : (name === 'Routing'
                                                                                                                                                                                                ? `<div class=\"d-flex align-items-center justify-content-end gap-2\">`
                                                                                                                                                                                                        + `<span>Density</span>`
                                                                                                                                                                                                        + `<input type=\"number\" step=\"0.01\" min=\"0\" max=\"1\" class=\"form-control form-control-sm\" style=\"width:120px\" placeholder=\"e.g., 0.25\" value=\"${densVal}\" data-scen-idx=\"${activeIdx}\" data-sec=\"${name}\" data-field=\"density\">`
                                                                                                                                                                                                    + `</div>`
                                                                                                                                                                                                : (() => {
                                                                                                                                                                                                    const tooltip = (name === 'Services')
                                                                                                                                                                                                        ? 'Services: per-item Count overrides density; assigns exactly that many hosts the selected service.'
                                                                                                                                                                                                        : (name === 'Traffic')
                                                                                                                                                                                                            ? 'Traffic: per-item Count overrides density; creates exactly that many sender/receiver pairs.'
                                                                                                                                                                                                            : (name === 'Segmentation')
                                                                                                                                                                                                                ? 'Segmentation: per-item Count overrides density; plans exactly that many slots (NAT prioritized).'
                                                                                                                                                                                                                : '';
                                                                                                                                                                                                    let info = '';
                                                                                                                                                                                                    // Density tooltip removed
                                                                                                                                                                                                    return '<div class="d-flex align-items-center justify-content-end gap-2">'
                                                                                                                                                                                                        + '<span>Density</span>'
                                                                                                                                                                                                        + info
                                                                                                                                                                                                        + '<input type="number" step="0.01" min="0" max="1" class="form-control form-control-sm" style="width:100px" value="' + densVal + '" data-scen-idx="' + activeIdx + '" data-sec="' + name + '" data-field="density">'
                                                                                                                                                                                                    + '</div>';
                                                                                                                                                                                                })()
                                                                                                                                                                                            )
                                                                                                                                                                        );
                                                                                    parts.push(`<tr class=\"table-light\"><td colspan=\"2\"><strong>Weight-based</strong></td><td class=\"text-end\">${densCtrl}</td><td></td></tr>`);
                                                                                    if (weights.length) { parts.push(weights.map(x => renderItemRow(activeIdx, name, x.iidx, x.it)).join('')); }
                                                                                }
                                                                                if (counts.length) {
                                                                                    const countHdr = (name === 'Node Information') ? 'Count-based' : 'Count-based';
                                                                                    parts.push(`<tr class=\"table-light\"><td colspan=\"4\"><strong>${countHdr}</strong></td></tr>`);
                                                                                    parts.push(counts.map(x => renderItemRow(activeIdx, name, x.iidx, x.it)).join(''));
                                                                                }
                                                                                return parts.join('');
                                                                            })()}
                                                                    </tbody>
                    </table>
                </div>
                                        <div class="text-danger small mt-1 section-warning" data-scen-idx="${activeIdx}" data-sec="${name}" style="display:none">Weights must sum to 1.000</div>
                                        ${name==='Routing' ? `
                                        <div id="routingEdgesWarnings" class="alert alert-warning py-2 px-3 small mt-3 d-none"></div>
                                        <div class="d-flex flex-wrap align-items-center gap-3 mt-3 small" id="routingEdgesSummary" style="display:none;">
                                                <div><strong>Policy:</strong> <span data-role="edges-policy">(pending)</span></div>
                                        </div>
                                        ` : ''}
            </div>`;
        root.appendChild(card);
    });
    // Apply visibility rule: show H/S bounds only for R-to-S NonUniform mode
    try {
        document.querySelectorAll('[data-field="r2s_mode"]').forEach(selEl => {
            const modeVal = selEl.value;
            const wrapper = selEl.closest('.routing-edge-groups')?.querySelector('.hs-bounds-wrapper');
            if (wrapper) {
                if (modeVal === 'NonUniform') { wrapper.classList.add('hs-show'); } else { wrapper.classList.remove('hs-show'); }
            }
        });
    } catch(e) { /* ignore */ }
        // activate tooltips for icons
        if(window.bootstrap){
            const tts = root.querySelectorAll('[data-bs-toggle="tooltip"]');
            tts.forEach(el => new bootstrap.Tooltip(el));
        }

    // Notes card (collapsible, collapsed by default)
    const notesCard = document.createElement('div');
    notesCard.className = 'card mb-3';
    const hasNotes = (scen.notes||'').trim().length>0;
    const collapseId = `notesCollapse_${activeIdx}`;
    notesCard.innerHTML = `
        <div class="card-header d-flex justify-content-between align-items-center">
            <button class="btn btn-sm btn-link text-decoration-none p-0 d-flex align-items-center gap-2" type="button" data-bs-toggle="collapse" data-bs-target="#${collapseId}" aria-expanded="false" aria-controls="${collapseId}">
                <span class="me-1">Notes</span>
                <span id="notesIndicator_${activeIdx}" class="d-inline-flex align-items-center" data-bs-toggle="tooltip" data-bs-title="${hasNotes? 'Notes present':'No notes'}">
                    ${hasNotes ? `<i class='bi bi-journal-text text-success'></i>` : `<i class='bi bi-journal text-muted'></i>`}
                </span>
            </button>
            <small class="text-muted">optional</small>
        </div>
        <div id="${collapseId}" class="collapse">
            <div class="card-body p-2">
                <textarea class="form-control" rows="3" data-scen-idx="${activeIdx}" data-field="notes" placeholder="Add scenario notes (markdown supported)">${scen.notes || ''}</textarea>
            </div>
        </div>`;
    root.appendChild(notesCard);

    wireHandlers();
    wireCoreControls();
    // Populate dynamic vuln selects after DOM paint
    populateVulnSelects();
    // Hook up Specific picker buttons
    document.querySelectorAll('[data-action="pick-specific"]').forEach(btn => {
        const handler = () => {
            const sidx = parseInt(btn.getAttribute('data-scen-idx'));
            const sec = btn.getAttribute('data-sec');
            const iidx = parseInt(btn.getAttribute('data-item-idx'));
            openVulnPicker(sidx, sec, iidx);
        };
        // Attach the click handler (fix: previously not wired)
        btn.addEventListener('click', handler);
    });
}

// renderSections was deprecated and removed; rendering is handled in renderMain()
function renderItemRow(sidx, secName, iidx, it) {
    // Build Selected options and current weight
    const weight = ((parseFloat(it.factor) || 0).toFixed(3));
    let opts = '';
    if (secName === 'Vulnerabilities') {
        const cur = it.selected || 'Category';
        const options = ['Category', 'Specific', 'Random'];
        opts = options.map(o => `<option ${o===cur?'selected':''}>${o}</option>`).join('');
    } else {
        const cur = it.selected || 'Random';
        // Per-section allowed options (excluding 'auto')
        let options = ['Random'];
        switch (secName) {
            case 'Node Information':
                options = ['Server', 'Workstation', 'PC', 'Random'];
                break;
            case 'Routing':
                options = ['RIP', 'RIPv2', 'BGP', 'OSPFv2', 'OSPFv3', 'Random'];
                break;
            case 'Services':
                options = ['SSH', 'HTTP', 'DHCPClient', 'Random'];
                break;
            case 'Traffic':
                options = ['Random', 'TCP', 'UDP', 'CUSTOM'];
                break;
            case 'Events':
                options = ['Script Path'];
                break;
            case 'Segmentation':
                options = ['Random', 'Firewall', 'NAT', 'CUSTOM'];
                break;
            default:
                options = ['Random'];
        }
        opts = options.map(o => `<option ${o===cur?'selected':''}>${o}</option>`).join('');
    }

    const extras = (() => {
        if (secName === 'Events') {
            return `<input class="form-control form-control-sm" placeholder="script path" value="${it.script_path || ''}" data-scen-idx="${sidx}" data-sec="${secName}" data-item-idx="${iidx}" data-field="script_path">`;
        }
        if (secName === 'Routing') {
            // Edges mode (Random/Min/Max/Exact). Random now acts like previous Auto (no extra links augmentation).
            const mode = it.r2r_mode || (it.r2r_edges !== undefined ? 'Exact' : 'Random');
            const val = (it.r2r_edges !== undefined && it.r2r_edges !== null) ? it.r2r_edges : '';
            const options = [
                {v:'Random', l:'Random'},
                {v:'Min', l:'Min'},
                {v:'Uniform', l:'Uniform'},
                {v:'Exact', l:'Exact'},
                {v:'NonUniform', l:'NonUniform'}
            ];
            const selHtml = `<select class="form-select form-select-sm routing-mode-select" style="width:105px" data-field="r2r_mode" data-scen-idx="${sidx}" data-sec="${secName}" data-item-idx="${iidx}">${options.map(o => `<option value="${o.v}" ${o.v===mode?'selected':''}>${o.l}</option>`).join('')}</select>`;
            // R-to-S (router to switch) connectivity policy (same option set)
            const r2sMode = it.r2s_mode || 'Random';
            const r2sVal = (it.r2s_edges !== undefined && it.r2s_edges !== null) ? it.r2s_edges : '';
            const r2sSel = `<select class="form-select form-select-sm routing-mode-select" style="width:105px" data-field="r2s_mode" data-scen-idx="${sidx}" data-sec="${secName}" data-item-idx="${iidx}">${options.map(o => `<option value="${o.v}" ${o.v===r2sMode?'selected':''}>${o.l}</option>`).join('')}</select>`;
            const r2sHostsMin = (it.r2s_hosts_min !== undefined && it.r2s_hosts_min !== null) ? it.r2s_hosts_min : 1;
            const r2sHostsMax = (it.r2s_hosts_max !== undefined && it.r2s_hosts_max !== null) ? it.r2s_hosts_max : 4;
            const showHsBounds = (r2sMode === 'NonUniform');
            return `
                <div class="d-flex flex-column gap-1 routing-edge-groups">
                    <div class="d-flex flex-wrap gap-2 align-items-center">
                        <label class="form-label mb-0 me-1" style="min-width:110px" title="Router-to-Router edge policy. Random = spanning tree; Min = chain; Uniform = balanced degrees; Exact = chain+augment to target; NonUniform = heterogeneous.">R-to-R Edges</label>
                        <div class="d-flex gap-3 align-items-end">
                            <div>${selHtml}</div>
                            <div class="edges-exact-input" style="display:${mode==='Exact'?'block':'none'};">
                                <input type="number" min="1" class="form-control form-control-sm edges-degree-input" style="width:110px" value="${val}" data-field="r2r_edges" data-scen-idx="${sidx}" data-sec="${secName}" data-item-idx="${iidx}" placeholder="Exact (e.g. 3)" aria-label="Exact router degree target" title="Target degree each router should attempt to reach (cannot reduce existing higher degrees).">
                            </div>
                        </div>
                    </div>
                    <div class="d-flex flex-wrap gap-2 align-items-center">
                        <label class="form-label mb-0 me-1" style="min-width:110px" title="Router-to-Switch attachment policy; controls how many distinct switches each router connects to.">R-to-S Edges</label>
                        <div class="d-flex gap-3 align-items-end flex-wrap align-items-center">
                            <div>${r2sSel}</div>
                            <div class="r2s-exact-input" style="display:${r2sMode==='Exact'?'block':'none'};">
                                <input type="number" min="1" class="form-control form-control-sm r2s-degree-input" style="width:110px" value="${r2sVal}" data-field="r2s_edges" data-scen-idx="${sidx}" data-sec="${secName}" data-item-idx="${iidx}" placeholder="Exact (e.g. 2)" aria-label="Exact router-to-switch target" title="Target number of switches per router (Exact mode).">
                            </div>
                            <div class="gap-2 align-items-end small hs-bounds-wrapper">
                                <div>
                                    <label class="form-label mb-0" style="font-size:0.7rem" title="Minimum hosts per created switch for this router row (preview & build).">H/S Min</label>
                                    <input type="number" min="1" max="32" class="form-control form-control-sm hs-min-input" style="width:70px" value="${r2sHostsMin}" data-field="r2s_hosts_min" data-scen-idx="${sidx}" data-sec="${secName}" data-item-idx="${iidx}" placeholder="min">
                                </div>
                                <div>
                                    <label class="form-label mb-0" style="font-size:0.7rem" title="Maximum hosts per created switch for this router row (preview & build).">H/S Max</label>
                                    <input type="number" min="1" max="64" class="form-control form-control-sm hs-max-input" style="width:70px" value="${r2sHostsMax}" data-field="r2s_hosts_max" data-scen-idx="${sidx}" data-sec="${secName}" data-item-idx="${iidx}" placeholder="max">
                                </div>
                            </div>
                        </div>
                    </div>
                </div>`;
        }
        if (secName === 'Traffic') {
            return `
                <div class="d-flex flex-wrap gap-2">
                    <div>
                        <label class="form-label mb-0">Payload</label>
                        <select class="form-select form-select-sm" data-field="content_type" data-scen-idx="${sidx}" data-sec="${secName}" data-item-idx="${iidx}">
                            ${['Random','text','photo','audio','video','gibberish'].map(ct => `<option value="${ct}" ${((it.content_type||'Random')===ct)?'selected':''}>${ct}</option>`).join('')}
                        </select>
                    </div>
                    <div class="traffic-config" style="display:${((it.content_type||'Random')==='Random')?'none':'block'};">
                        <label class="form-label mb-0">Pattern</label>
                        <select class="form-select form-select-sm" data-field="pattern" data-scen-idx="${sidx}" data-sec="${secName}" data-item-idx="${iidx}">
                            ${['continuous','periodic','burst','poisson','ramp'].map(p => `<option ${((it.pattern||'')===p)?'selected':''}>${p}</option>`).join('')}
                        </select>
                    </div>
                    <div class="traffic-config" style="display:${((it.content_type||'Random')==='Random')?'none':'block'};">
                        <label class="form-label mb-0">Rate (kbps)</label>
                        <input type="number" step="0.1" class="form-control form-control-sm" value="${it.rate_kbps ?? 64.0}" data-field="rate_kbps" data-scen-idx="${sidx}" data-sec="${secName}" data-item-idx="${iidx}">
                    </div>
                    <div class="traffic-config" style="display:${((it.content_type||'Random')==='Random')?'none':'block'};">
                        <label class="form-label mb-0">Period (s)</label>
                        <input type="number" step="0.1" class="form-control form-control-sm" value="${it.period_s ?? 1.0}" data-field="period_s" data-scen-idx="${sidx}" data-sec="${secName}" data-item-idx="${iidx}">
                    </div>
                    <div class="traffic-config" style="display:${((it.content_type||'Random')==='Random')?'none':'block'};">
                        <label class="form-label mb-0">Jitter (%)</label>
                        <input type="number" step="0.1" class="form-control form-control-sm" value="${it.jitter_pct ?? 10.0}" data-field="jitter_pct" data-scen-idx="${sidx}" data-sec="${secName}" data-item-idx="${iidx}">
                    </div>
                </div>`;
        }
        if (secName === 'Vulnerabilities') {
            const mode = it.selected || 'Type/Vector';
            if (mode === 'Specific') {
                const nm = it.v_name || '';
                // Try to obtain full description (prefer stored v_desc, else look up in catalog)
                let fullDesc = it.v_desc || '';
                if (!fullDesc && nm && window.VULN_CATALOG && Array.isArray(window.VULN_CATALOG.items)) {
                    const match = window.VULN_CATALOG.items.find(x => x.Name === nm && (!it.v_path || x.Path === it.v_path));
                    if (match && match.Description) { fullDesc = match.Description; }
                }
                const abbr = (s, n=80) => (s && s.length > n ? (s.slice(0, n-1) + '…') : (s||''));
                const esc = (s) => (s||'')
                    .replace(/&/g,'&amp;')
                    .replace(/</g,'&lt;')
                    .replace(/>/g,'&gt;')
                    .replace(/"/g,'&quot;')
                    .replace(/'/g,'&#39;');
                const descShort = abbr(fullDesc);
                const centerText = nm ? `${nm}${descShort ? ' — ' + descShort : ''}` : '<span class="text-muted">No selection</span>';
                return `<span class="small" ${fullDesc ? `data-bs-toggle="tooltip" data-bs-title="${esc(fullDesc)}"` : ''}>${centerText}</span>`;
            }
            return '';
        }
        return '';
    })();
    // Build first cell content, optionally augmenting Selected with Vulnerabilities controls
    const firstCell = (() => {
        const isProtectedRandom = (secName === 'Node Information') && ((it.selected||'').toLowerCase()==='random') && it._protected_random;
        const disabledAttr = isProtectedRandom ? 'disabled title="Residual Random row is auto-managed"' : '';
        const selectedCtl = `<select class="form-select form-select-sm" ${disabledAttr} data-field="selected" data-scen-idx="${sidx}" data-sec="${secName}" data-item-idx="${iidx}">${opts}</select>`;
        if (secName !== 'Vulnerabilities') return selectedCtl;
    const mode = it.selected || 'Category';
    if (mode === 'Category') {
            return `
            <div class="d-flex flex-wrap gap-2 align-items-end">
                <div style="min-width:160px">${selectedCtl}</div>
                <div>
                    <label class="form-label mb-0">Type</label>
                    <select class="form-select form-select-sm vuln-type" data-field="v_type" data-scen-idx="${sidx}" data-sec="${secName}" data-item-idx="${iidx}"></select>
                </div>
                <div>
                    <label class="form-label mb-0">Vector</label>
                    <select class="form-select form-select-sm vuln-vector" data-field="v_vector" data-scen-idx="${sidx}" data-sec="${secName}" data-item-idx="${iidx}"></select>
                </div>
            </div>`;
        } else if (mode === 'Specific') {
            const nm = it.v_name || '';
            // Try to obtain full description (prefer stored v_desc, else look up in catalog)
            let fullDesc = it.v_desc || '';
            if (!fullDesc && nm && window.VULN_CATALOG && Array.isArray(window.VULN_CATALOG.items)) {
                const match = window.VULN_CATALOG.items.find(x => x.Name === nm && (!it.v_path || x.Path === it.v_path));
                if (match && match.Description) { fullDesc = match.Description; }
            }
            const abbr = (s, n=80) => (s && s.length > n ? (s.slice(0, n-1) + '…') : (s||''));
            const esc = (s) => (s||'')
                .replace(/&/g,'&amp;')
                .replace(/</g,'&lt;')
                .replace(/>/g,'&gt;')
                .replace(/"/g,'&quot;')
                .replace(/'/g,'&#39;');
            const descShort = abbr(fullDesc);
            return `
            <div class="d-flex flex-wrap gap-2 align-items-center">
                <div style="min-width:160px">${selectedCtl}</div>
                <button type="button" class="btn btn-sm btn-outline-primary" data-action="pick-specific" data-scen-idx="${sidx}" data-sec="${secName}" data-item-idx="${iidx}">Choose...</button>
            </div>`;
        }
        return selectedCtl;
    })();
    // Right-most: Weight or Count cell
    const weightCell = (() => {
        if (secName === 'Vulnerabilities') {
            const mode = it.selected || 'Type/Vector';
            const metric = it.v_metric || (mode === 'Specific' ? 'Count' : 'Weight');
            const metricSel = `<select class="form-select form-select-sm" style="min-width: 140px" data-field="v_metric" data-scen-idx="${sidx}" data-sec="${secName}" data-item-idx="${iidx}"><option ${metric==='Weight'?'selected':''}>Weight</option><option ${metric==='Count'?'selected':''}>Count</option></select>`;
            if (metric === 'Count') {
                const count = (parseInt(it.v_count, 10) || 1);
                return `<div class="d-flex gap-2">${metricSel}<select class="form-select form-select-sm" style="min-width: 120px" data-field="v_count" data-scen-idx="${sidx}" data-sec="${secName}" data-item-idx="${iidx}">${Array.from({length:10},(_,k)=>k+1).map(n=>`<option ${n===count?'selected':''}>${n}</option>`).join('')}</select></div>`;
            }
            return `<div class="d-flex gap-2">${metricSel}<input type="number" step="0.01" min="0" max="1" class="form-control form-control-sm weight-input" style="min-width: 120px" value="${weight}" data-field="factor" data-scen-idx="${sidx}" data-sec="${secName}" data-item-idx="${iidx}"></div>`;
        }
        // For all other sections, provide a Count/Weight selector as well
        const metric = it.v_metric || 'Weight';
        const metricSel = `<select class="form-select form-select-sm" style="min-width: 140px" data-field="v_metric" data-scen-idx="${sidx}" data-sec="${secName}" data-item-idx="${iidx}"><option ${metric==='Weight'?'selected':''}>Weight</option><option ${metric==='Count'?'selected':''}>Count</option></select>`;
        if (metric === 'Count') {
            const count = (parseInt(it.v_count, 10) || 1);
            return `<div class="d-flex gap-2">${metricSel}<select class="form-select form-select-sm" style="min-width: 120px" data-field="v_count" data-scen-idx="${sidx}" data-sec="${secName}" data-item-idx="${iidx}">${Array.from({length:10},(_,k)=>k+1).map(n=>`<option ${n===count?'selected':''}>${n}</option>`).join('')}</select></div>`;
        }
    const isProtectedRandom = (secName === 'Node Information') && ((it.selected||'').toLowerCase()==='random') && it._protected_random;
    const metricDisabled = isProtectedRandom ? 'disabled title="Residual Random row metric locked"' : '';
    const metricSelProtected = `<select class="form-select form-select-sm" ${metricDisabled} style="min-width: 140px" data-field="v_metric" data-scen-idx="${sidx}" data-sec="${secName}" data-item-idx="${iidx}"><option ${metric==='Weight'?'selected':''}>Weight</option><option ${metric==='Count'?'selected':''}>Count</option></select>`;
    const ro = isProtectedRandom ? 'readonly class="form-control form-control-sm weight-input bg-light" title="Auto-adjusted to keep sum=1.0"' : 'class="form-control form-control-sm weight-input"';
    return `<div class="d-flex gap-2">${metricSelProtected}<input type="number" step="0.01" min="0" max="1" ${ro} style="min-width: 120px" value="${weight}" data-field="factor" data-scen-idx="${sidx}" data-sec="${secName}" data-item-idx="${iidx}"></div>`;
    })();
    const removeBtnHtml = ((secName === 'Node Information') && ((it.selected||'').toLowerCase()==='random') && it._protected_random)
        ? '<span class="text-muted small" title="Residual Random row">&mdash;</span>'
        : `<button type="button" class="btn btn-sm btn-outline-danger" data-action="remove-item" data-scen-idx="${sidx}" data-sec="${secName}" data-item-idx="${iidx}">Remove</button>`;
    return `
        <tr>
            <td>${firstCell}</td>
            <td>${extras}</td>
            <td>${weightCell}</td>
            <td>${removeBtnHtml}</td>
        </tr>`;
}
// Render Vulnerabilities rows grouped with two row-headers
function renderVulnRows(sidx, secName, items) {
    const withIdx = items.map((it, iidx) => ({ it, iidx }));
    const typeOrRandom = withIdx.filter(x => (x.it.selected || 'Category') !== 'Specific');
    const specifics = withIdx.filter(x => (x.it.selected || 'Category') === 'Specific');
    const parts = [];
    if (typeOrRandom.length) {
        parts.push(`<tr class="table-light"><td colspan="4"><strong>Category or Random</strong></td></tr>`);
        parts.push(typeOrRandom.map(x => renderItemRow(sidx, secName, x.iidx, x.it)).join(''));
    }
    if (specifics.length) {
        parts.push(`<tr class="table-light"><td colspan="4"><strong>Specific</strong></td></tr>`);
        parts.push(specifics.map(x => renderItemRow(sidx, secName, x.iidx, x.it)).join(''));
    }
    return parts.join('');
}

function wireHandlers() {
    // Count for Density input handler
    document.querySelectorAll('input[data-field="scenario_density_count"]').forEach(inp => {
        inp.addEventListener('change', () => {
            const idx = parseInt(inp.getAttribute('data-scen-idx'));
            let val = parseInt(inp.value, 10); if (isNaN(val) || val < 0) val = 0; if (val > 5000) val = 5000;
            state.scenarios[idx].density_count = val; // store at scenario level; do NOT mutate node rows
            if (val === '' || val === null) {
                // If cleared, revert to default 10 in UI but keep undefined so save omits and parser falls back.
                delete state.scenarios[idx].density_count;
            }
            renderMain();
        });
        // Prevent Enter key from triggering unintended form behavior (like adding a row)
        inp.addEventListener('keydown', (ev) => {
            if (ev.key === 'Enter') { ev.preventDefault(); inp.blur(); }
        });
    });
    document.querySelectorAll('[data-field]').forEach(el => {
        const sidx = parseInt(el.getAttribute('data-scen-idx'));
        const sec = el.getAttribute('data-sec');
        const field = el.getAttribute('data-field');
        const iidx = el.getAttribute('data-item-idx');
        const handler = () => {
            if (field === 'scenario_base_hosts') { return; }
            if (sec) {
                if (iidx !== null) {
                    const item = state.scenarios[sidx].sections[sec].items[parseInt(iidx)];
                    if (['factor','rate_kbps','period_s','jitter_pct','total_nodes','density','r2r_edges','r2s_edges','r2s_hosts_min','r2s_hosts_max'].includes(field)) {
                        item ? (item[field] = parseFloat(el.value)) : state.scenarios[sidx].sections[sec][field] = parseFloat(el.value);
                        if ((field === 'edges' || field === 'r2s_edges') && (isNaN(item[field]) || el.value === '')) {
                            // Allow blank to mean "unset" so generator can apply defaults
                            delete item[field];
                        }
                        if ((field === 'r2s_hosts_min' || field === 'r2s_hosts_max')) {
                            const mn = parseInt(item.r2s_hosts_min || 1, 10);
                            const mx = parseInt(item.r2s_hosts_max || 4, 10);
                            if (!isNaN(mn) && !isNaN(mx) && mn > mx) {
                                item.r2s_hosts_max = mn;
                            }
                            persistEditorState();
                        }
                        if (field === 'factor') {
                            adjustWeightsProportionally(sidx, sec, parseInt(iidx));
                            updateWeightWarning(sidx, sec);
                            updateWeightInputsDisplay(sidx, sec);
                        }
                        if (field === 'edges' || field === 'r2s_edges') {
                            setTimeout(validateRoutingEdges, 20);
                        }
                    } else if (['pattern','content_type','selected','script_path','v_type','v_vector','v_name','v_path','v_count','v_metric','r2r_mode','r2s_mode'].includes(field)) {
                        const prev = item[field];
                        if (field === 'v_count') {
                            const n = parseInt(el.value, 10) || 1;
                            item[field] = n;
                        } else {
                            item[field] = el.value;
                        }
                        if(field === 'r2r_mode') {
                            item.r2r_mode = el.value;
                            if(el.value !== 'Exact') { delete item.edges; }
                            renderMain();
                            setTimeout(validateRoutingEdges, 50);
                        }
                        if(field === 'r2s_mode') {
                            item.r2s_mode = el.value;
                            if(el.value !== 'Exact') { delete item.r2s_edges; }
                            renderMain();
                            setTimeout(validateRoutingEdges, 50);
                            // After re-render ensure H/S bounds inputs visibility toggled only for NonUniform
                            setTimeout(()=>{
                                document.querySelectorAll('[data-field="r2s_mode"]').forEach(selEl=>{
                                    try {
                                        const modeVal = selEl.value;
                                        const wrapper = selEl.closest('.routing-edge-groups')?.querySelector('.hs-bounds-wrapper');
                                        if(wrapper){ wrapper.style.display = (modeVal==='NonUniform') ? 'flex' : 'none'; }
                                    } catch(e) { /* ignore */ }
                                });
                            },60);
                        }
                        if (field === 'edges') {
                            setTimeout(validateRoutingEdges, 20);
                        } else if (field === 'content_type') {
                            // Re-render to reflect show/hide of traffic-config inputs when Random is selected
                            renderMain();
                        } else if (field === 'selected') {
                            if (item.selected === 'Specific') {
                                if (!item.v_count) item.v_count = 1;
                                if (!item.v_metric) item.v_metric = 'Count';
                            } else {
                                if (!item.v_metric) item.v_metric = 'Weight';
                            }
                            // Re-render to show/hide appropriate controls and recalc weight warnings
                            renderMain();
                        } else if (field === 'v_metric') {
                            // On metric toggle, normalize weights for current section and re-render
                            if (item.v_metric === 'Count' && (item.v_count === undefined || item.v_count === null || isNaN(parseInt(item.v_count, 10)))) {
                                item.v_count = 1;
                            }
                            redistributeEven(sidx, sec);
                            if (sec === 'Node Information') {
                                const secRef = state.scenarios[sidx].sections[sec];
                                const hasWeight = (secRef.items || []).some(it => (it.v_metric || 'Weight') === 'Weight');
                                if (!hasWeight && secRef.total_nodes) { secRef.total_nodes = 0; }
                            }
                            updateWeightWarning(sidx, sec);
                            renderMain();
                        } else if (field === 'v_count') {
                            // Count change affects Total Nodes label
                            renderMain();
                        }
                    } else {
                        state.scenarios[sidx].sections[sec][field] = el.value;
                    }
                } else {
                    if (field === 'density' || field === 'total_nodes') {
                        let v = parseFloat(el.value);
                        if (field === 'density') {
                            if (isNaN(v)) v = 0.0;
                            v = Math.max(0, Math.min(1, v)); // Clamp globally 0..1
                        }
                        state.scenarios[sidx].sections[sec][field] = v;
                        // keep hidden for submit and update any warnings
                        if (field === 'density') { updateWeightWarning(sidx, sec); }
                        // Ensure Total Nodes label refreshes on total_nodes edits
                        if (field === 'total_nodes') { renderMain(); }
                    } else {
                        state.scenarios[sidx].sections[sec][field] = el.value;
                    }
                }
            } else {
                if (field === 'name') state.scenarios[sidx].name = el.value;
                if (field === 'base-file') state.scenarios[sidx].base.filepath = el.value;
                if (field === 'notes') state.scenarios[sidx].notes = el.value;
                if(field === 'notes'){
                    try {
                        const ind = document.getElementById('notesIndicator_'+sidx);
                        if(ind){
                            const has = (el.value||'').trim().length>0;
                            ind.innerHTML = has ? `<i class='bi bi-journal-text text-success'></i>` : `<i class='bi bi-journal text-muted'></i>`;
                            ind.setAttribute('data-bs-title', has ? 'Notes present' : 'No notes');
                            if(window.bootstrap){ try { new bootstrap.Tooltip(ind); } catch(e){} }
                        }
                    } catch(e){}
                }
            }
            // keep hidden for submit
            document.getElementById('scenarios_json').value = JSON.stringify({ scenarios: state.scenarios });
            // persist edits across navigation
            persistEditorState();
            logDebug(`Field change: scen=${sidx} sec=${sec||''} field=${field}`);
            try { previewState.dirty = true; updatePlanButtons(); } catch(e){}
        };
        el.addEventListener('input', handler);
        el.addEventListener('change', handler);
    });
    document.querySelectorAll('[data-action="remove-item"]').forEach(btn => {
        btn.onclick = () => {
            const sidx = parseInt(btn.getAttribute('data-scen-idx'));
            const sec = btn.getAttribute('data-sec');
            const iidx = parseInt(btn.getAttribute('data-item-idx'));
            state.scenarios[sidx].sections[sec].items.splice(iidx,1);
                        logInfo(`Removed item ${iidx} from ${sec}`);
              redistributeEven(sidx, sec);
              // Auto-clear total_nodes if Node Information loses its last weight-based row
              if (sec === 'Node Information') {
                  const secRef = state.scenarios[sidx].sections[sec];
                  const hasWeight = (secRef.items || []).some(it => (it.v_metric || 'Weight') === 'Weight');
                  if (!hasWeight && secRef.total_nodes) { secRef.total_nodes = 0; }
              }
              // Re-render to refresh totals and labels
                            renderMain();
                            persistEditorState();
                            try { previewState.dirty = true; updatePlanButtons(); } catch(e){}
        };
    });
    document.querySelectorAll('[data-action="add-item"]').forEach(btn => {
        btn.onclick = () => {
            const sidx = parseInt(btn.getAttribute('data-scen-idx'));
            const sec = btn.getAttribute('data-sec');
            // Default selection logic: for Routing we prefer the first concrete protocol (not Random) so
            // routers don't silently become 'Random' unless user explicitly chooses it. Other sections
            // still start at 'Random' (or specialized default) as before.
            let defaultSelected = 'Random';
            if (sec === 'Routing') {
                try {
                    const opts = dropdownsBySection['Routing'] || [];
                    // pick the first option that isn't 'Random'
                    const concrete = opts.find(o => o !== 'Random');
                    if (concrete) defaultSelected = concrete;
                } catch(e){}
            }
            const item = { selected: defaultSelected, factor: 1.0 };
            if (sec === 'Events') item.script_path = '';
            if (sec === 'Traffic') { item.pattern = 'continuous'; item.rate_kbps = 64.0; item.period_s = 1.0; item.jitter_pct = 10.0; item.content_type = 'Random'; }
            if (sec === 'Vulnerabilities') { item.selected = 'Category'; item.v_type = 'Random'; item.v_vector = 'Random'; }
            // Default new rows: Node Information -> Count; others -> Weight.
            if (sec === 'Node Information') { item.v_metric = 'Count'; item.v_count = 1; }
            else { item.v_metric = 'Weight'; }
            state.scenarios[sidx].sections[sec].items.push(item);
                        logInfo(`Added item to ${sec}`);
              redistributeEven(sidx, sec);
                            renderMain();
                            persistEditorState();
                            try { previewState.dirty = true; updatePlanButtons(); } catch(e){}
        };
    });
    document.querySelectorAll('[data-action="toggle-collapse"]').forEach(btn => {
        btn.onclick = () => {
            const targetSel = btn.getAttribute('data-target');
            const target = document.querySelector(targetSel);
            if (!target) return;
            const visible = target.style.display !== 'none';
            target.style.display = visible ? 'none' : 'block';
            btn.textContent = visible ? 'Expand' : 'Collapse';
            const secName = targetSel.replace('#collapse-','').replace(/-/g,' ');
            const collapseKey = `${activeIdx}::${secName}`;
            collapseState[collapseKey] = visible; // store collapsed state (true means now collapsed)
            try { localStorage.setItem('sectionCollapseState', JSON.stringify(collapseState)); } catch(e) {}
            logDebug(`Section toggle ${targetSel} -> ${visible ? 'collapsed':'expanded'}`);
        };
    });
    // Export preview handler
    const previewBtn = document.querySelector('[data-action="preview-plan"]');
    if (previewBtn) {
        previewBtn.onclick = () => {
            const scen = state.scenarios[activeIdx];
            if (!scen) return;
            const ni = scen.sections['Node Information'] || { items: [], total_nodes:0 };
            const weightRows = (ni.items||[]).filter(it => (it.v_metric || (it.selected==='Specific'? 'Count':'Weight'))==='Weight');
            const countRows = (ni.items||[]).filter(it => (it.v_metric || (it.selected==='Specific'? 'Count':'Weight'))==='Count');
            const base = weightRows.length ? (parseInt(scen.density_count || 0) || 0) : 0;
            const addHosts = countRows.reduce((a,it)=> a + (parseInt(it.v_count,10)||0),0);
            const totalHosts = base + addHosts;
            let allocTable = [];
            if (base>0 && weightRows.length) {
                const sumW = weightRows.reduce((a,it)=> a + (parseFloat(it.factor)||0),0) || 1;
                const temp = weightRows.map(it => {
                    const f = parseFloat(it.factor)||0; const share = sumW? f/sumW:0; const raw = base*share; const alloc = Math.floor(raw);
                    return { it, share, raw, alloc, frac: raw - alloc };
                });
                let assigned = temp.reduce((a,r)=> a + r.alloc,0);
                let remain = base - assigned;
                temp.sort((a,b)=> b.frac - a.frac);
                for (let i=0;i<temp.length && remain>0;i++) { temp[i].alloc += 1; remain--; }
                allocTable = temp.sort((a,b)=> (ni.items.indexOf(a.it) - ni.items.indexOf(b.it))).map(r => ({ label: r.it.selected || 'Row', weight: (parseFloat(r.it.factor)||0), percent: (r.share*100), alloc: r.alloc }));
            }
            const routing = scen.sections['Routing'] || { items: [], density: 0 };
            const rWeight = (routing.items||[]).filter(it => (it.v_metric||'Weight')==='Weight');
            const rCount = (routing.items||[]).filter(it => (it.v_metric||'Weight')==='Count');
            const rExplicit = rCount.reduce((a,it)=> a + (parseInt(it.v_count,10)||0),0);
            let rDerived = 0; if (rWeight.length) { const d = parseFloat(routing.density)||0; rDerived = (d>=1)? d : Math.round((totalHosts - addHosts) * d); }
            const totalRouters = rExplicit + rDerived;
            const vulns = scen.sections['Vulnerabilities'] || { items: [], density: 0 };
            const vWeight = (vulns.items||[]).filter(it => (it.v_metric || (it.selected==='Specific'?'Count':'Weight'))==='Weight');
            const vCount = (vulns.items||[]).filter(it => (it.v_metric || (it.selected==='Specific'?'Count':'Weight'))==='Count');
            const vExplicit = vCount.reduce((a,it)=> a + (parseInt(it.v_count,10)||0),0);
            let vDerived = 0; if (vWeight.length) { const d = Math.min(1, Math.max(0, parseFloat(vulns.density)||0)); vDerived = Math.round((totalHosts - addHosts) * d); }
            const totalVulns = vExplicit + vDerived;
            const rowsHtml = allocTable.length ? allocTable.map(r => `<tr><td>${r.label}</td><td>${r.weight.toFixed(3)}</td><td>${r.percent.toFixed(1)}%</td><td>${r.alloc}</td></tr>`).join('') : '<tr><td colspan="4" class="text-muted">No weight allocation</td></tr>';
            const modalHtml = `
<div class=\"modal fade\" id=\"previewModal\" tabindex=\"-1\" aria-hidden=\"true\">\n  <div class=\"modal-dialog modal-lg modal-dialog-scrollable\">\n    <div class=\"modal-content\">\n      <div class=\"modal-header\">\n        <h5 class=\"modal-title\">Plan Preview: ${scen.name}</h5>\n        <button type=\"button\" class=\"btn-close\" data-bs-dismiss=\"modal\" aria-label=\"Close\"></button>\n      </div>\n      <div class=\"modal-body\">\n        <div class=\"row mb-3\">\n          <div class=\"col-md-4\"><div class=\"card card-body p-2\"><small class=\"text-muted\">Hosts Total</small><div class=\"fs-5\">${totalHosts}</div><div class=\"small text-muted\">Base ${base} + Add ${addHosts}</div></div></div>\n          <div class=\"col-md-4\"><div class=\"card card-body p-2\"><small class=\"text-muted\">Routers</small><div class=\"fs-5\">${totalRouters}</div><div class=\"small text-muted\">Explicit ${rExplicit} + Derived ${rDerived}</div></div></div>\n          <div class=\"col-md-4\"><div class=\"card card-body p-2\"><small class=\"text-muted\">Vulns</small><div class=\"fs-5\">${totalVulns}</div><div class=\"small text-muted\">Explicit ${vExplicit} + Derived ${vDerived}</div></div></div>\n        </div>\n        <h6>Host Weight Allocation</h6>\n        <div class=\"table-responsive\">\n          <table class=\"table table-sm\">\n            <thead><tr><th>Row</th><th>Weight</th><th>%</th><th>Alloc</th></tr></thead>\n            <tbody>${rowsHtml}</tbody>\n          </table>\n        </div>\n      </div>\n      <div class=\"modal-footer\">\n        <button type=\"button\" class=\"btn btn-sm btn-outline-secondary\" data-bs-dismiss=\"modal\">Close</button>\n      </div>\n    </div>\n  </div>\n</div>`;
            let container = document.getElementById('previewModalContainer');
            if (!container) { container = document.createElement('div'); container.id = 'previewModalContainer'; document.body.appendChild(container); }
            container.innerHTML = modalHtml;
            if (window.bootstrap) { try { new bootstrap.Modal(document.getElementById('previewModal')).show(); } catch(e) { alert('Bootstrap modal failed; see console'); console.error(e); } }
            else { alert('Bootstrap not loaded.'); }
        };
    }
    // Initialize popovers & tooltips (Bootstrap 5)
    if (window.bootstrap) {
        document.querySelectorAll('[data-bs-toggle="popover"]').forEach(el => { try { new bootstrap.Popover(el); } catch(e) {} });
        document.querySelectorAll('[data-bs-toggle="tooltip"]').forEach(el => { try { new bootstrap.Tooltip(el); } catch(e) {} });
    }
    // Flash animation on Base input change
    document.querySelectorAll('.base-input').forEach(inp => {
        inp.addEventListener('change', () => {
            const badge = document.querySelector('.host-total-badge');
            if (!badge) return;
            badge.classList.add('pulse-change');
            setTimeout(()=> badge.classList.remove('pulse-change'), 900);
        });
    });
    document.querySelectorAll('[data-action="remove-scenario"]').forEach(btn => {
        btn.onclick = async (ev) => {
            if (ev && typeof ev.preventDefault === 'function') ev.preventDefault();
            if (ev && typeof ev.stopPropagation === 'function') ev.stopPropagation();
            const sidx = parseInt(btn.getAttribute('data-scen-idx'));
            const scen = state.scenarios[sidx];
            if (!scen) { return; }
            let runCount = 0;
            try {
                const resp = await fetch('/reports_data');
                if (resp.ok) {
                    const data = await resp.json();
                    runCount = (data.history || []).filter(r => (r.scenario_names || []).includes(scen.name)).length;
                }
            } catch (e) {}
            const lines = [];
            lines.push(`Delete scenario "${scen.name}"?`);
            if (runCount > 0) {
                lines.push("");
                lines.push(`WARNING: ${runCount} run history entr${runCount===1?'y':'ies'} and their artifact files (XML, report, pre-session XML) will be permanently deleted.`);
            }
            lines.push("");
            lines.push("This action cannot be undone.");
            lines.push("");
            lines.push("Proceed?");
            const msg = lines.join('\n');
            if (!window.confirm(msg)) { return; }

            // Remove scenario
            state.scenarios.splice(sidx, 1);
            // Leave list empty if last scenario removed
            activeIdx = state.scenarios.length === 0 ? 0 : Math.min(sidx, state.scenarios.length - 1);
            // Persist immediately before re-render so state survives any navigation
            const hidden = document.getElementById('scenarios_json');
            if (hidden) hidden.value = JSON.stringify({ scenarios: state.scenarios });
            persistEditorState();
            logInfo(`Deleted scenario: ${scen.name}`);
            // Re-render UI
            render();
            try { showToast(`Scenario "${scen.name}" deleted`); } catch(e){}

            // Purge matching run history and artifacts in background
            if (runCount > 0) {
                try {
                    await fetch('/purge_history_for_scenario', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ name: scen.name })
                    });
                } catch (e) {}
            }
        };
    });
    // keep hidden JSON synced
    document.getElementById('scenarios_json').value = JSON.stringify({ scenarios: state.scenarios });
    persistEditorState();
        // Initialize warnings per section
        const scen = state.scenarios[activeIdx];
        if (scen) {
            ['Node Information','Routing','Services','Traffic','Events','Vulnerabilities','Segmentation'].forEach(sec => updateWeightWarning(activeIdx, sec));
        }
}
// Routing edges validation utilities
function validateRoutingEdges(){
    const scen = state.scenarios[activeIdx]; if(!scen) return;
    const routing = (scen.sections && scen.sections['Routing'] && scen.sections['Routing'].items) || [];
    const warn = [];
    routing.forEach((r,i)=>{ const m = r.r2r_mode; if(m==='Exact' && !(r.edges>=1)) warn.push(`Row ${i+1}: Exact mode requires a degree ≥ 1`); });
    routing.forEach((r,i)=>{ if(r.r2s_mode==='Exact' && !(r.r2s_edges>=1)) warn.push(`Row ${i+1}: R-to-S Exact requires a value ≥ 1`); });
    // Highlight inputs
    document.querySelectorAll('.edges-degree-input').forEach(inp => {
        const v = parseInt(inp.value,10); const tr = inp.closest('tr');
    const sel = tr ? tr.querySelector('[data-field="r2r_mode"]') : null;
        const mode = sel ? sel.value : '';
        if(mode==='Exact' && !(v>=1)) inp.classList.add('is-invalid'); else inp.classList.remove('is-invalid');
    });
    document.querySelectorAll('.r2s-degree-input').forEach(inp => {
        const v = parseInt(inp.value,10); const tr = inp.closest('tr');
        const sel = tr ? tr.querySelector('[data-field="r2s_mode"]') : null;
        const mode = sel ? sel.value : '';
        if(mode==='Exact' && !(v>=1)) inp.classList.add('is-invalid'); else inp.classList.remove('is-invalid');
    });
    // If a separate warning container existed we could populate it here later.
    computeRoutingEdgePolicyPreview();
}
setTimeout(validateRoutingEdges, 500);

// Derive a lightweight preview (pre-generation) of intended policy and an estimated degree band
function computeRoutingEdgePolicyPreview(){
    const scen = state.scenarios[activeIdx]; if(!scen) return;
    const routing = (scen.sections && scen.sections['Routing'] && scen.sections['Routing'].items) || [];
    const summaryEl = document.getElementById('routingEdgesSummary');
    if(!summaryEl) return;
    if(!routing.length){ summaryEl.style.display='none'; return; }
    // Determine target policy: Exact avg > Max > Min > Random (mirrors backend)
    const exactVals = routing.filter(r=> r.r2r_mode==='Exact' && r.edges>=1).map(r=>r.edges);
    let mode='Random'; let target=0;
    if(exactVals.length){
        target = Math.round(exactVals.reduce((a,b)=>a+b,0)/exactVals.length);
        if(target<1) target=1; mode='Exact';
    } else {
    const modes = routing.map(r=> r.r2r_mode).filter(Boolean);
    if(modes.includes('Uniform')) mode='Uniform';
        else if(modes.includes('Min')) mode='Min';
        else if(modes.includes('NonUniform')) mode='NonUniform';
        else mode='Random';
    }
    // Determine predominant R-to-S mode (simple precedence similar to R-to-R)
    let r2sMode = 'Random';
    const r2sExactVals = routing.filter(r=>r.r2s_mode==='Exact' && r.r2s_edges>=1).map(r=>r.r2s_edges);
    if(r2sExactVals.length){
        r2sMode = 'Exact';
    } else {
        const r2sModes = routing.map(r=>r.r2s_mode).filter(Boolean);
    if(r2sModes.includes('Uniform')) r2sMode='Uniform';
        else if(r2sModes.includes('Min')) r2sMode='Min';
        else if(r2sModes.includes('NonUniform')) r2sMode='NonUniform';
        else r2sMode='Random';
    }
    const policySpan = summaryEl.querySelector('[data-role="edges-policy"]');
    if(policySpan){ policySpan.textContent = `R-R: ${mode}${mode==='Exact'?`(≈${target})`:''} | R-S: ${r2sMode}`; }
    // Estimate degree distribution preview (pure heuristic):
    let minD=0, avgD=0, maxD=0;
    if(mode==='Exact'){ minD=target; avgD=target+1; maxD=target+2; }
    else if(mode==='Uniform'){ minD=4; avgD=4; maxD=5; }
    else if(mode==='NonUniform'){ minD=1; avgD=3; maxD=8; }
    else if(mode==='Min'){ minD=2; avgD=3; maxD=4; }
    else { minD=1; avgD=2; maxD=4; }
    // Removed Min/Avg/Max and sparkline visualization per request
    // Resource warning for Uniform (previously Max) mode – still warn if near-dense
	const warnEl = document.getElementById('routingEdgesWarnings');
	if(warnEl){
	    warnEl.classList.add('d-none');
	    warnEl.innerHTML='';
        if(mode==='Uniform'){
	        // Approximate router count: we don't know exact until build; use routing item count as lower bound
	        let approxRouters = routing.length || 0;
	        // If scenario embeds an explicit router count in future, prefer it; attempt common field names
	        if(typeof scen.router_count === 'number' && scen.router_count > approxRouters) approxRouters = scen.router_count;
	        if(typeof scen.routers_total === 'number' && scen.routers_total > approxRouters) approxRouters = scen.routers_total;
	        // Compute full mesh edges estimate
	        const estEdges = approxRouters > 1 ? (approxRouters * (approxRouters - 1) / 2) : 0;
	        // Thresholds: warn if routers >= 25 OR estimated edges >= 300
	        if(approxRouters >= 25 || estEdges >= 300){
	            const edgesFmt = estEdges.toLocaleString();
                warnEl.innerHTML = `<strong>Uniform Mode:</strong> balanced high degree connectivity can grow ~O(n²). With ~${approxRouters} routers this implies about ${edgesFmt} potential links. This may increase session startup time and resource usage.`;
	            warnEl.classList.remove('d-none');
	        } else {
	            // Light advisory (still show something so users understand cost) for smaller counts
	            if(approxRouters >= 10){
                    warnEl.innerHTML = `<strong>Heads up:</strong> Uniform mode aims for evenly high degrees (approaches dense graph). Routers: ~${approxRouters}.`;
	                warnEl.classList.remove('d-none');
	            }
	        }
	    }
	}
    summaryEl.style.display='flex';
}

function wireCoreControls() {
    // defaults
    if (!state.core) state.core = { host: (initialPayload?.core?.host || 'localhost'), port: (initialPayload?.core?.port || 50051) };
    const hostEl = document.getElementById('coreHost');
    const portEl = document.getElementById('corePort');
    const btn = document.getElementById('testCoreBtn');
    const statusEl = document.getElementById('coreStatus');
    const runSync = document.getElementById('runSyncBtn');
    const cancelBtn = document.getElementById('cancelRunBtn');
    const runSyncWrap = document.getElementById('runSyncWrap');

    // Always enable run buttons (CORE test optional now)
    const setRunEnabled = () => {
        runSync?.removeAttribute('disabled');
        runSync?.classList.remove('pe-none');
        runSyncWrap?.setAttribute('data-bs-title', '');
        statusEl.classList.remove('text-danger','text-success');
        statusEl.textContent = 'Not tested (runs allowed)';
    };

    // initialize values
    if (hostEl) hostEl.value = state.core.host || 'localhost';
    if (portEl) portEl.value = state.core.port || 50051;
    // Immediately enable regardless of prior test
    setRunEnabled();

    const onEdit = () => {
    state.core.host = hostEl.value.trim();
    state.core.port = parseInt(portEl.value || '50051', 10) || 50051;
    state.core_ok = false; // changing values invalidates previous test
        // any edit resets test state
    setRunEnabled();
    };
    hostEl?.addEventListener('input', () => { onEdit(); persistEditorState(); });
    portEl?.addEventListener('input', () => { onEdit(); persistEditorState(); });

    btn?.addEventListener('click', async () => {
    btn.disabled = true;
    logInfo('Testing CORE connection');
        statusEl.classList.remove('text-danger', 'text-success');
        statusEl.textContent = 'Testing...';
        try {
            const res = await fetch("{{ url_for('test_core') }}", {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ host: hostEl.value.trim() || 'localhost', port: parseInt(portEl.value || '50051', 10) || 50051 })
            });
            const data = await res.json();
            if (data && data.ok) {
                // persist success and the tested values
                state.core_ok = true;
                state.core_tested_host = hostEl.value.trim() || 'localhost';
                state.core_tested_port = parseInt(portEl.value || '50051', 10) || 50051;
                logInfo(`CORE reachable at ${data.host||hostEl.value}:${data.port||portEl.value}`);
                statusEl.classList.add('text-success');
                statusEl.textContent = 'CORE reachable (optional)';
                persistEditorState();
            } else {
                statusEl.classList.remove('text-success');
                statusEl.classList.add('text-danger');
                statusEl.textContent = 'Connection failed (run still allowed)' + (data?.error ? `: ${data.error}` : '');
                logWarn(`CORE connection failed: ${data?.error||'unknown'}`);
                state.core_ok = false;
                persistEditorState();
            }
        } catch (e) {
            statusEl.classList.remove('text-success');
            statusEl.classList.add('text-danger');
            statusEl.textContent = 'Connection failed (run still allowed)';
            logError('CORE test threw exception');
            state.core_ok = false;
            persistEditorState();
        } finally {
            btn.disabled = false;
        }
    });
}

function prepareRunCli() {
    // prefer the last saved XML path or result_path if it's XML
    const rp = state.result_path || '';
    if (!rp.endsWith('.xml')) {
        alert('Please save XML first.');
        logWarn('Run CLI blocked: no saved XML');
        return false;
    }
    // confirmation dialog warning user a CORE scenario will be created and started
    const confirmMsg = 'This action will generate a new CORE scenario and attempt to start it using the provided daemon connection.\n\nProceed?';
    if (!window.confirm(confirmMsg)) {
        logInfo('Run CLI cancelled by user at confirmation');
        return false;
    }
    document.getElementById('xml_path').value = rp;
    logInfo('Running CLI sync');
    // Preserve scroll so after the round trip we land where we were
    try { saveScrollBeforeNav(); } catch(e){}
    return true;
}

render();

// Restore scroll position if previously saved before a Save XML navigation
function restoreScrollIfAny() {
    try {
        const y = parseInt(sessionStorage.getItem('coretg_saved_scroll_y') || '', 10);
        if (!isNaN(y)) {
            window.scrollTo(0, y);
            sessionStorage.removeItem('coretg_saved_scroll_y');
        }
    } catch (e) { /* ignore */ }
}
// Use load to ensure layout (including dock sizing) has been applied
window.addEventListener('load', restoreScrollIfAny);

// Small helper to persist current scroll position prior to any navigation (form post or link)
function saveScrollBeforeNav(){
    try { sessionStorage.setItem('coretg_saved_scroll_y', String(window.scrollY || window.pageYOffset || 0)); } catch (e) { /* ignore */ }
}

// Always serialize state just before submitting the Save XML form
const editorForm = document.getElementById('editorForm');
if (editorForm) {
    editorForm.addEventListener('submit', () => {
        // preserve current scroll so we can restore after the server round-trip
        try { sessionStorage.setItem('coretg_saved_scroll_y', String(window.scrollY || window.pageYOffset || 0)); } catch (e) { /* ignore */ }
        document.getElementById('scenarios_json').value = JSON.stringify({ scenarios: state.scenarios });
        persistEditorState();
    });
}

// Enable Bootstrap tooltips globally
document.addEventListener('DOMContentLoaded', () => {
    const tooltipTriggerList = [].slice.call(document.querySelectorAll('[data-bs-toggle="tooltip"]'));
    tooltipTriggerList.forEach(el => {
        // Bootstrap 5 throws if title option resolves to null; normalize to empty string
        const dt = el.getAttribute('data-bs-title') || el.getAttribute('title');
        if (dt === null) {
            // skip creating tooltip entirely if no title is present
            return;
        }
        if (dt.trim() === '') {
            el.setAttribute('data-bs-title', '');
        }
        try { new bootstrap.Tooltip(el); } catch (e) { /* ignore */ }
    });
    // Wire Download XML button
    const dlBtn = document.getElementById('downloadXmlBtn');
    if (dlBtn) {
        dlBtn.addEventListener('click', () => {
            const rp = state.result_path || '';
            if (!rp || !rp.endsWith('.xml')) { alert('Please Save XML first.'); return; }
            window.location.href = window.location.origin + '/download_report?path=' + encodeURIComponent(rp);
        });
        // Initial state based on state.result_path
        const rp0 = state.result_path || '';
        if (rp0 && rp0.endsWith('.xml')) { dlBtn.removeAttribute('disabled'); dlBtn.classList.remove('pe-none'); dlBtn.setAttribute('title',''); }
    }
    // Capture any server-rendered logs before we render from storage
    let __serverLogsAtLoad = '';
    try { __serverLogsAtLoad = (document.getElementById('logsPre')?.textContent || '').trim(); } catch(e){}
    setupVulnCatalog();
});

// Vulnerability catalog and UI helpers
async function setupVulnCatalog(){
        try {
                const res = await fetch('/vuln_catalog');
        if(res.ok){ window.VULN_CATALOG = await res.json(); }
    } catch(e) { window.VULN_CATALOG = { types: [], vectors: [], items: [] }; }
}

function populateVulnSelects() {
        document.querySelectorAll('.vuln-type').forEach(sel => {
                const sidx = parseInt(sel.getAttribute('data-scen-idx'));
                const sec = sel.getAttribute('data-sec');
                const iidx = parseInt(sel.getAttribute('data-item-idx'));
                const cur = (state.scenarios[sidx].sections[sec].items[iidx].v_type) || 'Random';
                const opts = ['Random', ...(window.VULN_CATALOG?.types || [])];
                sel.innerHTML = opts.map(o => `<option ${o===cur?'selected':''}>${o}</option>`).join('');
        });
        document.querySelectorAll('.vuln-vector').forEach(sel => {
                const sidx = parseInt(sel.getAttribute('data-scen-idx'));
                const sec = sel.getAttribute('data-sec');
                const iidx = parseInt(sel.getAttribute('data-item-idx'));
                const cur = (state.scenarios[sidx].sections[sec].items[iidx].v_vector) || 'Random';
                const opts = ['Random', ...(window.VULN_CATALOG?.vectors || [])];
                sel.innerHTML = opts.map(o => `<option ${o===cur?'selected':''}>${o}</option>`).join('');
        });
}

// Modal for Specific selection
function ensureVulnModal(){
        if(document.getElementById('vulnModal')) return;
        const modal = document.createElement('div');
        modal.className = 'modal fade';
        modal.id = 'vulnModal';
        modal.innerHTML = `
        <div class="modal-dialog modal-lg">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title">Select Vulnerability</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
                </div>
                <div class="modal-body">
                    <div id="vulnLoadingWrap" class="mb-3" style="display:none;">
                        <div class="d-flex align-items-center gap-2 mb-2 text-muted small">
                            <div class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></div>
                            <span id="vulnLoadMeta">Loading eligible items…</span>
                        </div>
                        <div class="progress" style="height: 14px;">
                            <div class="progress-bar" id="vulnLoadProgressBar" role="progressbar" style="width:0%" aria-valuenow="0" aria-valuemin="0" aria-valuemax="100">0%</div>
                        </div>
                    </div>
                    <div class="d-flex align-items-start gap-2 mb-2">
                        <div class="flex-grow-1">
                            <input class="form-control" placeholder="Filter (string or /regex/)" id="vulnFilter">
                            <div class="invalid-feedback" id="vulnFilterError">Invalid regex</div>
                        </div>
                        <button class="btn btn-outline-secondary" type="button" id="vulnFilterClear" title="Clear filter">Clear</button>
                    </div>
                    <div class="text-muted small mb-2" id="vulnFilterMeta"></div>
                    <div class="table-responsive" id="vulnTableWrap" style="max-height:50vh; overflow:auto; display:none;">
                        <table class="table table-sm">
                            <thead><tr><th>Name</th><th>Type</th><th>Vector</th><th>Path</th></tr></thead>
                            <tbody id="vulnList"></tbody>
                        </table>
                    </div>
                </div>
                <div class="modal-footer">
                    <button class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
                </div>
            </div>
        </div>`;
        document.body.appendChild(modal);
}

async function openVulnPicker(sidx, secName, iidx){
    ensureVulnModal();
    const modalEl = document.getElementById('vulnModal');
    const modalObj = window.bootstrap ? new bootstrap.Modal(modalEl, { backdrop: true, keyboard: true }) : null;
    const filterInput = modalEl.querySelector('#vulnFilter');
    const filterClearBtn = modalEl.querySelector('#vulnFilterClear');
    const filterMeta = modalEl.querySelector('#vulnFilterMeta');
    const filterError = modalEl.querySelector('#vulnFilterError');
    const tbody = modalEl.querySelector('#vulnList');
    const tblWrap = modalEl.querySelector('#vulnTableWrap');
    const loadWrap = modalEl.querySelector('#vulnLoadingWrap');
    const loadBar = modalEl.querySelector('#vulnLoadProgressBar');
    const loadMeta = modalEl.querySelector('#vulnLoadMeta');
    const row = state.scenarios[sidx].sections[secName].items[iidx] || {};
    const selVector = (row.v_vector || 'Random');
    // Base: docker-compose only
    const all = (window.VULN_CATALOG?.items || []);
    let base = all.filter(it => (it.Type||'').toLowerCase() === 'docker-compose');
    if (selVector && selVector !== 'Random') {
        const vv = selVector.toLowerCase();
        base = base.filter(it => (it.Vector||'').toLowerCase() === vv);
    }
    // Do not compute eligibility; show immediately
    let eligible = base;
    try {
        if (modalObj) modalObj.show();
        if (loadWrap) loadWrap.style.display = 'none';
        if (tblWrap) tblWrap.style.display = '';
    } catch(e){}
    let current = eligible;
    const renderRows = () => {
        tbody.innerHTML = '';
        if (!current || current.length === 0) {
            const tr = document.createElement('tr');
            const td = document.createElement('td');
            td.colSpan = 4;
            td.className = 'text-center text-muted py-3';
            td.textContent = 'No results';
            tr.appendChild(td);
            tbody.appendChild(tr);
            return;
        }
        current.forEach((it) => {
            const tr = document.createElement('tr');
            tr.innerHTML = `<td>${it.Name}</td><td>${it.Type}</td><td>${it.Vector}</td><td>${it.Path}</td>`;
            tr.style.cursor = 'pointer';
            tr.onclick = () => {
                const item = state.scenarios[sidx].sections[secName].items[iidx];
                item.v_name = it.Name;
                item.v_path = it.Path;
                item.v_type = it.Type;
                item.v_vector = it.Vector;
                if (it.Description) item.v_desc = it.Description;
                // also set selected to Specific defensively
                item.selected = 'Specific';
                document.getElementById('scenarios_json').value = JSON.stringify({ scenarios: state.scenarios });
                try { if(window.bootstrap){ bootstrap.Modal.getInstance(modalEl)?.hide(); } } catch(e) {}
                renderMain();
            };
            tbody.appendChild(tr);
        });
    };
    const applyFilter = () => {
        const raw = (filterInput.value||'').trim();
        try { localStorage.setItem('vulnPickerFilter', raw); } catch(e){}
        filterInput.classList.remove('is-invalid');
        if (filterError) filterError.style.display = '';
        if(!raw){
            current = eligible;
            renderRows();
            if (filterMeta) filterMeta.textContent = `${current.length}/${eligible.length} shown`;
            return;
        }
        let matcher = null;
        if (raw.startsWith('/') && raw.endsWith('/') && raw.length >= 2) {
            try { matcher = new RegExp(raw.slice(1, -1), 'i'); } catch(e){ matcher = null; }
            if (!matcher) {
                filterInput.classList.add('is-invalid');
                if (filterMeta) filterMeta.textContent = `Invalid regex`;
                return;
            }
        }
        if (matcher) {
            current = eligible.filter(it => matcher.test(it.Name) || matcher.test(it.Type) || matcher.test(it.Vector) || matcher.test(it.Path));
        } else {
            const lower = raw.toLowerCase();
            current = eligible.filter(it => (it.Name||'').toLowerCase().includes(lower) || (it.Type||'').toLowerCase().includes(lower) || (it.Vector||'').toLowerCase().includes(lower) || (it.Path||'').toLowerCase().includes(lower));
        }
        renderRows();
        if (filterMeta) filterMeta.textContent = `${current.length}/${eligible.length} shown`;
    };
    filterInput.oninput = applyFilter;
    filterClearBtn.onclick = () => { filterInput.value = ''; applyFilter(); };
    // Load last-used filter, if any
    try {
        const saved = localStorage.getItem('vulnPickerFilter');
        if (saved) filterInput.value = saved;
    } catch(e){}
    // Render immediately and show counts
    try {
        renderRows();
        applyFilter();
    } catch(e){}
}


async function runAsync() {
    let rp = state.result_path || '';
    if (!rp.endsWith('.xml')) {
        const go = window.confirm('Your XML has not been saved. Save now and then run?');
        if (!go) { logInfo('Async run cancelled by user (declined save)'); return; }
        try {
            const ok = await saveXmlAjax();
            if (!ok) { logWarn('Save failed; aborting async run'); return; }
            rp = state.result_path || '';
            if (!rp.endsWith('.xml')) { logWarn('Save did not produce an XML path; aborting async run'); return; }
        } catch(e){ logError('Exception during auto-save; aborting async run'); return; }
    }
    const confirmMsg = 'This action will generate a new CORE scenario and attempt to start it asynchronously using the daemon connection.\n\nProceed?';
    if (!window.confirm(confirmMsg)) { logInfo('Async run cancelled by user at confirmation'); return; }
    const form = new FormData(); form.append('xml_path', rp);
        const res = await fetch("{{ url_for('run_cli_async') }}", { method: 'POST', body: form });
    if (!res.ok) { alert('Failed to start run'); return; }
    const { run_id } = await res.json();
    logInfo(`Async run started id=${run_id}`);
    startLogStream(run_id);
    pollRunStatus(run_id);
}

// Save XML via JSON API without navigation
async function saveXmlAjax(){
    try {
        const payload = { scenarios: state.scenarios };
        const res = await fetch('/save_xml_api', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload)
        });
        if (!res.ok) { try { const err = await res.json(); logWarn('Save failed: ' + (err?.error || res.status)); } catch(e){ logWarn('Save failed'); } return false; }
        const data = await res.json();
        if (data && data.ok && data.result_path) {
            state.result_path = data.result_path;
            persistEditorState();
            logInfo('Scenarios saved to ' + data.result_path);
            // Refresh XML preview lazily
            try {
                const xmlPre = document.getElementById('xmlPre');
                if (xmlPre) {
                    const txt = await (await fetch('/download_report?path=' + encodeURIComponent(data.result_path))).text();
                    xmlPre.textContent = txt;
                }
            } catch(e){}
            return true;
        }
        logWarn('Save did not return a valid path');
        return false;
    } catch(e) { logError('Save threw an exception'); return false; }
}
let evtSrc = null;
function startLogStream(runId) {
    if (evtSrc) { try { evtSrc.close(); } catch(e){} }
    evtSrc = new EventSource('/stream/' + runId);
    // keep existing logs; do not auto-clear
    // Ensure dock is visible so users can see live logs
    try {
        const showBtn = document.getElementById('dockShowBtn');
        if (showBtn && !showBtn.classList.contains('d-none')) { showBtn.click(); }
    } catch(e){}
    // Toggle buttons
    document.getElementById('runAsyncBtn').classList.add('d-none');
    document.getElementById('runSyncBtn').classList.add('disabled');
    document.getElementById('cancelRunBtn').classList.remove('d-none');
    evtSrc.onmessage = (ev) => {
        const raw = ev.data || '';
        let lvl = 'INFO';
        if (/\bERROR\b/.test(raw)) lvl = 'ERROR';
        else if (/\bWARN(ING)?\b/.test(raw)) lvl = 'WARN';
        else if (/\bDEBUG\b/.test(raw)) lvl = 'DEBUG';
        logLine(lvl, raw);
    };
    evtSrc.addEventListener('end', () => {
        evtSrc.close();
        document.getElementById('runAsyncBtn').classList.remove('d-none');
        document.getElementById('runSyncBtn').classList.remove('disabled');
        document.getElementById('cancelRunBtn').classList.add('d-none');
        logInfo('Async run ended');
    });
}

async function pollRunStatus(runId) {
    const xmlPre = document.getElementById('xmlPre');
    try {
    const res = await fetch('/run_status/' + runId);
        if (!res.ok) return;
        const data = await res.json();
        // Update download link
        const rp = data.report_path || data.xml_path;
        if (rp) { state.result_path = rp; persistEditorState(); }
        // Refresh XML preview if we have the xml path and it's changed
        if (data.xml_path && xmlPre && !xmlPre.textContent.trim()) {
                    try {
                        const txt = await (await fetch('/download_report?path=' + encodeURIComponent(data.xml_path))).text();
                        xmlPre.textContent = txt;
                    } catch(e){}
        }
        if (!data.done) {
            setTimeout(() => pollRunStatus(runId), 1000);
        } else {
            if (data.returncode === 0) {
                setTimeout(() => { window.location.href = "{{ url_for('reports_page') }}"; }, 500);
            }
        }
    } catch(e) {
        // ignore transient errors
        setTimeout(() => pollRunStatus(runId), 1500);
    }
}

    async function cancelRun() {
        if (!evtSrc) return;
        // Extract runId from the EventSource URL
        const url = evtSrc.url;
        const runId = url.split('/').pop();
        try {
            await fetch('/cancel_run/' + runId, { method: 'POST' });
        } catch(e) {}
    try { evtSrc.close(); } catch(e){}
        document.getElementById('runAsyncBtn').classList.remove('d-none');
        document.getElementById('runSyncBtn').classList.remove('disabled');
        document.getElementById('cancelRunBtn').classList.add('d-none');
    logInfo('Run cancelled by user');
    }

// --- Run CLI via modal (async under the hood) ---
let runProgressModalInst = null;
let runProgressEvtSrc = null;
let runProgressRunId = null;
function ensureRunProgressModal(){
    if(!runProgressModalInst){
        const el = document.getElementById('runProgressModal');
        if(el){ runProgressModalInst = new bootstrap.Modal(el, { backdrop: 'static', keyboard: false }); }
    }
    return runProgressModalInst;
}
function runProgressLogLine(s){
    const pre = document.getElementById('runProgressLog');
    if(!pre) return;
    pre.textContent += (s||'') + '\n';
    pre.parentElement?.scrollTo({ top: pre.parentElement.scrollHeight });
    // Also mirror into dock logs with level detection
    try {
        const raw = s || '';
        let lvl = 'INFO';
        if (/\bERROR\b/.test(raw)) lvl = 'ERROR';
        else if (/\bWARN(ING)?\b/.test(raw)) lvl = 'WARN';
        else if (/\bDEBUG\b/.test(raw)) lvl = 'DEBUG';
        logLine(lvl, raw);
    } catch(e){}
}
function openRunProgress(title){
    ensureRunProgressModal();
    try {
        if(title) document.querySelector('#runProgressModal .modal-title').textContent = title;
        document.getElementById('runProgressStatus').textContent = 'Starting…';
        document.getElementById('runProgressMeta').textContent = '';
        document.getElementById('runProgressBar').classList.add('progress-bar-animated');
        document.getElementById('runProgressLog').textContent = '';
        // Reset footer buttons to default state
        const hideBtn = document.getElementById('runProgressHideBtn');
        if (hideBtn) {
            hideBtn.textContent = 'Hide';
            hideBtn.onclick = null; // remove any prior navigation handler
        }
        runProgressModalInst?.show();
    } catch(e){}
}
function closeRunProgress(){
    try { if(runProgressEvtSrc) runProgressEvtSrc.close(); } catch(e){}
    runProgressEvtSrc = null;
    runProgressRunId = null;
    try { runProgressModalInst?.hide(); } catch(e){}
}
async function runSyncWithModal(ev){
    if(ev) ev.preventDefault();
    // Validate saved XML
    let rp = state.result_path || '';
    if (!rp.endsWith('.xml')) {
        const go = window.confirm('Your XML has not been saved. Save now and then run?');
        if (!go) { logInfo('Run CLI cancelled by user (declined save)'); return false; }
        try {
            const ok = await saveXmlAjax();
            if (!ok) { logWarn('Save failed; aborting run'); return false; }
            rp = state.result_path || '';
            if (!rp.endsWith('.xml')) { logWarn('Save did not produce an XML path; aborting run'); return false; }
        } catch(e){ logError('Exception during auto-save; aborting run'); return false; }
    }
    const confirmMsg = 'This will generate a CORE scenario and attempt to start it. Proceed?';
    if (!window.confirm(confirmMsg)) { logInfo('Run CLI cancelled by user at confirmation'); return false; }
    openRunProgress('Running CLI…');
    try {
        // Ensure dock is visible
        try {
            const showBtn = document.getElementById('dockShowBtn');
            if (showBtn && !showBtn.classList.contains('d-none')) { showBtn.click(); }
        } catch(e){}
        const form = new FormData(); form.append('xml_path', rp);
        const res = await fetch("{{ url_for('run_cli_async') }}", { method: 'POST', body: form });
        if(!res.ok){ runProgressLogLine('Failed to start CLI'); return false; }
        const { run_id } = await res.json();
        runProgressRunId = run_id;
        // No Cancel button in modal; runs cannot be cancelled here
        // Start SSE stream into modal
        try { if(runProgressEvtSrc) runProgressEvtSrc.close(); } catch(e){}
        runProgressEvtSrc = new EventSource('/stream/' + run_id);
        runProgressEvtSrc.onmessage = (ev)=>{ runProgressLogLine(ev.data||''); };
        runProgressEvtSrc.addEventListener('end', ()=>{ try { runProgressEvtSrc.close(); } catch(e){} logInfo('Run (modal) ended'); });
        // Poll for completion and update meta
        (async function poll(){
            try{
                const r = await fetch('/run_status/' + run_id);
                if(!r.ok){ setTimeout(poll, 1200); return; }
                const data = await r.json();
                if(data.report_path || data.xml_path){
                    state.result_path = data.report_path || data.xml_path;
                    persistEditorState();
                }
                const metaEl = document.getElementById('runProgressMeta');
                if(metaEl){ metaEl.textContent = data.done ? (data.returncode===0 ? 'Completed' : 'Failed') : 'Running…'; }
                if(!data.done){ setTimeout(poll, 1000); return; }
                document.getElementById('runProgressStatus').textContent = (data.returncode===0) ? 'Scenario started' : 'Finished with errors';
                document.getElementById('runProgressBar').classList.remove('progress-bar-animated');
                // If successful, redirect to Reports page
                try {
                    if (data.returncode === 0) {
                        setTimeout(() => { window.location.href = "{{ url_for('reports_page') }}"; }, 500);
                    }
                } catch(e){}
            } catch(e){ setTimeout(poll, 1500); }
        })();
    } catch(e){ runProgressLogLine('Exception starting CLI'); }
    return false; // prevent default form submit
}

// Run deterministically with a seed (preview seed or input)
async function runWithSeedBuild(){
    // Ensure XML is saved
    let rp = state.result_path || '';
    if(!rp.endsWith('.xml')){
        const go = window.confirm('XML not saved yet. Save now?');
        if(!go) return;
        const saved = await saveXmlAjax();
        if(!saved){ alert('Auto-save failed; cannot run.'); return; }
        rp = state.result_path || '';
        if(!rp.endsWith('.xml')){ alert('Saved XML path unresolved.'); return; }
    }
    // Derive seed: prefer explicit input, else current preview seed
    // seedInputEl removed
    let seedVal = null;
    if(seedInputEl && seedInputEl.value.trim()){
        const num = parseInt(seedInputEl.value.trim(),10); if(!isNaN(num) && num>0) seedVal = num;
    } else if(previewState.fullPreview && previewState.fullPreview.seed){
        seedVal = previewState.fullPreview.seed;
    }
    if(seedVal===null){
        alert('Enter a seed or generate a Full Preview (which records a seed) first.');
        return;
    }
    const confirmMsg = `Run CLI with seed=${seedVal}? This will start a CORE session.`;
    if(!window.confirm(confirmMsg)) return;
    openRunProgress('Running CLI (seed='+seedVal+')…');
    try {
        // Show dock logs
        try { const showBtn=document.getElementById('dockShowBtn'); if(showBtn && !showBtn.classList.contains('d-none')) showBtn.click(); } catch(e){}
        const res = await fetch("{{ url_for('run_cli_async') }}", {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ xml_path: rp, seed: seedVal })
        });
        if(!res.ok){ runProgressLogLine('Failed to start seeded run'); return; }
        const { run_id } = await res.json();
        runProgressRunId = run_id;
        // Stream logs
        try { if(runProgressEvtSrc) runProgressEvtSrc.close(); } catch(e){}
        runProgressEvtSrc = new EventSource('/stream/' + run_id);
        runProgressEvtSrc.onmessage = (ev)=> runProgressLogLine(ev.data||'');
        runProgressEvtSrc.addEventListener('end', ()=>{ try { runProgressEvtSrc.close(); } catch(e){} });
        // Poll status similar to runSyncWithModal
        (async function poll(){
            try{
                const r = await fetch('/run_status/' + run_id);
                if(!r.ok){ setTimeout(poll, 1200); return; }
                const data = await r.json();
                if(data.report_path || data.xml_path){ state.result_path = data.report_path || data.xml_path; persistEditorState(); }
                const metaEl = document.getElementById('runProgressMeta'); if(metaEl) metaEl.textContent = data.done ? (data.returncode===0 ? 'Completed' : 'Failed') : 'Running…';
                if(!data.done){ setTimeout(poll, 1000); return; }
                document.getElementById('runProgressStatus').textContent = (data.returncode===0) ? 'Scenario started' : 'Finished with errors';
                document.getElementById('runProgressBar').classList.remove('progress-bar-animated');
                if(data.returncode===0){ setTimeout(()=>{ window.location.href = "{{ url_for('reports_page') }}"; }, 600); }
            } catch(e){ setTimeout(poll, 1500); }
        })();
    } catch(e){ runProgressLogLine('Exception starting seeded run'); }
}

    function redistributeEven(sidx, secName) {
        const items = state.scenarios[sidx].sections[secName].items;
        const n = items.length;
        if (n === 0) return;
    const weightIdxs = items.map((it,i) => ({i,it})).filter(x => ((x.it.v_metric|| (x.it.selected==='Specific'?'Count':'Weight')) === 'Weight')).map(x => x.i);
    const m = weightIdxs.length;
    if (m === 0) { return; }
    const even = Math.round((1.0 / m) * 1000) / 1000;
    weightIdxs.slice(0, -1).forEach(i => { items[i].factor = even; });
        // last item gets the residual to hit 1.0
    const sumOther = weightIdxs.slice(0, -1).reduce((a, i) => a + (parseFloat(items[i].factor)||0), 0);
    const lastIdx = weightIdxs[weightIdxs.length - 1];
    items[lastIdx].factor = Math.max(0, Math.round((1.0 - sumOther) * 1000) / 1000);
        updateWeightWarning(sidx, secName);
    }

    function adjustWeightsProportionally(sidx, secName, changedIdx) {
        const items = state.scenarios[sidx].sections[secName].items;
        const n = items.length;
    const weightIdxs = items.map((it,i) => ({i,it})).filter(x => ((x.it.v_metric|| (x.it.selected==='Specific'?'Count':'Weight')) === 'Weight')).map(x => x.i);
        const m = weightIdxs.length;
        if (m <= 1) { if (m === 1) items[weightIdxs[0]].factor = 1.0; return; }
        // clamp changed value
        items[changedIdx].factor = Math.max(0, Math.min(1, parseFloat(items[changedIdx].factor)||0));
        const targetSum = 1.0;
        const changed = parseFloat(items[changedIdx].factor)||0;
        const others = weightIdxs.map(i => i !== changedIdx ? (parseFloat(items[i].factor)||0) : 0);
        const sumOthers = others.reduce((a,b) => a + b, 0);
        const residual = Math.max(0, targetSum - changed);
        if (sumOthers <= 0) {
            // Distribute evenly across others
            const even = residual / (m - 1);
            weightIdxs.forEach(i => { if (i !== changedIdx) items[i].factor = Math.round(even * 1000) / 1000; });
        } else {
            // Scale others proportionally to keep overall sum 1.0
            weightIdxs.forEach((i, idx) => {
                if (i === changedIdx) return;
                const ratio = others[idx] / sumOthers;
                items[i].factor = Math.round((residual * ratio) * 1000) / 1000;
            });
        }
        // Final normalization to exact 1.000 with 3 decimals
        normalizeToThousandths(sidx, secName);
    }

    function updateWeightWarning(sidx, secName) {
        const items = state.scenarios[sidx].sections[secName].items;
    // Exempt Node Information from weight validation (single Random item default)
    if (secName === 'Node Information') return;
    if (!items || items.length === 0) return;
        const sum = Math.round(items.reduce((a,b) => {
            const metric = b.v_metric || (b.selected==='Specific'?'Count':'Weight');
            return a + (metric==='Weight' ? (parseFloat(b.factor)||0) : 0);
        }, 0) * 1000) / 1000;
    const warn = document.querySelector(".section-warning[data-scen-idx='" + sidx + "'][data-sec='" + secName + "']");
        if (warn) {
            const density = parseFloat((state.scenarios[sidx].sections[secName]||{}).density);
            const weightCount = items.filter(b => (b.v_metric || (b.selected==='Specific'?'Count':'Weight')) === 'Weight').length;
            const badWeights = weightCount > 0 ? (Math.abs(sum - 1.0) > 0.005) : false;
            // Routing density: allow any density >= 0 (>=1 means absolute router count)
            // Other sections: keep 0..1 constraint
            const badDensity = isNaN(density) ? false : (
                secName === 'Routing' ? (density < 0) : (density < 0 || density > 1)
            );
            warn.style.display = (badWeights || badDensity) ? 'block' : 'none';
            let msgs = [];
            if (badWeights) msgs.push('Weights must sum to 1.000 (current: ' + sum.toFixed(3) + ')');
            if (badDensity) {
                if (secName === 'Routing') {
                    msgs.push('Routing density must be >= 0 (current: ' + density.toFixed(2) + '). Tip: < 1 = fraction of hosts; ≥ 1 = absolute router count.');
                } else {
                    msgs.push('Density must be between 0 and 1 (current: ' + density.toFixed(2) + ')');
                }
            }
            warn.textContent = msgs.join(' • ');
        }
    }

    function normalizeToThousandths(sidx, secName) {
        const items = state.scenarios[sidx].sections[secName].items;
        if (!items || items.length === 0) return;
        const vals = items.map(it => {
            const metric = it.v_metric || (it.selected==='Specific'?'Count':'Weight');
            const v = Math.max(0, Math.min(1, parseFloat(it.factor)||0));
            return metric==='Weight' ? v : 0;
        });
        // Convert to thousandths without rounding first
        const thousandthsRaw = vals.map(v => v * 1000);
        const floors = thousandthsRaw.map(v => Math.floor(v));
        let sumFloors = floors.reduce((a,b) => a + b, 0);
        let remainder = 1000 - sumFloors;
        if (remainder > 0) {
            // Distribute +1 to largest fractional parts
            const remainders = thousandthsRaw.map((v, i) => ({ idx: i, frac: v - floors[i] }));
            remainders.sort((a,b) => b.frac - a.frac);
            for (let k = 0; k < remainders.length && remainder > 0; k++) {
                floors[remainders[k].idx] += 1; remainder -= 1;
            }
        } else if (remainder < 0) {
            // Remove -1 from largest values to reduce sum to 1000
            const order = floors.map((v,i) => ({ idx: i, v }));
            order.sort((a,b) => b.v - a.v);
            while (remainder < 0) {
                for (let k = 0; k < order.length && remainder < 0; k++) {
                    const i = order[k].idx;
                    if (floors[i] > 0) { floors[i] -= 1; remainder += 1; }
                }
                if (order.length === 0) break;
            }
        }
        for (let i = 0; i < items.length; i++) {
            const metric = items[i].v_metric || (items[i].selected==='Specific'?'Count':'Weight');
            items[i].factor = (metric==='Weight') ? (floors[i] / 1000.0) : (items[i].factor||0);
        }
    }

    function updateWeightInputsDisplay(sidx, secName) {
        const items = state.scenarios[sidx].sections[secName].items;
    document.querySelectorAll("input.weight-input[data-scen-idx='" + sidx + "'][data-sec='" + secName + "']").forEach(input => {
            const iidx = parseInt(input.getAttribute('data-item-idx'));
            if (!isNaN(iidx) && items[iidx]) {
                input.value = (parseFloat(items[iidx].factor) || 0).toFixed(3);
            }
        });
    }

    // Dock setup handled by partial
</script>
</body>
<!-- Toast container -->
<div aria-live="polite" aria-atomic="true" class="position-fixed" style="z-index: 1080; right: 12px; bottom: 12px;">
    <div id="toastContainer" class="toast-container"></div>
    <template id="toastTemplate">
        <div class="toast align-items-center text-bg-dark border-0" role="alert" aria-live="assertive" aria-atomic="true">
            <div class="d-flex">
                <div class="toast-body">Action completed.</div>
                <button type="button" class="btn-close btn-close-white me-2 m-auto" data-bs-dismiss="toast" aria-label="Close"></button>
            </div>
        </div>
    </template>
    <script>
        function showToast(message, opts){
            try {
                const container = document.getElementById('toastContainer');
                const tmpl = document.getElementById('toastTemplate');
                if(!container || !tmpl) return;
                const node = tmpl.content.firstElementChild.cloneNode(true);
                node.querySelector('.toast-body').textContent = message || 'Done';
                container.appendChild(node);
                const t = new bootstrap.Toast(node, Object.assign({ delay: 2500, autohide: true }, (opts||{})));
                t.show();
                node.addEventListener('hidden.bs.toast', () => { try { node.remove(); } catch(e){} });
            } catch(e){}
        }
    </script>
</div>
<!-- Success Modal -->
<div class="modal fade" id="runSuccessModal" tabindex="-1" aria-hidden="true">
    <div class="modal-dialog modal-dialog-centered">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title">Run Completed</h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
                <p class="mb-1" id="runSuccessBody">Generation complete.</p>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
            </div>
        </div>
    </div>
</div>
<script>
function showRunSuccessModal(msg){
    try { if(msg) document.getElementById('runSuccessBody').textContent = msg; new bootstrap.Modal(document.getElementById('runSuccessModal')).show(); } catch(e){}
}
document.addEventListener('DOMContentLoaded', () => {
    if (window.runSuccessFlag) {
        setTimeout(() => { window.location.href = "{{ url_for('reports_page') }}"; }, 300);
    }
});
// Capture server-provided flag (injected if present)
// Inject run success flag
window.runSuccessFlag = ("{{ '1' if (run_success is defined and run_success) else '0' }}" === '1');
// Wrap pollRunStatus to detect async completion success
const __origPollRunStatus = pollRunStatus;
pollRunStatus = async function(runId){
    await __origPollRunStatus(runId);
    try {
        const res = await fetch('/run_status/' + runId);
        if(!res.ok) return;
        const data = await res.json();
        if(data.done && data.returncode === 0){
            showRunSuccessModal('Asynchronous run completed successfully.');
        } else if(!data.done) {
            setTimeout(() => pollRunStatus(runId), 800);
        }
    } catch(e){}
};
</script>
{% endblock %}
