{% extends 'layout.html' %}
{% block title %}Flag Sequencing{% endblock %}
{% block active_page %}{% set active_page='scenarios' %}{% endblock %}
{% block header_icon %}<i class="bi bi-bezier2 fs-4"></i>{% endblock %}
{% block header_title %}Flag Sequencing{% endblock %}

{% block extra_head %}
<script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
<style>
  body { padding-bottom: 0; }
  #flowLayoutRow { min-height: calc(100vh - 200px); }
  /* Prevent long <pre>/<svg> content from forcing the Bootstrap row to wrap columns. */
  #flowLayoutRow > [class*='col-'] { min-width: 0; }
  @media (max-width: 992px) {
    #flowLayoutRow { min-height: 0; }
  }
</style>
{% endblock %}

{% block content %}
{% set scenario_tab = (active_scenario or request.args.get('scenario','')) %}
{% set scenarios_active_tab = 'flag-sequencing' %}
{% include 'partials/scenarios_tabs.html' with context %}
<div class="container-fluid mt-3 d-flex flex-column" id="flowPageWrap">
  <div class="row g-3 flex-grow-1 align-items-stretch" id="flowLayoutRow">
    <div class="col-12 col-lg-3 d-flex">
      <div class="card shadow-sm mb-3 flex-fill d-flex flex-column">
        <div class="card-header d-flex justify-content-between align-items-center flex-nowrap gap-2">
          <span class="fw-bold">Scenarios</span>
          <div class="btn-toolbar gap-1 align-items-center flex-nowrap">
            <button type="button" class="btn btn-sm btn-outline-secondary py-0 px-1" id="toggleScenarioSeedBtn" title="Show seeds" aria-label="Toggle seed visibility">
              <i class="bi bi-eye" aria-hidden="true"></i>
            </button>
            <button class="btn btn-sm btn-outline-secondary {% if not active_scenario %}d-none{% endif %}" id="flowScenarioFilterClear" type="button" title="Clear">Clear</button>
          </div>
        </div>
        <div class="list-group list-group-flush flex-grow-1 overflow-auto" id="flowScenarioList" style="min-height:0;">
          {% if scenarios %}
            {% for s in scenarios %}
            <button type="button" class="list-group-item list-group-item-action py-1 {% if active_scenario and active_scenario==s %}active bg-primary text-white{% endif %}" data-scen-name="{{ s }}">
              <div class="d-flex align-items-center">
                <span class="flex-grow-1 text-truncate">{{ s }}</span>
                <span class="badge text-bg-light border ms-2 d-none" data-seed-badge="1"></span>
              </div>
            </button>
            {% endfor %}
          {% else %}
            <div class="p-3 text-muted small">No scenarios yet</div>
          {% endif %}
        </div>
      </div>
    </div>

    <div class="col-12 col-lg-9 d-flex">
      <div class="flex-fill d-flex flex-column">
        <div class="d-flex align-items-center justify-content-between flex-wrap gap-2 mb-3">
          <div class="fw-semibold">Generate an Attack Flow from the latest preview plan</div>
        </div>

        <div class="card mb-3">
          <div class="card-body">
            <input id="flowScenario" class="form-control d-none" value="{{ active_scenario or request.args.get('scenario','') }}">
            <div class="row g-2 align-items-end">
              <div class="col-sm-6 col-md-2">
                <label class="form-label">Chain Length</label>
                <input id="flowLength" class="form-control" type="number" min="1" max="50" value="5">
              </div>
              <div class="col-sm-6 col-md-4">
                <label class="form-label">Preset</label>
                <select id="flowPreset" class="form-select">
                  <option value="">Random (default)</option>
                  <option value="sample_reverse_nfs_ssh">Sample: reverse_nfs_ssh</option>
                </select>
              </div>
              <div class="col-md-6">
                <div class="d-flex gap-2 flex-nowrap">
                  <button id="flowGenerateBtn" class="btn btn-primary text-nowrap" type="button">Generate</button>
                  <a id="flowAfbDownloadLink" class="btn btn-outline-secondary text-nowrap" href="#" role="button">Download Attack Flow Builder (.afb)</a>
                </div>
              </div>
              <div class="col-md-4">
                <div class="small">
                  <span id="flowStatus" class="text-muted" style="white-space: pre-line;"></span>
                  <a id="flowLoginLink" class="ms-2 d-none" href="/login">Login</a>
                </div>
              </div>
            </div>
            <div class="small text-muted mt-2">Current rule: flags are placed on Docker-role nodes and vulnerability nodes. Vulnerability nodes are only assigned <span class="font-monospace">flag-generator</span> flags (not <span class="font-monospace">flag-node-generator</span>). Default chain order is randomized; you can tweak it below.</div>
          </div>
        </div>

        <div id="flowValidityAlert" class="alert alert-danger d-none" role="alert"></div>

        <div class="card mb-3">
          <div class="card-header d-flex align-items-center justify-content-between">
            <div class="fw-semibold">Visualization</div>
          </div>
          <div class="card-body">
            <div class="small mb-2" id="flowMetaRow">
              <table class="table table-sm table-borderless mb-0 align-middle">
                <thead>
                  <tr class="text-secondary">
                    <th scope="col" class="fw-normal" style="width: 18%;">Scenario</th>
                    <th scope="col" class="fw-normal" style="width: 32%;">Preview</th>
                    <th scope="col" class="fw-normal">Eligibility</th>
                  </tr>
                </thead>
                <tbody class="text-muted">
                  <tr>
                    <td id="flowMetaScenario"></td>
                    <td style="min-width: 0; max-width: 0;">
                      <div id="flowMetaPreview" class="text-truncate" style="max-width: 100%;"></div>
                    </td>
                    <td id="flowMetaStats"></td>
                  </tr>
                </tbody>
              </table>
            </div>
            <div id="flowDiagramWrap" class="border rounded p-2" style="min-height: 180px; overflow-x: auto;">
              <div id="flowDiagram" class="mermaid">graph LR\n  A[Generate] --> B[Flow]</div>
            </div>

            <dialog id="flowNodeDetailsDialog" class="p-0 border rounded" style="max-width: 1150px; width: calc(100% - 2rem); max-height: 85vh; overflow: hidden;">
              <form method="dialog" class="m-0" style="display:flex;flex-direction:column;max-height:85vh;">
                <div class="p-3 border-bottom d-flex align-items-center justify-content-between" style="flex:0 0 auto;">
                  <div class="fw-semibold" id="flowNodeDetailsTitle">Node</div>
                  <button class="btn btn-sm btn-outline-secondary" value="close" type="submit">Close</button>
                </div>
                <div class="p-3" style="flex:1 1 auto; overflow: auto;">
                  <div id="flowNodeDetailsBody" class="small"></div>
                </div>
              </form>
            </dialog>

            <dialog id="flowInputsDialog" class="p-0 border rounded" style="max-width: 1150px; width: calc(100% - 2rem); max-height: 85vh; overflow: hidden;">
              <form method="dialog" class="m-0" style="display:flex;flex-direction:column;max-height:85vh;">
                <div class="p-3 border-bottom d-flex align-items-center justify-content-between" style="flex:0 0 auto;">
                  <div class="fw-semibold" id="flowInputsTitle">Inputs</div>
                  <button class="btn btn-sm btn-outline-secondary" value="close" type="submit">Close</button>
                </div>
                <div class="p-3" style="flex:1 1 auto; overflow: auto;">
                  <div id="flowInputsBody" class="small"></div>
                </div>
              </form>
            </dialog>

            <dialog id="flowSubstituteDialog" class="p-0 border rounded" style="max-width: 1150px; width: calc(100% - 2rem); max-height: 85vh; overflow: hidden;">
              <form method="dialog" class="m-0" style="display:flex;flex-direction:column;max-height:85vh;">
                <div class="p-3 border-bottom d-flex align-items-center justify-content-between" style="flex:0 0 auto;">
                  <div class="fw-semibold" id="flowSubstituteTitle">Substitute</div>
                  <button class="btn btn-sm btn-outline-secondary" value="close" type="submit">Close</button>
                </div>
                <div class="p-3" style="flex:1 1 auto; overflow: auto;">
                  <div id="flowSubstituteBody" class="small"></div>
                </div>
              </form>
            </dialog>
          </div>
        </div>

        <div class="card mb-3">
          <div class="card-header d-flex align-items-center justify-content-between">
            <div class="fw-semibold">Chain Order</div>
            <div class="small text-muted">Use ↑/↓ to reorder</div>
          </div>
          <div class="card-body">
            <div class="small text-muted mb-1" aria-hidden="true" style="display:grid;grid-template-columns:84px 1fr 76px;gap:.5rem;align-items:center;">
              <div class="pe-2" style="border-right: 1px solid var(--bs-border-color, #dee2e6);">Sequence</div>
              <div>Details</div>
              <div class="text-end">Reorder</div>
            </div>
            <div id="flowChainList" class="list-group"></div>
            <div class="small text-muted mt-2">Reordering updates the export and download.</div>
          </div>
        </div>

      </div>
    </div>
  </div>
</div>
{% endblock %}

{% block body_container %}
{{ super() }}
{% set xml_preview_enabled = True %}
{% set xml_preview_text = xml_preview %}
{% include 'partials/dock.html' %}

<!-- Loading overlay shown during slow operations (e.g., resolving hint templates via generator runs). -->
<div id="flowLoadingOverlay" class="position-fixed top-0 start-0 w-100 h-100 d-none" style="z-index: 2000;">
  <div class="position-absolute top-0 start-0 w-100 h-100 bg-dark bg-opacity-50"></div>
  <div class="position-absolute top-50 start-50 translate-middle bg-white rounded shadow p-3" style="min-width: 320px; max-width: 560px;">
    <div class="d-flex align-items-center gap-2">
      <div class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></div>
      <div class="fw-semibold" id="flowLoadingText">Loading…</div>
    </div>
    <div class="small text-muted mt-2">This can take a few seconds while generators run and hints resolve.</div>
  </div>
</div>

<!-- Generate options (minimal) -->
<dialog id="flowGenerateOptionsDialog" class="p-0 border rounded" style="max-width: 520px; width: calc(100% - 2rem);">
  <form method="dialog" class="m-0">
    <div class="p-3 border-bottom d-flex align-items-center justify-content-between">
      <div class="fw-semibold">Generate options</div>
      <button class="btn btn-sm btn-outline-secondary" value="cancel" type="submit">Close</button>
    </div>
    <div class="p-3">
      <div class="form-check">
        <input class="form-check-input" type="checkbox" id="flowGenerateNoDuplicates" checked>
        <label class="form-check-label" for="flowGenerateNoDuplicates">No duplicates allowed</label>
      </div>
      <div class="small text-muted mt-2">
        If unchecked, the chain may repeat nodes; repeated rows are highlighted and generator seeds will differ per occurrence.
      </div>
    </div>
    <div class="p-3 border-top d-flex justify-content-end gap-2">
      <button class="btn btn-outline-secondary" value="cancel" type="submit">Cancel</button>
      <button class="btn btn-primary" value="generate" type="submit">Generate</button>
    </div>
  </form>
</dialog>

<script>
(function(){
  const SIDEBAR_SEED_VISIBILITY_STORAGE_KEY = 'coretg_sidebar_show_seed';

  const statusEl = document.getElementById('flowStatus');
  const loginLinkEl = document.getElementById('flowLoginLink');
  const scenarioEl = document.getElementById('flowScenario');
  const scenarioLabelEl = document.getElementById('flowScenarioLabel');
  const lengthEl = document.getElementById('flowLength');
  const presetEl = document.getElementById('flowPreset');
  const btnEl = document.getElementById('flowGenerateBtn');
  const saveXmlEl = document.getElementById('saveXmlBtn');
  const execEl = document.getElementById('scenariosExecuteBtn');
  const downloadXmlEl = document.getElementById('downloadXmlBtn');
  const jsonEl = document.getElementById('flowJson');
  const metaScenarioEl = document.getElementById('flowMetaScenario');
  const metaPreviewEl = document.getElementById('flowMetaPreview');
  const metaStatsEl = document.getElementById('flowMetaStats');

  const nodeDetailsDialogEl = document.getElementById('flowNodeDetailsDialog');
  const nodeDetailsTitleEl = document.getElementById('flowNodeDetailsTitle');
  const nodeDetailsBodyEl = document.getElementById('flowNodeDetailsBody');
  const inputsDialogEl = document.getElementById('flowInputsDialog');
  const inputsTitleEl = document.getElementById('flowInputsTitle');
  const inputsBodyEl = document.getElementById('flowInputsBody');
  const substituteDialogEl = document.getElementById('flowSubstituteDialog');
  const substituteTitleEl = document.getElementById('flowSubstituteTitle');
  const substituteBodyEl = document.getElementById('flowSubstituteBody');
  const afbDownloadLink = document.getElementById('flowAfbDownloadLink');
  const scenarioListEl = document.getElementById('flowScenarioList');
  const clearScenarioBtn = document.getElementById('flowScenarioFilterClear');
  const seedToggleBtn = document.getElementById('toggleScenarioSeedBtn');
  const validityAlertEl = document.getElementById('flowValidityAlert');
  const loadingOverlayEl = document.getElementById('flowLoadingOverlay');
  const loadingTextEl = document.getElementById('flowLoadingText');
  const generateOptionsDialogEl = document.getElementById('flowGenerateOptionsDialog');
  const generateNoDuplicatesEl = document.getElementById('flowGenerateNoDuplicates');

  const participantUrlFlags = {{ (participant_url_flags or {})|tojson }};
  const scenarioNamesCache = {{ (scenarios or [])|tojson }};
  const initialScenario = {{ (active_scenario or '')|tojson }};
  let activeScenario = (initialScenario || (Array.isArray(scenarioNamesCache) && scenarioNamesCache.length ? String(scenarioNamesCache[0]) : '')).trim();

  function getSidebarShowSeed(){
    try { return (localStorage.getItem(SIDEBAR_SEED_VISIBILITY_STORAGE_KEY) || '') === '1'; } catch(e) { return false; }
  }

  function setSidebarShowSeed(value){
    try { localStorage.setItem(SIDEBAR_SEED_VISIBILITY_STORAGE_KEY, value ? '1' : '0'); } catch(e) {}
  }

  function syncSidebarSeedToggleButton(){
    if(!seedToggleBtn) return;
    const show = getSidebarShowSeed();
    const icon = seedToggleBtn.querySelector('i');
    if(icon){
      icon.classList.remove('bi-eye', 'bi-eye-slash');
      icon.classList.add(show ? 'bi-eye-slash' : 'bi-eye');
    }
    seedToggleBtn.title = show ? 'Hide seeds' : 'Show seeds';
  }

  function updateScenarioSeedBadges(){
    if(!scenarioListEl) return;
    const show = getSidebarShowSeed();
    scenarioListEl.querySelectorAll('button[data-scen-name]').forEach((btn)=>{
      const scen = (btn.getAttribute('data-scen-name') || '').trim();
      const badge = btn.querySelector('[data-seed-badge]');
      if(!badge) return;
      if(!show){
        badge.classList.add('d-none');
        badge.textContent = '';
        return;
      }
      let seed = null;
      try {
        if (scen && typeof window.coretgEnsureSeedForScenario === 'function') {
          seed = window.coretgEnsureSeedForScenario(scen);
        }
      } catch(e) { seed = null; }
      badge.textContent = 'seed=' + (seed !== null && seed !== undefined ? String(seed) : '…');
      badge.classList.remove('d-none');
    });
    syncSidebarSeedToggleButton();
  }

  function rememberActiveScenario(){
    try {
      if (activeScenario && typeof window.coretgSetActiveScenarioForNav === 'function') {
        window.coretgSetActiveScenarioForNav(activeScenario);
      } else if (activeScenario && typeof window.coretgSetLastSelectedScenario === 'function') {
        window.coretgSetLastSelectedScenario(activeScenario);
      }
    } catch(e) {}
  }

  let currentChain = [];
  let lastStats = null;
  let lastPreviewPlanPath = '';
  let lastFlowPlanPath = '';
  let currentFlagAssignments = [];
  let selectedChainIndex = -1;
  let lastFlowValid = true;
  let lastFlowErrors = [];
  let lastFlagsEnabled = true;
  let allowNodeDuplicates = false;

  let _flagGeneratorsCatalog = null;
  let _flagNodeGeneratorsCatalog = null;

  async function ensureGeneratorCatalogsLoaded(){
    if(Array.isArray(_flagGeneratorsCatalog) && Array.isArray(_flagNodeGeneratorsCatalog)) return;
    try {
      const [fg, fng] = await Promise.all([
        fetchJson('/flag_generators_data'),
        fetchJson('/flag_node_generators_data'),
      ]);
      _flagGeneratorsCatalog = (fg && Array.isArray(fg.generators)) ? fg.generators.slice() : [];
      _flagNodeGeneratorsCatalog = (fng && Array.isArray(fng.generators)) ? fng.generators.slice() : [];
    } catch(e) {
      _flagGeneratorsCatalog = Array.isArray(_flagGeneratorsCatalog) ? _flagGeneratorsCatalog : [];
      _flagNodeGeneratorsCatalog = Array.isArray(_flagNodeGeneratorsCatalog) ? _flagNodeGeneratorsCatalog : [];
      throw e;
    }
  }

  function compileStringOrRegex(input){
    const raw = String(input || '').trim();
    if(!raw) return { ok: true, regex: null, isRegex: false, error: '' };
    // Mirror the vulnerability chooser: accept /regex/ syntax.
    if(raw.length >= 2 && raw.startsWith('/') && raw.lastIndexOf('/') > 0){
      const lastSlash = raw.lastIndexOf('/');
      const body = raw.slice(1, lastSlash);
      const flags = raw.slice(lastSlash + 1);
      try {
        const re = new RegExp(body, flags || 'i');
        return { ok: true, regex: re, isRegex: true, error: '' };
      } catch(e) {
        return { ok: false, regex: null, isRegex: true, error: String(e && e.message || e || 'Invalid regex') };
      }
    }
    // Plain string match (case-insensitive substring).
    try {
      const escaped = raw.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
      return { ok: true, regex: new RegExp(escaped, 'i'), isRegex: false, error: '' };
    } catch(e) {
      return { ok: false, regex: null, isRegex: false, error: String(e && e.message || e || 'Invalid filter') };
    }
  }

  function persistFlowState(){
    try {
      const scenario = (scenarioEl && scenarioEl.value || '').trim();
      if(!scenario) return;
      const preset = (presetEl && presetEl.value) ? String(presetEl.value).trim() : '';
      const chainIds = Array.isArray(currentChain) ? currentChain.map(n => (n && n.id) ? String(n.id) : '').filter(Boolean) : [];
      if(!chainIds.length) return;
      if(typeof window.coretgSetSavedFlowStateForScenario !== 'function') return;
      window.coretgSetSavedFlowStateForScenario(scenario, {
        preset,
        length: chainIds.length,
        chain_ids: chainIds,
      });
    } catch(e) {}
  }

  function toRoman(n){
    const num = parseInt(n, 10);
    if(!Number.isFinite(num) || num <= 0) return '';
    const map = [
      [1000,'M'], [900,'CM'], [500,'D'], [400,'CD'],
      [100,'C'], [90,'XC'], [50,'L'], [40,'XL'],
      [10,'X'], [9,'IX'], [5,'V'], [4,'IV'], [1,'I']
    ];
    let x = num;
    let out = '';
    for(const [v,s] of map){
      while(x >= v){
        out += s;
        x -= v;
      }
    }
    return out;
  }

  function showLoading(text){
    try{
      if(!loadingOverlayEl) return;
      if(loadingTextEl) loadingTextEl.textContent = (text || 'Loading…').toString();
      loadingOverlayEl.classList.remove('d-none');
    } catch(e) {}
  }

  function hideLoading(){
    try{
      if(!loadingOverlayEl) return;
      loadingOverlayEl.classList.add('d-none');
    } catch(e) {}
  }

  function setFlowValidityFromPayload(payload){
    const p = payload && typeof payload === 'object' ? payload : null;
    const flowValid = p && ('flow_valid' in p) ? !!p.flow_valid : true;
    const flagsEnabled = p && ('flags_enabled' in p) ? !!p.flags_enabled : true;
    const flowErrors = (p && Array.isArray(p.flow_errors)) ? p.flow_errors.slice() : [];
    lastFlowValid = flowValid;
    lastFlagsEnabled = flagsEnabled;
    lastFlowErrors = flowErrors;
    if(!validityAlertEl) return;
    if(flowValid && flagsEnabled){
      validityAlertEl.classList.add('d-none');
      validityAlertEl.textContent = '';
      return;
    }
    const base = 'Invalid flag dependency order: execution will NOT include flags.';
    const details = flowErrors.length ? (' ' + flowErrors.join(' | ')) : '';
    validityAlertEl.textContent = base + details;
    validityAlertEl.classList.remove('d-none');
  }

  async function refreshXmlDockPreview({ force = false } = {}){
    const xmlPre = document.getElementById('xmlPre');
    if(!xmlPre) return;
    const xmlPath = (document.getElementById('scenariosPreviewXmlPath')?.value || '').trim();
    const lastPath = (xmlPre.dataset.xmlPreviewPath || '').trim();
    if(!xmlPath){
      if(force){
        try { xmlPre.textContent = ''; } catch(e) {}
        try { xmlPre.dataset.xmlPreviewPath = ''; } catch(e) {}
      }
      return;
    }
    if(!force && xmlPre.textContent.trim() && lastPath === xmlPath) return;
    try {
      const res = await fetch('/download_report?path=' + encodeURIComponent(xmlPath), { credentials: 'same-origin' });
      if(!res.ok) return;
      const txt = await res.text();
      try { xmlPre.textContent = txt || ''; } catch(e) {}
      try { xmlPre.dataset.xmlPreviewPath = xmlPath; } catch(e) {}
    } catch(e) {}
  }

  function normalizeScenarioNorm(raw){
    return (raw || '').toString().trim().toLowerCase().replace(/\s+/g, ' ');
  }

  function defaultScenarioName(){
    return (Array.isArray(scenarioNamesCache) && scenarioNamesCache.length) ? String(scenarioNamesCache[0]) : null;
  }

  function updateScenarioQueryParam(){
    try {
      const url = new URL(window.location.href);
      if(activeScenario){
        url.searchParams.set('scenario', activeScenario);
      } else {
        url.searchParams.delete('scenario');
      }
      window.history.replaceState({}, '', url.toString());
    } catch(e) {}
  }

  function updateScenarioFilterControls(){
    try {
      if(clearScenarioBtn){
        const def = defaultScenarioName();
        const show = !!activeScenario && !!def && activeScenario !== def;
        clearScenarioBtn.classList.toggle('d-none', !show);
      }
      if(!scenarioListEl) return;
      scenarioListEl.querySelectorAll('[data-scen-name]').forEach(btn => {
        const name = btn.getAttribute('data-scen-name');
        const isActive = !!activeScenario && name === activeScenario;
        btn.classList.toggle('active', isActive);
        btn.classList.toggle('bg-primary', isActive);
        btn.classList.toggle('text-white', isActive);
      });
    } catch(e) {}
  }

  function refreshParticipantNavForScenario(scenarioName){
    try {
      const scen = (scenarioName || '').toString().trim();
      if (typeof window.CORETG_PATCH_SCENARIO_NAV === 'function') {
        window.CORETG_PATCH_SCENARIO_NAV(scen);
      }
      const norm = normalizeScenarioNorm(scen);
      const hasParticipant = !!participantUrlFlags[norm];
      if (typeof window.CORETG_SET_PARTICIPANT_NAV_VISIBLE === 'function') {
        window.CORETG_SET_PARTICIPANT_NAV_VISIBLE(hasParticipant);
      }
    } catch(e) {}
  }

  async function setScenario(value){
    activeScenario = (value || defaultScenarioName() || '').toString().trim();
    if(scenarioEl) scenarioEl.value = activeScenario;
    if(scenarioLabelEl) scenarioLabelEl.textContent = activeScenario;
    updateScenarioQueryParam();
    updateScenarioFilterControls();
    refreshParticipantNavForScenario(activeScenario);
    rememberActiveScenario();
    updateScenarioSeedBadges();
    // When switching scenarios (or loading after refresh), prefer any saved Flow state.
    await generate(false);
  }

  function setStatus(msg, isError){
    if(!statusEl) return;
    let out = msg || '';
    // Improve readability of eligibility errors:
    // "Requires … Current: …" -> put "Current:" on the next line.
    try{
      if(out && typeof out === 'string' && out.includes('Requires') && out.includes('Current:')){
        out = out.replace(/\s+Current:/, '\nCurrent:');
      }
    } catch(e) {}
    statusEl.textContent = out;
    statusEl.classList.toggle('text-danger', !!isError);
    statusEl.classList.toggle('text-muted', !isError);
  }

  function setLoginLinkVisible(visible){
    try{
      if(!loginLinkEl) return;
      loginLinkEl.classList.toggle('d-none', !visible);
    } catch(e) {}
  }

  function basenameFromPath(p){
    try{
      const s = (p||'').toString();
      const parts = s.split('/');
      return parts[parts.length-1] || s;
    } catch(e){
      return (p||'').toString();
    }
  }

  async function fetchJson(url, opts){
    opts = opts || {};
    const timeoutMs = Number.isFinite(+opts.timeoutMs) ? (+opts.timeoutMs) : 0;
    const controller = (typeof AbortController !== 'undefined') ? new AbortController() : null;
    const signal = controller ? controller.signal : undefined;
    let t = null;
    if(controller && timeoutMs > 0){
      t = setTimeout(() => { try{ controller.abort(); } catch(e){} }, timeoutMs);
    }
    let res;
    try{
      res = await fetch(url, { credentials: 'same-origin', signal });
    } catch(e){
      if(controller && e && (e.name === 'AbortError')){
        const err = new Error('Request timed out.');
        err.isTimeout = true;
        throw err;
      }
      throw e;
    } finally {
      if(t) clearTimeout(t);
    }
    const ct = (res.headers.get('content-type') || '').toLowerCase();
    if(!ct.includes('application/json')){
      const text = await res.text();
      if(res.redirected || (text && text.includes('<html'))){
        const err = new Error('Login required.');
        err.loginRequired = true;
        throw err;
      }
      throw new Error('Non-JSON response');
    }
    const data = await res.json();
    if(!res.ok){
      const err = new Error((data && (data.error || data.message)) || ('HTTP ' + res.status));
      err.payload = data;
      if(res.status === 401) err.loginRequired = true;
      throw err;
    }
    return data;
  }

  async function postJson(url, payload, opts){
    opts = opts || {};
    const timeoutMs = Number.isFinite(+opts.timeoutMs) ? (+opts.timeoutMs) : 0;
    const controller = (typeof AbortController !== 'undefined') ? new AbortController() : null;
    const signal = controller ? controller.signal : undefined;
    let t = null;
    if(controller && timeoutMs > 0){
      t = setTimeout(() => { try{ controller.abort(); } catch(e){} }, timeoutMs);
    }
    let res;
    try{
      res = await fetch(url, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      credentials: 'same-origin',
      body: JSON.stringify(payload || {}),
      signal,
      });
    } catch(e){
      if(controller && e && (e.name === 'AbortError')){
        const err = new Error('Request timed out.');
        err.isTimeout = true;
        throw err;
      }
      throw e;
    } finally {
      if(t) clearTimeout(t);
    }
    const ct = (res.headers.get('content-type') || '').toLowerCase();
    if(!ct.includes('application/json')){
      const text = await res.text();
      if(res.redirected || (text && text.includes('<html'))){
        const err = new Error('Login required.');
        err.loginRequired = true;
        throw err;
      }
      throw new Error('Non-JSON response');
    }
    const data = await res.json();
    if(!res.ok){
      const err = new Error((data && (data.error || data.message)) || ('HTTP ' + res.status));
      err.payload = data;
      if(res.status === 401) err.loginRequired = true;
      throw err;
    }
    return data;
  }

  function chainFeasibility(assignments){
    // Returns per-index feasibility based on cumulative outputs.
    // Shape: {ok:boolean, missing:string[], missing_artifacts:string[], missing_fields:string[]}
    const out = [];
    // Keep in sync with server-side synthesized Flow inputs (see _flow_default_generator_config).
    const synthesizedFields = ['seed','secret','env_name','challenge','flag_prefix','username_prefix','key_len','node_name'];
    const synthesizedSet = new Set(synthesizedFields);
    const haveEffective = new Set(synthesizedFields);
    // Track origin so UI can show "Provided by Chain" vs "Provided by Sequencer".
    const haveArtifactsChain = new Set();
    const haveArtifactsSequencer = new Set();
    const haveFieldsChain = new Set();
    const haveFieldsSequencer = new Set(synthesizedFields);
    const haveArtifacts = new Set();
    const haveFields = new Set(synthesizedFields);
    if(!Array.isArray(assignments)) return out;
    for(let i=0;i<assignments.length;i++){
      const a = assignments[i] || {};

      const hasSplit = Array.isArray(a.requires) || Array.isArray(a.input_fields_required) || Array.isArray(a.input_fields);
      if(hasSplit){
        const reqArtifactsRaw = Array.isArray(a.requires) ? a.requires.map(String) : [];
        // Some generator definitions historically mixed synthesized "fields" into
        // `requires` (artifacts). Normalize those back into the Fields bucket.
        const reqArtifacts = reqArtifactsRaw.filter(k => k && !synthesizedSet.has(k));
        const reqFieldsBase = Array.isArray(a.input_fields_required)
          ? a.input_fields_required.map(String)
          : (Array.isArray(a.input_fields) ? a.input_fields.map(String) : []);
        const reqFields = reqFieldsBase.concat(reqArtifactsRaw.filter(k => k && synthesizedSet.has(k)));
        const optFields = Array.isArray(a.input_fields_optional) ? a.input_fields_optional.map(String) : [];
        const optSet = new Set(optFields.filter(Boolean));

        const reqArtifactsEffective = reqArtifacts.filter(k => k && !optSet.has(k));
        const providedByChainArtifacts = reqArtifactsEffective.filter(k => k && haveArtifactsChain.has(k));
        const providedBySequencerArtifacts = reqArtifactsEffective.filter(k => k && haveArtifactsSequencer.has(k));
        const missingArtifacts = reqArtifactsEffective.filter(k => k && !haveArtifacts.has(k));

        const providedByChainFields = reqFields.filter(k => k && haveFieldsChain.has(k));
        const providedBySequencerFields = reqFields.filter(k => k && haveFieldsSequencer.has(k));
        const missingFields = reqFields.filter(k => k && !haveFields.has(k));

        const missing = missingArtifacts.concat(missingFields);
        out.push({
          ok: missing.length === 0,
          missing,
          missing_artifacts: missingArtifacts,
          missing_fields: missingFields,
          providing_artifacts_chain: providedByChainArtifacts,
          providing_artifacts_sequencer: providedBySequencerArtifacts,
          providing_fields_chain: providedByChainFields,
          providing_fields_sequencer: providedBySequencerFields,
        });
      } else {
        const reqEffective = Array.isArray(a.inputs) ? a.inputs.map(String) : [];
        const providingChain = reqEffective.filter(k => k && (haveArtifactsChain.has(k) || haveFieldsChain.has(k)));
        const providingSequencer = reqEffective.filter(k => k && (haveArtifactsSequencer.has(k) || haveFieldsSequencer.has(k)));
        const missing = reqEffective.filter(k => k && !haveEffective.has(k));
        out.push({
          ok: missing.length === 0,
          missing,
          missing_artifacts: [],
          missing_fields: [],
          providing_effective_chain: providingChain,
          providing_effective_sequencer: providingSequencer,
        });
      }

      const provEffective = Array.isArray(a.outputs) ? a.outputs.map(String) : [];
      provEffective.forEach(k => { if(k) haveEffective.add(k); });

      if(Array.isArray(a.produces)){
        a.produces.map(String).forEach(k => {
          if(!k) return;
          haveArtifacts.add(k);
          haveArtifactsChain.add(k);
        });
      }
      if(Array.isArray(a.output_fields)){
        a.output_fields.map(String).forEach(k => {
          if(!k) return;
          haveFields.add(k);
          haveFieldsChain.add(k);
        });
      }
    }
    return out;
  }

  function renderChainEditor(){
    const wrap = document.getElementById('flowChainList');
    if(!wrap) return;
    wrap.innerHTML = '';
    if(!Array.isArray(currentChain) || currentChain.length === 0){
      const empty = document.createElement('div');
      empty.className = 'text-muted small';
      empty.textContent = 'Generate a flow to populate the chain.';
      wrap.appendChild(empty);
      return;
    }

    const idCounts = {};
    const idFirstIdx = {};
    const genCounts = {};
    const genFirstIdx = {};
    try{
      currentChain.forEach((n, idx) => {
        const id = (n && n.id) ? String(n.id).trim() : '';
        if(!id) return;
        idCounts[id] = (idCounts[id] || 0) + 1;
        if(idFirstIdx[id] === undefined) idFirstIdx[id] = idx;
      });

      // Generator ids by position.
      currentChain.forEach((_n, idx) => {
        const fa = (Array.isArray(currentFlagAssignments) && currentFlagAssignments[idx]) ? currentFlagAssignments[idx] : null;
        const gid = fa && (fa.id || fa.generator_id) ? String(fa.id || fa.generator_id).trim() : '';
        if(!gid) return;
        genCounts[gid] = (genCounts[gid] || 0) + 1;
        if(genFirstIdx[gid] === undefined) genFirstIdx[gid] = idx;
      });
    } catch(e) {}

    currentChain.forEach((node, idx) => {
      const item = document.createElement('div');
      item.className = 'list-group-item';
      let isDupNode = false;
      let isDupGen = false;
      let dupNodeFirstIdx = -1;
      let dupGenFirstIdx = -1;
      try{
        const nid = (node && node.id) ? String(node.id).trim() : '';
        if(nid && idCounts[nid] > 1){
          item.classList.add('list-group-item-warning');
          isDupNode = true;
          dupNodeFirstIdx = (idFirstIdx[nid] !== undefined) ? parseInt(String(idFirstIdx[nid]), 10) : -1;
        }
      } catch(e) {}

      // Generator duplication is informational but still flagged.
      try{
        const fa0 = (Array.isArray(currentFlagAssignments) && currentFlagAssignments[idx]) ? currentFlagAssignments[idx] : null;
        const gid0 = fa0 && (fa0.id || fa0.generator_id) ? String(fa0.id || fa0.generator_id).trim() : '';
        if(gid0 && genCounts[gid0] > 1){
          item.classList.add('list-group-item-warning');
          isDupGen = true;
          dupGenFirstIdx = (genFirstIdx[gid0] !== undefined) ? parseInt(String(genFirstIdx[gid0]), 10) : -1;
        }
      } catch(e) {}
      item.style.cursor = 'default';
      item.style.display = 'grid';
      item.style.gridTemplateColumns = '84px 1fr 76px';
      item.style.columnGap = '.5rem';
      item.style.alignItems = 'start';

      const seq = document.createElement('div');
      seq.className = 'text-muted small fw-semibold';
      seq.style.width = '84px';
      seq.style.whiteSpace = 'nowrap';
      seq.style.borderRight = '1px solid var(--bs-border-color, #dee2e6)';
      seq.style.paddingRight = '.5rem';
      seq.textContent = toRoman(idx + 1);

      const left = document.createElement('div');
      left.className = 'd-flex flex-column';
      left.style.minWidth = '0';
      left.style.justifySelf = 'stretch';
      const titleRow = document.createElement('div');
      titleRow.className = 'd-flex align-items-center gap-2';
      const title = document.createElement('div');
      title.className = 'fw-semibold';
      title.textContent = (node && node.name) ? String(node.name) : ('Node ' + (idx+1));
      titleRow.appendChild(title);
      if(isDupNode){
        const badge = document.createElement('span');
        badge.className = 'badge text-bg-warning';
        const isFirst = (dupNodeFirstIdx >= 0 && dupNodeFirstIdx === idx);
        const sameAs = (!isFirst && dupNodeFirstIdx >= 0) ? (' (same as ' + toRoman(dupNodeFirstIdx + 1) + ')') : '';
        badge.textContent = 'Duplicate node' + sameAs;
        titleRow.appendChild(badge);
      }
      if(isDupGen){
        const badge = document.createElement('span');
        badge.className = 'badge text-bg-warning';
        const isFirst = (dupGenFirstIdx >= 0 && dupGenFirstIdx === idx);
        const sameAs = (!isFirst && dupGenFirstIdx >= 0) ? (' (same as ' + toRoman(dupGenFirstIdx + 1) + ')') : '';
        badge.textContent = 'Duplicate generator' + sameAs;
        titleRow.appendChild(badge);
      }

      // Per-step actions (top-right).
      try {
        const btnGroup = document.createElement('div');
        btnGroup.className = 'btn-group btn-group-sm ms-auto';

        const inputsBtn = document.createElement('button');
        inputsBtn.type = 'button';
        inputsBtn.className = 'btn btn-outline-secondary';
        inputsBtn.textContent = 'Value Override';
        inputsBtn.addEventListener('click', (ev)=>{
          try { ev && ev.preventDefault && ev.preventDefault(); } catch(e) {}
          try { ev && ev.stopPropagation && ev.stopPropagation(); } catch(e) {}
          try { selectChainIndex(idx); } catch(e) {}
          try { openInputsDialog(idx); } catch(e) {}
        });

        const subBtn = document.createElement('button');
        subBtn.type = 'button';
        subBtn.className = 'btn btn-outline-primary';
        subBtn.textContent = 'Edit';
        subBtn.addEventListener('click', (ev)=>{
          try { ev && ev.preventDefault && ev.preventDefault(); } catch(e) {}
          try { ev && ev.stopPropagation && ev.stopPropagation(); } catch(e) {}
          try { selectChainIndex(idx); } catch(e) {}
          try { openSubstituteDialog(idx); } catch(e) {}
        });

        btnGroup.appendChild(inputsBtn);
        btnGroup.appendChild(subBtn);
        titleRow.appendChild(btnGroup);
      } catch(e) {}
      left.appendChild(titleRow);

      // Sub-details: compact table for readability.
      const details = document.createElement('div');
      details.className = 'mt-1';
      const tbl = document.createElement('table');
      tbl.className = 'table table-sm table-borderless mb-0 small';
      const tbody = document.createElement('tbody');

      function addRow(label, valueElOrText, { danger = false } = {}){
        const tr = document.createElement('tr');
        const tdL = document.createElement('td');
        tdL.className = 'text-muted';
        tdL.style.whiteSpace = 'nowrap';
        tdL.style.width = '1%';
        tdL.textContent = String(label || '').trim() ? (String(label).trim() + ':') : '';
        const tdV = document.createElement('td');
        if(danger) tdV.classList.add('text-danger');
        if(valueElOrText && typeof valueElOrText === 'object' && valueElOrText.nodeType){
          tdV.appendChild(valueElOrText);
        } else {
          tdV.textContent = String(valueElOrText || '-');
        }
        tr.appendChild(tdL);
        tr.appendChild(tdV);
        tbody.appendChild(tr);
      }

      const fa = (Array.isArray(currentFlagAssignments) && currentFlagAssignments[idx]) ? currentFlagAssignments[idx] : null;
      const genId = fa && fa.id ? String(fa.id) : '-';
      const genName = fa && fa.name ? String(fa.name) : '-';
      addRow('Generator', (genName && genName !== '-' && genName !== genId)
        ? (genId + ' | ' + genName)
        : genId);

      const genLabel = fa && fa.flag_generator ? String(fa.flag_generator) : '-';
      addRow('Source', genLabel);

      try{
        const nid = (node && node.id) ? String(node.id).trim() : '';
        if(nid && idCounts[nid] > 1){
          const firstIdx = (idFirstIdx[nid] !== undefined) ? parseInt(String(idFirstIdx[nid]), 10) : -1;
          const isFirst = (firstIdx >= 0 && firstIdx === idx);
          const sameAs = (!isFirst && firstIdx >= 0) ? ('same as ' + toRoman(firstIdx + 1) + '; ') : '';
          addRow('Notice', 'Duplicate node in chain (' + sameAs + 'allowed; reseeded per occurrence).');
        }
      } catch(e) {}

      try{
        const gid = fa && (fa.id || fa.generator_id) ? String(fa.id || fa.generator_id).trim() : '';
        if(gid && genCounts[gid] > 1){
          const firstIdx = (genFirstIdx[gid] !== undefined) ? parseInt(String(genFirstIdx[gid]), 10) : -1;
          const isFirst = (firstIdx >= 0 && firstIdx === idx);
          const sameAs = (!isFirst && firstIdx >= 0) ? ('same as ' + toRoman(firstIdx + 1)) : 'reused in chain';
          addRow('Notice', 'Duplicate generator assignment (' + sameAs + ').');
        }
      } catch(e) {}

      // Realized flag value (populated after prepare_preview_for_execute).
      try{
        const fv = (fa && typeof fa.flag_value === 'string') ? fa.flag_value.trim() : '';
        if(fv){
          const code = document.createElement('code');
          code.className = 'font-monospace';
          code.style.whiteSpace = 'pre-wrap';
          code.textContent = fv;
          addRow('Flag', code);
        }
      } catch(e) {}

      const descList = (fa && Array.isArray(fa.description_hints) && fa.description_hints.length)
        ? fa.description_hints.map(x => String(x || '').trim()).filter(Boolean)
        : [];
      if(descList.length > 1){
        const wrap = document.createElement('div');
        const ul = document.createElement('ol');
        ul.className = 'mb-0 ps-3';
        descList.forEach((ht) => {
          const li = document.createElement('li');
          li.textContent = ht;
          ul.appendChild(li);
        });
        wrap.appendChild(ul);
        addRow('Description Hints', wrap);
      } else if(descList.length === 1){
        addRow('Description Hints', descList[0]);
      }

      const hintList = (fa && Array.isArray(fa.hints) && fa.hints.length)
        ? fa.hints.map(x => String(x || '').trim()).filter(Boolean)
        : [];
      if(hintList.length > 1){
        const wrap = document.createElement('div');
        const ul = document.createElement('ol');
        ul.className = 'mb-0 ps-3';
        hintList.forEach((ht) => {
          const li = document.createElement('li');
          li.textContent = ht;
          ul.appendChild(li);
        });
        wrap.appendChild(ul);
        addRow('Hints', wrap);
      } else {
        const hintText = hintList.length ? hintList[0] : (fa && fa.hint ? String(fa.hint) : '');
        addRow('Hint', hintText || '-');
      }

      const feas = chainFeasibility(currentFlagAssignments);
      const step = feas && feas[idx] ? feas[idx] : null;
        const inReq = (fa && Array.isArray(fa.input_fields_required)) ? fa.input_fields_required.map(String).filter(Boolean) : [];
        const inOpt = (fa && Array.isArray(fa.input_fields_optional)) ? fa.input_fields_optional.map(String).filter(Boolean) : [];
        const inAll = (fa && Array.isArray(fa.input_fields)) ? fa.input_fields.map(String).filter(Boolean) : [];
        const inputsDisplay = (inReq.length || inOpt.length)
          ? (inReq.concat(inOpt.map(x => x + ' (optional)')).join(', '))
          : (inAll.length ? inAll.join(', ') : '-');
        const isNodeGen = String((fa && fa.type) || '').trim() === 'flag-node-generator';
        const injectedFiles = (fa && Array.isArray(fa.inject_files))
          ? fa.inject_files.map(x => String(x || '').trim()).filter(Boolean)
          : [];
        // Inputs/Outputs: tabular view with Providing/Missing side-by-side.
        try{
          const reqArtifacts = (fa && Array.isArray(fa.requires)) ? fa.requires.map(String).filter(Boolean) : [];
          const providedArtifactsChain = (step && Array.isArray(step.providing_artifacts_chain)) ? step.providing_artifacts_chain.map(String).filter(Boolean) : [];
          const providedArtifactsSeq = (step && Array.isArray(step.providing_artifacts_sequencer)) ? step.providing_artifacts_sequencer.map(String).filter(Boolean) : [];
          const missingArtifacts = (step && Array.isArray(step.missing_artifacts)) ? step.missing_artifacts.map(String).filter(Boolean) : [];

          const reqFields = inReq;
          const defFields = (inReq.length || inOpt.length)
            ? inReq.concat(inOpt.map(x => x + ' (optional)'))
            : inAll;
          const providedFieldsChain = (step && Array.isArray(step.providing_fields_chain)) ? step.providing_fields_chain.map(String).filter(Boolean) : [];
          const providedFieldsSeq = (step && Array.isArray(step.providing_fields_sequencer)) ? step.providing_fields_sequencer.map(String).filter(Boolean) : [];
          const missingFields = (step && Array.isArray(step.missing_fields)) ? step.missing_fields.map(String).filter(Boolean) : [];

          const showMissingCol = (missingArtifacts.length + missingFields.length) > 0;

          function _stringifyAny(v){
            if(v === undefined) return '';
            if(v === null) return 'null';
            if(typeof v === 'string') return v;
            try { return JSON.stringify(v); } catch(e) { return String(v); }
          }

          function renderResolvedCell(kv, keysOrder, opts){
            const options = (opts && typeof opts === 'object') ? opts : {};
            const maxItems = Number.isFinite(+options.maxItems) ? (+options.maxItems) : 3;
            const maxLen = Number.isFinite(+options.maxLen) ? (+options.maxLen) : 60;
            const maxDetailItems = Number.isFinite(+options.maxDetailItems) ? (+options.maxDetailItems) : 25;

            const obj = (kv && typeof kv === 'object' && !Array.isArray(kv)) ? kv : null;
            if(!obj || !Object.keys(obj).length) return document.createTextNode('-');

            let keys = Array.isArray(keysOrder) && keysOrder.length
              ? keysOrder.map(x => String(x || '').trim()).filter(Boolean)
              : Object.keys(obj);

            // Prefer showing flag first when present.
            try {
              if(Object.prototype.hasOwnProperty.call(obj, 'flag')){
                keys = ['flag'].concat(keys.filter(k => k !== 'flag'));
              }
            } catch(e) {}

            const seen = new Set();
            const pairs = [];
            for(const k of keys){
              const kk = String(k || '').trim();
              if(!kk || seen.has(kk)) continue;
              seen.add(kk);
              if(!(kk in obj)) continue;
              const v = obj[kk];
              if(v === undefined) continue;
              const full = _stringifyAny(v);
              let short = full;
              if(typeof short === 'string' && short.length > maxLen){
                short = short.slice(0, Math.max(0, maxLen - 1)) + '…';
              }
              pairs.push({ k: kk, full, short });
            }

            if(!pairs.length) return document.createTextNode('-');

            const details = document.createElement('details');
            details.className = 'small';
            const summary = document.createElement('summary');
            summary.style.cursor = 'pointer';
            summary.className = 'text-decoration-none';

            const summaryWrap = document.createElement('span');
            summaryWrap.className = 'd-inline-flex flex-wrap gap-1 align-items-center';

            const head = pairs.slice(0, Math.max(1, maxItems));
            head.forEach(p => {
              const code = document.createElement('code');
              code.className = 'font-monospace';
              code.title = p.k + '=' + p.full;
              code.textContent = p.k + '=' + p.short;
              summaryWrap.appendChild(code);
            });
            if(pairs.length > head.length){
              const more = document.createElement('span');
              more.className = 'text-muted';
              more.textContent = `(+${pairs.length - head.length})`;
              summaryWrap.appendChild(more);
            }
            summary.appendChild(summaryWrap);
            details.appendChild(summary);

            const body = document.createElement('div');
            body.className = 'mt-1';
            const list = document.createElement('div');
            list.className = 'd-flex flex-column gap-1';
            pairs.slice(0, maxDetailItems).forEach(p => {
              const row = document.createElement('div');
              const kcode = document.createElement('code');
              kcode.className = 'me-1 text-muted';
              kcode.textContent = p.k;
              const vcode = document.createElement('code');
              vcode.className = 'font-monospace';
              vcode.style.whiteSpace = 'pre-wrap';
              vcode.textContent = p.full;
              row.appendChild(kcode);
              row.appendChild(document.createTextNode(': '));
              row.appendChild(vcode);
              list.appendChild(row);
            });
            if(pairs.length > maxDetailItems){
              const moreLine = document.createElement('div');
              moreLine.className = 'text-muted';
              moreLine.textContent = `(+${pairs.length - maxDetailItems} more not shown)`;
              list.appendChild(moreLine);
            }
            body.appendChild(list);
            details.appendChild(body);
            return details;
          }

          const resolvedInputs = (fa && typeof fa.resolved_inputs === 'object' && fa.resolved_inputs && !Array.isArray(fa.resolved_inputs)) ? fa.resolved_inputs : null;
          const resolvedOutputs = (fa && typeof fa.resolved_outputs === 'object' && fa.resolved_outputs && !Array.isArray(fa.resolved_outputs)) ? fa.resolved_outputs : null;

          const outFields = (fa && Array.isArray(fa.output_fields)) ? fa.output_fields.map(String).filter(Boolean) : [];
          const outArtifacts = (fa && Array.isArray(fa.produces)) ? fa.produces.map(String).filter(Boolean) : [];

          // For outputs, show what is *required by downstream steps* (subset of this step's defined outputs).
          const synthesizedFields = ['seed','secret','env_name','challenge','flag_prefix','username_prefix','key_len','node_name'];
          const synthesizedSet = new Set(synthesizedFields);
          const downstreamReqArtifacts = new Set();
          const downstreamReqFields = new Set();
          try{
            for(let j = idx + 1; j < (Array.isArray(currentFlagAssignments) ? currentFlagAssignments.length : 0); j++){
              const a2 = currentFlagAssignments[j] || {};
              const reqArtRaw = Array.isArray(a2.requires) ? a2.requires.map(String).filter(Boolean) : [];
              reqArtRaw.filter(k => k && !synthesizedSet.has(k)).forEach(k => downstreamReqArtifacts.add(k));

              const reqFld = Array.isArray(a2.input_fields_required)
                ? a2.input_fields_required.map(String).filter(Boolean)
                : (Array.isArray(a2.input_fields) ? a2.input_fields.map(String).filter(Boolean) : []);
              reqFld.forEach(k => downstreamReqFields.add(k));
            }
          } catch(e) {}
          const outArtifactsReq = outArtifacts.filter(k => downstreamReqArtifacts.has(k));
          const outFieldsReq = outFields.filter(k => downstreamReqFields.has(k));

          const inputsTbl = document.createElement('table');
          inputsTbl.className = 'table table-sm mb-0';
          const itHead = document.createElement('thead');
          itHead.innerHTML = showMissingCol
            ? '<tr class="text-secondary"><th style="width: 1%; white-space: nowrap;">Inputs</th><th>Required</th><th>Defined</th><th>Resolved</th><th>Provided by Chain</th><th>Provided by Sequencer</th><th>Missing</th></tr>'
            : '<tr class="text-secondary"><th style="width: 1%; white-space: nowrap;">Inputs</th><th>Required</th><th>Defined</th><th>Resolved</th><th>Provided by Chain</th><th>Provided by Sequencer</th></tr>';
          inputsTbl.appendChild(itHead);
          const itBody = document.createElement('tbody');
          function addIoRow(label, requiredList, definedList, byChainList, bySeqList, missingList){
            const tr = document.createElement('tr');
            const td0 = document.createElement('td');
            td0.className = 'text-muted';
            td0.style.whiteSpace = 'nowrap';
            td0.textContent = label;
            const td1 = document.createElement('td');
            td1.textContent = (requiredList && requiredList.length) ? requiredList.join(', ') : '-';
            const td2 = document.createElement('td');
            td2.textContent = (definedList && definedList.length) ? definedList.join(', ') : '-';
            const tdR = document.createElement('td');
            tdR.className = 'small';
            if(label === 'Fields'){
              const keys = (fa && Array.isArray(fa.input_fields) && fa.input_fields.length) ? fa.input_fields : (definedList || []);
              tdR.appendChild(renderResolvedCell(resolvedInputs, keys, { maxItems: 2, maxLen: 48, maxDetailItems: 25 }));
            } else {
              tdR.textContent = '-';
            }
            const td3 = document.createElement('td');
            td3.textContent = (byChainList && byChainList.length) ? byChainList.join(', ') : '-';
            const td4 = document.createElement('td');
            td4.textContent = (bySeqList && bySeqList.length) ? bySeqList.join(', ') : '-';
            tr.appendChild(td0);
            tr.appendChild(td1);
            tr.appendChild(td2);
            tr.appendChild(tdR);
            tr.appendChild(td3);
            tr.appendChild(td4);
            if(showMissingCol){
              const td5 = document.createElement('td');
              if(missingList && missingList.length) td5.classList.add('text-danger');
              td5.textContent = (missingList && missingList.length) ? missingList.join(', ') : '-';
              tr.appendChild(td5);
            }
            itBody.appendChild(tr);
          }
          addIoRow('Artifacts', reqArtifacts, reqArtifacts, providedArtifactsChain, providedArtifactsSeq, missingArtifacts);
          addIoRow('Fields', reqFields, defFields, providedFieldsChain, providedFieldsSeq, missingFields);
          inputsTbl.appendChild(itBody);

          // Full-width row so the Inputs table is flush-left (no empty label column indentation).
          {
            const tr = document.createElement('tr');
            const td = document.createElement('td');
            td.colSpan = 2;
            td.style.paddingLeft = '0';
            td.appendChild(inputsTbl);
            tr.appendChild(td);
            tbody.appendChild(tr);
          }

          const outputsTbl = document.createElement('table');
          outputsTbl.className = 'table table-sm mb-0';
          const otHead = document.createElement('thead');
          otHead.innerHTML = '<tr class="text-secondary"><th style="width: 1%; white-space: nowrap;">Outputs</th><th>Required</th><th>Defined</th><th>Injects</th><th>Provided to Chain</th><th>Resolved</th></tr>';
          outputsTbl.appendChild(otHead);
          const otBody = document.createElement('tbody');
          function addOutRow(label, requiredList, definedList, injectedList, toChainList){
            const tr = document.createElement('tr');
            const td0 = document.createElement('td');
            td0.className = 'text-muted';
            td0.style.whiteSpace = 'nowrap';
            td0.textContent = label;
            const td1 = document.createElement('td');
            td1.textContent = (requiredList && requiredList.length) ? requiredList.join(', ') : '-';
            const td2 = document.createElement('td');
            td2.textContent = (definedList && definedList.length) ? definedList.join(', ') : '-';
            const td3 = document.createElement('td');
            td3.textContent = (injectedList && injectedList.length) ? injectedList.join(', ') : '-';
            const td4 = document.createElement('td');
            td4.textContent = (toChainList && toChainList.length) ? toChainList.join(', ') : '-';
            const tdR = document.createElement('td');
            tdR.className = 'small';
            if(label === 'Fields'){
              const keys = (fa && Array.isArray(fa.actual_outputs) && fa.actual_outputs.length)
                ? fa.actual_outputs
                : ((fa && Array.isArray(fa.output_fields) && fa.output_fields.length) ? fa.output_fields : (definedList || []));
              tdR.appendChild(renderResolvedCell(resolvedOutputs, keys, { maxItems: 2, maxLen: 48, maxDetailItems: 25 }));
            } else {
              tdR.textContent = '-';
            }
            tr.appendChild(td0);
            tr.appendChild(td1);
            tr.appendChild(td2);
            tr.appendChild(td3);
            tr.appendChild(td4);
            tr.appendChild(tdR);
            otBody.appendChild(tr);
          }
          // Generator outputs are provided to the chain; sequencer does not provide outputs here.
          addOutRow('Artifacts', outArtifactsReq, outArtifacts, injectedFiles, outArtifacts);
          addOutRow('Fields', outFieldsReq, outFields, [], outFields);
          outputsTbl.appendChild(otBody);

          // Full-width row so the Outputs table is flush-left (no empty label column indentation).
          {
            const tr = document.createElement('tr');
            const td = document.createElement('td');
            td.colSpan = 2;
            td.style.paddingLeft = '0';
            td.appendChild(outputsTbl);
            tr.appendChild(td);
            tbody.appendChild(tr);
          }
        } catch(e) {
          // If anything goes wrong, fall back to the old simple rows.
          addRow(isNodeGen ? 'Flag-Node-Generator Defined Input' : 'Flag-Generator Defined Input', inputsDisplay);
          addRow(isNodeGen ? 'Flag-Node-Generator Defined Output' : 'Flag-Generator Defined Output', fa && Array.isArray(fa.output_fields) && fa.output_fields.length ? fa.output_fields.join(', ') : '-');
          addRow('Chain Item Providing', fa && Array.isArray(fa.requires) && fa.requires.length ? fa.requires.join(', ') : '-');
          addRow('Providing to Chain', fa && Array.isArray(fa.produces) && fa.produces.length ? fa.produces.join(', ') : '-');
          if(step && step.ok === false){
            addRow('Missing Inputs', (step.missing || []).join(', ') || '-', { danger: true });
          }
        }

      // After prepare_preview_for_execute, the backend may attach runtime validation
      // fields like outputs_match/outputs_mismatch to help validate generator specs.
      try {
        if(fa && fa.inputs_match === false){
          const mm = fa.inputs_mismatch || {};
          const missingReq = Array.isArray(mm.missing_required) ? mm.missing_required : [];
          const unsetReq = Array.isArray(mm.unset_required) ? mm.unset_required : [];
          const dropped = Array.isArray(mm.dropped) ? mm.dropped : [];

          const parts = [];
          if(missingReq.length){
            const msg = missingReq.map(k => String(k || '').trim()).filter(Boolean)
              .map(k => `${k} (required by catalog inputs, but not provided in generator config)`)
              .join('; ');
            parts.push('missing required: ' + (msg || missingReq.join(', ')));
          }
          if(unsetReq.length){
            const msg = unsetReq.map(k => String(k || '').trim()).filter(Boolean)
              .map(k => `${k} (provided but empty/null)`)
              .join('; ');
            parts.push('unset required: ' + (msg || unsetReq.join(', ')));
          }
          if(dropped.length){
            const msg = dropped.map(k => String(k || '').trim()).filter(Boolean)
              .map(k => `${k} (not declared by generator inputs; not passed)`)
              .join('; ');
            parts.push('dropped: ' + (msg || dropped.join(', ')));
          }
          addRow('Inputs Mismatch', parts.length ? parts.join(' | ') : 'inputs mismatch', { danger: true });
        }
        if(fa && fa.outputs_match === false){
          const mm = fa.outputs_mismatch || {};
          const missing = Array.isArray(mm.missing) ? mm.missing : [];
          const extra = Array.isArray(mm.extra) ? mm.extra : [];
          const parts = [];
          if(missing.length){
            const msg = missing.map(k => String(k || '').trim()).filter(Boolean)
              .map(k => `${k} (declared in catalog output_fields, but not present in outputs.json)`)
              .join('; ');
            parts.push('missing: ' + (msg || missing.join(', ')));
          }
          if(extra.length){
            const msg = extra.map(k => String(k || '').trim()).filter(Boolean)
              .map(k => `${k} (present in outputs.json, but not declared in catalog output_fields)`)
              .join('; ');
            parts.push('extra: ' + (msg || extra.join(', ')));
          }
          addRow('Outputs Mismatch', parts.length ? parts.join(' | ') : 'outputs mismatch', { danger: true });
        }
      } catch(e) {}

      tbl.appendChild(tbody);
      details.appendChild(tbl);
      left.appendChild(details);

      // (Per-step action buttons moved to title row.)

      const right = document.createElement('div');
      right.className = 'btn-group btn-group-sm';
      right.style.justifySelf = 'end';
      const up = document.createElement('button');
      up.type = 'button';
      up.className = 'btn btn-outline-secondary';
      up.textContent = '↑';
      up.disabled = idx === 0;
      up.addEventListener('click', async () => {
        if(idx === 0) return;
        const tmp = currentChain[idx-1];
        currentChain[idx-1] = currentChain[idx];
        currentChain[idx] = tmp;
        renderChainEditor();
        persistFlowState();
        await refreshAssignmentsFromChain();
      });
      const down = document.createElement('button');
      down.type = 'button';
      down.className = 'btn btn-outline-secondary';
      down.textContent = '↓';
      down.disabled = idx === currentChain.length - 1;
      down.addEventListener('click', async () => {
        if(idx === currentChain.length - 1) return;
        const tmp = currentChain[idx+1];
        currentChain[idx+1] = currentChain[idx];
        currentChain[idx] = tmp;
        renderChainEditor();
        persistFlowState();
        await refreshAssignmentsFromChain();
      });
      right.appendChild(up);
      right.appendChild(down);

      item.appendChild(seq);
      item.appendChild(left);
      item.appendChild(right);
      wrap.appendChild(item);
    });
  }

  function openNodeDetailsDialog(idx, opts){
    if(!nodeDetailsDialogEl || !nodeDetailsBodyEl) return;
    const i = Number.isFinite(+idx) ? (+idx) : -1;
    if(!Array.isArray(currentChain) || i < 0 || i >= currentChain.length) return;
    const node = currentChain[i] || {};
    const fa = (Array.isArray(currentFlagAssignments) && currentFlagAssignments[i]) ? currentFlagAssignments[i] : null;

    const seq = toRoman(i + 1);
    const nodeName = (node && node.name) ? String(node.name) : ('Node ' + (i + 1));
    if(nodeDetailsTitleEl) nodeDetailsTitleEl.textContent = (seq ? (seq + '. ') : '') + nodeName;

    nodeDetailsBodyEl.innerHTML = '';

    const tbl = document.createElement('table');
    tbl.className = 'table table-sm table-borderless mb-0';
    const tbody = document.createElement('tbody');

    function addRow(label, valueElOrText){
      const tr = document.createElement('tr');
      const tdL = document.createElement('td');
      tdL.className = 'text-muted';
      tdL.style.whiteSpace = 'nowrap';
      tdL.style.width = '1%';
      tdL.textContent = String(label || '').trim() ? (String(label).trim() + ':') : '';
      const tdV = document.createElement('td');
      if(valueElOrText && typeof valueElOrText === 'object' && valueElOrText.nodeType){
        tdV.appendChild(valueElOrText);
      } else {
        tdV.textContent = String(valueElOrText || '-');
      }
      tr.appendChild(tdL);
      tr.appendChild(tdV);
      tbody.appendChild(tr);
    }

    // Flag(s) assigned to this node (currently 1-per-chain-position).
    if(fa && (fa.id || fa.name)){
      const genId = fa && fa.id ? String(fa.id) : '-';
      const genName = fa && fa.name ? String(fa.name) : '-';
      const genType = (fa && fa.type) ? String(fa.type) : '';
      const genSource = (fa && fa.flag_generator) ? String(fa.flag_generator) : '';

      const flagEl = document.createElement('div');
      flagEl.className = 'd-flex flex-column';

      const line1 = document.createElement('div');
      line1.className = 'small';
      const typeLabel = document.createElement('span');
      typeLabel.className = 'text-muted';
      typeLabel.textContent = 'Type:';
      const typeVal = document.createElement('code');
      typeVal.className = 'ms-1';
      typeVal.textContent = genType || '-';
      line1.appendChild(typeLabel);
      line1.appendChild(typeVal);

      const sourceLabel = document.createElement('span');
      sourceLabel.className = 'text-muted ms-2';
      sourceLabel.textContent = 'Source:';
      const sourceVal = document.createElement('code');
      sourceVal.className = 'ms-1';
      sourceVal.textContent = genSource || '-';
      line1.appendChild(sourceLabel);
      line1.appendChild(sourceVal);

      const line2 = document.createElement('div');
      const idVal = document.createElement('code');
      idVal.textContent = genId || '-';
      line2.appendChild(idVal);
      if(genName && genName !== '-' && genName !== genId){
        const nameSpan = document.createElement('span');
        nameSpan.className = 'ms-2';
        nameSpan.textContent = genName;
        line2.appendChild(nameSpan);
      }

      flagEl.appendChild(line1);
      flagEl.appendChild(line2);
      addRow('Flag', flagEl);
    } else {
      addRow('Flag', '-');
    }

    tbl.appendChild(tbody);
    nodeDetailsBodyEl.appendChild(tbl);

    try{
      if(typeof nodeDetailsDialogEl.showModal === 'function'){
        nodeDetailsDialogEl.showModal();
      }
    } catch(e) {}
  }

  function openInputsDialog(idx){
    if(!inputsDialogEl || !inputsBodyEl) return;
    const i = Number.isFinite(+idx) ? (+idx) : -1;
    if(!Array.isArray(currentChain) || i < 0 || i >= currentChain.length) return;
    const node = currentChain[i] || {};
    const fa = (Array.isArray(currentFlagAssignments) && currentFlagAssignments[i]) ? currentFlagAssignments[i] : null;

    const seq = toRoman(i + 1);
    const nodeName = (node && node.name) ? String(node.name) : ('Node ' + (i + 1));
    if(inputsTitleEl) inputsTitleEl.textContent = 'Value Override — ' + (seq ? (seq + '. ') : '') + nodeName;

    inputsBodyEl.innerHTML = '';

    // Header summary (generator id/type/source).
    try{
      const genId = fa && fa.id ? String(fa.id) : '-';
      const genType = (fa && fa.type) ? String(fa.type) : '-';
      const genSource = (fa && fa.flag_generator) ? String(fa.flag_generator) : '-';
      const hdr = document.createElement('div');
      hdr.className = 'mb-2';
      const label = document.createElement('div');
      label.className = 'small text-muted';
      label.textContent = 'Generator';
      hdr.appendChild(label);

      const row = document.createElement('div');
      row.className = 'd-flex flex-wrap gap-2 align-items-center';
      const idCode = document.createElement('code');
      idCode.textContent = genId;
      row.appendChild(idCode);

      const typeLabel = document.createElement('span');
      typeLabel.className = 'text-muted small';
      typeLabel.textContent = 'type';
      row.appendChild(typeLabel);
      const typeCode = document.createElement('code');
      typeCode.textContent = genType;
      row.appendChild(typeCode);

      const srcLabel = document.createElement('span');
      srcLabel.className = 'text-muted small';
      srcLabel.textContent = 'source';
      row.appendChild(srcLabel);
      const srcCode = document.createElement('code');
      srcCode.textContent = genSource;
      row.appendChild(srcCode);

      hdr.appendChild(row);
      inputsBodyEl.appendChild(hdr);
    } catch(e) {}

    // Inputs override UI (always expanded).
    try{
      const box = document.createElement('div');
      box.className = 'd-flex flex-column gap-2';

      const help = document.createElement('div');
      help.className = 'small text-muted';
      help.textContent = 'Override generator input values for this chain step.';
      box.appendChild(help);

      const form = document.createElement('div');
      form.className = 'border rounded p-2';

      const cfg = (fa && typeof fa.config === 'object' && fa.config && !Array.isArray(fa.config)) ? fa.config : null;
      const overrides0 = (fa && typeof fa.config_overrides === 'object' && fa.config_overrides && !Array.isArray(fa.config_overrides)) ? fa.config_overrides : null;
      const inputNames = [];
      try{
        const req = (fa && Array.isArray(fa.input_fields_required)) ? fa.input_fields_required.map(String) : [];
        const opt = (fa && Array.isArray(fa.input_fields_optional)) ? fa.input_fields_optional.map(String) : [];
        const all = (req.length || opt.length) ? req.concat(opt) : ((fa && Array.isArray(fa.input_fields)) ? fa.input_fields.map(String) : []);
        const seen = new Set();
        for(const k of all){
          const kk = String(k || '').trim();
          if(!kk || seen.has(kk)) continue;
          seen.add(kk);
          inputNames.push(kk);
        }
      } catch(e) {}

      const note = document.createElement('div');
      note.className = 'small text-muted';
      note.textContent = cfg
        ? 'Effective config is shown below. Overrides persist into Execute and Save.'
        : 'No effective config yet. Click Generate (with hint resolution) or Execute to compute defaults, then override.';
      form.appendChild(note);

      const tableWrap = document.createElement('div');
      tableWrap.className = 'mt-2';
      const t = document.createElement('table');
      t.className = 'table table-sm mb-0 align-middle';
      const thead = document.createElement('thead');
      thead.innerHTML = '<tr class="text-secondary"><th style="width: 1%; white-space: nowrap;">Input</th><th>Effective</th><th>Override</th></tr>';
      t.appendChild(thead);
      const tb = document.createElement('tbody');

      const inputElsByKey = {};
      function renderVal(v){
        if(v === undefined) return '';
        if(v === null) return 'null';
        if(typeof v === 'string') return v;
        try { return JSON.stringify(v); } catch(e) { return String(v); }
      }

      function tryParseInputValue(raw){
        const s = String(raw ?? '').trim();
        if(!s) return '';
        const looksJson = s.startsWith('{') || s.startsWith('[') || s.startsWith('"') || s === 'true' || s === 'false' || s === 'null' || /^-?\d+(?:\.\d+)?$/.test(s);
        if(!looksJson) return s;
        try { return JSON.parse(s); } catch(e) { return s; }
      }

      function setInputRow(k){
        const tr = document.createElement('tr');
        const tdK = document.createElement('td');
        tdK.className = 'text-muted';
        tdK.style.whiteSpace = 'nowrap';
        const code = document.createElement('code');
        code.textContent = k;
        tdK.appendChild(code);

        const tdEff = document.createElement('td');
        tdEff.className = 'small';
        const eff = cfg ? cfg[k] : undefined;
        tdEff.textContent = (eff === undefined) ? '-' : renderVal(eff);

        const tdOvr = document.createElement('td');
        const inp = document.createElement('input');
        inp.type = 'text';
        inp.className = 'form-control form-control-sm font-monospace';
        inp.placeholder = 'leave blank to use default';
        inp.value = (overrides0 && (k in overrides0)) ? renderVal(overrides0[k]) : '';
        inputElsByKey[k] = inp;
        tdOvr.appendChild(inp);

        tr.appendChild(tdK);
        tr.appendChild(tdEff);
        tr.appendChild(tdOvr);
        tb.appendChild(tr);
      }

      if(inputNames.length){
        inputNames.forEach(setInputRow);
      } else {
        const tr = document.createElement('tr');
        const td = document.createElement('td');
        td.colSpan = 3;
        td.className = 'text-muted small';
        td.textContent = 'This generator declares no inputs.';
        tr.appendChild(td);
        tb.appendChild(tr);
      }

      t.appendChild(tb);
      tableWrap.appendChild(t);
      form.appendChild(tableWrap);

      const actions = document.createElement('div');
      actions.className = 'd-flex justify-content-end gap-2 mt-2';
      const clearBtn = document.createElement('button');
      clearBtn.type = 'button';
      clearBtn.className = 'btn btn-sm btn-outline-secondary';
      clearBtn.textContent = 'Clear overrides';
      const saveBtn = document.createElement('button');
      saveBtn.type = 'button';
      saveBtn.className = 'btn btn-sm btn-primary';
      saveBtn.textContent = 'Save overrides';
      actions.appendChild(clearBtn);
      actions.appendChild(saveBtn);
      form.appendChild(actions);

      async function persistOverridesForIndex(){
        if(!Array.isArray(currentChain) || !currentChain.length) throw new Error('Generate a chain first.');
        const scenario = (scenarioEl && scenarioEl.value || '').trim();
        if(!scenario) throw new Error('No scenario selected.');
        const chainIds = currentChain.map(n => (n && n.id) ? String(n.id) : '').filter(Boolean);
        if(!chainIds.length) throw new Error('Missing chain ids.');

        const reqAssignments = chainIds.map((nid, j)=>{
          const curA = (Array.isArray(currentFlagAssignments) && currentFlagAssignments[j]) ? currentFlagAssignments[j] : {};
          const curId = String((curA && (curA.id || curA.generator_id)) || '').trim();
          const ovr = (curA && typeof curA.config_overrides === 'object' && curA.config_overrides && !Array.isArray(curA.config_overrides))
            ? curA.config_overrides
            : undefined;
          return { node_id: nid, id: curId, config_overrides: ovr };
        });
        const missing = reqAssignments.find(x => !x.id);
        if(missing) throw new Error('Some chain positions have no generator assignment yet. Try Generate again.');

        showLoading('Saving input overrides…');
        const res = await postJson('/api/flag-sequencing/save_flow_substitutions', {
          scenario: activeScenario,
          chain_ids: chainIds,
          preview_plan: (lastPreviewPlanPath || lastFlowPlanPath || ''),
          flag_assignments: reqAssignments,
          allow_node_duplicates: !!allowNodeDuplicates,
        }, { timeoutMs: 60000 });
        setFlowValidityFromPayload(res);
        if(res && Array.isArray(res.chain)) currentChain = res.chain.slice();
        if(res && Array.isArray(res.flag_assignments)) currentFlagAssignments = res.flag_assignments.slice();
        if(res && res.flow_plan_path) lastFlowPlanPath = String(res.flow_plan_path);
        updateMeta();
        renderChainEditor();
        return res;
      }

      clearBtn.addEventListener('click', async ()=>{
        try { clearBtn.disabled = true; saveBtn.disabled = true; } catch(e) {}
        try {
          if(!Array.isArray(currentFlagAssignments) || !currentFlagAssignments[i]) throw new Error('No assignment for this step.');
          currentFlagAssignments[i].config_overrides = {};
          await persistOverridesForIndex();
          for(const k of Object.keys(inputElsByKey)){
            try { inputElsByKey[k].value = ''; } catch(e) {}
          }
          setStatus('Input overrides cleared.', false);
        } catch(e) {
          setStatus('Failed to clear overrides: ' + String(e && e.message || e), true);
        } finally {
          hideLoading();
          try { clearBtn.disabled = false; saveBtn.disabled = false; } catch(e) {}
        }
      });

      saveBtn.addEventListener('click', async ()=>{
        try { clearBtn.disabled = true; saveBtn.disabled = true; } catch(e) {}
        try {
          if(!Array.isArray(currentFlagAssignments) || !currentFlagAssignments[i]) throw new Error('No assignment for this step.');
          const newOverrides = {};
          for(const k of Object.keys(inputElsByKey)){
            const el = inputElsByKey[k];
            const raw = (el && el.value !== undefined) ? String(el.value) : '';
            const trimmed = raw.trim();
            if(!trimmed) continue;
            newOverrides[k] = tryParseInputValue(trimmed);
          }
          currentFlagAssignments[i].config_overrides = newOverrides;
          await persistOverridesForIndex();
          setStatus('Input overrides saved.', false);
        } catch(e) {
          setStatus('Failed to save overrides: ' + String(e && e.message || e), true);
        } finally {
          hideLoading();
          try { clearBtn.disabled = false; saveBtn.disabled = false; } catch(e) {}
        }
      });

      box.appendChild(form);
      inputsBodyEl.appendChild(box);
    } catch(e) {
      // Non-fatal
    }

    try{
      if(typeof inputsDialogEl.showModal === 'function') inputsDialogEl.showModal();
    } catch(e) {}
  }

  function openSubstituteDialog(idx){
    if(!substituteDialogEl || !substituteBodyEl) return;
    const i = Number.isFinite(+idx) ? (+idx) : -1;
    if(!Array.isArray(currentChain) || i < 0 || i >= currentChain.length) return;
    const node = currentChain[i] || {};
    const fa = (Array.isArray(currentFlagAssignments) && currentFlagAssignments[i]) ? currentFlagAssignments[i] : null;

    // Hint overrides editor state (scoped to this dialog open).
    let hintOverridesEnabled = false;
    let hintOverrideToggleEl = null;
    let hintOverrideInputs = [];

    const seq = toRoman(i + 1);
    const nodeName = (node && node.name) ? String(node.name) : ('Node ' + (i + 1));
    if(substituteTitleEl) substituteTitleEl.textContent = 'Edit Flag + Hints — ' + (seq ? (seq + '. ') : '') + nodeName;

    substituteBodyEl.innerHTML = '';

    // Header summary.
    try{
      const genId = fa && fa.id ? String(fa.id) : '-';
      const genType = (fa && fa.type) ? String(fa.type) : '-';
      const genSource = (fa && fa.flag_generator) ? String(fa.flag_generator) : '-';
      const hdr = document.createElement('div');
      hdr.className = 'mb-2';
      const label = document.createElement('div');
      label.className = 'small text-muted';
      label.textContent = 'Current generator';
      hdr.appendChild(label);

      const row = document.createElement('div');
      row.className = 'd-flex flex-wrap gap-2 align-items-center';
      const idCode = document.createElement('code');
      idCode.textContent = genId;
      row.appendChild(idCode);

      const typeLabel = document.createElement('span');
      typeLabel.className = 'text-muted small';
      typeLabel.textContent = 'type';
      row.appendChild(typeLabel);
      const typeCode = document.createElement('code');
      typeCode.textContent = genType;
      row.appendChild(typeCode);

      const srcLabel = document.createElement('span');
      srcLabel.className = 'text-muted small';
      srcLabel.textContent = 'source';
      row.appendChild(srcLabel);
      const srcCode = document.createElement('code');
      srcCode.textContent = genSource;
      row.appendChild(srcCode);

      hdr.appendChild(row);
      substituteBodyEl.appendChild(hdr);
    } catch(e) {}

    // Substitute generator UI (always expanded).
    try{
      const isVuln = !!(node && (node.is_vuln || node.is_vulnerability || node.isVuln));
      const currentType = (fa && fa.type) ? String(fa.type) : (isVuln ? 'flag-generator' : 'flag-generator');
      const currentSource = (fa && fa.flag_generator) ? String(fa.flag_generator) : '';

      const help = document.createElement('div');
      help.className = 'small text-muted';
      help.textContent = isVuln
        ? 'Flag generator type (fixed for vulnerabilities)'
        : 'Choose a compatible flag-generator or flag-node-generator.';
      substituteBodyEl.appendChild(help);

      const form = document.createElement('div');
      form.className = 'border rounded p-2 mt-2';

      const row1 = document.createElement('div');
      row1.className = 'd-flex align-items-center gap-2';

      const nodeLabel = document.createElement('div');
      nodeLabel.className = 'small text-muted';
      nodeLabel.textContent = 'Node:';
      row1.appendChild(nodeLabel);

      const nodeSel = document.createElement('select');
      nodeSel.className = 'form-select form-select-sm';
      nodeSel.style.width = '360px';
      row1.appendChild(nodeSel);

      const kindLabel = document.createElement('div');
      kindLabel.className = 'small text-muted';
      kindLabel.textContent = 'Type:';
      row1.appendChild(kindLabel);

      const kindSel = document.createElement('select');
      kindSel.className = 'form-select form-select-sm';
      kindSel.style.width = '220px';
      const optFg = document.createElement('option');
      optFg.value = 'flag-generator';
      optFg.textContent = 'flag-generator';
      kindSel.appendChild(optFg);
      const optFng = document.createElement('option');
      optFng.value = 'flag-node-generator';
      optFng.textContent = 'flag-node-generator';
      if(!isVuln){
        kindSel.appendChild(optFng);
      }
      kindSel.value = (currentType === 'flag-node-generator' && !isVuln) ? 'flag-node-generator' : 'flag-generator';
      if(isVuln){
        kindSel.disabled = true;
      }
      row1.appendChild(kindSel);

      const sourceLabel = document.createElement('div');
      sourceLabel.className = 'small text-muted ms-1';
      sourceLabel.textContent = 'Source:';
      row1.appendChild(sourceLabel);

      const sourceSel = document.createElement('select');
      sourceSel.className = 'form-select form-select-sm';
      sourceSel.style.width = '320px';
      row1.appendChild(sourceSel);

      form.appendChild(row1);

      const row2 = document.createElement('div');
      row2.className = 'd-flex flex-column gap-1 mt-2';

      const entryInput = document.createElement('input');
      entryInput.type = 'text';
      entryInput.className = 'form-control form-control-sm d-none';
      entryInput.placeholder = 'Filter (string or /regex/)';

      const entryErr = document.createElement('div');
      entryErr.className = 'small text-danger d-none';

      const candWrap = document.createElement('div');
      candWrap.className = 'border rounded';
      candWrap.style.maxHeight = '240px';
      candWrap.style.overflow = 'auto';

      const candTable = document.createElement('table');
      candTable.className = 'table table-sm mb-0 align-middle';
      const candHead = document.createElement('thead');
      const candHeadTr = document.createElement('tr');
      ;['Pick','Generator','Source','Incompatibility'].forEach((h)=>{
        const th = document.createElement('th');
        th.className = 'small text-muted';
        th.style.whiteSpace = 'nowrap';
        th.textContent = h;
        candHeadTr.appendChild(th);
      });
      candHead.appendChild(candHeadTr);
      const candBody = document.createElement('tbody');
      candTable.appendChild(candHead);
      candTable.appendChild(candBody);
      candWrap.appendChild(candTable);

      let selectedCandidateId = '';
      let selectedNodeId = '';
      let nodeCandidatesCache = [];

      function chainIdsWithSelectedNode(){
        const base = Array.isArray(currentChain)
          ? currentChain.map(n => (n && n.id) ? String(n.id) : '').filter(Boolean)
          : [];
        if(!base.length) return [];
        const chosen = String(selectedNodeId || '').trim();
        if(!chosen) return base;
        return base.map((cid, j) => (j === i ? chosen : cid));
      }

      function refreshNodeOptionsFromResponse(resp){
        const list = (resp && Array.isArray(resp.node_candidates)) ? resp.node_candidates.slice() : [];
        nodeCandidatesCache = list;
        const curId = (Array.isArray(currentChain) && currentChain[i] && currentChain[i].id) ? String(currentChain[i].id) : '';
        if(!selectedNodeId){
          selectedNodeId = curId;
        }
        nodeSel.innerHTML = '';
        if(!list.length){
          const opt = document.createElement('option');
          opt.value = curId || '';
          opt.textContent = curId ? ('Current: ' + curId) : '(no nodes)';
          nodeSel.appendChild(opt);
          nodeSel.value = opt.value;
          return;
        }
        for(const n of list){
          const nid = String((n && n.id) || '').trim();
          if(!nid) continue;
          const nm = String((n && n.name) || '').trim();
          const isDocker = !!(n && n.is_docker);
          const isVuln = !!(n && n.is_vuln);
          const ok = !!(n && n.compatible);
          const label = (nm ? (nid + ' — ' + nm) : nid)
            + (isDocker ? ' [docker]' : '')
            + (isVuln ? ' [vuln]' : '')
            + (!ok ? ' (incompatible)' : '');
          const opt = document.createElement('option');
          opt.value = nid;
          opt.textContent = label;
          opt.disabled = !ok;
          nodeSel.appendChild(opt);
        }
        const hasSelected = Array.from(nodeSel.options).some(o => o.value === selectedNodeId && !o.disabled);
        if(!hasSelected){
          const curOk = Array.from(nodeSel.options).find(o => o.value === curId && !o.disabled);
          const firstOk = Array.from(nodeSel.options).find(o => !o.disabled);
          const pick = curOk || firstOk;
          selectedNodeId = pick ? pick.value : (curId || '');
        }
        nodeSel.value = selectedNodeId;
      }

      function syncKindAvailabilityForSelectedNode(){
        const nid = String(nodeSel.value || '').trim();
        selectedNodeId = nid;
        const info = (nodeCandidatesCache || []).find(x => String((x && x.id) || '').trim() === nid) || null;
        const isVuln = !!(info && info.is_vuln);
        const isDocker = !!(info && info.is_docker);
        const allowNodeGen = (!!isDocker && !isVuln);
        if(!allowNodeGen){
          kindSel.value = 'flag-generator';
        }
        try {
          const opt = Array.from(kindSel.options).find(o => String(o.value) === 'flag-node-generator');
          if(opt){
            opt.disabled = !allowNodeGen;
            if(!allowNodeGen && kindSel.value === 'flag-node-generator') kindSel.value = 'flag-generator';
          }
        } catch(e) {}
      }

      row2.appendChild(entryInput);
      row2.appendChild(entryErr);
      row2.appendChild(candWrap);
      form.appendChild(row2);

      // Hints editor (override / generated).
      try {
        const hintsDivider = document.createElement('hr');
        hintsDivider.className = 'my-3';
        form.appendChild(hintsDivider);

        const hintsHdr = document.createElement('div');
        hintsHdr.className = 'fw-semibold';
        hintsHdr.textContent = 'Hints';
        form.appendChild(hintsHdr);

        const hintsHelp = document.createElement('div');
        hintsHelp.className = 'small text-muted';
        hintsHelp.textContent = 'Override the displayed hints for this step. If disabled, hints are generated from the selected generator templates.';
        form.appendChild(hintsHelp);

        const toggleRow = document.createElement('div');
        toggleRow.className = 'd-flex align-items-center justify-content-between gap-2 mt-2';

        const toggleWrap = document.createElement('div');
        toggleWrap.className = 'form-check';
        hintOverrideToggleEl = document.createElement('input');
        hintOverrideToggleEl.type = 'checkbox';
        hintOverrideToggleEl.className = 'form-check-input';
        hintOverrideToggleEl.id = 'flowHintOverrideToggle_' + i;
        const toggleLabel = document.createElement('label');
        toggleLabel.className = 'form-check-label';
        toggleLabel.setAttribute('for', hintOverrideToggleEl.id);
        toggleLabel.textContent = 'Override hints';
        toggleWrap.appendChild(hintOverrideToggleEl);
        toggleWrap.appendChild(toggleLabel);

        const resetBtn = document.createElement('button');
        resetBtn.type = 'button';
        resetBtn.className = 'btn btn-sm btn-outline-secondary';
        resetBtn.textContent = 'Reset to generated';

        toggleRow.appendChild(toggleWrap);
        toggleRow.appendChild(resetBtn);
        form.appendChild(toggleRow);

        const listWrap = document.createElement('div');
        listWrap.className = 'border rounded p-2 mt-2';
        form.appendChild(listWrap);

        function normalizeHints(list){
          const out = [];
          try {
            (Array.isArray(list) ? list : []).forEach((x)=>{
              const s = String(x ?? '').trim();
              if(!s) return;
              out.push(s);
            });
          } catch(e) {}
          return out;
        }

        function getGeneratedHintsFromAssignment(){
          const cur = (fa && Array.isArray(fa.hints) && fa.hints.length) ? normalizeHints(fa.hints) : [];
          if(cur.length) return cur;
          const h = (fa && fa.hint) ? String(fa.hint || '').trim() : '';
          return h ? [h] : [];
        }

        function getOverrideHintsFromAssignment(){
          if(fa && Array.isArray(fa.hint_overrides)) return normalizeHints(fa.hint_overrides);
          return null;
        }

        function renderHintList(hints){
          hintOverrideInputs = [];
          listWrap.innerHTML = '';

          const stack = document.createElement('div');
          stack.className = 'd-flex flex-column gap-2';

          function addRow(value){
            const row = document.createElement('div');
            row.className = 'd-flex gap-2 align-items-center';

            const inp = document.createElement('input');
            inp.type = 'text';
            inp.className = 'form-control form-control-sm';
            inp.placeholder = 'Hint text…';
            inp.value = String(value ?? '');

            const del = document.createElement('button');
            del.type = 'button';
            del.className = 'btn btn-sm btn-outline-danger';
            del.textContent = 'Remove';
            del.addEventListener('click', ()=>{
              try { row.remove(); } catch(e) {}
              hintOverrideInputs = hintOverrideInputs.filter(x => x !== inp);
            });

            hintOverrideInputs.push(inp);
            row.appendChild(inp);
            row.appendChild(del);
            stack.appendChild(row);
          }

          (Array.isArray(hints) && hints.length ? hints : ['']).forEach(addRow);

          const addBtn = document.createElement('button');
          addBtn.type = 'button';
          addBtn.className = 'btn btn-sm btn-outline-primary';
          addBtn.textContent = 'Add hint';
          addBtn.addEventListener('click', ()=> addRow(''));

          listWrap.appendChild(stack);
          listWrap.appendChild(addBtn);
        }

        function setHintOverrideEnabled(enabled){
          hintOverridesEnabled = !!enabled;
          try { if(hintOverrideToggleEl) hintOverrideToggleEl.checked = hintOverridesEnabled; } catch(e) {}
          try { listWrap.style.display = hintOverridesEnabled ? '' : 'none'; } catch(e) {}
          try { resetBtn.disabled = !hintOverridesEnabled; } catch(e) {}
        }

        const existingOverride = getOverrideHintsFromAssignment();
        if(existingOverride !== null){
          renderHintList(existingOverride);
          setHintOverrideEnabled(true);
        } else {
          renderHintList(getGeneratedHintsFromAssignment());
          setHintOverrideEnabled(false);
        }

        hintOverrideToggleEl.addEventListener('change', ()=>{
          setHintOverrideEnabled(!!hintOverrideToggleEl.checked);
        });

        resetBtn.addEventListener('click', ()=>{
          setHintOverrideEnabled(false);
          renderHintList(getGeneratedHintsFromAssignment());
        });
      } catch(e) {
        // Non-fatal
      }

      const row3 = document.createElement('div');
      row3.className = 'd-flex align-items-center justify-content-between gap-2 mt-2';

      const cur = document.createElement('div');
      cur.className = 'small text-muted';
      cur.textContent = (fa && (fa.id || fa.name))
        ? ('Current: ' + String(fa.id || '') + (currentSource ? (' (' + currentSource + ')') : ''))
        : 'Current: -';

      const actions = document.createElement('div');
      actions.className = 'd-flex gap-2';
      const cancelBtn = document.createElement('button');
      cancelBtn.type = 'button';
      cancelBtn.className = 'btn btn-sm btn-outline-secondary';
      cancelBtn.textContent = 'Cancel';
      const applyBtn = document.createElement('button');
      applyBtn.type = 'button';
      applyBtn.className = 'btn btn-sm btn-primary';
      applyBtn.textContent = 'Apply';
      actions.appendChild(cancelBtn);
      actions.appendChild(applyBtn);

      row3.appendChild(cur);
      row3.appendChild(actions);
      form.appendChild(row3);

      substituteBodyEl.appendChild(form);

      function getCatalogForKind(kind){
        const cat = (String(kind) === 'flag-node-generator')
          ? (Array.isArray(_flagNodeGeneratorsCatalog) ? _flagNodeGeneratorsCatalog : [])
          : (Array.isArray(_flagGeneratorsCatalog) ? _flagGeneratorsCatalog : []);
        return (cat || []).filter(g => !(g && g._disabled));
      }

      function rebuildSourceOptions(){
        const kind = String(kindSel.value || 'flag-generator');
        const cat = getCatalogForKind(kind);
        const sources = new Set();
        (cat || []).forEach(g => {
          try {
            const s = String((g && g._source_name) || '').trim();
            if(s) sources.add(s);
          } catch(e) {}
        });
        const sorted = Array.from(sources).sort((a,b)=>String(a).localeCompare(String(b)));
        sourceSel.innerHTML = '';
        const anyOpt = document.createElement('option');
        anyOpt.value = '__any__';
        anyOpt.textContent = '(Any source)';
        sourceSel.appendChild(anyOpt);
        for(const s of sorted){
          const o = document.createElement('option');
          o.value = s;
          o.textContent = s;
          sourceSel.appendChild(o);
        }
        const entryOpt = document.createElement('option');
        entryOpt.value = '__entry__';
        entryOpt.textContent = 'Entry…';
        sourceSel.appendChild(entryOpt);
        if(currentSource && sorted.includes(currentSource)){
          sourceSel.value = currentSource;
        } else {
          sourceSel.value = '__any__';
        }
      }

      function rebuildGeneratorOptions(){
        const kind = String(kindSel.value || 'flag-generator');
        const cat = getCatalogForKind(kind);
        const source = String(sourceSel.value || '__any__');

        entryErr.classList.add('d-none');
        entryErr.textContent = '';

        let filtered = (cat || []).slice();

        if(source === '__entry__'){
          entryInput.classList.remove('d-none');
          const compiled = compileStringOrRegex(entryInput.value);
          if(!compiled.ok){
            entryErr.textContent = compiled.error;
            entryErr.classList.remove('d-none');
            filtered = [];
          } else if(compiled.regex){
            filtered = filtered.filter(g => {
              const gid = String((g && g.id) || '');
              const gname = String((g && g.name) || '');
              return compiled.regex.test(gid) || compiled.regex.test(gname);
            });
          }
        } else {
          entryInput.classList.add('d-none');
          if(source !== '__any__'){
            filtered = filtered.filter(g => String((g && g._source_name) || '').trim() === source);
          }
        }

        // Cap for UI sanity.
        filtered = filtered.slice(0, 250);

        // Default selection to current.
        try {
          const curId = (fa && fa.id) ? String(fa.id) : '';
          selectedCandidateId = curId || '';
        } catch(e) {
          selectedCandidateId = '';
        }

        // Ask server to compute compatibility against the current chain context.
        const chainIds = chainIdsWithSelectedNode();
        const reqAssignments = chainIds.map((nid, j)=>{
          const curA = (Array.isArray(currentFlagAssignments) && currentFlagAssignments[j]) ? currentFlagAssignments[j] : {};
          const curId = String((curA && (curA.id || curA.generator_id)) || '').trim();
          return { node_id: nid, id: curId };
        });
        const candidateIds = filtered.map(g => String((g && g.id) || '').trim()).filter(Boolean);

        // Render optimistic placeholder.
        candBody.innerHTML = '';
        if(!candidateIds.length){
          const tr = document.createElement('tr');
          const td = document.createElement('td');
          td.colSpan = 4;
          td.className = 'text-muted small';
          td.textContent = 'No matches.';
          tr.appendChild(td);
          candBody.appendChild(tr);
          return;
        }

        (async ()=>{
          let candidates = [];
          try {
            const res = await postJson('/api/flag-sequencing/substitution_candidates', {
              scenario: activeScenario,
              preview_plan: (lastPreviewPlanPath || lastFlowPlanPath || ''),
              chain_ids: chainIds,
              flag_assignments: reqAssignments,
              index: i,
              kind,
              candidate_ids: candidateIds,
              allow_node_duplicates: !!allowNodeDuplicates,
            }, { timeoutMs: 45000 });
            try { refreshNodeOptionsFromResponse(res); } catch(e) {}
            try { syncKindAvailabilityForSelectedNode(); } catch(e) {}
            candidates = (res && Array.isArray(res.candidates)) ? res.candidates.slice() : [];
          } catch(e) {
            // If this fails, fall back to showing everything as selectable.
            candidates = candidateIds.map((gid)=>{
              const g = filtered.find(x => String((x && x.id) || '').trim() === gid) || {};
              return {
                id: String(gid),
                name: String((g && g.name) || ''),
                source: String((g && g._source_name) || '').trim() || 'unknown',
                compatible: true,
                blocked_by: [],
              };
            });
          }

          // Ensure ordering: compatible first.
          candidates.sort((a,b)=>{
            const ak = (a && a.compatible) ? 0 : 1;
            const bk = (b && b.compatible) ? 0 : 1;
            if(ak !== bk) return ak - bk;
            const an = String((a && a.name) || '').toLowerCase();
            const bn = String((b && b.name) || '').toLowerCase();
            if(an < bn) return -1;
            if(an > bn) return 1;
            return String((a && a.id) || '').localeCompare(String((b && b.id) || ''));
          });

          candBody.innerHTML = '';
          for(const c of candidates){
            const cid = String((c && c.id) || '').trim();
            if(!cid) continue;
            const tr = document.createElement('tr');
            const ok = !!(c && c.compatible);
            if(!ok){
              tr.classList.add('text-muted');
              tr.style.opacity = '0.6';
            }

            const tdPick = document.createElement('td');
            tdPick.style.width = '1%';
            tdPick.style.whiteSpace = 'nowrap';
            const radio = document.createElement('input');
            radio.type = 'radio';
            radio.name = 'flowSubstitutePick';
            radio.value = cid;
            radio.checked = !!(selectedCandidateId && selectedCandidateId === cid);
            radio.addEventListener('change', ()=>{ selectedCandidateId = cid; });
            tdPick.appendChild(radio);

            const tdGen = document.createElement('td');
            tdGen.style.whiteSpace = 'nowrap';
            const nm = String((c && c.name) || '').trim();
            tdGen.textContent = nm ? (cid + ' — ' + nm) : cid;

            const tdSrc = document.createElement('td');
            tdSrc.style.whiteSpace = 'nowrap';
            tdSrc.textContent = String((c && c.source) || '').trim() || '-';

            const tdWhy = document.createElement('td');
            tdWhy.className = 'small';
            const blocked = (c && Array.isArray(c.blocked_by)) ? c.blocked_by.map(x => String(x || '').trim()).filter(Boolean) : [];
            tdWhy.textContent = ok ? '' : (blocked.length ? blocked.join(' · ') : 'incompatible');

            tr.appendChild(tdPick);
            tr.appendChild(tdGen);
            tr.appendChild(tdSrc);
            tr.appendChild(tdWhy);

            tr.addEventListener('click', ()=>{
              selectedCandidateId = cid;
              try { radio.checked = true; } catch(e) {}
            });

            candBody.appendChild(tr);
          }

          if(selectedCandidateId){
            const found = candidates.find(x => String((x && x.id) || '') === selectedCandidateId);
            if(!found) selectedCandidateId = '';
          }
        })();
      }

      nodeSel.addEventListener('change', ()=>{
        try { syncKindAvailabilityForSelectedNode(); } catch(e) {}
        rebuildSourceOptions();
        rebuildGeneratorOptions();
      });

      kindSel.addEventListener('change', ()=>{
        try { syncKindAvailabilityForSelectedNode(); } catch(e) {}
        rebuildSourceOptions();
        rebuildGeneratorOptions();
      });
      sourceSel.addEventListener('change', ()=>{
        rebuildGeneratorOptions();
      });
      entryInput.addEventListener('input', ()=>{
        if(String(sourceSel.value || '') === '__entry__') rebuildGeneratorOptions();
      });

      cancelBtn.addEventListener('click', ()=>{
        try {
          if(typeof substituteDialogEl.close === 'function') substituteDialogEl.close();
        } catch(e) {}
      });

      applyBtn.addEventListener('click', async ()=>{
        const chosenId = String(selectedCandidateId || '').trim();
        if(!chosenId){
          setStatus('Select a generator first.', true);
          return;
        }
        try { applyBtn.disabled = true; } catch(e) {}
        try { cancelBtn.disabled = true; } catch(e) {}
        try{
          if(!Array.isArray(currentChain) || currentChain.length === 0){
            throw new Error('Generate a chain first.');
          }
          const chainIds = chainIdsWithSelectedNode();
          if(!chainIds.length) throw new Error('Missing chain ids.');

          const currentNodeId = (Array.isArray(currentChain) && currentChain[i] && currentChain[i].id) ? String(currentChain[i].id) : '';
          const reqAssignments = chainIds.map((nid, j)=>{
            const curA = (Array.isArray(currentFlagAssignments) && currentFlagAssignments[j]) ? currentFlagAssignments[j] : {};
            const curId = String((curA && (curA.id || curA.generator_id)) || '').trim();
            const idOut = (j === i) ? chosenId : curId;

            let ovr = (curA && typeof curA.config_overrides === 'object' && curA.config_overrides && !Array.isArray(curA.config_overrides))
              ? curA.config_overrides
              : undefined;
            if(j === i){
              if(String(nid) !== String(currentNodeId) || String(idOut) !== String(curId)){
                ovr = undefined;
              }
            }

            // Preserve hint overrides for other steps. For this step:
            // - if override enabled: send list
            // - else: send null to clear any previous override (use generated templates)
            let hintOvr = undefined;
            try {
              if(curA && Array.isArray(curA.hint_overrides)) hintOvr = curA.hint_overrides;
            } catch(e) {}

            if(j === i){
              if(hintOverridesEnabled){
                const texts = [];
                try {
                  (hintOverrideInputs || []).forEach((el)=>{
                    const s = String((el && el.value) ?? '').trim();
                    if(!s) return;
                    texts.push(s);
                  });
                } catch(e) {}
                hintOvr = texts;
              } else {
                hintOvr = null;
              }

              if((String(nid) !== String(currentNodeId) || String(idOut) !== String(curId)) && !hintOverridesEnabled){
                hintOvr = null;
              }
            }

            const out = { node_id: nid, id: idOut, config_overrides: ovr };
            if(hintOvr !== undefined) out.hint_overrides = hintOvr;
            return out;
          });
          const missing = reqAssignments.find(x => !x.id);
          if(missing){
            throw new Error('Cannot save substitution because some chain positions have no generator assignment yet. Try Generate again.');
          }

          showLoading('Saving substitution…');
          const res = await postJson('/api/flag-sequencing/save_flow_substitutions', {
            scenario: activeScenario,
            chain_ids: chainIds,
            preview_plan: (lastPreviewPlanPath || lastFlowPlanPath || ''),
            flag_assignments: reqAssignments,
          }, { timeoutMs: 60000 });

          setFlowValidityFromPayload(res);
          if(res && Array.isArray(res.chain)) currentChain = res.chain.slice();
          if(res && Array.isArray(res.flag_assignments)) currentFlagAssignments = res.flag_assignments.slice();
          if(res && res.flow_plan_path) lastFlowPlanPath = String(res.flow_plan_path);
          updateMeta();
          renderChainEditor();
          setStatus('Edits saved. Saving XML…', false);

          try {
            if(typeof substituteDialogEl.close === 'function') substituteDialogEl.close();
          } catch(e) {}

          try {
            await saveXmlOnly({});
          } catch(e) {
            setStatus('Saved edits, but Save XML failed: ' + String(e && e.message || e), true);
          }
        } catch(e){
          setStatus('Failed to save edits: ' + String(e && e.message || e), true);
        } finally {
          try { applyBtn.disabled = false; } catch(e) {}
          try { cancelBtn.disabled = false; } catch(e) {}
          hideLoading();
        }
      });

      // Load generator catalogs immediately.
      (async ()=>{
        try{
          showLoading('Loading generator catalog…');
          await ensureGeneratorCatalogsLoaded();
          rebuildSourceOptions();
          rebuildGeneratorOptions();
        } catch(e){
          setStatus('Failed to load generator catalog: ' + String(e && e.message || e), true);
        } finally {
          hideLoading();
        }
      })();
    } catch(e) {
      // Non-fatal
    }

    try{
      if(typeof substituteDialogEl.showModal === 'function') substituteDialogEl.showModal();
    } catch(e) {}
  }

  function selectChainIndex(idx){
    selectedChainIndex = Number.isFinite(+idx) ? (+idx) : -1;
    if(selectedChainIndex < 0 || !Array.isArray(currentChain) || selectedChainIndex >= currentChain.length){
      selectedChainIndex = -1;
      renderChainEditor();
      return;
    }
    renderChainEditor();
  }

  function updateMeta(){
    if(metaScenarioEl) metaScenarioEl.textContent = (activeScenario || '') ? String(activeScenario) : '-';
    if(metaPreviewEl) metaPreviewEl.textContent = lastPreviewPlanPath ? basenameFromPath(lastPreviewPlanPath) : '-';
    if(metaStatsEl) metaStatsEl.textContent = formatStats(lastStats) || '-';
  }

  async function refreshAssignmentsFromChain(){
    if(!Array.isArray(currentChain) || currentChain.length === 0) return;
    setStatus('Updating…', false);
    try{
      // Recompute assignments + validity based on the current chain order.
      const data = await postJson('/api/flag-sequencing/afb_from_chain', { scenario: activeScenario, chain: currentChain });
      currentFlagAssignments = Array.isArray(data.flag_assignments) ? data.flag_assignments.slice() : currentFlagAssignments;
      setFlowValidityFromPayload(data);
      if(jsonEl){
        jsonEl.textContent = JSON.stringify({
          scenario: (data && data.scenario) ? data.scenario : activeScenario,
          length: (data && Number.isFinite(+data.length)) ? (+data.length) : (Array.isArray(currentChain) ? currentChain.length : 0),
          chain: Array.isArray(currentChain) ? currentChain : [],
          flag_assignments: Array.isArray(currentFlagAssignments) ? currentFlagAssignments : [],
          flow_valid: !!(data && data.flow_valid),
          flow_errors: Array.isArray(data && data.flow_errors) ? data.flow_errors : [],
          flags_enabled: !!(data && data.flags_enabled),
        }, null, 2);
      }
      const diagram = buildMermaid(currentChain);
      await renderMermaid(diagram);
      updateMeta();
      setStatus('Ready.', false);
    } catch(err){
      setStatus(String(err && err.message || err), true);
    }
  }

  function formatStats(stats){
    if(!stats || typeof stats !== 'object') return '';
    const fg = Number.isFinite(+stats.flag_generator_eligible_total) ? (+stats.flag_generator_eligible_total) : (Number.isFinite(+stats.eligible_total) ? (+stats.eligible_total) : null);
    const fng = Number.isFinite(+stats.flag_node_generator_eligible_total) ? (+stats.flag_node_generator_eligible_total) : (Number.isFinite(+stats.docker_nonvuln_total) ? (+stats.docker_nonvuln_total) : null);
    const v = Number.isFinite(+stats.vuln_total) ? (+stats.vuln_total) : null;
    const dOther = Number.isFinite(+stats.docker_nonvuln_total) ? (+stats.docker_nonvuln_total) : null;
    if(fg === null && fng === null && v === null && dOther === null) return '';
    const parts = [];
    if(fg !== null) parts.push('Flag-Generator eligible: ' + fg);
    if(fng !== null) parts.push('Flag-Node-Generator eligible: ' + fng);
    if(v !== null) parts.push('Vuln nodes: ' + v);
    if(dOther !== null) parts.push('Other Docker Nodes: ' + dOther);
    return parts.join(' · ');
  }

  function buildMermaid(chain){
    const lines = ['flowchart LR'];
    if(!Array.isArray(chain) || chain.length === 0){
      lines.push('  A[No chain available]');
      return lines.join('\n');
    }
    for(let i=0;i<chain.length;i++){
      const node = chain[i];
      const safeId = 'N' + i;
      const label = (node && node.name) ? node.name : ('Node ' + (i+1));
      const seq = toRoman(i + 1);
      const prefixed = (seq ? (seq + '. ') : '') + String(label || '');
      lines.push(`  ${safeId}[${prefixed.replace(/\]/g,'')}]`);
      if(i>0){
        lines.push(`  N${i-1} --> ${safeId}`);
      }
    }
    for(let i=0;i<chain.length;i++){
      lines.push(`  click N${i} flowSelectNode "Show details"`);
    }
    return lines.join('\n');
  }

  async function renderMermaid(diagramText){
    try {
      if(window.mermaid){
        mermaid.initialize({ startOnLoad: false, securityLevel: 'loose' });
        const wrap = document.getElementById('flowDiagram');
        wrap.textContent = diagramText;
        wrap.removeAttribute('data-processed');
        await mermaid.run({ querySelector: '#flowDiagram' });
      }
    } catch(e) {
      // If rendering fails, keep plaintext.
      const wrap = document.getElementById('flowDiagram');
      if(wrap) wrap.textContent = diagramText;
    }
  }

  function shouldOfferBestEffort(err){
    try{
      const p = err && err.payload && typeof err.payload === 'object' ? err.payload : null;
      const available = p && Number.isFinite(+p.available) ? (+p.available) : null;
      if(!available || available <= 0) return null;
      const msg = (p && (p.error || p.message)) ? String(p.error || p.message) : '';
      if(msg && !msg.toLowerCase().includes('eligible')) return null;
      return { available, message: msg, requested: p && Number.isFinite(+p.requested_length) ? (+p.requested_length) : null };
    } catch(e){
      return null;
    }
  }

  async function generate(preferPreview, opts){
    const options = (opts && typeof opts === 'object') ? opts : {};
    const usePreview = !!preferPreview;
    const scenario = (scenarioEl && scenarioEl.value || '').trim();
    const preset = (presetEl && presetEl.value) ? String(presetEl.value).trim() : '';
    const length = preset ? 3 : (parseInt((lengthEl && lengthEl.value) || '5', 10) || 5);

    // User-click Generate should be deterministic: save current settings, produce a fresh
    // preview plan, then build + resolve the flow from that exact snapshot.
    const runSavePreviewResolve = !!(usePreview && options && options.savePreviewResolve);

    const params = new URLSearchParams();
    if(scenario) params.set('scenario', scenario);
    params.set('length', String(length));
    if(preset) params.set('preset', preset);
    // Only force preview selection when the user explicitly clicks Generate.
    if(usePreview){
      params.set('prefer_preview', '1');
      params.set('force_preview', '1');
    }

    const allowDupes = !!options.allow_node_duplicates;
    if(allowDupes){
      params.set('allow_node_duplicates', '1');
    }

    const buildAttackflowPreviewUrl = (p) => '/api/flag-sequencing/attackflow_preview?' + (p ? p.toString() : params.toString());
    if(afbDownloadLink) afbDownloadLink.href = '#';

    setStatus('Generating…', false);
    setLoginLinkVisible(false);
    showLoading('Generating flow…');
    if(metaScenarioEl) metaScenarioEl.textContent = '';
    if(metaPreviewEl) metaPreviewEl.textContent = '';
    if(metaStatsEl) metaStatsEl.textContent = '';
    if(jsonEl) jsonEl.textContent = '';

    try {
      if(runSavePreviewResolve){
        const scenLabel = (scenario || activeScenario || '').toString().trim();
        const msg = scenLabel
          ? ('Generate will save current Topology / VM Access settings for scenario "' + scenLabel + '" and then resolve Flag Sequencing hints.\n\nContinue?')
          : 'Generate will save current Topology / VM Access settings and then resolve Flag Sequencing hints.\n\nContinue?';
        const ok = confirm(msg);
        if(!ok){
          hideLoading();
          setStatus('Generate cancelled.', false);
          return;
        }
        if(typeof window.coretgSaveXmlViaApi !== 'function' || typeof window.coretgPostJson !== 'function'){
          throw new Error('Save helper unavailable; refresh and try again.');
        }

        setStatus('Saving XML…', false);
        showLoading('Saving XML…');
        const xmlPath = await window.coretgSaveXmlViaApi();
        if(!xmlPath){
          throw new Error('Save did not return xml_path');
        }

        setStatus('Preparing preview plan…', false);
        showLoading('Preparing preview plan…');
        let seed = null;
        try {
          if (scenario && typeof window.coretgEnsureSeedForScenario === 'function') {
            seed = window.coretgEnsureSeedForScenario(scenario);
          }
        } catch(e) { seed = null; }
        const persisted = await window.coretgPostJson('/api/plan/persist_preview_plan', { xml_path: xmlPath, scenario, seed });
        try {
          if (scenario && persisted && persisted.seed !== undefined && typeof window.coretgSetSeedForScenario === 'function') {
            window.coretgSetSeedForScenario(scenario, persisted.seed);
          }
        } catch(e) {}
        const previewPlan = (persisted && persisted.preview_plan_path) ? String(persisted.preview_plan_path) : '';
        if(!previewPlan){
          throw new Error('Failed to persist preview plan');
        }
        try {
          if (scenario && typeof window.coretgSetPreviewPlanPathForScenario === 'function') {
            window.coretgSetPreviewPlanPathForScenario(scenario, previewPlan);
          }
        } catch(e) {}
        try {
          if (scenario && typeof window.coretgSetPreviewPlanPathForScenario === 'function') {
            window.coretgSetPreviewPlanPathForScenario(scenario, previewPlan);
          }
        } catch(e) {}
        lastPreviewPlanPath = previewPlan;
        params.set('preview_plan', previewPlan);
      }

      let data;
      try{
        data = await fetchJson(buildAttackflowPreviewUrl(params));
      } catch(err){
        // If Generate requested a longer chain than available, ask user whether to
        // retry in best-effort mode (clamp to available) or cancel.
        const offer = usePreview ? shouldOfferBestEffort(err) : null;
        if(offer){
          const want = confirm(`Only ${offer.available} eligible nodes are available for this scenario.\n\nRun Generate in best-effort mode (use ${offer.available})?`);
          if(!want){
            hideLoading();
            setStatus('Generate cancelled.', false);
            return;
          }
          const params2 = new URLSearchParams(params.toString());
          params2.set('best_effort', '1');
          const retryUrl = buildAttackflowPreviewUrl(params2);
          data = await fetchJson(retryUrl);
        } else {
          throw err;
        }
      }
      currentChain = Array.isArray(data.chain) ? data.chain.slice() : [];
      currentFlagAssignments = Array.isArray(data.flag_assignments) ? data.flag_assignments.slice() : [];
      setFlowValidityFromPayload(data);
      lastStats = data.stats || null;
      lastPreviewPlanPath = data.preview_plan_path || '';
      // IMPORTANT: never carry a stale flow-plan path across runs.
      // If the backend doesn't return a flow plan path for this preview, clear it.
      lastFlowPlanPath = data.flow_plan_path || '';
      try {
        // If the backend loaded a saved chain whose effective length differs from the
        // current input value (e.g. page reload reset to default), keep the UI in sync.
        const effLen = Number.isFinite(+data.length) ? (+data.length) : null;
        if (effLen !== null && lengthEl) lengthEl.value = String(effLen);
      } catch(e) {}
      updateMeta();
      selectedChainIndex = -1;
      renderChainEditor();
      persistFlowState();

      if(jsonEl){
        jsonEl.textContent = JSON.stringify({
          scenario: (data && data.scenario) ? data.scenario : activeScenario,
          length: (data && Number.isFinite(+data.length)) ? (+data.length) : (Array.isArray(currentChain) ? currentChain.length : 0),
          chain: Array.isArray(currentChain) ? currentChain : [],
          flag_assignments: Array.isArray(currentFlagAssignments) ? currentFlagAssignments : [],
          flow_valid: !!(data && data.flow_valid),
          flow_errors: Array.isArray(data && data.flow_errors) ? data.flow_errors : [],
          flags_enabled: !!(data && data.flags_enabled),
        }, null, 2);
      }
      const diagram = buildMermaid(currentChain);
      await renderMermaid(diagram);

      // Optional (user-click only): run the prepare step so generator outputs can resolve
      // hint templates immediately (e.g., IPs/ports/usernames) without requiring a refresh.
      if(usePreview){
        try{
          if(Array.isArray(currentChain) && currentChain.length){
            showLoading('Resolving hint values…');
            setStatus('Resolving hint values…', false);
            const chainIds = currentChain.map(n => (n && n.id) ? String(n.id) : '').filter(Boolean);
            const prepData = await postJson(
              '/api/flag-sequencing/prepare_preview_for_execute',
              {
                scenario,
                length: currentChain.length,
                preset,
                chain_ids: chainIds,
                // Use the preview plan that produced the current chain.
                // Using a stale flow plan can cause chain_ids to mismatch and collapse.
                preview_plan: (lastPreviewPlanPath || ''),
                allow_node_duplicates: !!allowDupes,
                mode: 'hint',
                best_effort: true,
                timeout_s: 30
              },
              { timeoutMs: 35000 }
            );
            setFlowValidityFromPayload(prepData);

            // If the server adjusted the chain (rare, e.g. preset repair), keep UI in sync.
            const oldIds = chainIds.join('|');
            const newChain = (prepData && Array.isArray(prepData.chain)) ? prepData.chain.slice() : null;
            const newIds = (newChain || []).map(n => (n && n.id) ? String(n.id) : '').filter(Boolean).join('|');
            if(newChain && newChain.length){
              currentChain = newChain;
            }

            if(prepData && Array.isArray(prepData.flag_assignments)){
              currentFlagAssignments = prepData.flag_assignments.slice();
              renderChainEditor();
            }
            if(prepData && prepData.preview_plan_path){
              lastPreviewPlanPath = String(prepData.preview_plan_path);
              updateMeta();
            }
            if(prepData && prepData.flow_plan_path){
              lastFlowPlanPath = String(prepData.flow_plan_path);
            }

            // If chain changed, regenerate computed assignments to match (keep resolved hints in UI).
            if(newChain && newIds && oldIds !== newIds){
              await refreshAssignmentsFromChain();
              if(prepData && Array.isArray(prepData.flag_assignments)){
                currentFlagAssignments = prepData.flag_assignments.slice();
                renderChainEditor();
              }
              const diagram2 = buildMermaid(currentChain);
              await renderMermaid(diagram2);
            }
          }
        } catch(e) {
          // Non-fatal: the flow UI is still usable even if hints aren't resolved.
          try {
            const msg = (e && e.message) ? String(e.message) : String(e || 'prepare failed');
            setStatus('Hint resolution failed: ' + msg, true);
          } catch(_) {}
        }
      }

      setStatus('Ready.', false);
    } catch(err){
      setStatus(String(err && err.message || err), true);
      setLoginLinkVisible(!!(err && err.loginRequired));
      const payload = err && err.payload ? err.payload : null;
      setFlowValidityFromPayload(payload);
      lastStats = payload && payload.stats ? payload.stats : null;
      lastPreviewPlanPath = payload && payload.preview_plan_path ? String(payload.preview_plan_path) : '';
      lastFlowPlanPath = payload && payload.flow_plan_path ? String(payload.flow_plan_path) : lastFlowPlanPath;
      updateMeta();
      currentChain = [];
      currentFlagAssignments = [];
      selectedChainIndex = -1;
      renderChainEditor();
      const diagram = buildMermaid([]);
      await renderMermaid(diagram);
    } finally {
      hideLoading();
    }
  }

  async function execute(){
    const scenario = (scenarioEl && scenarioEl.value || '').trim();
    const preset = (presetEl && presetEl.value) ? String(presetEl.value).trim() : '';
    const length = (Array.isArray(currentChain) && currentChain.length) ? currentChain.length : (parseInt((lengthEl && lengthEl.value) || '5', 10) || 5);
    if(!scenario){
      setStatus('No scenario selected.', true);
      return;
    }
    // If the shared Execute button is gated (CORE VM not verified), it won't be clickable,
    // but keep this guard anyway in case something calls execute() programmatically.
    if(execEl && execEl.disabled){
      setStatus('Verify a CORE VM in VM / Access to enable Execute.', true);
      return;
    }
    if(execEl) execEl.disabled = true;
    setStatus('Preparing preview for execution…', false);
    setLoginLinkVisible(false);
    showLoading('Resolving hint values…');
    try{
      if(!Array.isArray(currentChain) || currentChain.length === 0){
        throw new Error('Generate a chain first.');
      }
      const chainIds = currentChain.map(n => (n && n.id) ? String(n.id) : '').filter(Boolean);
      const planPath = (lastFlowPlanPath || lastPreviewPlanPath || '');
      const prepData = await postJson(
        '/api/flag-sequencing/prepare_preview_for_execute',
        {
          scenario,
          length,
          preset,
          chain_ids: chainIds,
          preview_plan: planPath,
          allow_node_duplicates: !!allowNodeDuplicates,
        },
        { timeoutMs: 480000 }
      );
      setFlowValidityFromPayload(prepData);
      // Prefer server-returned (possibly enriched) assignments so the UI can show
      // generator run status/mismatch info before scenario execution.
      if(prepData && Array.isArray(prepData.flag_assignments)){
        currentFlagAssignments = prepData.flag_assignments.slice();
        renderChainEditor();
      }
      const xmlPath = (prepData && prepData.xml_path) ? String(prepData.xml_path) : '';
      const previewPlan = (prepData && prepData.preview_plan_path) ? String(prepData.preview_plan_path) : '';
      const flowPlan = (prepData && prepData.flow_plan_path) ? String(prepData.flow_plan_path) : '';
      if(!xmlPath || !previewPlan){
        throw new Error('Prepare step did not return xml_path/preview_plan_path');
      }
      if(flowPlan) lastFlowPlanPath = flowPlan;
      setStatus('Starting async execution…', false);
      const runData = await postJson('/run_cli_async', { xml_path: xmlPath, preview_plan: (flowPlan || planPath || previewPlan), scenario });
      const runId = runData && runData.run_id ? String(runData.run_id) : '';
      if(runId){
        setStatus('Run started: ' + runId + ' (see Core/Reports pages).', false);
      } else {
        setStatus('Run started (missing run_id).', false);
      }
    } catch(err){
      setStatus(String(err && err.message || err), true);
      setLoginLinkVisible(!!(err && err.loginRequired));
    } finally {
      hideLoading();
      try {
        if (typeof window.coretgRefreshScenariosExecuteButtonState === 'function') {
          window.coretgRefreshScenariosExecuteButtonState();
        } else if (execEl) {
          execEl.disabled = false;
        }
      } catch (e) {
        if (execEl) execEl.disabled = false;
      }
    }
  }

  async function preview(){
    // Save XML, persist a preview plan, persist flow sequencing, then redirect to Preview.
    try {
      const scenario = (scenarioEl && scenarioEl.value || '').trim();
      if(!scenario){
        setStatus('No scenario selected.', true);
        return;
      }
      persistFlowState();
      if(typeof window.coretgSaveXmlViaApi !== 'function' || typeof window.coretgPostJson !== 'function'){
        setStatus('Save helper unavailable; refresh and try again.', true);
        return;
      }

      if(execEl) execEl.disabled = true;
      setStatus('Saving XML…', false);
      showLoading('Saving XML…');
      const xmlPath = await window.coretgSaveXmlViaApi();
      if(!xmlPath){
        throw new Error('Save did not return xml_path');
      }

      // Ensure we have a persisted preview plan artifact to base Flow changes on.
      setStatus('Preparing preview plan…', false);
      showLoading('Preparing preview plan…');
      let seed = null;
      try {
        if (scenario && typeof window.coretgEnsureSeedForScenario === 'function') {
          seed = window.coretgEnsureSeedForScenario(scenario);
        }
      } catch(e) { seed = null; }
      const persisted = await window.coretgPostJson('/api/plan/persist_preview_plan', { xml_path: xmlPath, scenario, seed });
      try {
        if (scenario && persisted && persisted.seed !== undefined && typeof window.coretgSetSeedForScenario === 'function') {
          window.coretgSetSeedForScenario(scenario, persisted.seed);
        }
      } catch(e) {}
      const previewPlan = (persisted && persisted.preview_plan_path) ? String(persisted.preview_plan_path) : '';
      if(!previewPlan){
        throw new Error('Failed to persist preview plan');
      }

      // Persist the current chain into a flow-modified plan immediately.
      const preset = (presetEl && presetEl.value) ? String(presetEl.value).trim() : '';
      const chainIds = Array.isArray(currentChain) ? currentChain.map(n => (n && n.id) ? String(n.id) : '').filter(Boolean) : [];
      if(chainIds.length){
        setStatus('Saving Flag Sequencing…', false);
        showLoading('Saving Flag Sequencing…');
        await window.coretgPostJson('/api/flag-sequencing/prepare_preview_for_execute', {
          scenario,
          preset,
          length: chainIds.length,
          chain_ids: chainIds,
          preview_plan: previewPlan,
          allow_node_duplicates: !!allowNodeDuplicates,
        });
      }

      // Navigate to Preview tab.
      const baseUrl = String(document.getElementById('scenariosPreviewTabLink')?.dataset?.previewBaseUrl || '/scenarios/preview');
      const url = baseUrl + '?xml_path=' + encodeURIComponent(xmlPath) + '&scenario=' + encodeURIComponent(scenario);
      window.location.href = url;
    } catch(e) {
      setStatus('Preview failed: ' + String(e && e.message || e), true);
    } finally {
      hideLoading();
      try {
        if (typeof window.coretgRefreshScenariosExecuteButtonState === 'function') {
          window.coretgRefreshScenariosExecuteButtonState();
        } else if (execEl) {
          execEl.disabled = false;
        }
      } catch (e) {
        if (execEl) execEl.disabled = false;
      }
    }
  }

  async function saveXmlStay(){
    try {
      persistFlowState();
      if(typeof window.coretgSaveXmlViaApi !== 'function'){
        setStatus('Save helper unavailable; refresh and try again.', true);
        return;
      }
      if(saveXmlEl) saveXmlEl.disabled = true;
      showLoading('Saving XML…');

      const scenario = (scenarioEl && scenarioEl.value || activeScenario || '').trim();
      const preset = (presetEl && presetEl.value) ? String(presetEl.value).trim() : '';
      const length = (Array.isArray(currentChain) && currentChain.length) ? currentChain.length : (parseInt((lengthEl && lengthEl.value) || '5', 10) || 5);

      const xmlPath = await window.coretgSaveXmlViaApi();
      if(xmlPath){
        let hintResolveFailed = false;
        try {
          const xmlPathInput = document.getElementById('scenariosPreviewXmlPath');
          if(xmlPathInput) xmlPathInput.value = String(xmlPath);
        } catch(e) {}
        try {
          if(downloadXmlEl){
            downloadXmlEl.disabled = false;
            downloadXmlEl.removeAttribute('title');
          }
        } catch(e) {}

        // Pull the fresh preview plan path produced during Save XML so subsequent
        // hint resolution uses the latest snapshot.
        try {
          if(scenario && typeof window.coretgGetPreviewPlanPathForScenario === 'function'){
            const p = (window.coretgGetPreviewPlanPathForScenario(scenario) || '').toString().trim();
            if(p) lastPreviewPlanPath = p;
          }
        } catch(e) {}

        // Best-effort: if a chain is already generated, resolve templates/hints now.
        // This mirrors Generate's "save + resolve" behavior.
        try {
          if(scenario && Array.isArray(currentChain) && currentChain.length){
            const chainIds = currentChain.map(n => (n && n.id) ? String(n.id) : '').filter(Boolean);
            const planPath = (lastPreviewPlanPath || '');
            if(chainIds.length && planPath){
              showLoading('Resolving hint values…');
              const prepData = await postJson('/api/flag-sequencing/prepare_preview_for_execute', {
                scenario,
                length,
                preset,
                chain_ids: chainIds,
                preview_plan: planPath,
                allow_node_duplicates: !!allowNodeDuplicates,
              });
              setFlowValidityFromPayload(prepData);
              if(prepData && Array.isArray(prepData.flag_assignments)){
                currentFlagAssignments = prepData.flag_assignments.slice();
              }
              try {
                if(scenario && typeof window.coretgSetFlowDirtyForScenario === 'function') {
                  window.coretgSetFlowDirtyForScenario(scenario, false);
                }
              } catch(e) {}
              try {
                if(prepData && prepData.preview_plan_path) lastPreviewPlanPath = String(prepData.preview_plan_path);
              } catch(e) {}
              try {
                if(prepData && prepData.flow_plan_path) lastFlowPlanPath = String(prepData.flow_plan_path);
              } catch(e) {}
              updateMeta();
              renderChainEditor();
            }
          }
        } catch(e) {
          // Non-fatal: XML save succeeded.
          hintResolveFailed = true;
          setStatus('Saved XML, but hint resolution failed: ' + String(e && e.message || e), true);
        }

        if(!hintResolveFailed){
          setStatus('Saved XML: ' + basenameFromPath(xmlPath), false);
        }
        try { await refreshXmlDockPreview({ force: true }); } catch(e) {}
      } else {
        setStatus('Saved XML (missing path).', false);
      }
    } catch(e){
      setStatus('Save failed: ' + String(e && e.message || e), true);
    } finally {
      hideLoading();
      if(saveXmlEl) saveXmlEl.disabled = false;
    }
  }

  // Bottom-bar buttons: Save XML saves and stays; Preview saves then redirects.
  document.addEventListener('DOMContentLoaded', () => {
    try {
      if(saveXmlEl){
        saveXmlEl.addEventListener('click', (ev) => {
          try { ev.preventDefault(); } catch(e) {}
          saveXmlStay();
        });
      }
    } catch(e) {}
    try {
      if(execEl){
        execEl.addEventListener('click', (ev) => {
          try { ev.preventDefault(); } catch(e) {}
          preview();
        });
      }
    } catch(e) {}
  });

  async function saveXmlOnly(opts){
    const options = (opts && typeof opts === 'object') ? opts : {};
    const scenario = (scenarioEl && scenarioEl.value || '').trim();
    const preset = (presetEl && presetEl.value) ? String(presetEl.value).trim() : '';
    const length = (Array.isArray(currentChain) && currentChain.length) ? currentChain.length : (parseInt((lengthEl && lengthEl.value) || '5', 10) || 5);
    if(!scenario){
      setStatus('No scenario selected.', true);
      return '';
    }
    if(saveXmlEl) saveXmlEl.disabled = true;
    setStatus('Preparing preview and saving XML…', false);
    setLoginLinkVisible(false);
    showLoading('Resolving hint values…');
    try{
      if(!Array.isArray(currentChain) || currentChain.length === 0){
        throw new Error('Generate a chain first.');
      }
      const chainIds = currentChain.map(n => (n && n.id) ? String(n.id) : '').filter(Boolean);
      const planPath = (lastFlowPlanPath || lastPreviewPlanPath || '');
      const prepData = await postJson('/api/flag-sequencing/prepare_preview_for_execute', { scenario, length, preset, chain_ids: chainIds, preview_plan: planPath, allow_node_duplicates: !!allowNodeDuplicates });
      setFlowValidityFromPayload(prepData);
      if(prepData && Array.isArray(prepData.flag_assignments)){
        currentFlagAssignments = prepData.flag_assignments.slice();
        renderChainEditor();
      }
      const xmlPath = (prepData && prepData.xml_path) ? String(prepData.xml_path) : '';
      const previewPlan = (prepData && prepData.preview_plan_path) ? String(prepData.preview_plan_path) : '';
      if(!xmlPath || !previewPlan){
        throw new Error('Prepare step did not return xml_path/preview_plan_path');
      }
      lastPreviewPlanPath = previewPlan;
      try {
        if(prepData && prepData.flow_plan_path) lastFlowPlanPath = String(prepData.flow_plan_path);
      } catch(e) {}
      updateMeta();
      try {
        const xmlPathInput = document.getElementById('scenariosPreviewXmlPath');
        if(xmlPathInput) xmlPathInput.value = xmlPath;
      } catch(e) {}
      try {
        if(downloadXmlEl){
          downloadXmlEl.disabled = false;
          downloadXmlEl.removeAttribute('title');
        }
      } catch(e) {}
      setStatus('Saved XML: ' + basenameFromPath(xmlPath), false);
      try { await refreshXmlDockPreview({ force: true }); } catch(e) {}
      return xmlPath;
    } catch(err){
      setStatus(String(err && err.message || err), true);
      setLoginLinkVisible(!!(err && err.loginRequired));
      // If preview requested, surface failure by throwing so caller does not redirect.
      if (options && options.redirectAfter) throw err;
      return '';
    } finally {
      hideLoading();
      if(saveXmlEl) saveXmlEl.disabled = false;
    }
  }

  function downloadXml(){
    try {
      const xmlPath = (document.getElementById('scenariosPreviewXmlPath')?.value || '').trim();
      if(!xmlPath){
        setStatus('Save XML first to download.', true);
        return;
      }
      window.location.href = '/download_report?path=' + encodeURIComponent(xmlPath);
    } catch(err){
      setStatus(String(err && err.message || err), true);
    }
  }

  // Expose a mermaid click callback; it receives the nodeId like "N0".
  window.flowSelectNode = function(nodeId){
    try{
      const m = String(nodeId || '').match(/^N(\d+)$/);
      if(!m) return;
      const idx = parseInt(m[1], 10);
      if(Number.isFinite(idx)){
        selectChainIndex(idx);
        openNodeDetailsDialog(idx);
      }
    } catch(e) {}
  };

  // Allow clicking the backdrop to close the node dialog.
  try{
    if(nodeDetailsDialogEl){
      nodeDetailsDialogEl.addEventListener('click', (ev)=>{
        try {
          if(ev && ev.target === nodeDetailsDialogEl && typeof nodeDetailsDialogEl.close === 'function'){
            nodeDetailsDialogEl.close();
          }
        } catch(e) {}
      });
    }
  } catch(e) {}

  // Generate options dialog.
  try{
    if(generateOptionsDialogEl){
      generateOptionsDialogEl.addEventListener('close', ()=>{
        try{
          const rv = String(generateOptionsDialogEl.returnValue || '');
          if(rv !== 'generate') return;
          const noDupes = generateNoDuplicatesEl ? !!generateNoDuplicatesEl.checked : true;
          allowNodeDuplicates = !noDupes;
          generate(true, { savePreviewResolve: true, allow_node_duplicates: !!allowNodeDuplicates });
        } catch(e) {}
      });
    }
  } catch(e) {}

  if(btnEl) btnEl.addEventListener('click', (e)=>{
    try { e.preventDefault(); } catch(_) {}
    try{
      if(generateOptionsDialogEl && typeof generateOptionsDialogEl.showModal === 'function'){
        generateOptionsDialogEl.showModal();
        return;
      }
    } catch(_) {}
    // Fallback: behave like old Generate (no duplicates).
    allowNodeDuplicates = false;
    generate(true, { savePreviewResolve: true, allow_node_duplicates: false });
  });
  // Handlers for Save/Preview are registered above.
  if(downloadXmlEl) downloadXmlEl.addEventListener('click', (e)=>{ e.preventDefault(); downloadXml(); });

  if(afbDownloadLink){
    afbDownloadLink.addEventListener('click', async (e)=>{
      try{
        e.preventDefault();
        if(!Array.isArray(currentChain) || currentChain.length === 0){
          setStatus('Nothing to download yet (generate first).', true);
          return;
        }

        // Keep UI validity state in sync before exporting.
        try{ await refreshAssignmentsFromChain(); } catch(err) {}

        setStatus('Building .afb…', false);
        const data = await postJson('/api/flag-sequencing/afb_from_chain', { scenario: activeScenario, chain: currentChain });
        setFlowValidityFromPayload(data);
        const afb = data && data.afb ? data.afb : null;
        if(!afb){
          setStatus('No .afb returned by server.', true);
          return;
        }
        const scenario = (scenarioEl && scenarioEl.value || activeScenario || 'scenario').toString().trim();
        const norm = normalizeScenarioNorm(scenario).replace(/\s+/g,'_') || 'scenario';
        const fname = 'attackflow_builder_' + norm + '_' + String(Array.isArray(currentChain)?currentChain.length:0) + '.afb';
        const blob = new Blob([JSON.stringify(afb, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = fname;
        document.body.appendChild(a);
        a.click();
        a.remove();
        setTimeout(()=>URL.revokeObjectURL(url), 1000);
        setStatus('Ready.', false);
      } catch(err){
        setStatus(String(err && err.message || err), true);
      }
    });
  }

  // Wire scenario list.
  if(scenarioListEl){
    scenarioListEl.querySelectorAll('[data-scen-name]').forEach(btn => {
      btn.addEventListener('click', async ()=>{
        const name = btn.getAttribute('data-scen-name') || '';
        if(!name || name === activeScenario) return;
        await setScenario(name);
      });
    });
  }
  if(clearScenarioBtn){
    clearScenarioBtn.addEventListener('click', async ()=>{
      const def = defaultScenarioName();
      if(def && def !== activeScenario) await setScenario(def);
    });
  }

  // Auto-generate on load (per-scenario page). If there are no scenarios, disable.
  if(!activeScenario){
    setStatus('No scenarios available yet.', true);
    if(btnEl) btnEl.disabled = true;
    return;
  }
  if(scenarioEl && !scenarioEl.value) scenarioEl.value = activeScenario;
  if(scenarioLabelEl && !scenarioLabelEl.textContent) scenarioLabelEl.textContent = activeScenario;
  updateScenarioQueryParam();
  updateScenarioFilterControls();
  refreshParticipantNavForScenario(activeScenario);
  rememberActiveScenario();
  if(seedToggleBtn && !seedToggleBtn.dataset.boundSeedToggle){
    seedToggleBtn.addEventListener('click', (ev)=>{
      try { ev.preventDefault(); } catch(e) {}
      const next = !getSidebarShowSeed();
      setSidebarShowSeed(next);
      updateScenarioSeedBadges();
    });
    seedToggleBtn.dataset.boundSeedToggle = '1';
  }
  updateScenarioSeedBadges();
  // Auto-generate on load (prefer any saved Flow state).
  try { refreshXmlDockPreview({ force: false }); } catch(e) {}
  generate(false);
})();
</script>
{% endblock %}
  // Scenarios header Preview tab: route to /scenarios/preview.
  document.addEventListener('DOMContentLoaded', ()=>{
    const link = document.getElementById('scenariosPreviewTabLink');
    if(!link) return;
    link.addEventListener('click', (ev)=>{
      try {
        ev.preventDefault();
        const xmlPath = (document.getElementById('scenariosPreviewXmlPath')?.value || '').trim();
        const scen = (document.getElementById('flowScenario')?.value || document.getElementById('scenariosPreviewScenario')?.value || '').trim();
        if(!xmlPath){
          alert('Save XML first to preview.');
          return;
        }
        const baseUrl = String(link.dataset?.previewBaseUrl || '/scenarios/preview');
        const url = baseUrl + '?xml_path=' + encodeURIComponent(xmlPath) + (scen ? ('&scenario=' + encodeURIComponent(scen)) : '');
        window.location.href = url;
      } catch(e){}
    });
  });

