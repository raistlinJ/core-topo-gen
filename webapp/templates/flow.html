{% extends 'layout.html' %}
{% block title %}Flag Sequencing{% endblock %}
{% block active_page %}{% set active_page='scenarios' %}{% endblock %}
{% block header_icon %}<i class="bi bi-bezier2 fs-4"></i>{% endblock %}
{% block header_title %}Flag Sequencing{% endblock %}
{% block extra_head %}
<script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
<style>
  body { padding-bottom: 0; }
  #flowLayoutRow { min-height: calc(100vh - 200px); }
  /* Prevent long <pre>/<svg> content from forcing the Bootstrap row to wrap columns. */
  #flowLayoutRow > [class*='col-'] { min-width: 0; }
  @media (max-width: 992px) {
    #flowLayoutRow { min-height: 0; }
  }
</style>
{% endblock %}

{% block content %}
{% set scenario_tab = (active_scenario or request.args.get('scenario','')) %}
{% set scenarios_active_tab = 'flag-sequencing' %}
{% include 'partials/scenarios_tabs.html' with context %}
<div class="container-fluid mt-3 d-flex flex-column" id="flowPageWrap">
  <div class="row g-3 flex-grow-1 align-items-stretch" id="flowLayoutRow">
    <div class="col-12 col-lg-3 d-flex">
      <div class="card shadow-sm mb-3 flex-fill d-flex flex-column">
        <div class="card-header d-flex justify-content-between align-items-center flex-nowrap gap-2">
          <span class="fw-bold">Scenarios</span>
          <div class="btn-toolbar gap-1 align-items-center flex-nowrap">
            <button type="button" class="btn btn-sm btn-outline-secondary py-0 px-1" id="toggleScenarioSeedBtn" title="Show seeds" aria-label="Toggle seed visibility">
              <i class="bi bi-eye" aria-hidden="true"></i>
            </button>
            <button class="btn btn-sm btn-outline-secondary {% if not active_scenario %}d-none{% endif %}" id="flowScenarioFilterClear" type="button" title="Clear">Clear</button>
          </div>
        </div>
        <div class="list-group list-group-flush flex-grow-1 overflow-auto" id="flowScenarioList" style="min-height:0;">
          {% if scenarios %}
            {% for s in scenarios %}
            <button type="button" class="list-group-item list-group-item-action py-1 {% if active_scenario and active_scenario==s %}active bg-primary text-white{% endif %}" data-scen-name="{{ s }}">
              <div class="d-flex align-items-center">
                <span class="flex-grow-1 text-truncate">{{ s }}</span>
                <span class="badge text-bg-light border ms-2 d-none" data-seed-badge="1"></span>
              </div>
            </button>
            {% endfor %}
          {% else %}
            <div class="p-3 text-muted small">No scenarios yet</div>
          {% endif %}
        </div>
      </div>
    </div>

    <div class="col-12 col-lg-9 d-flex">
      <div class="flex-fill d-flex flex-column">
        <div class="d-flex align-items-center justify-content-between flex-wrap gap-2 mb-3">
          <div class="fw-semibold">Generate an Attack Flow from the latest preview plan</div>
        </div>

        <div class="card mb-3">
          <div class="card-body">
            <input id="flowScenario" class="form-control d-none" value="{{ active_scenario or request.args.get('scenario','') }}">
            <div class="row g-2 align-items-end">
              <div class="col-sm-6 col-md-2">
                <label class="form-label">Max Chain length</label>
                <input id="flowLength" class="form-control" type="number" min="1" max="50" value="5">
              </div>
              <div class="col-sm-6 col-md-4">
                <label class="form-label">Preset</label>
                <select id="flowPreset" class="form-select">
                  <option value="">Random (default)</option>
                  <option value="sample_reverse_nfs_ssh">Sample: reverse_nfs_ssh</option>
                </select>
              </div>
              <div class="col-md-6">
                <div class="d-flex gap-2 flex-nowrap align-items-end">
                  <div>
                    <button id="flowGenerateBtn" class="btn btn-primary text-nowrap" type="button">Generate</button>
                  </div>
                  <div>
                    <label class="form-label small text-muted mb-1" for="flowGenerateMaxRetries">Max retries</label>
                    <input id="flowGenerateMaxRetries" class="form-control form-control-sm" type="number" min="0" max="50" value="5" style="width: 90px;">
                  </div>
                  <div class="dropdown">
                    <button class="btn btn-outline-secondary dropdown-toggle text-nowrap" type="button" id="flowDownloadDropdown" data-bs-toggle="dropdown" aria-expanded="false">
                      Download
                    </button>
                    <ul class="dropdown-menu" aria-labelledby="flowDownloadDropdown">
                      <li><a class="dropdown-item" href="#" id="flowDownloadAfb">Attack Flow (afb)</a></li>
                      <li><a class="dropdown-item" href="#" id="flowDownloadAttackGraphDot">Attack Graph (dot)</a></li>
                      <li><a class="dropdown-item" href="#" id="flowDownloadAttackGraphJson">Attack Graph (json)</a></li>
                      <li><a class="dropdown-item" href="#" id="flowDownloadAttackGraphPdf">Attack Graph (pdf)</a></li>
                    </ul>
                  </div>
                </div>
              </div>
              <div class="col-md-4">
                <div class="small">
                  <span id="flowStatus" class="text-muted" style="white-space: pre-line;"></span>
                  <span id="flowRestoreBadge" class="ms-2 text-success d-none">Restored saved flow state</span>
                  <a id="flowLoginLink" class="ms-2 d-none" href="/login">Login</a>
                </div>
              </div>
            </div>
            <div class="small text-muted mt-2">Current rule: <span class="font-monospace">flag-generator</span> steps are placed on vulnerability nodes only. Non-vulnerability Docker nodes use <span class="font-monospace">flag-node-generator</span>. Default chain order is randomized; you can tweak it below.</div>
          </div>
        </div>

        <div id="flowValidityAlert" class="alert alert-danger d-none" role="alert"></div>

        <div class="card mb-3">
          <div class="card-header d-flex align-items-center justify-content-between">
            <div class="fw-semibold">Visualization</div>
          </div>
          <div class="card-body">
            <div class="small mb-2" id="flowMetaRow">
              <table class="table table-sm table-borderless mb-0 align-middle">
                <thead>
                  <tr class="text-secondary">
                    <th scope="col" class="fw-normal" style="width: 18%;">Scenario</th>
                    <th scope="col" class="fw-normal" style="width: 32%;">Preview</th>
                    <th scope="col" class="fw-normal">Eligibility</th>
                  </tr>
                </thead>
                <tbody class="text-muted">
                  <tr>
                    <td id="flowMetaScenario"></td>
                    <td style="min-width: 0; max-width: 0;">
                      <div id="flowMetaPreview" class="text-truncate" style="max-width: 100%;"></div>
                    </td>
                    <td id="flowMetaStats"></td>
                  </tr>
                </tbody>
              </table>
            </div>
            <div id="flowDiagramWrap" class="border rounded p-2" style="min-height: 180px; overflow-x: auto;">
              <div id="flowDiagram" class="mermaid">graph LR\n  A[Generate] --> B[Flow]</div>
            </div>

            <dialog id="flowNodeDetailsDialog" class="p-0 border rounded" style="max-width: 1150px; width: calc(100% - 2rem); max-height: 85vh; overflow: hidden;">
              <form method="dialog" class="m-0" style="display:flex;flex-direction:column;max-height:85vh;">
                <div class="p-3 border-bottom d-flex align-items-center justify-content-between" style="flex:0 0 auto;">
                  <div class="fw-semibold" id="flowNodeDetailsTitle">Node</div>
                  <button class="btn btn-sm btn-outline-secondary" value="close" type="submit">Close</button>
                </div>
                <div class="p-3" style="flex:1 1 auto; overflow: auto;">
                  <div id="flowNodeDetailsBody" class="small"></div>
                </div>
              </form>
            </dialog>

            <dialog id="flowInputsDialog" class="p-0 border rounded" style="max-width: 1150px; width: calc(100% - 2rem); max-height: 85vh; overflow: hidden;">
              <form method="dialog" class="m-0" style="display:flex;flex-direction:column;max-height:85vh;">
                <div class="p-3 border-bottom d-flex align-items-center justify-content-between" style="flex:0 0 auto;">
                  <div class="fw-semibold" id="flowInputsTitle">Inputs</div>
                </div>
                <div class="p-3" style="flex:1 1 auto; overflow: auto;">
                  <div id="flowInputsBody" class="small"></div>
                </div>
                <div class="p-3 border-top d-flex justify-content-end" style="flex:0 0 auto;">
                  <button class="btn btn-sm btn-outline-secondary" value="close" type="submit">Close</button>
                </div>
              </form>
            </dialog>

            <dialog id="flowFactsDialog" class="p-0 border rounded" style="max-width: 800px; width: calc(100% - 2rem); max-height: 85vh; overflow: hidden;">
              <form method="dialog" class="m-0" style="display:flex;flex-direction:column;max-height:85vh;">
                <div class="p-3 border-bottom d-flex align-items-center justify-content-between" style="flex:0 0 auto;">
                  <div class="fw-semibold" id="flowFactsTitle">Facts</div>
                </div>
                <div class="p-3" style="flex:1 1 auto; overflow: auto;">
                  <div id="flowFactsBody" class="small"></div>
                </div>
                <div class="p-3 border-top d-flex justify-content-end" style="flex:0 0 auto;">
                  <button class="btn btn-sm btn-outline-secondary" value="close" type="submit">Close</button>
                </div>
              </form>
            </dialog>

            <dialog id="flowSubstituteDialog" class="p-0 border rounded" style="max-width: 1150px; width: calc(100% - 2rem); max-height: 85vh; overflow: hidden;">
              <form method="dialog" class="m-0" style="display:flex;flex-direction:column;max-height:85vh;">
                <div class="p-3 border-bottom d-flex align-items-center justify-content-between" style="flex:0 0 auto;">
                  <div class="fw-semibold" id="flowSubstituteTitle">Substitute</div>
                  <button class="btn btn-sm btn-outline-secondary" value="close" type="submit">Close</button>
                </div>
                <div class="p-3" style="flex:1 1 auto; overflow: auto;">
                  <div id="flowSubstituteBody" class="small"></div>
                </div>
              </form>
            </dialog>
          </div>
        </div>

        <div class="card mb-3">
          <div class="card-header d-flex align-items-center justify-content-between">
            <div class="fw-semibold">Chain Order</div>
          </div>
          <div class="card-body">
            <div class="small text-muted mb-1" aria-hidden="true" style="display:grid;grid-template-columns:84px 1fr;gap:.5rem;align-items:center;">
              <div class="pe-2" style="border-right: 1px solid var(--bs-border-color, #dee2e6);">Sequence</div>
              <div>Details</div>
            </div>
            <div id="flowChainList" class="list-group"></div>
          </div>
        </div>

      </div>
    </div>
  </div>
</div>
{% endblock %}

{% block body_container %}
{{ super() }}
{% set xml_preview_enabled = True %}
{% set xml_preview_text = xml_preview %}
{% include 'partials/dock.html' %}

<!-- Loading overlay shown during slow operations (e.g., resolving hint templates via generator runs). -->
<div id="flowLoadingOverlay" class="position-fixed top-0 start-0 w-100 h-100 d-none" style="z-index: 2000;">
  <div class="position-absolute top-0 start-0 w-100 h-100 bg-dark bg-opacity-50"></div>
  <div class="position-absolute top-50 start-50 translate-middle bg-white rounded shadow p-3" style="min-width: 320px; max-width: 560px;">
    <div class="d-flex align-items-center gap-2">
      <div class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></div>
      <div class="fw-semibold" id="flowLoadingText">Loading…</div>
    </div>
    <div class="small text-muted mt-2" id="flowLoadingStepsLabel">Progress steps</div>
    <ul id="flowLoadingSteps" class="small mt-1 mb-0 d-none"></ul>
    <div class="small text-muted mt-2 d-none" id="flowLoadingLogLabel">Details</div>
    <ul id="flowLoadingLog" class="small text-muted mt-1 mb-0 d-none"></ul>
    <div class="small text-muted mt-2">This can take a few seconds while preview plans and sequencing run.</div>
  </div>
</div>

<!-- Generate options (minimal) -->
<dialog id="flowGenerateOptionsDialog" class="p-0 border rounded" style="max-width: 520px; width: calc(100% - 2rem);">
  <form method="dialog" class="m-0">
    <div class="p-3 border-bottom d-flex align-items-center justify-content-between">
      <div class="fw-semibold">Generate options</div>
      <button class="btn btn-sm btn-outline-secondary" value="cancel" type="submit">Close</button>
    </div>
    <div class="p-3">
      <div class="form-check">
        <input class="form-check-input" type="checkbox" id="flowGenerateNoDuplicates">
        <label class="form-check-label" for="flowGenerateNoDuplicates">Allow duplicates</label>
      </div>
      <div class="small text-muted mt-2">
        If checked, the chain may repeat nodes; repeated rows are highlighted and generator seeds will differ per occurrence.
      </div>
    </div>
    <div class="p-3 border-top d-flex justify-content-end gap-2">
      <button class="btn btn-outline-secondary" value="cancel" type="submit">Cancel</button>
      <button class="btn btn-primary" value="generate" type="submit">Generate</button>
    </div>
  </form>
</dialog>

<script>
(async function(){
  const SIDEBAR_SEED_VISIBILITY_STORAGE_KEY = 'coretg_sidebar_show_seed';

  const statusEl = document.getElementById('flowStatus');
  const loginLinkEl = document.getElementById('flowLoginLink');
  const scenarioEl = document.getElementById('flowScenario');
  const scenarioLabelEl = document.getElementById('flowScenarioLabel');
  const lengthEl = document.getElementById('flowLength');
  const presetEl = document.getElementById('flowPreset');
  const btnEl = document.getElementById('flowGenerateBtn');
  const generateMaxRetriesEl = document.getElementById('flowGenerateMaxRetries');
  const restoreBadgeEl = document.getElementById('flowRestoreBadge');
  const saveXmlEl = document.getElementById('saveXmlBtn');
  const execEl = document.getElementById('scenariosExecuteBtn');
  const downloadXmlEl = document.getElementById('downloadXmlBtn');
  const jsonEl = document.getElementById('flowJson');
  const metaScenarioEl = document.getElementById('flowMetaScenario');
  const metaPreviewEl = document.getElementById('flowMetaPreview');
  const metaStatsEl = document.getElementById('flowMetaStats');

  const nodeDetailsDialogEl = document.getElementById('flowNodeDetailsDialog');
  const nodeDetailsTitleEl = document.getElementById('flowNodeDetailsTitle');
  const nodeDetailsBodyEl = document.getElementById('flowNodeDetailsBody');
  const inputsDialogEl = document.getElementById('flowInputsDialog');
  const inputsTitleEl = document.getElementById('flowInputsTitle');
  const inputsBodyEl = document.getElementById('flowInputsBody');
  const factsDialogEl = document.getElementById('flowFactsDialog');
  const factsTitleEl = document.getElementById('flowFactsTitle');
  const factsBodyEl = document.getElementById('flowFactsBody');
  const substituteDialogEl = document.getElementById('flowSubstituteDialog');
  const substituteTitleEl = document.getElementById('flowSubstituteTitle');
  const substituteBodyEl = document.getElementById('flowSubstituteBody');
  const downloadAfbLink = document.getElementById('flowDownloadAfb');
  const downloadAttackGraphDotLink = document.getElementById('flowDownloadAttackGraphDot');
  const downloadAttackGraphJsonLink = document.getElementById('flowDownloadAttackGraphJson');
  const downloadAttackGraphPdfLink = document.getElementById('flowDownloadAttackGraphPdf');
  const scenarioListEl = document.getElementById('flowScenarioList');
  const clearScenarioBtn = document.getElementById('flowScenarioFilterClear');
  const seedToggleBtn = document.getElementById('toggleScenarioSeedBtn');
  const validityAlertEl = document.getElementById('flowValidityAlert');
  const loadingOverlayEl = document.getElementById('flowLoadingOverlay');
  const loadingTextEl = document.getElementById('flowLoadingText');
  const loadingStepsLabelEl = document.getElementById('flowLoadingStepsLabel');
  const loadingStepsEl = document.getElementById('flowLoadingSteps');
  const loadingLogLabelEl = document.getElementById('flowLoadingLogLabel');
  const loadingLogEl = document.getElementById('flowLoadingLog');
  const generateOptionsDialogEl = document.getElementById('flowGenerateOptionsDialog');
  const generateNoDuplicatesEl = document.getElementById('flowGenerateNoDuplicates');

  const participantUrlFlags = {{ (participant_url_flags or {})|tojson }};
  const flowStateByScenario = {{ (flow_state_by_scenario or {})|tojson }};
  const scenarioNamesCache = {{ (scenarios or [])|tojson }};
  const initialScenario = {{ (active_scenario or '')|tojson }};
  let activeScenario = (initialScenario || (Array.isArray(scenarioNamesCache) && scenarioNamesCache.length ? String(scenarioNamesCache[0]) : '')).trim();

  function getSidebarShowSeed(){
    try { return (localStorage.getItem(SIDEBAR_SEED_VISIBILITY_STORAGE_KEY) || '') === '1'; } catch(e) { return false; }
  }

  function setSidebarShowSeed(value){
    try { localStorage.setItem(SIDEBAR_SEED_VISIBILITY_STORAGE_KEY, value ? '1' : '0'); } catch(e) {}
  }

  function syncSidebarSeedToggleButton(){
    if(!seedToggleBtn) return;
    const show = getSidebarShowSeed();
    const icon = seedToggleBtn.querySelector('i');
    if(icon){
      icon.classList.remove('bi-eye', 'bi-eye-slash');
      icon.classList.add(show ? 'bi-eye-slash' : 'bi-eye');
    }
    seedToggleBtn.title = show ? 'Hide seeds' : 'Show seeds';
  }

  function updateScenarioSeedBadges(){
    if(!scenarioListEl) return;
    const show = getSidebarShowSeed();
    try{
      const maxLen = Array.isArray(currentChain) ? currentChain.length : 0;
      Array.from(heldChainIndices || []).forEach((idx)=>{
        const n = Number(idx);
        if(!Number.isFinite(n) || n < 0 || n >= maxLen){
          try { heldChainIndices.delete(idx); } catch(e) {}
        }
      });
    } catch(e) {}
    scenarioListEl.querySelectorAll('button[data-scen-name]').forEach((btn)=>{
      const scen = (btn.getAttribute('data-scen-name') || '').trim();
      const badge = btn.querySelector('[data-seed-badge]');
      if(!badge) return;
      if(!show){
        badge.classList.add('d-none');
        badge.textContent = '';
        return;
      }
      let seed = null;
      try {
        if (scen && typeof window.coretgEnsureSeedForScenario === 'function') {
          seed = window.coretgEnsureSeedForScenario(scen);
        }
      } catch(e) { seed = null; }
      badge.textContent = 'seed=' + (seed !== null && seed !== undefined ? String(seed) : '…');
      badge.classList.remove('d-none');
    });
    syncSidebarSeedToggleButton();
  }

  function rememberActiveScenario(){
    try {
      if (activeScenario && typeof window.coretgSetActiveScenarioForNav === 'function') {
        window.coretgSetActiveScenarioForNav(activeScenario);
      } else if (activeScenario && typeof window.coretgSetLastSelectedScenario === 'function') {
        window.coretgSetLastSelectedScenario(activeScenario);
      }
    } catch(e) {}
  }

  let currentChain = [];
  let lastStats = null;
  let lastPreviewPlanPath = '';
  let currentFlagAssignments = [];
  let selectedChainIndex = -1;
  let lastFlowValid = true;
  let lastFlowErrors = [];
  let lastFlagsEnabled = true;
  let lastHostIpMap = new Map();
  let allowNodeDuplicates = false;
  let heldChainIndices = new Set();
  let heldFactRows = new Set();
  let flowInitialFactsOverride = null;
  let flowGoalFactsOverride = null;

  function isAutosaveXmlPath(value){
    if(!value || typeof value !== 'string') return false;
    const normalized = value.replace(/\\/g, '/');
    return normalized.includes('/outputs/autosave/') || /\bautosave[-_]/i.test(normalized);
  }

  let _flagGeneratorsCatalog = null;
  let _flagNodeGeneratorsCatalog = null;

  async function ensureGeneratorCatalogsLoaded(){
    if(Array.isArray(_flagGeneratorsCatalog) && Array.isArray(_flagNodeGeneratorsCatalog)) return;
    try {
      const [fg, fng] = await Promise.all([
        fetchJson('/flag_generators_data'),
        fetchJson('/flag_node_generators_data'),
      ]);
      _flagGeneratorsCatalog = (fg && Array.isArray(fg.generators)) ? fg.generators.slice() : [];
      _flagNodeGeneratorsCatalog = (fng && Array.isArray(fng.generators)) ? fng.generators.slice() : [];
    } catch(e) {
      _flagGeneratorsCatalog = Array.isArray(_flagGeneratorsCatalog) ? _flagGeneratorsCatalog : [];
      _flagNodeGeneratorsCatalog = Array.isArray(_flagNodeGeneratorsCatalog) ? _flagNodeGeneratorsCatalog : [];
      throw e;
    }
  }

  function compileStringOrRegex(input){
    const raw = String(input || '').trim();
    if(!raw) return { ok: true, regex: null, isRegex: false, error: '' };
    // Mirror the vulnerability chooser: accept /regex/ syntax.
    if(raw.length >= 2 && raw.startsWith('/') && raw.lastIndexOf('/') > 0){
      const lastSlash = raw.lastIndexOf('/');
      const body = raw.slice(1, lastSlash);
      const flags = raw.slice(lastSlash + 1);
      try {
        const re = new RegExp(body, flags || 'i');
        return { ok: true, regex: re, isRegex: true, error: '' };
      } catch(e) {
        return { ok: false, regex: null, isRegex: true, error: String(e && e.message || e || 'Invalid regex') };
      }
    }
    // Plain string match (case-insensitive substring).
    try {
      const escaped = raw.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
      return { ok: true, regex: new RegExp(escaped, 'i'), isRegex: false, error: '' };
    } catch(e) {
      return { ok: false, regex: null, isRegex: false, error: String(e && e.message || e || 'Invalid filter') };
    }
  }

  function persistFlowState(){
    try {
      const scenario = (scenarioEl && scenarioEl.value || '').trim();
      if(!scenario) return;
      const preset = (presetEl && presetEl.value) ? String(presetEl.value).trim() : '';
      const chain_ids = Array.isArray(currentChain) ? currentChain.map(n => (n && n.id) ? String(n.id) : '').filter(Boolean) : [];
      if(!chain_ids.length) return;
      if(typeof window.coretgSetSavedFlowStateForScenario !== 'function') return;
      window.coretgSetSavedFlowStateForScenario(scenario, {
        preset,
        length: chain_ids.length,
        chain_ids: chain_ids,
        flag_assignments: buildPersistAssignments(chain_ids),
        allow_node_duplicates: !!allowNodeDuplicates,
        initial_facts: flowInitialFactsOverride,
        goal_facts: flowGoalFactsOverride,
      });
    } catch(e) {}
  }

  function alignAssignmentsToChain(chain, assignments){
    try{
      if(!Array.isArray(chain) || !Array.isArray(assignments)) return assignments;
      const pools = new Map();
      assignments.forEach((a)=>{
        if(!a || typeof a !== 'object') return;
        const nid = (a.node_id !== undefined && a.node_id !== null) ? String(a.node_id) : '';
        if(!nid) return;
        const list = pools.get(nid) || [];
        list.push(a);
        pools.set(nid, list);
      });
      const out = [];
      chain.forEach((n, i)=>{
        const nid = (n && n.id !== undefined && n.id !== null) ? String(n.id) : '';
        let a = null;
        if(nid && pools.has(nid)){
          const list = pools.get(nid) || [];
          if(list.length){
            a = list.shift();
            pools.set(nid, list);
          }
        }
        if(!a && i < assignments.length){
          a = assignments[i];
        }
        if(!a || typeof a !== 'object') a = {};
        if(nid) a.node_id = nid;
        out.push(a);
      });
      return out;
    } catch(e){
      return assignments;
    }
  }

  function clearFlowState(message){
    try{
      currentChain = [];
      currentFlagAssignments = [];
      selectedChainIndex = -1;
      updateMeta();
      renderChainEditor();
      if(jsonEl){
        jsonEl.textContent = JSON.stringify({
          scenario: activeScenario,
          length: 0,
          chain: [],
          flag_assignments: [],
          flow_valid: false,
          flow_errors: [],
          flags_enabled: false,
        }, null, 2);
      }
      const diagram = buildMermaid([]);
      renderMermaid(diagram);
      if(message) setStatus(message, true);
    } catch(e) {}
  }

  function shouldAllowGeneratorReuse(warningText){
    try{
      const msg = String(warningText || '');
      if(!msg) return true;
      if(!msg.toLowerCase().includes('generator reuse')) return true;
      return confirm('Not enough unique generators for this chain length. Allow generator reuse?');
    } catch(e) {
      return true;
    }
  }

  function buildPersistAssignments(chain_ids){
    const ids = Array.isArray(chain_ids) ? chain_ids : [];
    return ids.map((nid, j)=>{
      const curA = (Array.isArray(currentFlagAssignments) && currentFlagAssignments[j]) ? currentFlagAssignments[j] : {};
      const curId = String((curA && (curA.id || curA.generator_id)) || '').trim();
      const out = { node_id: String(nid || ''), id: curId };

      const ovr = (curA && typeof curA.config_overrides === 'object' && curA.config_overrides && !Array.isArray(curA.config_overrides))
        ? curA.config_overrides
        : undefined;
      const outOvr = (curA && typeof curA.output_overrides === 'object' && curA.output_overrides && !Array.isArray(curA.output_overrides))
        ? curA.output_overrides
        : undefined;
      const injOvr = (curA && Array.isArray(curA.inject_files_override))
        ? curA.inject_files_override
        : undefined;
      const hintOvr = (curA && Array.isArray(curA.hint_overrides)) ? curA.hint_overrides : undefined;
      const flagOvr = (curA && typeof curA.flag_override === 'string' && curA.flag_override.trim()) ? String(curA.flag_override).trim() : undefined;

      const typeVal = (curA && typeof curA.type === 'string' && curA.type.trim()) ? String(curA.type).trim() : undefined;
      const genLabel = (curA && typeof curA.flag_generator === 'string' && curA.flag_generator.trim()) ? String(curA.flag_generator).trim() : undefined;
      const inputFields = (curA && Array.isArray(curA.input_fields)) ? curA.input_fields.map(String).filter(Boolean) : undefined;
      const inputFieldsReq = (curA && Array.isArray(curA.input_fields_required)) ? curA.input_fields_required.map(String).filter(Boolean) : undefined;
      const inputFieldsOpt = (curA && Array.isArray(curA.input_fields_optional)) ? curA.input_fields_optional.map(String).filter(Boolean) : undefined;
      const outputFields = (curA && Array.isArray(curA.output_fields)) ? curA.output_fields.map(String).filter(Boolean) : undefined;
      const produces = (curA && Array.isArray(curA.produces)) ? curA.produces.map(String).filter(Boolean) : undefined;
      const requires = (curA && Array.isArray(curA.requires)) ? curA.requires.map(String).filter(Boolean) : undefined;
      const hintVal = (curA && typeof curA.hint === 'string' && curA.hint.trim()) ? String(curA.hint).trim() : undefined;
      const hintsVal = (curA && Array.isArray(curA.hints)) ? curA.hints.map(String).filter(Boolean) : undefined;
      const descHints = (curA && Array.isArray(curA.description_hints)) ? curA.description_hints.map(String).filter(Boolean) : undefined;

      if(ovr !== undefined) out.config_overrides = ovr;
      if(outOvr !== undefined) out.output_overrides = outOvr;
      if(injOvr !== undefined) out.inject_files_override = injOvr;
      if(hintOvr !== undefined) out.hint_overrides = hintOvr;
      if(flagOvr !== undefined) out.flag_override = flagOvr;
      if(typeVal !== undefined) out.type = typeVal;
      if(genLabel !== undefined) out.flag_generator = genLabel;
      if(inputFields !== undefined) out.input_fields = inputFields;
      if(inputFieldsReq !== undefined) out.input_fields_required = inputFieldsReq;
      if(inputFieldsOpt !== undefined) out.input_fields_optional = inputFieldsOpt;
      if(outputFields !== undefined) out.output_fields = outputFields;
      if(produces !== undefined) out.produces = produces;
      if(requires !== undefined) out.requires = requires;
      if(hintVal !== undefined) out.hint = hintVal;
      if(hintsVal !== undefined) out.hints = hintsVal;
      if(descHints !== undefined) out.description_hints = descHints;
      try{
        if(curA && typeof curA.resolved_inputs === 'object' && !Array.isArray(curA.resolved_inputs)){
          out.resolved_inputs = curA.resolved_inputs;
        }
        if(curA && typeof curA.resolved_outputs === 'object' && !Array.isArray(curA.resolved_outputs)){
          out.resolved_outputs = curA.resolved_outputs;
        }
        if(curA && typeof curA.flag_value === 'string' && curA.flag_value.trim()){
          out.flag_value = curA.flag_value.trim();
        }
      } catch(e) {}
      return out;
    });
  }

  function getFlowStateForScenario(scenarioName){
    try{
      const key = normalizeScenarioNorm(scenarioName);
      if(!key) return null;
      const fs = (flowStateByScenario && typeof flowStateByScenario === 'object') ? flowStateByScenario[key] : null;
      if(fs && typeof fs === 'object') return fs;
    } catch(e) {}
    return null;
  }

  function getSavedFlowStateForScenario(scenarioName){
    try{
      const fromServer = getFlowStateForScenario(scenarioName);
      if(fromServer && Array.isArray(fromServer.chain_ids) && fromServer.chain_ids.length){
        return fromServer;
      }
    } catch(e) {}
    try{
      if(typeof window.coretgGetSavedFlowStateForScenario === 'function'){
        const saved = window.coretgGetSavedFlowStateForScenario(scenarioName);
        if(saved && Array.isArray(saved.chain_ids) && saved.chain_ids.length){
          return saved;
        }
      }
    } catch(e) {}
    return null;
  }

  async function restoreSavedFlowForScenario(scenarioName){
    const saved = getSavedFlowStateForScenario(scenarioName);
    if(!saved || !Array.isArray(saved.chain_ids) || !saved.chain_ids.length){
      return false;
    }
    const chainLen = saved.chain_ids.length;
    try { if(lengthEl) lengthEl.value = String(chainLen); } catch(e) {}

    const params = new URLSearchParams();
    if(scenarioName) params.set('scenario', scenarioName);
    params.set('length', String(chainLen));
    params.set('prefer_flow', '1');
    try {
      const xmlPath = (typeof window.coretgGetLatestXmlPathForScenario === 'function') ? window.coretgGetLatestXmlPathForScenario(scenarioName) : '';
      if(xmlPath) params.set('xml_path', String(xmlPath));
    } catch(e) {}

    setStatus('Restoring saved flow…', false);
    setLoginLinkVisible(false);
    showLoading('Restoring saved flow…');
    try {
      const data = await fetchJson('/api/flag-sequencing/attackflow_preview?' + params.toString());
      currentChain = Array.isArray(data.chain) ? data.chain.slice() : [];
      currentFlagAssignments = Array.isArray(data.flag_assignments) ? data.flag_assignments.slice() : [];
      currentFlagAssignments = alignAssignmentsToChain(currentChain, currentFlagAssignments);
      mergeResolvedFromFlowState(saved, currentChain);
      currentFlagAssignments = alignAssignmentsToChain(currentChain, currentFlagAssignments);
      setFlowValidityFromPayload(data);
      lastStats = data.stats || null;
      lastPreviewPlanPath = data.preview_plan_path || '';
      updateMeta();
      selectedChainIndex = -1;
      renderChainEditor();
      try {
        const diagram = buildMermaid(currentChain);
        await renderMermaid(diagram);
      } catch(e) {}
      if(jsonEl){
        jsonEl.textContent = JSON.stringify({
          scenario: (data && data.scenario) ? data.scenario : activeScenario,
          length: (data && Number.isFinite(+data.length)) ? (+data.length) : (Array.isArray(currentChain) ? currentChain.length : 0),
          chain: Array.isArray(currentChain) ? currentChain : [],
          flag_assignments: Array.isArray(currentFlagAssignments) ? currentFlagAssignments : [],
          flow_valid: !!(data && data.flow_valid),
          flow_errors: Array.isArray(data && data.flow_errors) ? data.flow_errors : [],
          flags_enabled: !!(data && data.flags_enabled),
        }, null, 2);
      }
      showRestoreBadge('Restored saved flow state');
      persistFlowState();
      setStatus('Ready.', false);
      return true;
    } catch(err){
      setStatus('Restore failed: ' + String(err && err.message || err), true);
      setLoginLinkVisible(!!(err && err.loginRequired));
      return false;
    } finally {
      hideLoading();
    }
  }

  function mergeResolvedFromFlowState(flowState, chainNodes){
    try{
      if(!flowState || typeof flowState !== 'object') return;
      try{
        if(flowState.initial_facts && !flowInitialFactsOverride){
          flowInitialFactsOverride = normalizeFactsOverride(flowState.initial_facts);
        }
        if(flowState.goal_facts && !flowGoalFactsOverride){
          flowGoalFactsOverride = normalizeFactsOverride(flowState.goal_facts);
        }
      } catch(e) {}
      const savedAssignments = Array.isArray(flowState.flag_assignments) ? flowState.flag_assignments : [];
      if(!savedAssignments.length) return;
      const chain_ids = Array.isArray(chainNodes) ? chainNodes.map(n => (n && n.id) ? String(n.id) : '').filter(Boolean) : [];
      if(!chain_ids.length) return;

      const byIndex = savedAssignments.slice();
      const nextAssignments = Array.isArray(currentFlagAssignments) ? currentFlagAssignments.map(a => (a && typeof a === 'object') ? a : {}) : [];
      for(let i = 0; i < chain_ids.length; i++){
        const savedA = byIndex[i];
        if(!savedA || typeof savedA !== 'object') continue;
        const curA = nextAssignments[i] && typeof nextAssignments[i] === 'object' ? nextAssignments[i] : {};
        const hasInputs = curA.resolved_inputs && typeof curA.resolved_inputs === 'object' && !Array.isArray(curA.resolved_inputs) && Object.keys(curA.resolved_inputs).length > 0;
        const hasOutputs = curA.resolved_outputs && typeof curA.resolved_outputs === 'object' && !Array.isArray(curA.resolved_outputs) && Object.keys(curA.resolved_outputs).length > 0;
        if(savedA.resolved_inputs && (!hasInputs)) curA.resolved_inputs = savedA.resolved_inputs;
        if(savedA.resolved_outputs && (!hasOutputs)) curA.resolved_outputs = savedA.resolved_outputs;
        nextAssignments[i] = curA;
      }
      currentFlagAssignments = nextAssignments;
    } catch(e) {}
  }

  function mergeResolvedFromSavedState(scenarioName, chainNodes){
    try{
      if(typeof window.coretgGetSavedFlowStateForScenario !== 'function') return;
      const saved = window.coretgGetSavedFlowStateForScenario(scenarioName);
      if(!saved || !Array.isArray(saved.flag_assignments)) return;
      const savedByNode = new Map();
      const savedAssignments = saved.flag_assignments;
      savedAssignments.forEach((a, idx)=>{
        if(!a || typeof a !== 'object') return;
        const nid = String(a.node_id || '').trim();
        if(nid) savedByNode.set(nid, a);
        else savedByNode.set(String(idx), a);
      });

      const chain_ids = Array.isArray(chainNodes) ? chainNodes.map(n => (n && n.id) ? String(n.id) : '').filter(Boolean) : [];
      if(!chain_ids.length) return;

      const nextAssignments = Array.isArray(currentFlagAssignments) ? currentFlagAssignments.map(a => (a && typeof a === 'object') ? a : {}) : [];
      for(let i = 0; i < chain_ids.length; i++){
        const nid = chain_ids[i];
        const savedA = savedByNode.get(nid) || savedByNode.get(String(i));
        if(!savedA || typeof savedA !== 'object') continue;
        const curA = nextAssignments[i] && typeof nextAssignments[i] === 'object' ? nextAssignments[i] : {};
        const hasInputs = curA.resolved_inputs && typeof curA.resolved_inputs === 'object' && !Array.isArray(curA.resolved_inputs) && Object.keys(curA.resolved_inputs).length > 0;
        const hasOutputs = curA.resolved_outputs && typeof curA.resolved_outputs === 'object' && !Array.isArray(curA.resolved_outputs) && Object.keys(curA.resolved_outputs).length > 0;
        if(savedA.resolved_inputs && (!hasInputs)) curA.resolved_inputs = savedA.resolved_inputs;
        if(savedA.resolved_outputs && (!hasOutputs)) curA.resolved_outputs = savedA.resolved_outputs;
        if(savedA.type && (!curA.type || !String(curA.type).trim())) curA.type = savedA.type;
        if(savedA.flag_generator && (!curA.flag_generator || !String(curA.flag_generator).trim())) curA.flag_generator = savedA.flag_generator;
        if(savedA.input_fields && (!Array.isArray(curA.input_fields) || !curA.input_fields.length)) curA.input_fields = savedA.input_fields;
        if(savedA.input_fields_required && (!Array.isArray(curA.input_fields_required) || !curA.input_fields_required.length)) curA.input_fields_required = savedA.input_fields_required;
        if(savedA.input_fields_optional && (!Array.isArray(curA.input_fields_optional) || !curA.input_fields_optional.length)) curA.input_fields_optional = savedA.input_fields_optional;
        if(savedA.output_fields && (!Array.isArray(curA.output_fields) || !curA.output_fields.length)) curA.output_fields = savedA.output_fields;
        if(savedA.produces && (!Array.isArray(curA.produces) || !curA.produces.length)) curA.produces = savedA.produces;
        if(savedA.requires && (!Array.isArray(curA.requires) || !curA.requires.length)) curA.requires = savedA.requires;
        if(savedA.hint && (!curA.hint || !String(curA.hint).trim())) curA.hint = savedA.hint;
        if(savedA.hints && (!Array.isArray(curA.hints) || !curA.hints.length)) curA.hints = savedA.hints;
        if(savedA.description_hints && (!Array.isArray(curA.description_hints) || !curA.description_hints.length)) curA.description_hints = savedA.description_hints;
        nextAssignments[i] = curA;
      }
      currentFlagAssignments = nextAssignments;
    } catch(e) {}
  }

  function toRoman(n){
    const num = parseInt(n, 10);
    if(!Number.isFinite(num) || num <= 0) return '';
    const map = [
      [1000,'M'], [900,'CM'], [500,'D'], [400,'CD'],
      [100,'C'], [90,'XC'], [50,'L'], [40,'XL'],
      [10,'X'], [9,'IX'], [5,'V'], [4,'IV'], [1,'I']
    ];
    let x = num;
    let out = '';
    for(const [v,s] of map){
      while(x >= v){
        out += s;
        x -= v;
      }
    }
    return out;
  }

  function showLoading(text){
    try{
      if(!loadingOverlayEl) return;
      if(loadingTextEl) loadingTextEl.textContent = (text || 'Loading…').toString();
      loadingOverlayEl.classList.remove('d-none');
    } catch(e) {}
  }

  function escapeHtml(text){
    try{
      return String(text || '').replace(/[&<>"']/g, (c)=>({
        '&': '&amp;',
        '<': '&lt;',
        '>': '&gt;',
        '"': '&quot;',
        "'": '&#39;',
      })[c] || c);
    } catch(e){
      return String(text || '');
    }
  }

  function setLoadingSteps(steps, activeIndex){
    try{
      if(!loadingStepsEl) return;
      if(!Array.isArray(steps) || steps.length === 0){
        loadingStepsEl.innerHTML = '';
        loadingStepsEl.classList.add('d-none');
        if(loadingStepsLabelEl) loadingStepsLabelEl.classList.add('d-none');
        return;
      }
      if(loadingStepsLabelEl) loadingStepsLabelEl.classList.remove('d-none');
      loadingStepsEl.classList.remove('d-none');
      const idx = Number.isFinite(+activeIndex) ? (+activeIndex) : -1;
      loadingStepsEl.innerHTML = steps.map((s, i)=>{
        const state = (i === idx) ? 'active' : (i < idx ? 'done' : 'pending');
        const cls = state === 'active' ? 'fw-semibold text-body' : (state === 'done' ? 'text-success' : 'text-muted');
        const badgeCls = state === 'active' ? 'text-bg-primary' : (state === 'done' ? 'text-bg-success' : 'text-bg-secondary');
        const status = state === 'active' ? 'Working' : (state === 'done' ? 'Done' : 'Pending');
        return `
          <li class="d-flex align-items-center gap-2 ${cls}">
            <span class="badge ${badgeCls}">${i + 1}</span>
            <span>${escapeHtml(s)}</span>
            <span class="ms-auto small text-muted">${status}</span>
          </li>
        `;
      }).join('');
    } catch(e) {}
  }

  function summarizeChainForLog(chain, assignments){
    try{
      if(!Array.isArray(chain) || chain.length === 0){
        return { chain: 'Chain: (empty)', gens: 'Generators: (none)' };
      }
      const ids = chain.map((n)=>{
        const id = (n && n.id) ? String(n.id) : '';
        const name = (n && n.name) ? String(n.name) : '';
        return name ? `${id}:${name}` : id;
      }).filter(Boolean);
      const chainLine = ids.length ? `Chain IDs: ${ids.join(', ')}` : 'Chain IDs: (missing)';

      let genLine = 'Generators: (none)';
      if(Array.isArray(assignments) && assignments.length){
        const parts = assignments.map((a, i)=>{
          const label = a && (a.flag_generator || a.generator_label || a.generator_display_name || a.generator_name || a.generator_slug || a.generator_id || a.generator)
            ? String(a.flag_generator || a.generator_label || a.generator_display_name || a.generator_name || a.generator_slug || a.generator_id || a.generator)
            : '';
          if(!label) return `Generator ${i + 1}: unresolved`;
          const trimmed = label.trim();
          const safe = trimmed.length > 36 ? `${trimmed.slice(0, 16)}…${trimmed.slice(-12)}` : trimmed;
          return `Generator ${i + 1}: ${safe}`;
        });
        genLine = `Generators: ${parts.join(' · ')}`;
      }
      return { chain: chainLine, gens: genLine };
    } catch(e){
      return { chain: 'Chain: (unavailable)', gens: 'Generators: (unavailable)' };
    }
  }

  function appendLoadingLog(message){
    try{
      if(!loadingLogEl) return;
      const msg = String(message || '').trim();
      if(!msg) return;
      if(loadingLogLabelEl) loadingLogLabelEl.classList.remove('d-none');
      loadingLogEl.classList.remove('d-none');
      const item = document.createElement('li');
      item.textContent = msg;
      loadingLogEl.appendChild(item);
    } catch(e) {}
  }

  function clearLoadingLog(){
    try{
      if(!loadingLogEl) return;
      loadingLogEl.innerHTML = '';
      loadingLogEl.classList.add('d-none');
      if(loadingLogLabelEl) loadingLogLabelEl.classList.add('d-none');
    } catch(e) {}
  }

  function hideLoading(){
    try{
      if(!loadingOverlayEl) return;
      loadingOverlayEl.classList.add('d-none');
      setLoadingSteps([], -1);
      clearLoadingLog();
    } catch(e) {}
  }

  function setFlowValidityFromPayload(payload){
    const p = payload && typeof payload === 'object' ? payload : null;
    const flowValid = p && ('flow_valid' in p) ? !!p.flow_valid : true;
    const flagsEnabled = p && ('flags_enabled' in p) ? !!p.flags_enabled : true;
    const flowErrors = (p && Array.isArray(p.flow_errors)) ? p.flow_errors.slice() : [];
    const flowErrorsDetail = (p && typeof p.flow_errors_detail === 'string') ? p.flow_errors_detail : '';
    try {
      if(p && p.host_ip_map && typeof p.host_ip_map === 'object'){
        const entries = Object.entries(p.host_ip_map).map(([k, v]) => [String(k), String(v || '')]);
        lastHostIpMap = new Map(entries.filter(([k, v]) => k && v));
      }
    } catch(e) {}
    lastFlowValid = flowValid;
    lastFlagsEnabled = flagsEnabled;
    lastFlowErrors = flowErrors;
    try {
      if(p && p.initial_facts){
        flowInitialFactsOverride = normalizeFactsOverride(p.initial_facts);
      }
      if(p && p.goal_facts){
        flowGoalFactsOverride = normalizeFactsOverride(p.goal_facts);
      }
    } catch(e) {}
    if(!validityAlertEl) return;
    if(flowValid && flagsEnabled){
      validityAlertEl.classList.add('d-none');
      validityAlertEl.textContent = '';
      return;
    }
    const base = 'Invalid flag dependency order: execution will NOT include flags.';
    const details = flowErrors.length ? (' ' + flowErrors.join(' | ')) : '';
    const detail2 = flowErrorsDetail ? (' | ' + flowErrorsDetail) : '';
    validityAlertEl.textContent = base + details + detail2;
    validityAlertEl.classList.remove('d-none');
  }

  function normalizeFactsOverride(raw){
    if(!raw || typeof raw !== 'object') return null;
    const arts = Array.isArray(raw.artifacts) ? raw.artifacts : [];
    const fields = Array.isArray(raw.fields) ? raw.fields : [];
    const outArts = arts.map(x => String(x ?? '').trim()).filter(Boolean);
    const outFields = fields.map(x => String(x ?? '').trim()).filter(Boolean);
    if(!outArts.length && !outFields.length) return null;
    return { artifacts: outArts, fields: outFields };
  }

  function factsToText(list){
    return (Array.isArray(list) ? list : []).map(x => String(x ?? '').trim()).filter(Boolean).join('\n');
  }

  function parseFactsText(text){
    const out = [];
    try {
      String(text || '').split(/\r?\n/).forEach((line)=>{
        const s = String(line || '').trim();
        if(!s) return;
        out.push(s);
      });
    } catch(e) {}
    return out;
  }

  function isFlagFactName(name){
    const s = String(name || '').trim();
    if(!s) return false;
    if(s === 'Flag' || s.toLowerCase() === 'flag(flag_id)') return true;
    return s.startsWith('Flag(') || s.startsWith('flag(');
  }

  async function refreshXmlDockPreview({ force = false } = {}){
    const xmlPre = document.getElementById('xmlPre');
    if(!xmlPre) return;
    const xmlPath = (document.getElementById('scenariosPreviewXmlPath')?.value || '').trim();
    const lastPath = (xmlPre.dataset.xmlPreviewPath || '').trim();
    if(!xmlPath){
      if(force){
        try { xmlPre.textContent = ''; } catch(e) {}
        try { xmlPre.dataset.xmlPreviewPath = ''; } catch(e) {}
      }
      return;
    }
    if(!force && xmlPre.textContent.trim() && lastPath === xmlPath) return;
    try {
      const res = await fetch('/download_report?path=' + encodeURIComponent(xmlPath), { credentials: 'same-origin' });
      if(!res.ok) return;
      const txt = await res.text();
      try { xmlPre.textContent = txt || ''; } catch(e) {}
      try { xmlPre.dataset.xmlPreviewPath = xmlPath; } catch(e) {}
    } catch(e) {}
  }

  function normalizeScenarioNorm(raw){
    return (raw || '').toString().trim().toLowerCase().replace(/\s+/g, ' ');
  }

  function defaultScenarioName(){
    return (Array.isArray(scenarioNamesCache) && scenarioNamesCache.length) ? String(scenarioNamesCache[0]) : null;
  }

  function updateScenarioQueryParam(){
    try {
      const url = new URL(window.location.href);
      if(activeScenario){
        url.searchParams.set('scenario', activeScenario);
      } else {
        url.searchParams.delete('scenario');
      }
      window.history.replaceState({}, '', url.toString());
    } catch(e) {}
  }

  function updateScenarioFilterControls(){
    try {
      if(clearScenarioBtn){
        const def = defaultScenarioName();
        const show = !!activeScenario && !!def && activeScenario !== def;
        clearScenarioBtn.classList.toggle('d-none', !show);
      }
      if(!scenarioListEl) return;
      scenarioListEl.querySelectorAll('[data-scen-name]').forEach(btn => {
        const name = btn.getAttribute('data-scen-name');
        const isActive = !!activeScenario && name === activeScenario;
        btn.classList.toggle('active', isActive);
        btn.classList.toggle('bg-primary', isActive);
        btn.classList.toggle('text-white', isActive);
      });
    } catch(e) {}
  }

  function previewPlanForRequest(){
    return '';
  }

  function refreshParticipantNavForScenario(scenarioName){
    try {
      const scen = (scenarioName || '').toString().trim();
      if (typeof window.CORETG_PATCH_SCENARIO_NAV === 'function') {
        window.CORETG_PATCH_SCENARIO_NAV(scen);
      }
      const norm = normalizeScenarioNorm(scen);
      const hasParticipant = !!participantUrlFlags[norm];
      if (typeof window.CORETG_SET_PARTICIPANT_NAV_VISIBLE === 'function') {
        window.CORETG_SET_PARTICIPANT_NAV_VISIBLE(hasParticipant);
      }
    } catch(e) {}
  }

  function clearPreviewPlanCacheForScenario(scenarioName){
    const scen = (scenarioName || '').toString().trim();
    if(!scen) return;
    lastPreviewPlanPath = '';
    try {
      if (typeof window.coretgSetPreviewPlanPathForScenario === 'function') {
        window.coretgSetPreviewPlanPathForScenario(scen, '');
      }
    } catch(e) {}
    updateMeta();
  }

  async function refreshLatestPreviewPlanPathForScenario(scenarioName){
    const scen = (scenarioName || '').toString().trim();
    if(!scen) return '';
    try {
      let url = '/api/flag-sequencing/latest_preview_plan?scenario=' + encodeURIComponent(scen);
      try{
        const xmlPath = (typeof window.coretgGetLatestXmlPathForScenario === 'function') ? window.coretgGetLatestXmlPathForScenario(scen) : '';
        if(xmlPath){
          url += '&xml_path=' + encodeURIComponent(String(xmlPath));
        }
      } catch(e) {}
      const data = await fetchJson(url);
      const path = (data && typeof data.preview_plan_path === 'string') ? data.preview_plan_path.trim() : '';
      if(path){
        lastPreviewPlanPath = path;
        try {
          if (typeof window.coretgSetPreviewPlanPathForScenario === 'function') {
            window.coretgSetPreviewPlanPathForScenario(scen, path);
          }
        } catch(e) {}
        updateMeta();
        return path;
      }
    } catch(e) {}
    return '';
  }

  async function setScenario(value){
    activeScenario = (value || defaultScenarioName() || '').toString().trim();
    if(scenarioEl) scenarioEl.value = activeScenario;
    if(scenarioLabelEl) scenarioLabelEl.textContent = activeScenario;
    updateScenarioQueryParam();
    updateScenarioFilterControls();
    refreshParticipantNavForScenario(activeScenario);
    rememberActiveScenario();
    updateScenarioSeedBadges();
    clearPreviewPlanCacheForScenario(activeScenario);
    await refreshLatestPreviewPlanPathForScenario(activeScenario);
    // When switching scenarios (or loading after refresh), restore any saved Flow state.
    const restored = await restoreSavedFlowForScenario(activeScenario);
    if(!restored){
      currentChain = [];
      currentFlagAssignments = [];
      selectedChainIndex = -1;
      renderChainEditor();
      try {
        const diagram = buildMermaid([]);
        await renderMermaid(diagram);
      } catch(e) {}
      setStatus('No saved flow chain. Click Generate to start.', false);
    }
  }

  function setStatus(msg, isError){
    if(!statusEl) return;
    let out = msg || '';
    // Improve readability of eligibility errors:
    // "Requires … Current: …" -> put "Current:" on the next line.
    try{
      if(out && typeof out === 'string' && out.includes('Requires') && out.includes('Current:')){
        out = out.replace(/\s+Current:/, '\nCurrent:');
      }
    } catch(e) {}
    statusEl.textContent = out;
    statusEl.classList.toggle('text-danger', !!isError);
    statusEl.classList.toggle('text-muted', !isError);
  }

  function showRestoreBadge(message){
    try{
      if(!restoreBadgeEl) return;
      restoreBadgeEl.textContent = message || 'Restored saved flow state';
      restoreBadgeEl.classList.remove('d-none');
      setTimeout(()=>{ try{ restoreBadgeEl.classList.add('d-none'); } catch(e) {} }, 5000);
    } catch(e) {}
  }

  function setLoginLinkVisible(visible){
    try{
      if(!loginLinkEl) return;
      loginLinkEl.classList.toggle('d-none', !visible);
    } catch(e) {}
  }

  function basenameFromPath(p){
    try{
      const s = (p||'').toString();
      const parts = s.split('/');
      return parts[parts.length-1] || s;
    } catch(e){
      return (p||'').toString();
    }
  }

  async function fetchJson(url, opts){
    opts = opts || {};
    const timeoutMs = Number.isFinite(+opts.timeoutMs) ? (+opts.timeoutMs) : 0;
    const controller = (typeof AbortController !== 'undefined') ? new AbortController() : null;
    const signal = controller ? controller.signal : undefined;
    let t = null;
    if(controller && timeoutMs > 0){
      t = setTimeout(() => { try{ controller.abort(); } catch(e){} }, timeoutMs);
    }
    let res;
    try{
      res = await fetch(url, { credentials: 'same-origin', signal });
    } catch(e){
      if(controller && e && (e.name === 'AbortError')){
        const err = new Error('Request timed out.');
        err.isTimeout = true;
        throw err;
      }
      throw e;
    } finally {
      if(t) clearTimeout(t);
    }
    const ct = (res.headers.get('content-type') || '').toLowerCase();
    if(!ct.includes('application/json')){
      const text = await res.text();
      if(res.redirected || (text && text.includes('<html'))){
        const err = new Error('Login required.');
        err.loginRequired = true;
        throw err;
      }
      throw new Error('Non-JSON response');
    }
    const data = await res.json();
    if(!res.ok){
      const err = new Error((data && (data.error || data.message)) || ('HTTP ' + res.status));
      err.payload = data;
      if(res.status === 401) err.loginRequired = true;
      throw err;
    }
    return data;
  }

  async function postJson(url, payload, opts){
    opts = opts || {};
    const timeoutMs = Number.isFinite(+opts.timeoutMs) ? (+opts.timeoutMs) : 0;
    const controller = (typeof AbortController !== 'undefined') ? new AbortController() : null;
    const signal = controller ? controller.signal : undefined;
    let t = null;
    if(controller && timeoutMs > 0){
      t = setTimeout(() => { try{ controller.abort(); } catch(e){} }, timeoutMs);
    }
    let res;
    try{
      res = await fetch(url, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      credentials: 'same-origin',
      body: JSON.stringify(payload || {}),
      signal,
      });
    } catch(e){
      if(controller && e && (e.name === 'AbortError')){
        const err = new Error('Request timed out.');
        err.isTimeout = true;
        throw err;
      }
      throw e;
    } finally {
      if(t) clearTimeout(t);
    }
    const ct = (res.headers.get('content-type') || '').toLowerCase();
    if(!ct.includes('application/json')){
      const text = await res.text();
      if(res.redirected || (text && text.includes('<html'))){
        const err = new Error('Login required.');
        err.loginRequired = true;
        throw err;
      }
      throw new Error('Non-JSON response');
    }
    const data = await res.json();
    if(!res.ok){
      const err = new Error((data && (data.error || data.message)) || ('HTTP ' + res.status));
      err.payload = data;
      if(res.status === 401) err.loginRequired = true;
      throw err;
    }
    return data;
  }

  function chainFeasibility(assignments){
    // Returns per-index feasibility based on cumulative outputs.
    // Shape: {ok:boolean, missing:string[], missing_artifacts:string[], missing_fields:string[]}
    const out = [];
    // Keep in sync with server-side synthesized Flow inputs (see _flow_default_generator_config).
    const synthesizedFields = ['seed','secret','env_name','challenge','flag_prefix','username_prefix','key_len','node_name'];
    const synthesizedSet = new Set(synthesizedFields);
    const sequencerArtifacts = ['Knowledge(ip)'];
    const haveEffective = new Set(synthesizedFields);
    // Track origin so UI can show "Provided by Chain" vs "Provided by Sequencer".
    const haveArtifactsChain = new Set();
    const haveArtifactsSequencer = new Set(sequencerArtifacts);
    const haveFieldsChain = new Set();
    const haveFieldsSequencer = new Set(synthesizedFields);
    const haveArtifacts = new Set(sequencerArtifacts);
    const haveFields = new Set(synthesizedFields);
    try{
      const initOverride = normalizeFactsOverride(flowInitialFactsOverride);
      const initArts = (initOverride && Array.isArray(initOverride.artifacts)) ? initOverride.artifacts : [];
      const initFields = (initOverride && Array.isArray(initOverride.fields)) ? initOverride.fields : [];
      initArts.map(String).forEach((k)=>{
        const kk = String(k || '').trim();
        if(!kk || isFlagFactName(kk)) return;
        haveArtifacts.add(kk);
        haveArtifactsChain.add(kk);
        haveEffective.add(kk);
        if(haveArtifactsSequencer.has(kk)) haveArtifactsSequencer.delete(kk);
      });
      initFields.map(String).forEach((k)=>{
        const kk = String(k || '').trim();
        if(!kk || isFlagFactName(kk)) return;
        haveFields.add(kk);
        haveFieldsChain.add(kk);
        haveEffective.add(kk);
        if(haveFieldsSequencer.has(kk)) haveFieldsSequencer.delete(kk);
      });
    } catch(e) {}
    try{
      if(Array.isArray(assignments) && assignments.length){
        const a0 = assignments[0] || {};
        const ri = (a0 && typeof a0.resolved_inputs === 'object' && a0.resolved_inputs && !Array.isArray(a0.resolved_inputs))
          ? a0.resolved_inputs
          : null;
        if(ri){
          Object.keys(ri).forEach((k)=>{
            const kk = String(k || '').trim();
            if(!kk || isFlagFactName(kk)) return;
            if(kk.startsWith('Knowledge(') || haveArtifactsSequencer.has(kk)) return;
            haveFields.add(kk);
            haveFieldsChain.add(kk);
            haveEffective.add(kk);
            if(haveFieldsSequencer.has(kk)) haveFieldsSequencer.delete(kk);
          });
        }
      }
    } catch(e) {}
    if(!Array.isArray(assignments)) return out;
    for(let i=0;i<assignments.length;i++){
      const a = assignments[i] || {};

      const hasSplit = Array.isArray(a.requires) || Array.isArray(a.input_fields_required) || Array.isArray(a.input_fields);
      if(hasSplit){
        const reqArtifactsRaw = Array.isArray(a.requires) ? a.requires.map(String) : [];
        // Some generator definitions historically mixed synthesized "fields" into
        // `requires` (artifacts). Normalize those back into the Fields bucket.
        const reqArtifacts = reqArtifactsRaw.filter(k => k && !synthesizedSet.has(k));
        const reqFieldsBase = Array.isArray(a.input_fields_required)
          ? a.input_fields_required.map(String)
          : (Array.isArray(a.input_fields) ? a.input_fields.map(String) : []);
        const reqFields = reqFieldsBase.concat(reqArtifactsRaw.filter(k => k && synthesizedSet.has(k)));
        const optFields = Array.isArray(a.input_fields_optional) ? a.input_fields_optional.map(String) : [];
        const optSet = new Set(optFields.filter(Boolean));

        const reqArtifactsEffective = reqArtifacts.filter(k => k && !optSet.has(k));
        const providedByChainArtifacts = reqArtifactsEffective.filter(k => k && haveArtifactsChain.has(k));
        const providedBySequencerArtifacts = reqArtifactsEffective.filter(k => k && haveArtifactsSequencer.has(k));
        const missingArtifacts = reqArtifactsEffective.filter(k => k && !haveArtifacts.has(k));

        let displayFields = reqFields.slice();
        try{
          const ri = (a && typeof a.resolved_inputs === 'object' && a.resolved_inputs && !Array.isArray(a.resolved_inputs))
            ? a.resolved_inputs
            : null;
          if(ri){
            Object.keys(ri).forEach(k => {
              const kk = String(k || '').trim();
              if(!kk) return;
              displayFields.push(kk);
            });
          }
        } catch(e) {}
        displayFields = Array.from(new Set(displayFields.map(String).filter(Boolean)));

        const providedByChainFields = displayFields.filter(k => k && haveFieldsChain.has(k));
        const providedBySequencerFields = displayFields.filter(k => k && haveFieldsSequencer.has(k));
        const missingFields = reqFields.filter(k => k && !haveFields.has(k));

        const missing = missingArtifacts.concat(missingFields);
        out.push({
          ok: missing.length === 0,
          missing,
          missing_artifacts: missingArtifacts,
          missing_fields: missingFields,
          providing_artifacts_chain: providedByChainArtifacts,
          providing_artifacts_sequencer: providedBySequencerArtifacts,
          providing_fields_chain: providedByChainFields,
          providing_fields_sequencer: providedBySequencerFields,
        });
      } else {
        const reqEffective = Array.isArray(a.inputs) ? a.inputs.map(String) : [];
        const providingChain = reqEffective.filter(k => k && (haveArtifactsChain.has(k) || haveFieldsChain.has(k)));
        const providingSequencer = reqEffective.filter(k => k && (haveArtifactsSequencer.has(k) || haveFieldsSequencer.has(k)));
        const missing = reqEffective.filter(k => k && !haveEffective.has(k));
        out.push({
          ok: missing.length === 0,
          missing,
          missing_artifacts: [],
          missing_fields: [],
          providing_effective_chain: providingChain,
          providing_effective_sequencer: providingSequencer,
        });
      }

      const provEffective = Array.isArray(a.outputs) ? a.outputs.map(String) : [];
      provEffective.forEach(k => { if(k) haveEffective.add(k); });

      if(Array.isArray(a.produces)){
        a.produces.map(String).forEach(k => {
          if(!k) return;
          haveArtifacts.add(k);
          haveArtifactsChain.add(k);
        });
      }
      if(Array.isArray(a.output_fields)){
        a.output_fields.map(String).forEach(k => {
          if(!k) return;
          haveFields.add(k);
          haveFieldsChain.add(k);
        });
      }
    }
    return out;
  }

  function chainFeasibilityFinal(assignments){
    // Returns the final provider sets after the full chain executes.
    // Shape: {providing_artifacts_chain, providing_artifacts_sequencer, providing_fields_chain, providing_fields_sequencer}
    const synthesizedFields = ['seed','secret','env_name','challenge','flag_prefix','username_prefix','key_len','node_name'];
    const synthesizedSet = new Set(synthesizedFields);
    const sequencerArtifacts = ['Knowledge(ip)'];
    const haveEffective = new Set(synthesizedFields);
    const haveArtifactsChain = new Set();
    const haveArtifactsSequencer = new Set(sequencerArtifacts);
    const haveFieldsChain = new Set();
    const haveFieldsSequencer = new Set(synthesizedFields);
    const haveArtifacts = new Set(sequencerArtifacts);
    const haveFields = new Set(synthesizedFields);
    try{
      const initOverride = normalizeFactsOverride(flowInitialFactsOverride);
      const initArts = (initOverride && Array.isArray(initOverride.artifacts)) ? initOverride.artifacts : [];
      const initFields = (initOverride && Array.isArray(initOverride.fields)) ? initOverride.fields : [];
      initArts.map(String).forEach((k)=>{
        const kk = String(k || '').trim();
        if(!kk || isFlagFactName(kk)) return;
        haveArtifacts.add(kk);
        haveArtifactsChain.add(kk);
        haveEffective.add(kk);
        if(haveArtifactsSequencer.has(kk)) haveArtifactsSequencer.delete(kk);
      });
      initFields.map(String).forEach((k)=>{
        const kk = String(k || '').trim();
        if(!kk || isFlagFactName(kk)) return;
        haveFields.add(kk);
        haveFieldsChain.add(kk);
        haveEffective.add(kk);
        if(haveFieldsSequencer.has(kk)) haveFieldsSequencer.delete(kk);
      });
    } catch(e) {}

    try{
      if(Array.isArray(assignments) && assignments.length){
        const a0 = assignments[0] || {};
        const ri = (a0 && typeof a0.resolved_inputs === 'object' && a0.resolved_inputs && !Array.isArray(a0.resolved_inputs))
          ? a0.resolved_inputs
          : null;
        if(ri){
          Object.keys(ri).forEach((k)=>{
            const kk = String(k || '').trim();
            if(!kk || isFlagFactName(kk)) return;
            if(kk.startsWith('Knowledge(') || haveArtifactsSequencer.has(kk)) return;
            haveFields.add(kk);
            haveFieldsChain.add(kk);
            haveEffective.add(kk);
            if(haveFieldsSequencer.has(kk)) haveFieldsSequencer.delete(kk);
          });
        }
      }
    } catch(e) {}

    if(Array.isArray(assignments)){
      for(let i=0;i<assignments.length;i++){
        const a = assignments[i] || {};
        const hasSplit = Array.isArray(a.requires) || Array.isArray(a.input_fields_required) || Array.isArray(a.input_fields);
        if(hasSplit){
          const reqArtifactsRaw = Array.isArray(a.requires) ? a.requires.map(String) : [];
          const reqArtifacts = reqArtifactsRaw.filter(k => k && !synthesizedSet.has(k));
          const reqFieldsBase = Array.isArray(a.input_fields_required)
            ? a.input_fields_required.map(String)
            : (Array.isArray(a.input_fields) ? a.input_fields.map(String) : []);
          const reqFields = reqFieldsBase.concat(reqArtifactsRaw.filter(k => k && synthesizedSet.has(k)));
          const optFields = Array.isArray(a.input_fields_optional) ? a.input_fields_optional.map(String) : [];
          const optSet = new Set(optFields.filter(Boolean));
          const reqArtifactsEffective = reqArtifacts.filter(k => k && !optSet.has(k));
          reqArtifactsEffective.forEach(k => { if(k) haveArtifacts.add(k); });
          reqFields.forEach(k => { if(k) haveFields.add(k); });
        } else {
          const reqEffective = Array.isArray(a.inputs) ? a.inputs.map(String) : [];
          reqEffective.forEach(k => { if(k) haveEffective.add(k); });
        }

        const provEffective = Array.isArray(a.outputs) ? a.outputs.map(String) : [];
        provEffective.forEach(k => { if(k) haveEffective.add(k); });

        if(Array.isArray(a.produces)){
          a.produces.map(String).forEach(k => {
            if(!k) return;
            haveArtifacts.add(k);
            haveArtifactsChain.add(k);
          });
        }
        if(Array.isArray(a.output_fields)){
          a.output_fields.map(String).forEach(k => {
            if(!k) return;
            haveFields.add(k);
            haveFieldsChain.add(k);
          });
        }
      }
    }

    return {
      providing_artifacts_chain: Array.from(haveArtifactsChain),
      providing_artifacts_sequencer: Array.from(haveArtifactsSequencer),
      providing_fields_chain: Array.from(haveFieldsChain),
      providing_fields_sequencer: Array.from(haveFieldsSequencer),
    };
  }

  function buildGoalFactSourceMap(assignments){
    const outArtifacts = new Map();
    const outFields = new Map();
    if(!Array.isArray(assignments)) return { artifacts: outArtifacts, fields: outFields };
    for(let i = 0; i < assignments.length; i++){
      const a = assignments[i] || {};
      const artNames = [];
      const fieldNames = [];
      if(Array.isArray(a.produces)) artNames.push(...a.produces);
      if(Array.isArray(a.output_fields)) fieldNames.push(...a.output_fields);

      const artSet = new Set(artNames.map(String).map(s => String(s || '').trim()).filter(Boolean));
      const fieldSet = new Set(fieldNames.map(String).map(s => String(s || '').trim()).filter(Boolean));

      artSet.forEach((n)=>{
        if(!n || isFlagFactName(n)) return;
        if(!outArtifacts.has(n)) outArtifacts.set(n, i);
      });
      fieldSet.forEach((n)=>{
        if(!n || isFlagFactName(n)) return;
        outFields.set(n, i);
      });

      if(Array.isArray(a.outputs)){
        a.outputs.map(String).forEach((raw)=>{
          const n = String(raw || '').trim();
          if(!n || isFlagFactName(n)) return;
          if(artSet.has(n)) {
            if(!outArtifacts.has(n)) outArtifacts.set(n, i);
            return;
          }
          if(fieldSet.has(n)) {
            outFields.set(n, i);
            return;
          }
          // Untyped outputs default to fields to avoid duplicating artifact sources.
          outFields.set(n, i);
        });
      }
    }
    return { artifacts: outArtifacts, fields: outFields };
  }

  function goalFactBadgeFor(name, row, sourceMap){
    const n = String(name || '').trim();
    if(!n) return null;
    let idx = null;
    try{
      if(sourceMap){
        const isField = row && String(row.kind || '').toLowerCase() === 'field';
        const map = isField ? sourceMap.fields : sourceMap.artifacts;
        if(map && map.has(n)) idx = map.get(n);
      }
    } catch(e) {}
    if(Number.isFinite(+idx) && idx >= 0){
      const roman = toRoman(idx + 1);
      const label = roman ? ('Seq ' + roman) : ('Seq ' + (idx + 1));
      return { text: label, className: 'badge text-bg-primary' };
    }
    if(row && row.fromSeq) return { text: 'Sequencer', className: 'badge text-bg-info' };
    if(row && row.fromChain) return { text: 'Init', className: 'badge text-bg-secondary' };
    if(row && row.missing) return { text: 'Missing', className: 'badge text-bg-danger' };
    return { text: 'Unknown', className: 'badge text-bg-secondary' };
  }

  function renderChainEditor(){
    const wrap = document.getElementById('flowChainList');
    if(!wrap) return;
    wrap.innerHTML = '';
    try{
      const maxLen = Array.isArray(currentChain) ? currentChain.length : 0;
      Array.from(heldChainIndices || []).forEach((idx)=>{
        const n = Number(idx);
        if(!Number.isFinite(n) || n < 0 || n >= maxLen){
          try { heldChainIndices.delete(idx); } catch(e) {}
        }
      });
    } catch(e) {}
    if(!Array.isArray(currentChain) || currentChain.length === 0){
      const empty = document.createElement('div');
      empty.className = 'text-muted small';
      empty.textContent = 'Generate a flow to populate the chain.';
      wrap.appendChild(empty);
      return;
    }

    const idCounts = {};
    const idFirstIdx = {};
    const flagCounts = {};
    const flagFirstIdx = {};
    let chainFeas = [];
    try { chainFeas = chainFeasibility(currentFlagAssignments) || []; } catch(e) { chainFeas = []; }
    try{
      currentChain.forEach((n, idx) => {
        const id = (n && n.id) ? String(n.id).trim() : '';
        if(!id) return;
        idCounts[id] = (idCounts[id] || 0) + 1;
        if(idFirstIdx[id] === undefined) idFirstIdx[id] = idx;
      });

      // Flag values by position (resolved when available).
      currentChain.forEach((_n, idx) => {
        const fa = (Array.isArray(currentFlagAssignments) && currentFlagAssignments[idx]) ? currentFlagAssignments[idx] : null;
        const isRealized = !!(fa && (fa.generated === true || (typeof fa.flag_override === 'string' && fa.flag_override.trim()) || (fa.output_overrides && typeof fa.output_overrides === 'object')));
        if(!isRealized) return;
        let flagVal = '';
        try{
          if(fa && typeof fa.flag_value === 'string' && fa.flag_value.trim()) flagVal = fa.flag_value.trim();
        } catch(e) {}
        if(!flagVal){
          try{
            const ro = (fa && typeof fa.resolved_outputs === 'object' && fa.resolved_outputs && !Array.isArray(fa.resolved_outputs)) ? fa.resolved_outputs : null;
            if(ro){
              const rf = ro['Flag(flag_id)'] || ro['flag'] || ro['FLAG'] || '';
              if(typeof rf === 'string' && rf.trim()) flagVal = rf.trim();
            }
          } catch(e) {}
        }
        if(!flagVal) return;
        flagCounts[flagVal] = (flagCounts[flagVal] || 0) + 1;
        if(flagFirstIdx[flagVal] === undefined) flagFirstIdx[flagVal] = idx;
      });
    } catch(e) {}

    function normalizeFactList(list){
      const out = [];
      try {
        (Array.isArray(list) ? list : []).forEach((x)=>{
          const s = String(x ?? '').trim();
          if(!s) return;
          if(out.includes(s)) return;
          out.push(s);
        });
      } catch(e) {}
      return out;
    }

    function _resolveNodeIpsForChain(){
      const nameToIp = new Map();
      try{
        (Array.isArray(currentChain) ? currentChain : []).forEach((node, idx) => {
          const name = (node && node.name) ? String(node.name) : '';
          if(!name || nameToIp.has(name)) return;
          const nid = node && node.id !== undefined && node.id !== null ? String(node.id) : '';
          if(nid && lastHostIpMap && lastHostIpMap.has(nid)){
            const ipText = String(lastHostIpMap.get(nid) || '').trim();
            if(ipText) nameToIp.set(name, ipText);
            return;
          }
          const ips = [];
          const pushIps = (val) => {
            if(!val) return;
            if(Array.isArray(val)){
              val.forEach(v => pushIps(v));
              return;
            }
            const s = String(val || '').trim();
            if(!s) return;
            s.split(',').forEach(part => {
              const p = String(part || '').trim();
              if(p) ips.push(p);
            });
          };
          try{
            pushIps(node && (node.ip4 || node.ipv4 || node.ip || node.address));
            pushIps(node && node.ips);
            pushIps(node && node.addresses);
            pushIps(node && node.ipv4s);
            const ifaces = node && Array.isArray(node.interfaces) ? node.interfaces : [];
            ifaces.forEach(iface => {
              if(!iface || typeof iface !== 'object') return;
              pushIps(iface.ip4 || iface.ipv4 || iface.ip || iface.address);
            });
          } catch(e) {}
          if(!ips.length){
            try{
              const fa = (Array.isArray(currentFlagAssignments) && currentFlagAssignments[idx]) ? currentFlagAssignments[idx] : null;
              const rin = (fa && typeof fa.resolved_inputs === 'object' && fa.resolved_inputs && !Array.isArray(fa.resolved_inputs)) ? fa.resolved_inputs : null;
              if(rin){
                const ipVal = rin['Knowledge(ip)'] || rin['target_ip'] || rin['host_ip'] || rin['ip4'] || rin['ipv4'] || '';
                pushIps(ipVal);
                const nodeName = rin['node_name'] || rin['node'] || '';
                if(nodeName && ipVal && !nameToIp.has(String(nodeName))){
                  nameToIp.set(String(nodeName), String(ipVal));
                }
              }
            } catch(e) {}
          }
          const uniq = Array.from(new Set(ips)).filter(Boolean);
          const ipText = uniq.length ? uniq.join(', ') : '';
          if(ipText) nameToIp.set(name, ipText);
        });
      } catch(e) {}
      return nameToIp;
    }

    function _firstValidIpFromNode(node){
      try{
        if(!node || typeof node !== 'object') return '';
        const ips = [];
        const pushIps = (val) => {
          if(!val) return;
          if(Array.isArray(val)) { val.forEach(v => pushIps(v)); return; }
          const s = String(val || '').trim();
          if(!s) return;
          s.split(',').forEach(part => { const p = String(part || '').trim(); if(p) ips.push(p); });
        };
        pushIps(node.ip4 || node.ipv4 || node.ip || node.address);
        pushIps(node.ips || node.addresses || node.ipv4s);
        const ifaces = Array.isArray(node.interfaces) ? node.interfaces : [];
        ifaces.forEach(iface => { if(iface && typeof iface === 'object') pushIps(iface.ip4 || iface.ipv4 || iface.ip || iface.address); });
        const uniq = Array.from(new Set(ips));
        return uniq.length ? uniq.join(', ') : '';
      } catch(e){
        return '';
      }
    }

    function _applyHintNodeIps(text, nameToIp){
      const t = String(text || '');
      if(!t) return t;
      if(!(nameToIp && nameToIp.size)) return t;
      let out = t;
      const entries = Array.from(nameToIp.entries())
        .filter(([name, ip]) => name && ip)
        .sort((a, b) => b[0].length - a[0].length);
      entries.forEach(([name, ip]) => {
        if(!name || !ip) return;
        const needle = String(name);
        if(!out.includes(needle)) return;
        if(out.includes(needle + ' @')) return;
        out = out.split(needle).join(needle + ' @ ' + ip);
      });
      return out;
    }

    function renderFactSummaryRow(opts){
      const o = (opts && typeof opts === 'object') ? opts : {};
      const label = String(o.label || '').trim() || 'Facts';
      const artifacts = normalizeFactList(o.artifacts);
      const fields = normalizeFactList(o.fields);
      const hints = normalizeFactList(o.hints);
      const holdKey = String(o.holdKey || '').trim();
      const canOverride = typeof o.onValueOverride === 'function';

      const item = document.createElement('div');
      item.className = 'list-group-item';
      item.style.cursor = 'default';
      item.style.display = 'grid';
      item.style.gridTemplateColumns = '84px 1fr 76px';
      item.style.columnGap = '.5rem';
      item.style.alignItems = 'start';

      const seq = document.createElement('div');
      seq.className = 'text-muted small fw-semibold';
      seq.style.width = '84px';
      seq.style.whiteSpace = 'nowrap';
      seq.style.borderRight = '1px solid var(--bs-border-color, #dee2e6)';
      seq.style.paddingRight = '.5rem';
      seq.textContent = String(o.seq || '').trim() || '—';

      const left = document.createElement('div');
      left.className = 'd-flex flex-column';
      left.style.minWidth = '0';
      left.style.justifySelf = 'stretch';

      const titleRow = document.createElement('div');
      titleRow.className = 'd-flex align-items-center gap-2';
      const title = document.createElement('div');
      title.className = 'fw-semibold';
      title.textContent = label;
      titleRow.appendChild(title);
      if(canOverride || holdKey){
        const btnGroup = document.createElement('div');
        btnGroup.className = 'btn-group btn-group-sm ms-auto';
        if(canOverride){
          const ovBtn = document.createElement('button');
          ovBtn.type = 'button';
          ovBtn.className = 'btn btn-outline-secondary';
          ovBtn.textContent = 'Value Override';
          ovBtn.disabled = true;
          ovBtn.title = 'Disabled';
          ovBtn.addEventListener('click', (ev)=>{
            try { ev && ev.preventDefault && ev.preventDefault(); } catch(e) {}
            try { ev && ev.stopPropagation && ev.stopPropagation(); } catch(e) {}
            try { o.onValueOverride(); } catch(e) {}
          });
          btnGroup.appendChild(ovBtn);
        }
        if(holdKey){
          const holdBtn = document.createElement('button');
          holdBtn.type = 'button';
          const held = heldFactRows && heldFactRows.has(holdKey);
          holdBtn.className = held ? 'btn btn-warning' : 'btn btn-outline-warning';
          holdBtn.textContent = 'Hold';
          holdBtn.title = held ? 'Facts held' : 'Hold facts';
          holdBtn.disabled = true;
          holdBtn.title = 'Disabled';
          holdBtn.addEventListener('click', (ev)=>{
            try { ev && ev.preventDefault && ev.preventDefault(); } catch(e) {}
            try { ev && ev.stopPropagation && ev.stopPropagation(); } catch(e) {}
            try {
              if(heldFactRows && heldFactRows.has(holdKey)) heldFactRows.delete(holdKey);
              else heldFactRows.add(holdKey);
            } catch(e) {}
            renderChainEditor();
          });
          btnGroup.appendChild(holdBtn);
        }
        titleRow.appendChild(btnGroup);
      }
      left.appendChild(titleRow);

      const details = document.createElement('div');
      details.className = 'mt-1';
      const tbl = document.createElement('table');
      tbl.className = 'table table-sm table-borderless mb-0 small';
      const tbody = document.createElement('tbody');

      function addRow(labelText, valueElOrText){
        const tr = document.createElement('tr');
        const labelClean = String(labelText || '').trim();
        if(labelClean){
          const tdL = document.createElement('td');
          tdL.className = 'text-muted';
          tdL.style.whiteSpace = 'nowrap';
          tdL.style.width = '1%';
          tdL.textContent = labelClean + ':';
          tr.appendChild(tdL);
        }
        const tdV = document.createElement('td');
        if(!labelClean){
          tdV.style.padding = '0';
          tdV.style.margin = '0';
        }
        if(valueElOrText && typeof valueElOrText === 'object' && valueElOrText.nodeType){
          tdV.appendChild(valueElOrText);
        } else {
          tdV.textContent = String(valueElOrText || '-') || '-';
        }
        tr.appendChild(tdV);
        tbody.appendChild(tr);
      }

      const outputsRaw = Array.isArray(o.outputs) ? o.outputs : null;
      const inputsRaw = Array.isArray(o.inputs) ? o.inputs : null;
      const inputsShowMissing = !!o.inputsShowMissing;
      const hideArtifactsFields = !!o.hideArtifactsFields;
      function renderResolvedInline(val){
        let resolvedText = '';
        try{
          if(Array.isArray(val)){
            resolvedText = val.map(x => (x === null || x === undefined) ? '' : String(x)).filter(Boolean).join(', ');
          } else if(val && typeof val === 'object'){
            resolvedText = JSON.stringify(val);
          } else if(val !== undefined && val !== null) {
            resolvedText = String(val);
          }
        } catch(e) { resolvedText = ''; }
        if(!resolvedText) return document.createTextNode('-');
        const vcode = document.createElement('code');
        vcode.className = 'font-monospace';
        vcode.textContent = resolvedText;
        return vcode;
      }

      if(hints.length > 1){
        const wrap = document.createElement('div');
        const labelEl = document.createElement('div');
        labelEl.className = 'text-muted';
        labelEl.textContent = 'Hints:';
        const ul = document.createElement('ol');
        ul.className = 'mb-0 ps-3';
        hints.forEach((ht) => {
          const li = document.createElement('li');
          li.textContent = ht;
          ul.appendChild(li);
        });
        wrap.appendChild(labelEl);
        wrap.appendChild(ul);
        addRow('', wrap);
      } else if(hints.length === 1){
        const wrap = document.createElement('div');
        wrap.className = 'd-flex align-items-baseline gap-2';
        const labelEl = document.createElement('span');
        labelEl.className = 'text-muted';
        labelEl.textContent = 'Hint:';
        const textEl = document.createElement('span');
        textEl.textContent = hints[0];
        wrap.appendChild(labelEl);
        wrap.appendChild(textEl);
        addRow('', wrap);
      }

      if(inputsRaw){
        const inTbl = document.createElement('table');
        inTbl.className = 'table table-sm mb-0';
        inTbl.style.marginLeft = '0';
        inTbl.style.marginRight = '0';
        inTbl.style.width = '100%';
        inTbl.style.paddingLeft = '0';
        const thead = document.createElement('thead');
        thead.innerHTML = inputsShowMissing
          ? '<tr class="text-secondary"><th style="width: 1%; white-space: nowrap;">Variable</th><th>Resolved</th><th style="width: 1%; white-space: nowrap;">From Chain</th><th style="width: 1%; white-space: nowrap;">From Sequencer</th><th style="width: 1%; white-space: nowrap;">Missing</th></tr>'
          : '<tr class="text-secondary"><th style="width: 1%; white-space: nowrap;">Variable</th><th>Resolved</th><th style="width: 1%; white-space: nowrap;">From Chain</th><th style="width: 1%; white-space: nowrap;">From Sequencer</th></tr>';
        inTbl.appendChild(thead);
        try{
          const firstTh = thead.querySelector('th');
          if(firstTh) firstTh.style.paddingLeft = '0';
        } catch(e) {}
        const tbodyIn = document.createElement('tbody');
        inputsRaw.forEach((row)=>{
          if(!row || !row.name) return;
          const tr = document.createElement('tr');
          const tdVar = document.createElement('td');
          tdVar.style.paddingLeft = '0';
          const code = document.createElement('code');
          code.className = 'font-monospace';
          code.textContent = String(row.name || '-');
          const reqMark = document.createElement('span');
          reqMark.className = 'ms-1 text-danger fw-semibold';
          reqMark.textContent = '*';
          reqMark.title = 'Required input';
          if(row.sourceBadge && row.sourceBadge.text){
            const wrap = document.createElement('div');
            wrap.className = 'd-flex align-items-center gap-2';
            wrap.appendChild(code);
            if(row.required) wrap.appendChild(reqMark);
            const badge = document.createElement('span');
            badge.className = row.sourceBadge.className || 'badge text-bg-secondary';
            badge.textContent = String(row.sourceBadge.text || '').trim();
            wrap.appendChild(badge);
            tdVar.appendChild(wrap);
          } else {
            if(row.required){
              const wrap = document.createElement('div');
              wrap.className = 'd-flex align-items-center gap-1';
              wrap.appendChild(code);
              wrap.appendChild(reqMark);
              tdVar.appendChild(wrap);
            } else {
              tdVar.appendChild(code);
            }
          }

          const tdRes = document.createElement('td');
          tdRes.className = 'small';
          tdRes.appendChild(renderResolvedInline(row.resolved));

          const tdFromChain = document.createElement('td');
          const cbWrap1 = document.createElement('div');
          cbWrap1.className = 'form-check mb-0';
          const cb1 = document.createElement('input');
          cb1.type = 'checkbox';
          cb1.className = 'form-check-input';
          cb1.disabled = true;
          cb1.checked = !!row.fromChain;
          cbWrap1.appendChild(cb1);
          tdFromChain.appendChild(cbWrap1);

          const tdFromSeq = document.createElement('td');
          const cbWrap2 = document.createElement('div');
          cbWrap2.className = 'form-check mb-0';
          const cb2 = document.createElement('input');
          cb2.type = 'checkbox';
          cb2.className = 'form-check-input';
          cb2.disabled = true;
          cb2.checked = !!row.fromSeq;
          cbWrap2.appendChild(cb2);
          tdFromSeq.appendChild(cbWrap2);

          tr.appendChild(tdVar);
          tr.appendChild(tdRes);
          tr.appendChild(tdFromChain);
          tr.appendChild(tdFromSeq);

          if(inputsShowMissing){
            const tdMiss = document.createElement('td');
            if(row.missing) tdMiss.classList.add('text-danger');
            const cbWrap3 = document.createElement('div');
            cbWrap3.className = 'form-check mb-0';
            const cb3 = document.createElement('input');
            cb3.type = 'checkbox';
            cb3.className = 'form-check-input';
            cb3.disabled = true;
            cb3.checked = !!row.missing;
            cbWrap3.appendChild(cb3);
            tdMiss.appendChild(cbWrap3);
            tr.appendChild(tdMiss);
          }

          tbodyIn.appendChild(tr);
        });
        inTbl.appendChild(tbodyIn);
        addRow('', inTbl);
      }

      if(outputsRaw){
        const outputs = [];
        const seen = new Set();
        outputsRaw.forEach((entry)=>{
          if(entry && typeof entry === 'object' && !Array.isArray(entry)){
            const name = String(entry.name || '').trim();
            if(!name || seen.has(name)) return;
            seen.add(name);
            outputs.push({
              name,
              resolved: entry.resolved,
              toChain: (entry.toChain !== undefined) ? !!entry.toChain : true,
            });
            return;
          }
          const name = String(entry || '').trim();
          if(!name || seen.has(name)) return;
          seen.add(name);
          outputs.push({ name, resolved: undefined, toChain: true });
        });

        const outTbl = document.createElement('table');
        outTbl.className = 'table table-sm mb-0';
        outTbl.style.marginLeft = '0';
        outTbl.style.marginRight = '0';
        outTbl.style.width = '100%';
        outTbl.style.paddingLeft = '0';
        const thead = document.createElement('thead');
        thead.innerHTML = '<tr class="text-secondary"><th style="width: 1%; white-space: nowrap;">Variable</th><th>Resolved</th><th style="width: 1%; white-space: nowrap;">To Chain</th></tr>';
        outTbl.appendChild(thead);
        try{
          const firstTh = thead.querySelector('th');
          if(firstTh) firstTh.style.paddingLeft = '0';
        } catch(e) {}
        const tbodyOut = document.createElement('tbody');
        outputs.forEach((row)=>{
          const tr = document.createElement('tr');
          const tdVar = document.createElement('td');
          tdVar.style.paddingLeft = '0';
          const code = document.createElement('code');
          code.className = 'font-monospace';
          code.textContent = String(row.name || '-');
          tdVar.appendChild(code);

          const tdRes = document.createElement('td');
          tdRes.className = 'small';
          tdRes.appendChild(renderResolvedInline(row.resolved));

          const tdToChain = document.createElement('td');
          const cbWrap = document.createElement('div');
          cbWrap.className = 'form-check mb-0';
          const cb = document.createElement('input');
          cb.type = 'checkbox';
          cb.className = 'form-check-input';
          cb.disabled = true;
          cb.checked = !!row.toChain;
          cbWrap.appendChild(cb);
          tdToChain.appendChild(cbWrap);

          tr.appendChild(tdVar);
          tr.appendChild(tdRes);
          tr.appendChild(tdToChain);
          tbodyOut.appendChild(tr);
        });
        outTbl.appendChild(tbodyOut);
        addRow('', outTbl);
      }
      if(!hideArtifactsFields){
        addRow('Artifacts', artifacts.length ? artifacts.join(', ') : '-');
        addRow('Fields', fields.length ? fields.join(', ') : '-');
      }

      tbl.appendChild(tbody);
      details.appendChild(tbl);
      left.appendChild(details);

      const right = document.createElement('div');
      right.className = 'btn-group btn-group-sm';
      right.style.justifySelf = 'end';

      item.appendChild(seq);
      item.appendChild(left);
      item.appendChild(right);
      wrap.appendChild(item);
    }

    const _hintNodeIpMap = _resolveNodeIpsForChain();

    try {
      const firstStep = (chainFeas && chainFeas.length) ? chainFeas[0] : null;
      const initArtifacts = firstStep && Array.isArray(firstStep.missing_artifacts) ? firstStep.missing_artifacts : [];
      const initFields = firstStep && Array.isArray(firstStep.missing_fields) ? firstStep.missing_fields : [];
      const initOverride = normalizeFactsOverride(flowInitialFactsOverride);
      let initHints = [];
      let initOutputs = [];
      try{
        const faFirst = (Array.isArray(currentFlagAssignments) && currentFlagAssignments[0]) ? currentFlagAssignments[0] : null;
        const firstNode = (Array.isArray(currentChain) && currentChain.length) ? currentChain[0] : null;
        const firstName = (firstNode && firstNode.name) ? String(firstNode.name).trim() : '';
        let firstIp = '';
        try{
          const ips = [];
          const pushIps = (val) => {
            if(!val) return;
            if(Array.isArray(val)) { val.forEach(v => pushIps(v)); return; }
            const s = String(val || '').trim();
            if(!s) return;
            s.split(',').forEach(part => { const p = String(part || '').trim(); if(p) ips.push(p); });
          };
          pushIps(firstNode && (firstNode.ip4 || firstNode.ipv4 || firstNode.ip || firstNode.address));
          pushIps(firstNode && firstNode.ips);
          pushIps(firstNode && firstNode.addresses);
          pushIps(firstNode && firstNode.ipv4s);
          const ifaces = firstNode && Array.isArray(firstNode.interfaces) ? firstNode.interfaces : [];
          ifaces.forEach(iface => { if(iface && typeof iface === 'object') pushIps(iface.ip4 || iface.ipv4 || iface.ip || iface.address); });
          const uniq = Array.from(new Set(ips));
          if(uniq.length) firstIp = uniq.join(', ');
        } catch(e) {}
        if(!firstIp && firstName && _hintNodeIpMap && _hintNodeIpMap.get(firstName)) firstIp = _hintNodeIpMap.get(firstName);
        if(firstName){
          const suffix = firstIp ? (' @ ' + firstIp) : '';
          initHints = [`Start: ${firstName}${suffix}`];
        } else {
          initHints = [];
        }
        const ri = (faFirst && typeof faFirst.resolved_inputs === 'object' && faFirst.resolved_inputs && !Array.isArray(faFirst.resolved_inputs))
          ? faFirst.resolved_inputs
          : null;
        if(ri){
          const keys = Object.keys(ri).sort((a, b) => String(a).localeCompare(String(b)));
          initOutputs = keys.map((k)=>({
            name: String(k || '').trim(),
            resolved: ri[k],
            toChain: true,
          })).filter(x => x && x.name && !isFlagFactName(x.name));
        }
        if(!initOutputs.length){
          const names = new Set();
          try{
            const reqArt = (faFirst && Array.isArray(faFirst.requires)) ? faFirst.requires.map(String).filter(Boolean) : [];
            reqArt.forEach(n => { const s = String(n || '').trim(); if(s) names.add(s); });
          } catch(e) {}
          try{
            const inReq = (faFirst && Array.isArray(faFirst.input_fields_required)) ? faFirst.input_fields_required.map(String).filter(Boolean) : [];
            const inOpt = (faFirst && Array.isArray(faFirst.input_fields_optional)) ? faFirst.input_fields_optional.map(String).filter(Boolean) : [];
            const inAll = (faFirst && Array.isArray(faFirst.input_fields)) ? faFirst.input_fields.map(String).filter(Boolean) : [];
            const fields = (inReq.length || inOpt.length) ? inReq.concat(inOpt) : inAll;
            fields.forEach(n => { const s = String(n || '').trim(); if(s) names.add(s); });
          } catch(e) {}
          initOutputs = Array.from(names).sort().filter(k => !isFlagFactName(k)).map((k)=>({
            name: k,
            resolved: ri ? ri[k] : undefined,
            toChain: true,
          }));
        }
      } catch(e) { initHints = []; }
      renderFactSummaryRow({
        seq: 'Init',
        label: 'Initial Facts',
        outputs: initOutputs,
        artifacts: initOverride ? initOverride.artifacts : initArtifacts,
        fields: initOverride ? initOverride.fields : initFields,
        hideArtifactsFields: true,
        hints: initHints,
        onValueOverride: () => openFactsDialog('initial'),
        holdKey: 'initial',
      });
    } catch(e) {}

    currentChain.forEach((node, idx) => {
      const item = document.createElement('div');
      item.className = 'list-group-item';
      let isDupNode = false;
      let isDupFlag = false;
      let dupNodeFirstIdx = -1;
      let dupFlagFirstIdx = -1;
      try{
        const nid = (node && node.id) ? String(node.id).trim() : '';
        if(nid && idCounts[nid] > 1){
          item.classList.add('list-group-item-warning');
          isDupNode = true;
          dupNodeFirstIdx = (idFirstIdx[nid] !== undefined) ? parseInt(String(idFirstIdx[nid]), 10) : -1;
        }
      } catch(e) {}

      // Flag duplication is always flagged when resolved.
      try{
        const fa0 = (Array.isArray(currentFlagAssignments) && currentFlagAssignments[idx]) ? currentFlagAssignments[idx] : null;
        const isRealized = !!(fa0 && (fa0.generated === true || (typeof fa0.flag_override === 'string' && fa0.flag_override.trim()) || (fa0.output_overrides && typeof fa0.output_overrides === 'object')));
        if(!isRealized) throw new Error('not realized');
        let flagVal = '';
        if(fa0 && typeof fa0.flag_value === 'string' && fa0.flag_value.trim()) flagVal = fa0.flag_value.trim();
        if(!flagVal){
          const ro = (fa0 && typeof fa0.resolved_outputs === 'object' && fa0.resolved_outputs && !Array.isArray(fa0.resolved_outputs)) ? fa0.resolved_outputs : null;
          if(ro){
            const rf = ro['Flag(flag_id)'] || ro['flag'] || ro['FLAG'] || '';
            if(typeof rf === 'string' && rf.trim()) flagVal = rf.trim();
          }
        }
        if(flagVal && flagCounts[flagVal] > 1){
          item.classList.add('list-group-item-warning');
          isDupFlag = true;
          dupFlagFirstIdx = (flagFirstIdx[flagVal] !== undefined) ? parseInt(String(flagFirstIdx[flagVal]), 10) : -1;
        }
      } catch(e) {}
      item.style.cursor = 'default';
      item.style.display = 'grid';
      item.style.gridTemplateColumns = '84px 1fr 76px';
      item.style.columnGap = '.5rem';
      item.style.alignItems = 'start';

      const seq = document.createElement('div');
      seq.className = 'text-muted small fw-semibold';
      seq.style.width = '84px';
      seq.style.whiteSpace = 'nowrap';
      seq.style.borderRight = '1px solid var(--bs-border-color, #dee2e6)';
      seq.style.paddingRight = '.5rem';
      seq.textContent = toRoman(idx + 1);

      const left = document.createElement('div');
      left.className = 'd-flex flex-column';
      left.style.minWidth = '0';
      left.style.justifySelf = 'stretch';
      const titleRow = document.createElement('div');
      titleRow.className = 'd-flex align-items-center gap-2';
      const title = document.createElement('div');
      title.className = 'fw-semibold';
      const baseName = (node && node.name) ? String(node.name) : ('Node ' + (idx+1));
      let ipText = '';
      try{
        const faIp = (Array.isArray(currentFlagAssignments) && currentFlagAssignments[idx]) ? currentFlagAssignments[idx] : null;
        const ri = (faIp && typeof faIp.resolved_inputs === 'object' && faIp.resolved_inputs && !Array.isArray(faIp.resolved_inputs))
          ? faIp.resolved_inputs
          : null;
        if(ri){
          ['Knowledge(ip)', 'target_ip', 'host_ip', 'ip4', 'ipv4', 'ip'].some((k)=>{
            const v = ri[k];
            if(v !== undefined && v !== null && String(v).trim()){
              ipText = String(v).trim();
              return true;
            }
            return false;
          });
        }
      } catch(e) {}
      let titleSuffix = '';
      try{
        const fa1 = (Array.isArray(currentFlagAssignments) && currentFlagAssignments[idx]) ? currentFlagAssignments[idx] : null;
        let vulns = fa1 && Array.isArray(fa1.vulnerabilities) ? fa1.vulnerabilities.map(String).filter(Boolean) : [];
        if(!vulns.length){
          try{
            const nodeV = node && Array.isArray(node.vulnerabilities) ? node.vulnerabilities : [];
            vulns = nodeV.map(String).filter(Boolean);
          } catch(e) {}
        }
        const isVulnNode = vulns.length > 0;
        if(isVulnNode){
          titleSuffix = ' - ' + vulns.join(', ');
        } else {
          let osLabel = '';
          try{
            const composeName = node && node.compose_name ? String(node.compose_name) : '';
            const composePath = node && node.compose ? String(node.compose) : '';
            const hay = (composeName + ' ' + composePath).toLowerCase();
            if(hay.includes('ubuntu-22') || hay.includes('ubuntu22') || hay.includes('ubuntu-2204') || hay.includes('ubuntu_22')){
              osLabel = 'Ubuntu 22';
            } else if(hay.includes('ubuntu-20') || hay.includes('ubuntu20') || hay.includes('ubuntu-2004') || hay.includes('ubuntu_20')){
              osLabel = 'Ubuntu 20';
            } else if(hay.includes('ubuntu')){
              osLabel = 'Ubuntu';
            } else if(hay.includes('debian')){
              osLabel = 'Debian';
            } else if(hay.includes('alpine')){
              osLabel = 'Alpine';
            }
          } catch(e) {}
          titleSuffix = osLabel ? (' - Docker Node (' + osLabel + ')') : ' - Docker Node';
        }
      } catch(e) {}
      title.textContent = ipText ? (baseName + ' @ ' + ipText + titleSuffix) : (baseName + titleSuffix);
      titleRow.appendChild(title);
      if(isDupNode){
        const badge = document.createElement('span');
        badge.className = 'badge text-bg-warning';
        const isFirst = (dupNodeFirstIdx >= 0 && dupNodeFirstIdx === idx);
        const sameAs = (!isFirst && dupNodeFirstIdx >= 0) ? (' (same as ' + toRoman(dupNodeFirstIdx + 1) + ')') : '';
        badge.textContent = 'Duplicate node' + sameAs;
        titleRow.appendChild(badge);
      }
      if(isDupFlag){
        const badge = document.createElement('span');
        badge.className = 'badge text-bg-warning';
        const isFirst = (dupFlagFirstIdx >= 0 && dupFlagFirstIdx === idx);
        const sameAs = (!isFirst && dupFlagFirstIdx >= 0) ? (' (same as ' + toRoman(dupFlagFirstIdx + 1) + ')') : '';
        badge.textContent = 'Duplicate flag' + sameAs;
        titleRow.appendChild(badge);
      }

      // Per-step actions (top-right).
      try {
        const btnGroup = document.createElement('div');
        btnGroup.className = 'btn-group btn-group-sm ms-auto';

        const inputsBtn = document.createElement('button');
        inputsBtn.type = 'button';
        inputsBtn.className = 'btn btn-outline-secondary';
        inputsBtn.textContent = 'Value Override';
        inputsBtn.disabled = true;
        inputsBtn.title = 'Disabled';
        inputsBtn.addEventListener('click', (ev)=>{
          try { ev && ev.preventDefault && ev.preventDefault(); } catch(e) {}
          try { ev && ev.stopPropagation && ev.stopPropagation(); } catch(e) {}
          try { selectChainIndex(idx); } catch(e) {}
          try { openInputsDialog(idx); } catch(e) {}
        });

        const subBtn = document.createElement('button');
        subBtn.type = 'button';
        subBtn.className = 'btn btn-outline-primary';
        subBtn.textContent = 'Change Node';
        subBtn.disabled = true;
        subBtn.title = 'Disabled';
        subBtn.addEventListener('click', (ev)=>{
          try { ev && ev.preventDefault && ev.preventDefault(); } catch(e) {}
          try { ev && ev.stopPropagation && ev.stopPropagation(); } catch(e) {}
          try { selectChainIndex(idx); } catch(e) {}
          try { openSubstituteDialog(idx); } catch(e) {}
        });

        const holdBtn = document.createElement('button');
        holdBtn.type = 'button';
        holdBtn.className = (heldChainIndices && heldChainIndices.has(idx)) ? 'btn btn-warning' : 'btn btn-outline-warning';
        holdBtn.textContent = 'Hold';
        holdBtn.title = (heldChainIndices && heldChainIndices.has(idx))
          ? 'Node held (generator changes will not change this chain position)'
          : 'Hold node (generator changes will not change this chain position)';
        holdBtn.disabled = true;
        holdBtn.title = 'Disabled';
        holdBtn.addEventListener('click', (ev)=>{
          try { ev && ev.preventDefault && ev.preventDefault(); } catch(e) {}
          try { ev && ev.stopPropagation && ev.stopPropagation(); } catch(e) {}
          try {
            if(heldChainIndices && heldChainIndices.has(idx)){
              heldChainIndices.delete(idx);
            } else {
              heldChainIndices.add(idx);
            }
          } catch(e) {}
          renderChainEditor();
        });

        btnGroup.appendChild(subBtn);
        btnGroup.appendChild(inputsBtn);
        btnGroup.appendChild(holdBtn);
        titleRow.appendChild(btnGroup);
      } catch(e) {}
      left.appendChild(titleRow);

      // Sub-details: compact table for readability.
      const details = document.createElement('div');
      details.className = 'mt-1';
      const tbl = document.createElement('table');
      tbl.className = 'table table-sm table-borderless mb-0 small';
      const tbody = document.createElement('tbody');

      function addRow(label, valueElOrText, { danger = false } = {}){
        const tr = document.createElement('tr');
        const tdL = document.createElement('td');
        tdL.className = 'text-muted';
        tdL.style.whiteSpace = 'nowrap';
        tdL.style.width = '1%';
        tdL.textContent = String(label || '').trim() ? (String(label).trim() + ':') : '';
        const tdV = document.createElement('td');
        if(danger) tdV.classList.add('text-danger');
        if(valueElOrText && typeof valueElOrText === 'object' && valueElOrText.nodeType){
          tdV.appendChild(valueElOrText);
        } else {
          tdV.textContent = String(valueElOrText || '-');
        }
        tr.appendChild(tdL);
        tr.appendChild(tdV);
        tbody.appendChild(tr);
      }

      const fa = (Array.isArray(currentFlagAssignments) && currentFlagAssignments[idx]) ? currentFlagAssignments[idx] : null;
      const genId = fa && fa.id ? String(fa.id) : '-';
      const genName = fa && fa.name ? String(fa.name) : '-';
      addRow('Generator', (genName && genName !== '-' && genName !== genId)
        ? (genId + ' | ' + genName)
        : genId);

      const genLabel = fa && fa.flag_generator ? String(fa.flag_generator) : '-';
      addRow('Source', genLabel);

      const genType = fa && fa.type ? String(fa.type) : '-';
      addRow('Type', genType);

      try{
        const nid = (node && node.id) ? String(node.id).trim() : '';
        if(nid && idCounts[nid] > 1){
          const firstIdx = (idFirstIdx[nid] !== undefined) ? parseInt(String(idFirstIdx[nid]), 10) : -1;
          const isFirst = (firstIdx >= 0 && firstIdx === idx);
          const sameAs = (!isFirst && firstIdx >= 0) ? ('same as ' + toRoman(firstIdx + 1) + '; ') : '';
          addRow('Notice', 'Duplicate node in chain (' + sameAs + 'allowed; reseeded per occurrence).');
        }
      } catch(e) {}

      try{
        const gid = fa && (fa.id || fa.generator_id) ? String(fa.id || fa.generator_id).trim() : '';
        if(gid && genCounts[gid] > 1){
          const firstIdx = (genFirstIdx[gid] !== undefined) ? parseInt(String(genFirstIdx[gid]), 10) : -1;
          const isFirst = (firstIdx >= 0 && firstIdx === idx);
          const sameAs = (!isFirst && firstIdx >= 0) ? ('same as ' + toRoman(firstIdx + 1)) : 'reused in chain';
          addRow('Notice', 'Duplicate generator assignment (' + sameAs + ').');
        }
      } catch(e) {}
      try{
        const isRealized = !!(fa && (fa.generated === true || (typeof fa.flag_override === 'string' && fa.flag_override.trim()) || (fa.output_overrides && typeof fa.output_overrides === 'object')));
        if(!isRealized) throw new Error('not realized');
        let flagVal = '';
        if(fa && typeof fa.flag_value === 'string' && fa.flag_value.trim()) flagVal = fa.flag_value.trim();
        if(!flagVal){
          const ro = (fa && typeof fa.resolved_outputs === 'object' && fa.resolved_outputs && !Array.isArray(fa.resolved_outputs)) ? fa.resolved_outputs : null;
          if(ro){
            const rf = ro['Flag(flag_id)'] || ro['flag'] || ro['FLAG'] || '';
            if(typeof rf === 'string' && rf.trim()) flagVal = rf.trim();
          }
        }
        if(flagVal && flagCounts[flagVal] > 1){
          const firstIdx = (flagFirstIdx[flagVal] !== undefined) ? parseInt(String(flagFirstIdx[flagVal]), 10) : -1;
          const isFirst = (firstIdx >= 0 && firstIdx === idx);
          const sameAs = (!isFirst && firstIdx >= 0) ? ('same as ' + toRoman(firstIdx + 1)) : 'reused in chain';
          addRow('Notice', 'Duplicate flag value (' + sameAs + ').');
        }
      } catch(e) {}

      // Realized flag value (populated after prepare_preview_for_execute).
      try{
        const isRealized = !!(fa && (fa.generated === true || (typeof fa.flag_override === 'string' && fa.flag_override.trim()) || (fa.output_overrides && typeof fa.output_overrides === 'object')));
        if(!isRealized) throw new Error('not realized');
        const fv = (fa && typeof fa.flag_value === 'string') ? fa.flag_value.trim() : '';
        let resolvedFlag = fv;
        if(!resolvedFlag){
          try{
            const ro = (fa && typeof fa.resolved_outputs === 'object' && fa.resolved_outputs && !Array.isArray(fa.resolved_outputs)) ? fa.resolved_outputs : null;
            if(ro){
              const rf = ro['Flag(flag_id)'] || ro['flag'] || ro['FLAG'] || '';
              if(typeof rf === 'string' && rf.trim()) resolvedFlag = rf.trim();
            }
          } catch(e) {}
        }
        if(resolvedFlag){
          const code = document.createElement('code');
          code.className = 'font-monospace';
          code.style.whiteSpace = 'pre-wrap';
          code.textContent = resolvedFlag;
          addRow('Flag', code);
        }
      } catch(e) {}


      const descList = (fa && Array.isArray(fa.description_hints) && fa.description_hints.length)
        ? fa.description_hints.map(x => String(x || '').trim()).filter(Boolean)
        : [];
      if(descList.length > 1){
        const wrap = document.createElement('div');
        const ul = document.createElement('ol');
        ul.className = 'mb-0 ps-3';
        descList.forEach((ht) => {
          const li = document.createElement('li');
          li.textContent = ht;
          ul.appendChild(li);
        });
        wrap.appendChild(ul);
        addRow('Description Hints', wrap);
      } else if(descList.length === 1){
        addRow('Description Hints', descList[0]);
      }

      const hintList = (fa && Array.isArray(fa.hints) && fa.hints.length)
        ? fa.hints.map(x => String(x || '').trim()).filter(Boolean)
        : [];
      const hintListWithIp = hintList.map(h => _applyHintNodeIps(h, _hintNodeIpMap));
      if(hintList.length > 1){
        const wrap = document.createElement('div');
        const ul = document.createElement('ol');
        ul.className = 'mb-0 ps-3';
        hintListWithIp.forEach((ht) => {
          const li = document.createElement('li');
          li.textContent = ht;
          ul.appendChild(li);
        });
        wrap.appendChild(ul);
        addRow('Hints', wrap);
      } else {
        const hintTextRaw = hintList.length ? hintList[0] : (fa && fa.hint ? String(fa.hint) : '');
        const hintText = _applyHintNodeIps(hintTextRaw, _hintNodeIpMap);
        addRow('Hint', hintText || '-');
      }

      const feas = chainFeasibility(currentFlagAssignments);
      const step = feas && feas[idx] ? feas[idx] : null;
        const inReq = (fa && Array.isArray(fa.input_fields_required)) ? fa.input_fields_required.map(String).filter(Boolean) : [];
        const inOpt = (fa && Array.isArray(fa.input_fields_optional)) ? fa.input_fields_optional.map(String).filter(Boolean) : [];
        const inAll = (fa && Array.isArray(fa.input_fields)) ? fa.input_fields.map(String).filter(Boolean) : [];
        const useAllAsRequired = !(inReq.length || inOpt.length) && inAll.length;
        const reqFields = useAllAsRequired ? inAll : inReq;
        const inputsDisplay = (inReq.length || inOpt.length)
          ? (inReq.concat(inOpt).join(', '))
          : (inAll.length ? inAll.join(', ') : '-');
        const isNodeGen = String((fa && fa.type) || '').trim() === 'flag-node-generator';
        const injectedFiles = (fa && Array.isArray(fa.inject_files))
          ? fa.inject_files.map(x => String(x || '').trim()).filter(Boolean)
          : [];
        // Inputs/Outputs: tabular view with Providing/Missing side-by-side.
        try{
          const reqArtifacts = (fa && Array.isArray(fa.requires)) ? fa.requires.map(String).filter(Boolean) : [];
          const providedArtifactsChain = (step && Array.isArray(step.providing_artifacts_chain)) ? step.providing_artifacts_chain.map(String).filter(Boolean) : [];
          const providedArtifactsSeq = (step && Array.isArray(step.providing_artifacts_sequencer)) ? step.providing_artifacts_sequencer.map(String).filter(Boolean) : [];
          const missingArtifacts = (step && Array.isArray(step.missing_artifacts)) ? step.missing_artifacts.map(String).filter(Boolean) : [];

          const defFields = (inReq.length || inOpt.length)
            ? inReq.concat(inOpt)
            : inAll;
          const providedFieldsChain = (step && Array.isArray(step.providing_fields_chain)) ? step.providing_fields_chain.map(String).filter(Boolean) : [];
          const providedFieldsSeq = (step && Array.isArray(step.providing_fields_sequencer)) ? step.providing_fields_sequencer.map(String).filter(Boolean) : [];
          const missingFields = (step && Array.isArray(step.missing_fields)) ? step.missing_fields.map(String).filter(Boolean) : [];

          const showMissingCol = (missingArtifacts.length + missingFields.length) > 0;

          function _stringifyAny(v){
            if(v === undefined) return '';
            if(v === null) return 'null';
            if(typeof v === 'string') return v;
            try { return JSON.stringify(v); } catch(e) { return String(v); }
          }

          function renderResolvedCell(kv, keysOrder, opts){
            const options = (opts && typeof opts === 'object') ? opts : {};
            const maxItems = Number.isFinite(+options.maxItems) ? (+options.maxItems) : 3;
            const maxLen = Number.isFinite(+options.maxLen) ? (+options.maxLen) : 60;
            const maxDetailItems = Number.isFinite(+options.maxDetailItems) ? (+options.maxDetailItems) : 25;

            const obj = (kv && typeof kv === 'object' && !Array.isArray(kv)) ? kv : null;
            if(!obj || !Object.keys(obj).length) return document.createTextNode('-');

            let keys = Array.isArray(keysOrder) && keysOrder.length
              ? keysOrder.map(x => String(x || '').trim()).filter(Boolean)
              : Object.keys(obj);

            // Prefer showing flag first when present.
            try {
              if(Object.prototype.hasOwnProperty.call(obj, 'flag')){
                keys = ['flag'].concat(keys.filter(k => k !== 'flag'));
              }
            } catch(e) {}

            const seen = new Set();
            const pairs = [];
            for(const k of keys){
              const kk = String(k || '').trim();
              if(!kk || seen.has(kk)) continue;
              seen.add(kk);
              if(!(kk in obj)) continue;
              const v = obj[kk];
              if(v === undefined) continue;
              const full = _stringifyAny(v);
              let short = full;
              if(typeof short === 'string' && short.length > maxLen){
                short = short.slice(0, Math.max(0, maxLen - 1)) + '…';
              }
              pairs.push({ k: kk, full, short });
            }

            if(!pairs.length) return document.createTextNode('-');

            // If there's only one value, render it inline unless it's "complex" (object/array/truncated).
            if(pairs.length === 1){
              const p = pairs[0];
              let isComplex = false;
              try{
                const raw = obj[p.k];
                if(raw && typeof raw === 'object') isComplex = true;
              } catch(e) {}
              try{
                if(typeof p.full === 'string' && typeof p.short === 'string' && p.full !== p.short) isComplex = true;
              } catch(e) {}
              try{
                if(typeof p.full === 'string' && p.full.includes('\n')) isComplex = true;
              } catch(e) {}
              if(!isComplex){
                const code = document.createElement('code');
                code.className = 'font-monospace';
                code.title = p.full;
                code.textContent = p.short;
                return code;
              }
              const details = document.createElement('details');
              details.className = 'small';
              const summary = document.createElement('summary');
              summary.style.cursor = 'pointer';
              summary.className = 'text-decoration-none';
              const code = document.createElement('code');
              code.className = 'font-monospace';
              code.title = p.full;
              code.textContent = p.short;
              summary.appendChild(code);
              details.appendChild(summary);
              const body = document.createElement('div');
              body.className = 'mt-1';
              const vcode = document.createElement('code');
              vcode.className = 'font-monospace';
              vcode.style.whiteSpace = 'pre-wrap';
              vcode.textContent = p.full;
              body.appendChild(vcode);
              details.appendChild(body);
              return details;
            }

            const details = document.createElement('details');
            details.className = 'small';
            const summary = document.createElement('summary');
            summary.style.cursor = 'pointer';
            summary.className = 'text-decoration-none';

            const summaryWrap = document.createElement('span');
            summaryWrap.className = 'd-inline-flex flex-wrap gap-1 align-items-center';

            const head = pairs.slice(0, Math.max(1, maxItems));
            head.forEach(p => {
              const code = document.createElement('code');
              code.className = 'font-monospace';
              code.title = p.full;
              code.textContent = p.k + ': ' + p.short;
              summaryWrap.appendChild(code);
            });
            if(pairs.length > head.length){
              const more = document.createElement('span');
              more.className = 'text-muted';
              more.textContent = `(+${pairs.length - head.length})`;
              summaryWrap.appendChild(more);
            }
            summary.appendChild(summaryWrap);
            details.appendChild(summary);

            const body = document.createElement('div');
            body.className = 'mt-1';
            const list = document.createElement('div');
            list.className = 'd-flex flex-column gap-1';
            pairs.slice(0, maxDetailItems).forEach(p => {
              const row = document.createElement('div');
              const kcode = document.createElement('code');
              kcode.className = 'me-1 text-muted';
              kcode.textContent = p.k;
              const vcode = document.createElement('code');
              vcode.className = 'font-monospace';
              vcode.style.whiteSpace = 'pre-wrap';
              vcode.textContent = p.full;
              row.appendChild(kcode);
              row.appendChild(document.createTextNode(': '));
              row.appendChild(vcode);
              list.appendChild(row);
            });
            if(pairs.length > maxDetailItems){
              const moreLine = document.createElement('div');
              moreLine.className = 'text-muted';
              moreLine.textContent = `(+${pairs.length - maxDetailItems} more not shown)`;
              list.appendChild(moreLine);
            }
            body.appendChild(list);
            details.appendChild(body);
            return details;
          }

          const resolvedInputs = (fa && typeof fa.resolved_inputs === 'object' && fa.resolved_inputs && !Array.isArray(fa.resolved_inputs)) ? fa.resolved_inputs : null;
          const resolvedOutputs = (fa && typeof fa.resolved_outputs === 'object' && fa.resolved_outputs && !Array.isArray(fa.resolved_outputs)) ? fa.resolved_outputs : null;

          const outFields = (fa && Array.isArray(fa.output_fields)) ? fa.output_fields.map(String).filter(Boolean) : [];
          const outArtifacts = (fa && Array.isArray(fa.produces)) ? fa.produces.map(String).filter(Boolean) : [];

          // For outputs, show what is *required by downstream steps* (subset of this step's defined outputs).
          const synthesizedFields = ['seed','secret','env_name','challenge','flag_prefix','username_prefix','key_len','node_name'];
          const synthesizedSet = new Set(synthesizedFields);
          const downstreamReqArtifacts = new Set();
          const downstreamReqFields = new Set();
          try{
            for(let j = idx + 1; j < (Array.isArray(currentFlagAssignments) ? currentFlagAssignments.length : 0); j++){
              const a2 = currentFlagAssignments[j] || {};
              const reqArtRaw = Array.isArray(a2.requires) ? a2.requires.map(String).filter(Boolean) : [];
              reqArtRaw.filter(k => k && !synthesizedSet.has(k)).forEach(k => downstreamReqArtifacts.add(k));

              const reqFld = Array.isArray(a2.input_fields_required)
                ? a2.input_fields_required.map(String).filter(Boolean)
                : (Array.isArray(a2.input_fields) ? a2.input_fields.map(String).filter(Boolean) : []);
              reqFld.forEach(k => downstreamReqFields.add(k));
            }
          } catch(e) {}
          const outArtifactsReq = outArtifacts.filter(k => downstreamReqArtifacts.has(k));
          const outFieldsReq = outFields.filter(k => downstreamReqFields.has(k));

          function renderBoolCheckbox(checked, title){
            const wrap = document.createElement('div');
            wrap.className = 'form-check mb-0';
            const cb = document.createElement('input');
            cb.type = 'checkbox';
            cb.className = 'form-check-input';
            cb.disabled = true;
            cb.checked = !!checked;
            if(title) cb.title = String(title);
            wrap.appendChild(cb);
            return wrap;
          }

          function renderVarName(name, required){
            const span = document.createElement('span');
            span.style.whiteSpace = 'nowrap';
            const code = document.createElement('code');
            code.className = 'font-monospace';
            code.textContent = String(name || '').trim() || '-';
            span.appendChild(code);
            if(required){
              const star = document.createElement('span');
              star.className = 'text-danger ms-1';
              star.textContent = '*';
              span.appendChild(star);
            }
            return span;
          }

          function renderResolvedValueForKey(resolvedKv, key){
            const k = String(key || '').trim();
            if(!k || !resolvedKv || typeof resolvedKv !== 'object' || Array.isArray(resolvedKv)) return document.createTextNode('-');
            if(!(k in resolvedKv)) return document.createTextNode('-');
            const obj = {};
            obj[k] = resolvedKv[k];
            return renderResolvedCell(obj, [k], { maxItems: 1, maxLen: 72, maxDetailItems: 25 });
          }

          function buildIoTable(mode){
            const isInputs = mode === 'inputs';

            const tbl = document.createElement('table');
            tbl.className = 'table table-sm mb-0';

            const thead = document.createElement('thead');
            if(isInputs){
              thead.innerHTML = showMissingCol
                ? '<tr class="text-secondary"><th style="width: 1%; white-space: nowrap;">Variable</th><th>Resolved</th><th style="width: 1%; white-space: nowrap;">From Chain</th><th style="width: 1%; white-space: nowrap;">From Sequencer</th><th style="width: 1%; white-space: nowrap;">Missing</th></tr>'
                : '<tr class="text-secondary"><th style="width: 1%; white-space: nowrap;">Variable</th><th>Resolved</th><th style="width: 1%; white-space: nowrap;">From Chain</th><th style="width: 1%; white-space: nowrap;">From Sequencer</th></tr>';
            } else {
              thead.innerHTML = '<tr class="text-secondary"><th style="width: 1%; white-space: nowrap;">Variable</th><th>Resolved</th><th style="width: 1%; white-space: nowrap;">To Chain</th></tr>';
            }
            tbl.appendChild(thead);

            const tbody2 = document.createElement('tbody');

            function addRowVar(v){
              const tr = document.createElement('tr');

              const tdVar = document.createElement('td');
              tdVar.appendChild(renderVarName(v.name, v.required));

              const tdRes = document.createElement('td');
              tdRes.className = 'small';
              tdRes.appendChild(renderResolvedValueForKey(isInputs ? resolvedInputs : resolvedOutputs, v.name));

              tr.appendChild(tdVar);
              tr.appendChild(tdRes);

              if(isInputs){
                const tdFromChain = document.createElement('td');
                tdFromChain.appendChild(renderBoolCheckbox(v.fromChain, 'Provided by chain'));
                const tdFromSeq = document.createElement('td');
                tdFromSeq.appendChild(renderBoolCheckbox(v.fromSeq, 'Provided by sequencer (synthesized)'));
                tr.appendChild(tdFromChain);
                tr.appendChild(tdFromSeq);
                if(showMissingCol){
                  const tdMiss = document.createElement('td');
                  if(v.missing) tdMiss.classList.add('text-danger');
                  tdMiss.appendChild(renderBoolCheckbox(v.missing, v.missing ? 'Missing' : 'Not missing'));
                  tr.appendChild(tdMiss);
                }
              } else {
                const tdToChain = document.createElement('td');
                tdToChain.appendChild(renderBoolCheckbox(v.toChain, 'Provided to chain'));
                tr.appendChild(tdToChain);
              }

              tbody2.appendChild(tr);
            }

            const reqArtifactSet = new Set(reqArtifacts);
            const reqFieldSet = new Set(reqFields);
            const defArtifactSet = new Set(reqArtifacts);
            const defFieldSet = new Set(defFields);

            const provArtChainSet = new Set(providedArtifactsChain);
            const provArtSeqSet = new Set(providedArtifactsSeq);
            const missArtSet = new Set(missingArtifacts);

            const provFldChainSet = new Set(providedFieldsChain);
            const provFldSeqSet = new Set(providedFieldsSeq);
            const missFldSet = new Set(missingFields);

            if(isInputs){
              const hasExplicitInputSplit = (inReq.length || inOpt.length);
              const markAllFieldsRequired = !hasExplicitInputSplit;
              const rows = [];
              Array.from(defArtifactSet).sort().forEach((name) => {
                const n = String(name || '').trim();
                if(!n) return;
                rows.push({
                  name: n,
                  kind: 'Artifact',
                  required: reqArtifactSet.has(n),
                  fromChain: provArtChainSet.has(n),
                  fromSeq: provArtSeqSet.has(n),
                  missing: missArtSet.has(n),
                });
              });

              // If the generator declares no explicit input fields, still show any
              // resolved config keys (including synthesized defaults) so the Resolved
              // column isn't empty.
              const fieldNameSet = new Set(Array.from(defFieldSet));
              try{
                if((!fieldNameSet.size) && resolvedInputs && typeof resolvedInputs === 'object' && !Array.isArray(resolvedInputs)){
                  Object.keys(resolvedInputs).forEach(k => { if(String(k || '').trim()) fieldNameSet.add(String(k).trim()); });
                }
              } catch(e) {}
              try{
                // Prefer including synthesized fields when present.
                if(Array.isArray(synthesizedFields) && synthesizedFields.length && resolvedInputs){
                  synthesizedFields.forEach(k => {
                    const kk = String(k || '').trim();
                    if(!kk) return;
                    try{
                      if(resolvedInputs && typeof resolvedInputs === 'object' && !Array.isArray(resolvedInputs) && (kk in resolvedInputs)){
                        fieldNameSet.add(kk);
                      }
                    } catch(e) {}
                  });
                }
              } catch(e) {}

              Array.from(fieldNameSet).sort().forEach((name) => {
                const n = String(name || '').trim();
                if(!n) return;
                rows.push({
                  name: n,
                  kind: 'Field',
                  required: reqFieldSet.has(n) || markAllFieldsRequired,
                  fromChain: provFldChainSet.has(n),
                  fromSeq: provFldSeqSet.has(n),
                  missing: missFldSet.has(n),
                });
              });
              rows.forEach(addRowVar);
            } else {
              const reqOutArtifactSet = new Set(outArtifactsReq);
              const reqOutFieldSet = new Set(outFieldsReq);
              const rows = [];
              const outArtifactSet = new Set(outArtifacts.map(String).filter(Boolean).map(s => String(s).trim()).filter(Boolean));
              outArtifacts.map(String).filter(Boolean).sort().forEach((name) => {
                const n = String(name || '').trim();
                if(!n) return;
                rows.push({
                  name: n,
                  kind: 'Artifact',
                  required: reqOutArtifactSet.has(n),
                  toChain: true,
                });
              });

              const outFieldNameSet = new Set(outFields.map(String).filter(Boolean).map(s => String(s).trim()).filter(Boolean));
              try{
                if((!outFieldNameSet.size) && resolvedOutputs && typeof resolvedOutputs === 'object' && !Array.isArray(resolvedOutputs)){
                  Object.keys(resolvedOutputs).forEach(k => { if(String(k || '').trim()) outFieldNameSet.add(String(k).trim()); });
                }
              } catch(e) {}

              Array.from(outFieldNameSet).sort().forEach((name) => {
                const n = String(name || '').trim();
                if(!n) return;
                if(outArtifactSet.has(n)) return;
                rows.push({
                  name: n,
                  kind: 'Field',
                  required: reqOutFieldSet.has(n),
                  toChain: true,
                });
              });
              rows.forEach(addRowVar);
            }

            tbl.appendChild(tbody2);
            return tbl;
          }

          // Single tabbed table (Inputs/Outputs) in chain order.
          const ioWrap = document.createElement('div');

          const tabBar = document.createElement('div');
          tabBar.className = 'd-flex align-items-center gap-2 mb-2';

          const btnInputs = document.createElement('button');
          btnInputs.type = 'button';
          btnInputs.className = 'btn btn-sm btn-outline-primary';
          btnInputs.textContent = 'Inputs';

          const btnOutputs = document.createElement('button');
          btnOutputs.type = 'button';
          btnOutputs.className = 'btn btn-sm btn-outline-primary';
          btnOutputs.textContent = 'Outputs';

          const btnInjects = document.createElement('button');
          btnInjects.type = 'button';
          btnInjects.className = 'btn btn-sm btn-outline-primary';
          btnInjects.textContent = 'Injects';

          tabBar.appendChild(btnInputs);
          tabBar.appendChild(btnOutputs);
          tabBar.appendChild(btnInjects);
          ioWrap.appendChild(tabBar);

          const inputsPane = document.createElement('div');
          const outputsPane = document.createElement('div');
          const injectsPane = document.createElement('div');
          inputsPane.appendChild(buildIoTable('inputs'));
          outputsPane.appendChild(buildIoTable('outputs'));
          function parseInjectSpec(text){
            const raw = String(text ?? '').trim();
            if(!raw) return { src: '', dest: '' };
            for(const sep of ['->', '=>']){
              const idx = raw.indexOf(sep);
              if(idx >= 0){
                const left = raw.slice(0, idx).trim();
                const right = raw.slice(idx + sep.length).trim();
                return { src: left, dest: right };
              }
            }
            return { src: raw, dest: '' };
          }

          function _basenameFromPath(p){
            const s = String(p || '').replace('\\', '/');
            const parts = s.split('/').filter(Boolean);
            return parts.length ? parts[parts.length - 1] : s;
          }

          function filenameFromPath(p){
            const s = String(p || '').replace('\\', '/');
            const parts = s.split('/').filter(Boolean);
            return parts.length ? parts[parts.length - 1] : s;
          }

          function buildInjectsTable(files, resolved){
            const tbl = document.createElement('table');
            tbl.className = 'table table-sm mb-0';
            const thead = document.createElement('thead');
            thead.innerHTML = '<tr class="text-secondary"><th style="width: 1%; white-space: nowrap;">Variable</th><th>Resolved</th><th>Path</th></tr>';
            tbl.appendChild(thead);
            const tbody2 = document.createElement('tbody');
            const rows = Array.isArray(files) ? files : [];
            if(!rows.length){
              const tr = document.createElement('tr');
              const td = document.createElement('td');
              td.colSpan = 3;
              td.className = 'text-muted small';
              td.textContent = 'No inject files.';
              tr.appendChild(td);
              tbody2.appendChild(tr);
            } else {
              const resolvedMap = (resolved && typeof resolved === 'object' && !Array.isArray(resolved)) ? resolved : null;

              function normalizeDestDir(d){
                const s = String(d || '').trim();
                if(!s || !s.startsWith('/')) return '/tmp';
                return s.replace(/\/+$/g, '') || '/tmp';
              }

              function resolvedTargetsFor(src){
                if(!resolvedMap) return [];
                const key = String(src || '').trim();
                if(!key || !(key in resolvedMap)) return [];
                const v = resolvedMap[key];
                if(Array.isArray(v)){
                  return v.map(x => String(x ?? '')).filter(x => x.trim());
                }
                if(typeof v === 'string') return [v.trim()].filter(Boolean);
                return [];
              }

              function basenameFrom(p){
                const s = String(p || '').replace('\\', '/');
                const parts = s.split('/').filter(Boolean);
                return parts.length ? parts[parts.length - 1] : s;
              }

              rows.forEach((entry)=>{
                const parsed = parseInjectSpec(entry);
                const srcRaw = String(parsed.src || '');
                const dest = parsed.dest || '';

                let displaySrc = srcRaw;
                let resolvedTargets = [];
                if(srcRaw.startsWith('upload:')){
                  const base = filenameFromPath(srcRaw.slice('upload:'.length));
                  displaySrc = base ? `artifacts/${base}` : srcRaw;
                  resolvedTargets = displaySrc ? [displaySrc] : [];
                } else {
                  displaySrc = srcRaw;
                  resolvedTargets = resolvedTargetsFor(srcRaw);
                }

                const name = filenameFromPath(displaySrc);
                const destDir = normalizeDestDir(dest);

                const entries = resolvedTargets.length ? resolvedTargets : [''];
                entries.forEach((resolvedVal, idx)=>{
                  const tr = document.createElement('tr');
                  const tdName = document.createElement('td');
                  const nameCode = document.createElement('code');
                  nameCode.className = 'font-monospace';
                  nameCode.textContent = (idx === 0 ? (name || '-') : '');
                  tdName.appendChild(nameCode);

                  const tdResolved = document.createElement('td');
                  tdResolved.className = 'small text-muted';
                  tdResolved.textContent = resolvedVal ? resolvedVal : (resolvedTargets.length ? '-' : '');

                  const tdPath = document.createElement('td');
                  tdPath.className = 'small text-muted';
                  const resolvedBase = resolvedVal ? basenameFrom(resolvedVal) : basenameFrom(displaySrc);
                  const destPath = resolvedBase ? `${destDir}/${resolvedBase}` : destDir;
                  tdPath.textContent = destPath || '-';

                  tr.appendChild(tdName);
                  tr.appendChild(tdResolved);
                  tr.appendChild(tdPath);
                  tbody2.appendChild(tr);
                });
              });
            }
            tbl.appendChild(tbody2);
            return tbl;
          }

          injectsPane.appendChild(buildInjectsTable(injectedFiles, resolvedOutputs));
          outputsPane.style.display = 'none';
          injectsPane.style.display = 'none';

          function setTab(which){
            const showInputs = which === 'inputs';
            const showOutputs = which === 'outputs';
            const showInjects = which === 'injects';
            inputsPane.style.display = showInputs ? '' : 'none';
            outputsPane.style.display = showOutputs ? '' : 'none';
            injectsPane.style.display = showInjects ? '' : 'none';
            btnInputs.className = showInputs ? 'btn btn-sm btn-primary' : 'btn btn-sm btn-outline-primary';
            btnOutputs.className = showOutputs ? 'btn btn-sm btn-primary' : 'btn btn-sm btn-outline-primary';
            btnInjects.className = showInjects ? 'btn btn-sm btn-primary' : 'btn btn-sm btn-outline-primary';
          }
          btnInputs.addEventListener('click', () => setTab('inputs'));
          btnOutputs.addEventListener('click', () => setTab('outputs'));
          btnInjects.addEventListener('click', () => setTab('injects'));
          setTab('inputs');

          ioWrap.appendChild(inputsPane);
          ioWrap.appendChild(outputsPane);
          ioWrap.appendChild(injectsPane);

          // Full-width row so the IO block is flush-left.
          {
            const tr = document.createElement('tr');
            const td = document.createElement('td');
            td.colSpan = 2;
            td.style.paddingLeft = '0';
            td.appendChild(ioWrap);
            tr.appendChild(td);
            tbody.appendChild(tr);
          }
        } catch(e) {
          // If anything goes wrong, fall back to the old simple rows.
          addRow(isNodeGen ? 'Flag-Node-Generator Defined Input' : 'Flag-Generator Defined Input', inputsDisplay);
          addRow(isNodeGen ? 'Flag-Node-Generator Defined Output' : 'Flag-Generator Defined Output', fa && Array.isArray(fa.output_fields) && fa.output_fields.length ? fa.output_fields.join(', ') : '-');
          addRow('Chain Item Providing', fa && Array.isArray(fa.requires) && fa.requires.length ? fa.requires.join(', ') : '-');
          addRow('Providing to Chain', fa && Array.isArray(fa.produces) && fa.produces.length ? fa.produces.join(', ') : '-');
          if(step && step.ok === false){
            addRow('Missing Inputs', (step.missing || []).join(', ') || '-', { danger: true });
          }
        }

      // After prepare_preview_for_execute, the backend may attach runtime validation
      // fields like outputs_match/outputs_mismatch to help validate generator specs.
      try {
        if(fa && fa.inputs_match === false){
          const mm = fa.inputs_mismatch || {};
          const missingReq = Array.isArray(mm.missing_required) ? mm.missing_required : [];
          const unsetReq = Array.isArray(mm.unset_required) ? mm.unset_required : [];
          const dropped = Array.isArray(mm.dropped) ? mm.dropped : [];

          const parts = [];
          if(missingReq.length){
            const msg = missingReq.map(k => String(k || '').trim()).filter(Boolean)
              .map(k => `${k} (required by catalog inputs, but not provided in generator config)`)
              .join('; ');
            parts.push('missing required: ' + (msg || missingReq.join(', ')));
          }
          if(unsetReq.length){
            const msg = unsetReq.map(k => String(k || '').trim()).filter(Boolean)
              .map(k => `${k} (provided but empty/null)`)
              .join('; ');
            parts.push('unset required: ' + (msg || unsetReq.join(', ')));
          }
          if(dropped.length){
            const msg = dropped.map(k => String(k || '').trim()).filter(Boolean)
              .map(k => `${k} (not declared by generator inputs; not passed)`)
              .join('; ');
            parts.push('dropped: ' + (msg || dropped.join(', ')));
          }
          addRow('Inputs Mismatch', parts.length ? parts.join(' | ') : 'inputs mismatch', { danger: true });
        }
        if(fa && fa.outputs_match === false){
          const mm = fa.outputs_mismatch || {};
          const missing = Array.isArray(mm.missing) ? mm.missing : [];
          const extra = Array.isArray(mm.extra) ? mm.extra : [];
          const parts = [];
          if(missing.length){
            const msg = missing.map(k => String(k || '').trim()).filter(Boolean)
              .map(k => `${k} (declared in catalog output_fields, but not present in outputs.json)`)
              .join('; ');
            parts.push('missing: ' + (msg || missing.join(', ')));
          }
          if(extra.length){
            const msg = extra.map(k => String(k || '').trim()).filter(Boolean)
              .map(k => `${k} (present in outputs.json, but not declared in catalog output_fields)`)
              .join('; ');
            parts.push('extra: ' + (msg || extra.join(', ')));
          }
          addRow('Outputs Mismatch', parts.length ? parts.join(' | ') : 'outputs mismatch', { danger: true });
        }
      } catch(e) {}

      tbl.appendChild(tbody);
      details.appendChild(tbl);
      left.appendChild(details);

      // (Per-step action buttons moved to title row.)

      item.appendChild(seq);
      item.appendChild(left);
      wrap.appendChild(item);
    });

    try {
      const lastIdx = Math.max(0, (Array.isArray(currentFlagAssignments) ? currentFlagAssignments.length : 0) - 1);
      const faLast = (Array.isArray(currentFlagAssignments) && currentFlagAssignments[lastIdx]) ? currentFlagAssignments[lastIdx] : null;
      const goalArtifacts = faLast && Array.isArray(faLast.produces) ? faLast.produces : [];
      const goalFields = faLast && Array.isArray(faLast.output_fields) ? faLast.output_fields : [];
      const goalOverride = normalizeFactsOverride(flowGoalFactsOverride);
      let goalHints = [];
      let goalInputs = [];
      try{
        const hlist = (faLast && Array.isArray(faLast.hints) && faLast.hints.length) ? faLast.hints : [];
        const h1 = (faLast && typeof faLast.hint === 'string') ? String(faLast.hint).trim() : '';
        goalHints = hlist.length ? hlist : (h1 ? [h1] : []);
        goalHints = goalHints.map(h => _applyHintNodeIps(h, _hintNodeIpMap));
        const ro = (faLast && typeof faLast.resolved_outputs === 'object' && faLast.resolved_outputs && !Array.isArray(faLast.resolved_outputs))
          ? faLast.resolved_outputs
          : null;
        const finalFeas = chainFeasibilityFinal(currentFlagAssignments);
        const goalArtifactsEffective = goalOverride ? goalOverride.artifacts : goalArtifacts;
        const goalFieldsEffective = goalOverride ? goalOverride.fields : goalFields;
        const reqArtifacts = Array.isArray(goalArtifactsEffective) ? goalArtifactsEffective.map(String).filter(Boolean) : [];
        const defFields = Array.isArray(goalFieldsEffective) ? goalFieldsEffective.map(String).filter(Boolean) : [];
        const providedArtifactsChain = (finalFeas && Array.isArray(finalFeas.providing_artifacts_chain)) ? finalFeas.providing_artifacts_chain.map(String).filter(Boolean) : [];
        const providedArtifactsSeq = (finalFeas && Array.isArray(finalFeas.providing_artifacts_sequencer)) ? finalFeas.providing_artifacts_sequencer.map(String).filter(Boolean) : [];
        const providedFieldsChain = (finalFeas && Array.isArray(finalFeas.providing_fields_chain)) ? finalFeas.providing_fields_chain.map(String).filter(Boolean) : [];
        const providedFieldsSeq = (finalFeas && Array.isArray(finalFeas.providing_fields_sequencer)) ? finalFeas.providing_fields_sequencer.map(String).filter(Boolean) : [];

        const goalSourceMap = buildGoalFactSourceMap(currentFlagAssignments);

        const rows = [];
        const reqArtifactSet = new Set(reqArtifacts);
        const provArtChainSet = new Set(providedArtifactsChain);
        const provArtSeqSet = new Set(providedArtifactsSeq);
        reqArtifacts.map(String).filter(Boolean).sort().forEach((name)=>{
          const n = String(name || '').trim();
          if(!n || isFlagFactName(n)) return;
          rows.push({
            name: n,
            kind: 'Artifact',
            resolved: ro ? ro[n] : undefined,
            fromChain: provArtChainSet.has(n),
            fromSeq: provArtSeqSet.has(n),
            missing: !(provArtChainSet.has(n) || provArtSeqSet.has(n)),
            required: reqArtifactSet.has(n),
          });
        });

        const fieldNameSet = new Set(defFields.map(String).filter(Boolean));
        try{
          if((!fieldNameSet.size) && ri && typeof ri === 'object' && !Array.isArray(ri)){
            Object.keys(ri).forEach(k => { if(String(k || '').trim()) fieldNameSet.add(String(k).trim()); });
          }
        } catch(e) {}
        const provFldChainSet = new Set(providedFieldsChain);
        const provFldSeqSet = new Set(providedFieldsSeq);
        Array.from(fieldNameSet).sort().forEach((name)=>{
          const n = String(name || '').trim();
          if(!n || isFlagFactName(n)) return;
          rows.push({
            name: n,
            kind: 'Field',
            resolved: ro ? ro[n] : undefined,
            fromChain: provFldChainSet.has(n),
            fromSeq: provFldSeqSet.has(n),
            missing: !(provFldChainSet.has(n) || provFldSeqSet.has(n)),
            required: true,
          });
        });
        goalInputs = rows.map((row)=>{
          const badge = goalFactBadgeFor(row && row.name, row, goalSourceMap);
          return Object.assign({}, row, { sourceBadge: badge });
        });
        // Do not reuse generator hints for Goal Facts.
        goalHints = [];
      } catch(e) { goalHints = []; }
      renderFactSummaryRow({
        seq: 'Goal',
        label: 'Goal Facts',
        inputs: goalInputs,
        inputsShowMissing: goalInputs.some(r => r && r.missing),
        artifacts: goalOverride ? goalOverride.artifacts : goalArtifacts,
        fields: goalOverride ? goalOverride.fields : goalFields,
        hideArtifactsFields: true,
        hints: goalHints,
        onValueOverride: () => openFactsDialog('goal'),
        holdKey: 'goal',
      });
    } catch(e) {}
  }

  function openNodeDetailsDialog(idx, opts){
    if(!nodeDetailsDialogEl || !nodeDetailsBodyEl) return;
    const i = Number.isFinite(+idx) ? (+idx) : -1;
    if(!Array.isArray(currentChain) || i < 0 || i >= currentChain.length) return;
    const node = currentChain[i] || {};
    const fa = (Array.isArray(currentFlagAssignments) && currentFlagAssignments[i]) ? currentFlagAssignments[i] : null;

    const seq = toRoman(i + 1);
    const nodeName = (node && node.name) ? String(node.name) : ('Node ' + (i + 1));
    if(nodeDetailsTitleEl) nodeDetailsTitleEl.textContent = (seq ? (seq + '. ') : '') + nodeName;

    nodeDetailsBodyEl.innerHTML = '';

    const tbl = document.createElement('table');
    tbl.className = 'table table-sm table-borderless mb-0';
    const tbody = document.createElement('tbody');

    function addRow(label, valueElOrText){
      const tr = document.createElement('tr');
      const tdL = document.createElement('td');
      tdL.className = 'text-muted';
      tdL.style.whiteSpace = 'nowrap';
      tdL.style.width = '1%';
      tdL.textContent = String(label || '').trim() ? (String(label).trim() + ':') : '';
      const tdV = document.createElement('td');
      if(valueElOrText && typeof valueElOrText === 'object' && valueElOrText.nodeType){
        tdV.appendChild(valueElOrText);
      } else {
        tdV.textContent = String(valueElOrText || '-');
      }
      tr.appendChild(tdL);
      tr.appendChild(tdV);
      tbody.appendChild(tr);
    }

    // Flag(s) assigned to this node (currently 1-per-chain-position).
    if(fa && (fa.id || fa.name)){
      const genId = fa && fa.id ? String(fa.id) : '-';
      const genName = fa && fa.name ? String(fa.name) : '-';
      const genType = (fa && fa.type) ? String(fa.type) : '';
      const genSource = (fa && fa.flag_generator) ? String(fa.flag_generator) : '';

      const flagEl = document.createElement('div');
      flagEl.className = 'd-flex flex-column';

      const line1 = document.createElement('div');
      line1.className = 'small';
      const typeLabel = document.createElement('span');
      typeLabel.className = 'text-muted';
      typeLabel.textContent = 'Type:';
      const typeVal = document.createElement('code');
      typeVal.className = 'ms-1';
      typeVal.textContent = genType || '-';
      line1.appendChild(typeLabel);
      line1.appendChild(typeVal);

      const sourceLabel = document.createElement('span');
      sourceLabel.className = 'text-muted ms-2';
      sourceLabel.textContent = 'Source:';
      const sourceVal = document.createElement('code');
      sourceVal.className = 'ms-1';
      sourceVal.textContent = genSource || '-';
      line1.appendChild(sourceLabel);
      line1.appendChild(sourceVal);

      const line2 = document.createElement('div');
      const idVal = document.createElement('code');
      idVal.textContent = genId || '-';
      line2.appendChild(idVal);
      if(genName && genName !== '-' && genName !== genId){
        const nameSpan = document.createElement('span');
        nameSpan.className = 'ms-2';
        nameSpan.textContent = genName;
        line2.appendChild(nameSpan);
      }

      flagEl.appendChild(line1);
      flagEl.appendChild(line2);
      addRow('Flag', flagEl);
    } else {
      addRow('Flag', '-');
    }

    tbl.appendChild(tbody);
    nodeDetailsBodyEl.appendChild(tbl);

    try{
      if(typeof nodeDetailsDialogEl.showModal === 'function'){
        nodeDetailsDialogEl.showModal();
      }
    } catch(e) {}
  }

  async function openInputsDialog(idx){
    if(!inputsDialogEl || !inputsBodyEl) return;
    const i = Number.isFinite(+idx) ? (+idx) : -1;
    if(!Array.isArray(currentChain) || i < 0 || i >= currentChain.length) return;
    const node = currentChain[i] || {};
    const fa = (Array.isArray(currentFlagAssignments) && currentFlagAssignments[i]) ? currentFlagAssignments[i] : null;

    // Best-effort: load generator catalogs so we can show input types and file pickers.
    let inputDefsByName = new Map();
    let generatorIdForDialog = '';
    try{
      generatorIdForDialog = (fa && fa.id) ? String(fa.id) : '';
    } catch(e) { generatorIdForDialog = ''; }
    try{
      await ensureGeneratorCatalogsLoaded();
      let catalog = '';
      try{ catalog = (fa && fa.generator_catalog) ? String(fa.generator_catalog) : ''; } catch(e) { catalog = ''; }
      const list = (catalog === 'flag_node_generators') ? _flagNodeGeneratorsCatalog : _flagGeneratorsCatalog;
      const gen = (Array.isArray(list) && generatorIdForDialog)
        ? list.find(g => String((g && g.id) || '').trim() === String(generatorIdForDialog).trim())
        : null;
      const inputs = (gen && Array.isArray(gen.inputs)) ? gen.inputs : [];
      inputs.forEach((inp)=>{
        try{
          if(!inp || typeof inp !== 'object') return;
          const nm = String(inp.name || '').trim();
          if(!nm) return;
          inputDefsByName.set(nm, inp);
        } catch(e) {}
      });
    } catch(e) {
      inputDefsByName = new Map();
    }

    function normalizeInputType(typeVal){
      const t0 = String(typeVal || '').trim().toLowerCase();
      if(!t0) return 'string';
      const t = t0;
      const isList = t.includes('list') || t.endsWith('[]');
      if(t === 'file_list' || t === 'files') return 'file_list';
      if(t === 'string_list' || t === 'strings') return 'string_list';
      if(isList && (t.includes('file') || t.includes('path'))) return 'file_list';
      if(isList && (t.includes('string') || t.includes('text') || t.includes('str'))) return 'string_list';
      if(t.endsWith('[]')) return 'string_list';
      if(t === 'file' || t === 'filepath' || t === 'file_path' || t === 'path' || t === 'pathname') return 'file';
      if(t.includes('file') || t.includes('path')) return 'file';
      if(t === 'string' || t === 'text' || t === 'str') return 'string';
      if(t === 'int' || t === 'integer') return 'int';
      if(t === 'float' || t === 'double') return 'float';
      if(t === 'number' || t === 'numeric') return 'number';
      if(t === 'bool' || t === 'boolean') return 'boolean';
      if(t === 'json' || t === 'object' || t === 'dict' || t === 'map') return 'json';
      return 'string';
    }

    function isFileType(typeVal){
      const t = normalizeInputType(typeVal);
      return (t === 'file' || t === 'file_list');
    }

    function isFileListType(typeVal){
      return normalizeInputType(typeVal) === 'file_list';
    }

    function isStringListType(typeVal){
      return normalizeInputType(typeVal) === 'string_list';
    }

    async function uploadFlowInputFile(fileObj, inputName){
      const scen = (scenarioEl && scenarioEl.value) ? String(scenarioEl.value).trim() : '';
      const fd = new FormData();
      fd.append('scenario', scen);
      fd.append('step_index', String(i));
      fd.append('generator_id', String(generatorIdForDialog || ''));
      fd.append('input_name', String(inputName || ''));
      fd.append('file', fileObj, (fileObj && fileObj.name) ? fileObj.name : 'upload');
      const resp = await fetch('/api/flag-sequencing/upload_flow_input_file', { method: 'POST', body: fd });
      let data = null;
      try { data = await resp.json(); } catch(e) { data = null; }
      if(!resp.ok || !data || !data.ok){
        const msg = (data && data.error) ? String(data.error) : `Upload failed (HTTP ${resp.status})`;
        throw new Error(msg);
      }
      return data;
    }

    // Editor state (scoped to this dialog open).
    let hintOverridesEnabled = false;
    let hintOverrideToggleEl = null;
    let hintOverrideInputs = [];
    let hintsTouched = false;
    let hadHintOverrideInitially = false;
    try { hadHintOverrideInitially = !!(fa && Array.isArray(fa.hint_overrides)); } catch(e) { hadHintOverrideInitially = false; }

    let flagOverrideEl = null;
    let flagTouched = false;
    let hadFlagOverrideInitially = false;
    try { hadFlagOverrideInitially = !!(fa && typeof fa.flag_override === 'string' && fa.flag_override.trim()); } catch(e) { hadFlagOverrideInitially = false; }

    // Value override editor state.
    let inputOverrideElsByKey = {};
    let outputOverrideElsByKey = {};
    let inputOverridesTouched = false;
    let outputOverridesTouched = false;

    // Inject files editor state.
    let injectOverridesEnabled = true;
    let injectOverrideToggleEl = null;
    let injectOverrideInputs = [];
    let injectsTouched = false;
    let hadInjectOverrideInitially = false;
    try { hadInjectOverrideInitially = !!(fa && Array.isArray(fa.inject_files_override)); } catch(e) { hadInjectOverrideInitially = false; }

    function renderVal(v){
      if(v === undefined) return '';
      if(v === null) return 'null';
      if(typeof v === 'string') return v;
      try { return JSON.stringify(v); } catch(e) { return String(v); }
    }

    function tryParseLooseJson(raw){
      const s = String(raw ?? '').trim();
      if(!s) return '';
      const looksJson = s.startsWith('{') || s.startsWith('[') || s.startsWith('"') || s === 'true' || s === 'false' || s === 'null' || /^-?\d+(?:\.\d+)?$/.test(s);
      if(!looksJson) return s;
      try { return JSON.parse(s); } catch(e) { return s; }
    }

    const seq = toRoman(i + 1);
    const nodeName = (node && node.name) ? String(node.name) : ('Node ' + (i + 1));
    if(inputsTitleEl) inputsTitleEl.textContent = 'Value Override — ' + (seq ? (seq + '. ') : '') + nodeName;

    inputsBodyEl.innerHTML = '';

    // Header summary (generator id/type/source).
    try{
      const genId = fa && fa.id ? String(fa.id) : '-';
      const genType = (fa && fa.type) ? String(fa.type) : '-';
      const genSource = (fa && fa.flag_generator) ? String(fa.flag_generator) : '-';
      const hdr = document.createElement('div');
      hdr.className = 'mb-2';
      const label = document.createElement('div');
      label.className = 'small text-muted';
      label.textContent = 'Generator';
      hdr.appendChild(label);

      const row = document.createElement('div');
      row.className = 'd-flex flex-wrap gap-2 align-items-center';
      const idCode = document.createElement('code');
      idCode.textContent = genId;
      row.appendChild(idCode);

      const typeLabel = document.createElement('span');
      typeLabel.className = 'text-muted small';
      typeLabel.textContent = 'type';
      row.appendChild(typeLabel);
      const typeCode = document.createElement('code');
      typeCode.textContent = genType;
      row.appendChild(typeCode);

      const srcLabel = document.createElement('span');
      srcLabel.className = 'text-muted small';
      srcLabel.textContent = 'source';
      row.appendChild(srcLabel);
      const srcCode = document.createElement('code');
      srcCode.textContent = genSource;
      row.appendChild(srcCode);

      hdr.appendChild(row);
      inputsBodyEl.appendChild(hdr);
    } catch(e) {}

    // Inputs/Outputs tabular (same model as Chain Order), using current chain feasibility.
    try{
      const feas = chainFeasibility(currentFlagAssignments);
      const step = (feas && feas[i]) ? feas[i] : null;

      const resolvedInputs = (fa && typeof fa.resolved_inputs === 'object' && fa.resolved_inputs && !Array.isArray(fa.resolved_inputs)) ? fa.resolved_inputs : null;
      const resolvedOutputs = (fa && typeof fa.resolved_outputs === 'object' && fa.resolved_outputs && !Array.isArray(fa.resolved_outputs)) ? fa.resolved_outputs : null;

      const reqArtifacts = (fa && Array.isArray(fa.requires)) ? fa.requires.map(String).filter(Boolean) : [];
      const providedArtifactsChain = (step && Array.isArray(step.providing_artifacts_chain)) ? step.providing_artifacts_chain.map(String).filter(Boolean) : [];
      const providedArtifactsSeq = (step && Array.isArray(step.providing_artifacts_sequencer)) ? step.providing_artifacts_sequencer.map(String).filter(Boolean) : [];
      const missingArtifacts = (step && Array.isArray(step.missing_artifacts)) ? step.missing_artifacts.map(String).filter(Boolean) : [];

      const inReq = (fa && Array.isArray(fa.input_fields_required)) ? fa.input_fields_required.map(String).filter(Boolean) : [];
      const inOpt = (fa && Array.isArray(fa.input_fields_optional)) ? fa.input_fields_optional.map(String).filter(Boolean) : [];
      const inAll = (fa && Array.isArray(fa.input_fields)) ? fa.input_fields.map(String).filter(Boolean) : [];

      const reqFields = inReq;
      const defFields = (inReq.length || inOpt.length) ? inReq.concat(inOpt) : inAll;

      const providedFieldsChain = (step && Array.isArray(step.providing_fields_chain)) ? step.providing_fields_chain.map(String).filter(Boolean) : [];
      const providedFieldsSeq = (step && Array.isArray(step.providing_fields_sequencer)) ? step.providing_fields_sequencer.map(String).filter(Boolean) : [];
      const missingFields = (step && Array.isArray(step.missing_fields)) ? step.missing_fields.map(String).filter(Boolean) : [];

      const outFields = (fa && Array.isArray(fa.output_fields)) ? fa.output_fields.map(String).filter(Boolean) : [];
      const outArtifacts = (fa && Array.isArray(fa.produces)) ? fa.produces.map(String).filter(Boolean) : [];

      const overridesIn0 = (fa && typeof fa.config_overrides === 'object' && fa.config_overrides && !Array.isArray(fa.config_overrides)) ? fa.config_overrides : null;
      const overridesOut0 = (fa && typeof fa.output_overrides === 'object' && fa.output_overrides && !Array.isArray(fa.output_overrides)) ? fa.output_overrides : null;

      // In the Value Override dialog we hide Artifact rows (they're not editable values),
      // so only show the Missing column when we have missing *fields* to display.
      const showMissingCol = (missingFields.length) > 0;

      function _stringifyAny(v){
        if(v === undefined) return '';
        if(v === null) return 'null';
        if(typeof v === 'string') return v;
        try { return JSON.stringify(v); } catch(e) { return String(v); }
      }

      function renderResolvedCell(kv, keysOrder, opts){
        const options = (opts && typeof opts === 'object') ? opts : {};
        const maxItems = Number.isFinite(+options.maxItems) ? (+options.maxItems) : 3;
        const maxLen = Number.isFinite(+options.maxLen) ? (+options.maxLen) : 60;
        const maxDetailItems = Number.isFinite(+options.maxDetailItems) ? (+options.maxDetailItems) : 25;

        const obj = (kv && typeof kv === 'object' && !Array.isArray(kv)) ? kv : null;
        if(!obj || !Object.keys(obj).length) return document.createTextNode('-');

        let keys = Array.isArray(keysOrder) && keysOrder.length
          ? keysOrder.map(x => String(x || '').trim()).filter(Boolean)
          : Object.keys(obj);

        try {
          if(Object.prototype.hasOwnProperty.call(obj, 'flag')){
            keys = ['flag'].concat(keys.filter(k => k !== 'flag'));
          }
        } catch(e) {}

        const seen = new Set();
        const pairs = [];
        for(const k of keys){
          const kk = String(k || '').trim();
          if(!kk || seen.has(kk)) continue;
          seen.add(kk);
          if(!(kk in obj)) continue;
          const v = obj[kk];
          if(v === undefined) continue;
          const full = _stringifyAny(v);
          let short = full;
          if(typeof short === 'string' && short.length > maxLen){
            short = short.slice(0, Math.max(0, maxLen - 1)) + '…';
          }
          pairs.push({ k: kk, full, short });
        }

        if(!pairs.length) return document.createTextNode('-');

        // If there's only one value, render it inline unless it's "complex" (object/array/truncated).
        if(pairs.length === 1){
          const p = pairs[0];
          let isComplex = false;
          try{
            const raw = obj[p.k];
            if(raw && typeof raw === 'object') isComplex = true;
          } catch(e) {}
          try{
            if(typeof p.full === 'string' && typeof p.short === 'string' && p.full !== p.short) isComplex = true;
          } catch(e) {}
          try{
            if(typeof p.full === 'string' && p.full.includes('\n')) isComplex = true;
          } catch(e) {}
          if(!isComplex){
            const code = document.createElement('code');
            code.className = 'font-monospace';
            code.title = p.full;
            code.textContent = p.short;
            return code;
          }
          const details = document.createElement('details');
          details.className = 'small';
          const summary = document.createElement('summary');
          summary.style.cursor = 'pointer';
          summary.className = 'text-decoration-none';
          const code = document.createElement('code');
          code.className = 'font-monospace';
          code.title = p.full;
          code.textContent = p.short;
          summary.appendChild(code);
          details.appendChild(summary);
          const body = document.createElement('div');
          body.className = 'mt-1';
          const vcode = document.createElement('code');
          vcode.className = 'font-monospace';
          vcode.style.whiteSpace = 'pre-wrap';
          vcode.textContent = p.full;
          body.appendChild(vcode);
          details.appendChild(body);
          return details;
        }

        const details = document.createElement('details');
        details.className = 'small';
        const summary = document.createElement('summary');
        summary.style.cursor = 'pointer';
        summary.className = 'text-decoration-none';

        const summaryWrap = document.createElement('span');
        summaryWrap.className = 'd-inline-flex flex-wrap gap-1 align-items-center';

        const head = pairs.slice(0, Math.max(1, maxItems));
        head.forEach(p => {
          const code = document.createElement('code');
          code.className = 'font-monospace';
          code.title = p.full;
          code.textContent = p.k + ': ' + p.short;
          summaryWrap.appendChild(code);
        });
        if(pairs.length > head.length){
          const more = document.createElement('span');
          more.className = 'text-muted';
          more.textContent = `(+${pairs.length - head.length})`;
          summaryWrap.appendChild(more);
        }
        summary.appendChild(summaryWrap);
        details.appendChild(summary);

        const body = document.createElement('div');
        body.className = 'mt-1';
        const list = document.createElement('div');
        list.className = 'd-flex flex-column gap-1';
        pairs.slice(0, maxDetailItems).forEach(p => {
          const row = document.createElement('div');
          const kcode = document.createElement('code');
          kcode.className = 'me-1 text-muted';
          kcode.textContent = p.k;
          const vcode = document.createElement('code');
          vcode.className = 'font-monospace';
          vcode.style.whiteSpace = 'pre-wrap';
          vcode.textContent = p.full;
          row.appendChild(kcode);
          row.appendChild(document.createTextNode(': '));
          row.appendChild(vcode);
          list.appendChild(row);
        });
        if(pairs.length > maxDetailItems){
          const moreLine = document.createElement('div');
          moreLine.className = 'text-muted';
          moreLine.textContent = `(+${pairs.length - maxDetailItems} more not shown)`;
          list.appendChild(moreLine);
        }
        body.appendChild(list);
        details.appendChild(body);
        return details;
      }

      function renderBoolCheckbox(checked, title){
        const wrap = document.createElement('div');
        wrap.className = 'form-check mb-0';
        const cb = document.createElement('input');
        cb.type = 'checkbox';
        cb.className = 'form-check-input';
        cb.disabled = true;
        cb.checked = !!checked;
        if(title) cb.title = String(title);
        wrap.appendChild(cb);
        return wrap;
      }

      function renderVarName(name, required){
        const span = document.createElement('span');
        span.style.whiteSpace = 'nowrap';
        const code = document.createElement('code');
        code.className = 'font-monospace';
        code.textContent = String(name || '').trim() || '-';
        span.appendChild(code);
        if(required){
          const star = document.createElement('span');
          star.className = 'text-danger ms-1';
          star.textContent = '*';
          span.appendChild(star);
        }
        return span;
      }

      function renderResolvedValueForKey(resolvedKv, key){
        const k = String(key || '').trim();
        if(!k || !resolvedKv || typeof resolvedKv !== 'object' || Array.isArray(resolvedKv)) return document.createTextNode('-');
        if(!(k in resolvedKv)) return document.createTextNode('-');
        const obj = {};
        obj[k] = resolvedKv[k];
        return renderResolvedCell(obj, [k], { maxItems: 1, maxLen: 72, maxDetailItems: 25 });
      }

      function placeholderFromResolved(resolvedKv, key, opts){
        const options = (opts && typeof opts === 'object') ? opts : {};
        const maxLen = Number.isFinite(+options.maxLen) ? (+options.maxLen) : 80;
        const k = String(key || '').trim();
        if(!k || !resolvedKv || typeof resolvedKv !== 'object' || Array.isArray(resolvedKv)) return '';
        if(!(k in resolvedKv)) return '';
        let v = resolvedKv[k];
        if(v === undefined || v === null) return '';
        if(Array.isArray(v)){
          if(!v.length) return '';
          v = v[0];
        }
        let s = '';
        if(typeof v === 'string') s = v;
        else {
          try { s = JSON.stringify(v); } catch(e) { s = String(v); }
        }
        s = String(s || '').trim();
        if(!s) return '';
        if(s.length > maxLen) s = s.slice(0, Math.max(0, maxLen - 1)) + '…';
        return s;
      }

      // For outputs, show what is *required by downstream steps* (subset of this step's defined outputs).
      const synthesizedFields = ['seed','secret','env_name','challenge','flag_prefix','username_prefix','key_len','node_name'];
      const synthesizedSet = new Set(synthesizedFields);
      const downstreamReqArtifacts = new Set();
      const downstreamReqFields = new Set();
      try{
        for(let j = i + 1; j < (Array.isArray(currentFlagAssignments) ? currentFlagAssignments.length : 0); j++){
          const a2 = currentFlagAssignments[j] || {};
          const reqArtRaw = Array.isArray(a2.requires) ? a2.requires.map(String).filter(Boolean) : [];
          reqArtRaw.filter(k => k && !synthesizedSet.has(k)).forEach(k => downstreamReqArtifacts.add(k));

          const reqFld = Array.isArray(a2.input_fields_required)
            ? a2.input_fields_required.map(String).filter(Boolean)
            : (Array.isArray(a2.input_fields) ? a2.input_fields.map(String).filter(Boolean) : []);
          reqFld.forEach(k => downstreamReqFields.add(k));
        }
      } catch(e) {}
      const outArtifactsReq = outArtifacts.filter(k => downstreamReqArtifacts.has(k));
      const outFieldsReq = outFields.filter(k => downstreamReqFields.has(k));

      function buildIoTable(mode){
        const isInputs = mode === 'inputs';

        const tbl = document.createElement('table');
        tbl.className = 'table table-sm mb-0';

        const thead = document.createElement('thead');
        if(isInputs){
          thead.innerHTML = showMissingCol
            ? '<tr class="text-secondary"><th style="width: 1%; white-space: nowrap;">Variable</th><th style="width: 1%; white-space: nowrap;">Type</th><th>Resolved</th><th>Override</th><th style="width: 1%; white-space: nowrap;">From Chain</th><th style="width: 1%; white-space: nowrap;">From Sequencer</th><th style="width: 1%; white-space: nowrap;">Missing</th></tr>'
            : '<tr class="text-secondary"><th style="width: 1%; white-space: nowrap;">Variable</th><th style="width: 1%; white-space: nowrap;">Type</th><th>Resolved</th><th>Override</th><th style="width: 1%; white-space: nowrap;">From Chain</th><th style="width: 1%; white-space: nowrap;">From Sequencer</th></tr>';
        } else {
          thead.innerHTML = '<tr class="text-secondary"><th style="width: 1%; white-space: nowrap;">Variable</th><th style="width: 1%; white-space: nowrap;">Type</th><th>Resolved</th><th>Override</th><th style="width: 1%; white-space: nowrap;">To Chain</th></tr>';
        }
        tbl.appendChild(thead);

        const tbody2 = document.createElement('tbody');

        function addRowVar(v){
          const tr = document.createElement('tr');

          const tdVar = document.createElement('td');
          tdVar.appendChild(renderVarName(v.name, v.required));

          const tdType = document.createElement('td');
          tdType.className = 'text-muted';
          tdType.style.whiteSpace = 'nowrap';
          let typeLabel = v.kind;
          try{
            if(isInputs && v.kind === 'Field'){
              const def = inputDefsByName.get(v.name);
              if(def && def.type) typeLabel = normalizeInputType(def.type);
            }
          } catch(e) {}
          tdType.textContent = typeLabel;

          const tdRes = document.createElement('td');
          tdRes.className = 'small';
          if(v.kind === 'Field'){
            tdRes.appendChild(renderResolvedValueForKey(isInputs ? resolvedInputs : resolvedOutputs, v.name));
          } else {
            tdRes.textContent = '-';
          }

          const tdOvr = document.createElement('td');
          if(v.kind === 'Field'){
            const inp = document.createElement('input');
            inp.type = 'text';
            inp.className = 'form-control form-control-sm font-monospace';
            const ph = placeholderFromResolved(isInputs ? resolvedInputs : resolvedOutputs, v.name);
            if(ph) inp.placeholder = ph;

            // Inputs can be typed; outputs remain free-form.
            let inputType = 'string';
            if(isInputs){
              try{
                const def = inputDefsByName.get(v.name);
                inputType = def ? normalizeInputType(def.type) : 'string';
              } catch(e) { inputType = 'string'; }
            }

            if(isInputs){
              inp.value = (overridesIn0 && (v.name in overridesIn0)) ? renderVal(overridesIn0[v.name]) : '';
              inp.addEventListener('input', ()=>{ inputOverridesTouched = true; });
              inputOverrideElsByKey[v.name] = inp;
            } else {
              inp.value = (overridesOut0 && (v.name in overridesOut0)) ? renderVal(overridesOut0[v.name]) : '';
              inp.addEventListener('input', ()=>{ outputOverridesTouched = true; });
              outputOverrideElsByKey[v.name] = inp;
            }

            let wantsFileUi = false;
            let wantsFileListUi = false;
            let wantsStringListUi = false;
            try{
              if(isInputs){
                wantsFileUi = (inputType === 'file');
                wantsFileListUi = (inputType === 'file_list');
                wantsStringListUi = (inputType === 'string_list');
              }
            } catch(e) {
              wantsFileUi = false;
              wantsFileListUi = false;
              wantsStringListUi = false;
            }

            if(wantsFileListUi || wantsStringListUi){
              // Render list editor + store canonical JSON array in a hidden input.
              const hidden = document.createElement('input');
              hidden.type = 'hidden';
              hidden.value = '';
              inputOverrideElsByKey[v.name] = hidden;

              const wrap = document.createElement('div');
              wrap.className = 'd-flex flex-column gap-2';

              const stack = document.createElement('div');
              stack.className = 'd-flex flex-column gap-2';

              const addBtn = document.createElement('button');
              addBtn.type = 'button';
              addBtn.className = 'btn btn-sm btn-outline-primary align-self-start';
              addBtn.textContent = wantsFileListUi ? 'Add file' : 'Add value';

              function syncHidden(){
                const vals = [];
                try{
                  const rows = stack.querySelectorAll('input[type="text"]');
                  rows.forEach((el)=>{
                    const s = String((el && el.value) ?? '').trim();
                    if(!s) return;
                    vals.push(s);
                  });
                } catch(e) {}
                hidden.value = vals.length ? JSON.stringify(vals) : '';
              }

              function addRow(initial){
                const row = document.createElement('div');
                row.className = 'd-flex align-items-center gap-2';

                const txt = document.createElement('input');
                txt.type = 'text';
                txt.className = 'form-control form-control-sm font-monospace';
                const rowPh = placeholderFromResolved(resolvedInputs, v.name);
                if(rowPh) txt.placeholder = rowPh;
                txt.value = String(initial || '');
                txt.addEventListener('input', ()=>{ inputOverridesTouched = true; syncHidden(); });

                const del = document.createElement('button');
                del.type = 'button';
                del.className = 'btn btn-sm btn-outline-danger';
                del.textContent = 'Remove';
                del.addEventListener('click', ()=>{
                  inputOverridesTouched = true;
                  try { row.remove(); } catch(e) {}
                  syncHidden();
                });

                row.appendChild(txt);

                if(wantsFileListUi){
                  const btn = document.createElement('button');
                  btn.type = 'button';
                  btn.className = 'btn btn-sm btn-outline-primary';
                  btn.textContent = 'Choose File';

                  const fileEl = document.createElement('input');
                  fileEl.type = 'file';
                  fileEl.className = 'd-none';

                  btn.addEventListener('click', ()=>{ try { fileEl.click(); } catch(e) {} });
                  fileEl.addEventListener('change', async ()=>{
                    const fileObj = (fileEl.files && fileEl.files.length) ? fileEl.files[0] : null;
                    if(!fileObj) return;
                    btn.disabled = true;
                    const prevText = btn.textContent;
                    btn.textContent = 'Uploading…';
                    try{
                      const up = await uploadFlowInputFile(fileObj, v.name);
                      txt.value = String(up.stored_path || '');
                      inputOverridesTouched = true;
                      syncHidden();
                    } catch(err){
                      alert(String((err && err.message) || err || 'Upload failed'));
                    } finally {
                      btn.disabled = false;
                      btn.textContent = prevText;
                      try { fileEl.value = ''; } catch(e) {}
                    }
                  });

                  row.appendChild(btn);
                  row.appendChild(fileEl);
                }

                row.appendChild(del);
                stack.appendChild(row);
              }

              addBtn.addEventListener('click', ()=>{ inputOverridesTouched = true; addRow(''); syncHidden(); });

              // Initialize from existing override value.
              let initialVals = [];
              try{
                const existing = (overridesIn0 && (v.name in overridesIn0)) ? overridesIn0[v.name] : null;
                if(Array.isArray(existing)){
                  initialVals = existing.map(x => String(x ?? '')).filter(x => x.trim());
                } else if(typeof existing === 'string'){
                  const parsed = tryParseLooseJson(existing);
                  if(Array.isArray(parsed)) initialVals = parsed.map(x => String(x ?? '')).filter(x => x.trim());
                }
              } catch(e) { initialVals = []; }

              (initialVals.length ? initialVals : ['']).forEach(addRow);
              syncHidden();

              wrap.appendChild(stack);
              wrap.appendChild(addBtn);
              wrap.appendChild(hidden);
              tdOvr.appendChild(wrap);
            }
            else if(wantsFileUi){
              const wrap = document.createElement('div');
              wrap.className = 'd-flex align-items-center gap-2';

              const btn = document.createElement('button');
              btn.type = 'button';
              btn.className = 'btn btn-sm btn-outline-primary';
              btn.textContent = 'Choose File';

              const fileEl = document.createElement('input');
              fileEl.type = 'file';
              fileEl.className = 'd-none';

              btn.addEventListener('click', ()=>{ try { fileEl.click(); } catch(e) {} });

              fileEl.addEventListener('change', async ()=>{
                const fileObj = (fileEl.files && fileEl.files.length) ? fileEl.files[0] : null;
                if(!fileObj) return;
                btn.disabled = true;
                const prevText = btn.textContent;
                btn.textContent = 'Uploading…';
                try{
                  const up = await uploadFlowInputFile(fileObj, v.name);
                  inp.value = String(up.stored_path || '');
                  inputOverridesTouched = true;
                } catch(err){
                  alert(String((err && err.message) || err || 'Upload failed'));
                } finally {
                  btn.disabled = false;
                  btn.textContent = prevText;
                  try { fileEl.value = ''; } catch(e) {}
                }
              });

              wrap.appendChild(inp);
              wrap.appendChild(btn);
              wrap.appendChild(fileEl);
              tdOvr.appendChild(wrap);
            } else {
              tdOvr.appendChild(inp);
            }
          } else {
            tdOvr.className = 'text-muted small';
            tdOvr.textContent = '-';
          }

          tr.appendChild(tdVar);
          tr.appendChild(tdType);
          tr.appendChild(tdRes);
          tr.appendChild(tdOvr);

          if(isInputs){
            const tdFromChain = document.createElement('td');
            tdFromChain.appendChild(renderBoolCheckbox(v.fromChain, 'Provided by chain'));
            const tdFromSeq = document.createElement('td');
            tdFromSeq.appendChild(renderBoolCheckbox(v.fromSeq, 'Provided by sequencer (synthesized)'));
            tr.appendChild(tdFromChain);
            tr.appendChild(tdFromSeq);
            if(showMissingCol){
              const tdMiss = document.createElement('td');
              if(v.missing) tdMiss.classList.add('text-danger');
              tdMiss.appendChild(renderBoolCheckbox(v.missing, v.missing ? 'Missing' : 'Not missing'));
              tr.appendChild(tdMiss);
            }
          } else {
            const tdToChain = document.createElement('td');
            tdToChain.appendChild(renderBoolCheckbox(v.toChain, 'Provided to chain'));
            tr.appendChild(tdToChain);
          }

          tbody2.appendChild(tr);
        }

        const reqArtifactSet = new Set(reqArtifacts);
        const reqFieldSet = new Set(reqFields);
        const defArtifactSet = new Set(reqArtifacts);
        const defFieldSet = new Set(defFields);

        const provArtChainSet = new Set(providedArtifactsChain);
        const provArtSeqSet = new Set(providedArtifactsSeq);
        const missArtSet = new Set(missingArtifacts);

        const provFldChainSet = new Set(providedFieldsChain);
        const provFldSeqSet = new Set(providedFieldsSeq);
        const missFldSet = new Set(missingFields);

        if(isInputs){
          const rows = [];

          const fieldNameSet = new Set(Array.from(defFieldSet));
          try{
            if((!fieldNameSet.size) && resolvedInputs && typeof resolvedInputs === 'object' && !Array.isArray(resolvedInputs)){
              Object.keys(resolvedInputs).forEach(k => { if(String(k || '').trim()) fieldNameSet.add(String(k).trim()); });
            }
          } catch(e) {}
          try{
            if(Array.isArray(synthesizedFields) && synthesizedFields.length && resolvedInputs){
              synthesizedFields.forEach(k => {
                const kk = String(k || '').trim();
                if(!kk) return;
                try{
                  if(resolvedInputs && typeof resolvedInputs === 'object' && !Array.isArray(resolvedInputs) && (kk in resolvedInputs)){
                    fieldNameSet.add(kk);
                  }
                } catch(e) {}
              });
            }
          } catch(e) {}

          Array.from(fieldNameSet).sort().forEach((name) => {
            const n = String(name || '').trim();
            if(!n) return;
            rows.push({
              name: n,
              kind: 'Field',
              required: reqFieldSet.has(n),
              fromChain: provFldChainSet.has(n),
              fromSeq: provFldSeqSet.has(n),
              missing: missFldSet.has(n),
            });
          });
          rows.forEach(addRowVar);
        } else {
          const reqOutFieldSet = new Set(outFieldsReq);
          const rows = [];

          const outFieldNameSet = new Set(outFields.map(String).filter(Boolean).map(s => String(s).trim()).filter(Boolean));
          try{
            if((!outFieldNameSet.size) && resolvedOutputs && typeof resolvedOutputs === 'object' && !Array.isArray(resolvedOutputs)){
              Object.keys(resolvedOutputs).forEach(k => { if(String(k || '').trim()) outFieldNameSet.add(String(k).trim()); });
            }
          } catch(e) {}

          Array.from(outFieldNameSet).sort().forEach((name) => {
            const n = String(name || '').trim();
            if(!n) return;
            rows.push({
              name: n,
              kind: 'Field',
              required: reqOutFieldSet.has(n),
              toChain: true,
            });
          });
          rows.forEach(addRowVar);
        }

        tbl.appendChild(tbody2);
        return tbl;
      }

      const ioOuter = document.createElement('div');
      ioOuter.className = 'mt-2';

      const ioHelp = document.createElement('div');
      ioHelp.className = 'small text-muted';
      ioHelp.textContent = 'Inputs/Outputs view for this step. Resolved values appear after Generate (with hint resolution) or Execute.';
      ioOuter.appendChild(ioHelp);

      const tabBar = document.createElement('div');
      tabBar.className = 'd-flex align-items-center gap-2 mt-2';

      const btnInputs = document.createElement('button');
      btnInputs.type = 'button';
      btnInputs.className = 'btn btn-sm btn-primary';
      btnInputs.textContent = 'Inputs';

      const btnOutputs = document.createElement('button');
      btnOutputs.type = 'button';
      btnOutputs.className = 'btn btn-sm btn-outline-primary';
      btnOutputs.textContent = 'Outputs';

      const btnInjects = document.createElement('button');
      btnInjects.type = 'button';
      btnInjects.className = 'btn btn-sm btn-outline-primary';
      btnInjects.textContent = 'Injects';

      tabBar.appendChild(btnInputs);
      tabBar.appendChild(btnOutputs);
      tabBar.appendChild(btnInjects);
      ioOuter.appendChild(tabBar);

      const inputsPane = document.createElement('div');
      const outputsPane = document.createElement('div');
      const injectsPane = document.createElement('div');
      inputsPane.className = 'mt-2';
      outputsPane.className = 'mt-2';
      injectsPane.className = 'mt-2';
      inputsPane.appendChild(buildIoTable('inputs'));
      outputsPane.appendChild(buildIoTable('outputs'));

      // Inject files editor (override list; may be empty).
      try{
        const injWrap = document.createElement('div');
        injWrap.className = 'border rounded p-2 mt-2';

        const injHdr = document.createElement('div');
        injHdr.className = 'fw-semibold';
        injHdr.textContent = 'Inject files';
        injWrap.appendChild(injHdr);

        const injHelp = document.createElement('div');
        injHelp.className = 'small text-muted';
        injHelp.textContent = 'Override the list of files the generator may inject. Variable can be a path or an output key (e.g., File(path)). Optionally set a destination directory; default is /tmp.';
        injWrap.appendChild(injHelp);

        const injHelp2 = document.createElement('div');
        injHelp2.className = 'small text-muted';
        injHelp2.textContent = 'Example: variable=File(path), dest=/opt/bin (saved as File(path) -> /opt/bin).';
        injWrap.appendChild(injHelp2);

        const toggleRow = document.createElement('div');
        toggleRow.className = 'd-flex align-items-center justify-content-between gap-2 mt-2';
        const resetBtn = document.createElement('button');
        resetBtn.type = 'button';
        resetBtn.className = 'btn btn-sm btn-outline-secondary';
        resetBtn.textContent = 'Reset to generator';

        toggleRow.appendChild(resetBtn);
        injWrap.appendChild(toggleRow);

        const listWrap = document.createElement('div');
        listWrap.className = 'border rounded p-2 mt-2';
        injWrap.appendChild(listWrap);

        function normalizeInjects(list){
          const out = [];
          try{
            (Array.isArray(list) ? list : []).forEach((x)=>{
              const s = String(x ?? '').trim();
              if(!s) return;
              out.push(s);
            });
          } catch(e) {}
          return out;
        }

        function splitInjectSpec(text){
          const raw = String(text ?? '').trim();
          if(!raw) return { src: '', dest: '' };
          const seps = ['->', '=>'];
          for(const sep of seps){
            const idx = raw.indexOf(sep);
            if(idx >= 0){
              const left = raw.slice(0, idx).trim();
              const right = raw.slice(idx + sep.length).trim();
              return { src: left, dest: right };
            }
          }
          return { src: raw, dest: '' };
        }

        function basenameFromPath(p){
          const s = String(p || '').replace('\\', '/');
          const parts = s.split('/').filter(Boolean);
          return parts.length ? parts[parts.length - 1] : s;
        }

        function getGeneratedInjectsFromAssignment(){
          const cur = (fa && Array.isArray(fa.inject_files) && fa.inject_files.length) ? normalizeInjects(fa.inject_files) : [];
          return cur;
        }

        function getOverrideInjectsFromAssignment(){
          if(fa && Array.isArray(fa.inject_files_override)){
            const vals = normalizeInjects(fa.inject_files_override);
            return vals.length ? vals : null;
          }
          return null;
        }

        function renderInjectList(files){
          injectOverrideInputs = [];
          listWrap.innerHTML = '';

          const stack = document.createElement('div');
          stack.className = 'd-flex flex-column gap-2';

          const header = document.createElement('div');
          header.className = 'd-grid gap-2 align-items-center small text-muted';
          header.style.gridTemplateColumns = '1fr 1fr 160px 260px 90px';
          const h1 = document.createElement('div');
          h1.textContent = 'Variable';
          const h2 = document.createElement('div');
          h2.textContent = 'Resolved';
          const h3 = document.createElement('div');
          h3.textContent = 'Destination dir';
          const h4 = document.createElement('div');
          h4.textContent = '';
          const h5 = document.createElement('div');
          h5.textContent = '';
          header.appendChild(h1);
          header.appendChild(h2);
          header.appendChild(h3);
          header.appendChild(h4);
          header.appendChild(h5);
          stack.appendChild(header);

          const availableInputs = Array.isArray(inAll) ? inAll.map(String).filter(Boolean) : [];
          const availableOutputs = Array.isArray(outFields) ? outFields.map(String).filter(Boolean) : [];
          let availableResolvedOutputs = [];
          try{
            if(resolvedOutputs && typeof resolvedOutputs === 'object' && !Array.isArray(resolvedOutputs)){
              availableResolvedOutputs = Object.keys(resolvedOutputs || {}).map(String).filter(Boolean);
            }
          } catch(e) { availableResolvedOutputs = []; }

          function resolvedTargetsFor(srcKey){
            if(!resolvedOutputs || typeof resolvedOutputs !== 'object' || Array.isArray(resolvedOutputs)) return [];
            const k = String(srcKey || '').trim();
            if(!k || !(k in resolvedOutputs)) return [];
            const v = resolvedOutputs[k];
            if(Array.isArray(v)){
              return v.map(x => String(x ?? '')).filter(x => x.trim());
            }
            if(typeof v === 'string') return [v.trim()].filter(Boolean);
            return [];
          }

          function buildVarPicker(){
            const sel = document.createElement('select');
            sel.className = 'form-select form-select-sm font-monospace';
            const empty = document.createElement('option');
            empty.value = '';
            empty.textContent = 'Pick input/output…';
            sel.appendChild(empty);

            function addGroup(label, items){
              if(!items || !items.length) return;
              const grp = document.createElement('optgroup');
              grp.label = label;
              items.forEach((k)=>{
                const opt = document.createElement('option');
                opt.value = k;
                opt.textContent = k;
                grp.appendChild(opt);
              });
              sel.appendChild(grp);
            }

            addGroup('Inputs', Array.from(new Set(availableInputs)));
            addGroup('Outputs', Array.from(new Set(availableOutputs)));
            addGroup('Resolved outputs', Array.from(new Set(availableResolvedOutputs)));
            return sel;
          }

          function addRow(value){
            const parsed = splitInjectSpec(value);
            const row = document.createElement('div');
            row.className = 'd-grid gap-2 align-items-center';
            row.style.gridTemplateColumns = '1fr 1fr 160px 260px 90px';

            const srcInp = document.createElement('input');
            srcInp.type = 'text';
            srcInp.className = 'form-control form-control-sm font-monospace';
            srcInp.placeholder = 'e.g., hint.txt or File(path)';
            {
              const rawSrc = String(parsed.src ?? '');
              if(rawSrc.startsWith('upload:')){
                const base = basenameFromPath(rawSrc.slice('upload:'.length));
                srcInp.dataset.uploadToken = rawSrc;
                srcInp.value = base ? `artifacts/${base}` : '';
              } else {
                srcInp.value = rawSrc;
              }
            }
            srcInp.addEventListener('input', ()=>{
              injectsTouched = true;
              try { delete srcInp.dataset.uploadToken; } catch(e) {}
              try { refreshResolvedHint(); } catch(e) {}
            });

            const destInp = document.createElement('input');
            destInp.type = 'text';
            destInp.className = 'form-control form-control-sm font-monospace';
            destInp.placeholder = '/tmp (default)';
            destInp.value = String(parsed.dest ?? '');
            destInp.addEventListener('input', ()=>{ injectsTouched = true; });

            const picker = buildVarPicker();
            picker.addEventListener('change', ()=>{
              const v = String(picker.value || '').trim();
              if(!v) return;
              srcInp.value = v;
              injectsTouched = true;
              try { delete srcInp.dataset.uploadToken; } catch(e) {}
              try { picker.value = ''; } catch(e) {}
              try { refreshResolvedHint(); } catch(e) {}
            });

            const uploadBtn = document.createElement('button');
            uploadBtn.type = 'button';
            uploadBtn.className = 'btn btn-sm btn-outline-primary';
            uploadBtn.textContent = 'Upload';

            const uploadInput = document.createElement('input');
            uploadInput.type = 'file';
            uploadInput.className = 'd-none';

            uploadBtn.addEventListener('click', ()=>{ try { uploadInput.click(); } catch(e) {} });
            uploadInput.addEventListener('change', async ()=>{
              const fileObj = (uploadInput.files && uploadInput.files.length) ? uploadInput.files[0] : null;
              if(!fileObj) return;
              uploadBtn.disabled = true;
              const prev = uploadBtn.textContent;
              uploadBtn.textContent = 'Uploading…';
              try{
                const scen = (scenarioEl && scenarioEl.value) ? String(scenarioEl.value).trim() : '';
                const fd = new FormData();
                fd.append('scenario', scen);
                fd.append('step_index', String(i));
                fd.append('generator_id', String(generatorIdForDialog || ''));
                fd.append('file', fileObj, (fileObj && fileObj.name) ? fileObj.name : 'upload');
                const resp = await fetch('/api/flag-sequencing/upload_flow_inject_file', { method: 'POST', body: fd });
                let data = null;
                try { data = await resp.json(); } catch(e) { data = null; }
                if(!resp.ok || !data || !data.ok){
                  const msg = (data && data.error) ? String(data.error) : `Upload failed (HTTP ${resp.status})`;
                  throw new Error(msg);
                }
                try { srcInp.dataset.uploadToken = String(data.inject_value || data.stored_path || ''); } catch(e) {}
                const base = basenameFromPath(String(data.stored_filename || ''));
                srcInp.value = base ? `artifacts/${base}` : String(data.stored_filename || data.original_filename || '') || 'artifacts/upload';
                injectsTouched = true;
                try { refreshResolvedHint(); } catch(e) {}
              } catch(err){
                alert(String((err && err.message) || err || 'Upload failed'));
              } finally {
                uploadBtn.disabled = false;
                uploadBtn.textContent = prev;
                try { uploadInput.value = ''; } catch(e) {}
              }
            });

            const rowObj = { srcEl: srcInp, destEl: destInp };

            const del = document.createElement('button');
            del.type = 'button';
            del.className = 'btn btn-sm btn-outline-danger';
            del.textContent = 'Remove';
            del.addEventListener('click', ()=>{
              try { row.remove(); } catch(e) {}
              injectOverrideInputs = injectOverrideInputs.filter(x => x !== rowObj);
              injectsTouched = true;
            });

            injectOverrideInputs.push(rowObj);
            const pickWrap = document.createElement('div');
            pickWrap.className = 'd-flex align-items-center gap-2';
            pickWrap.appendChild(picker);
            pickWrap.appendChild(uploadBtn);
            pickWrap.appendChild(uploadInput);

            const resolvedHint = document.createElement('div');
            resolvedHint.className = 'small text-muted';
            resolvedHint.textContent = '-';

            function refreshResolvedHint(){
              let key = String((srcInp && srcInp.value) ?? '').trim();
              try{
                if(srcInp && srcInp.dataset && srcInp.dataset.uploadToken){
                  key = String(srcInp.dataset.uploadToken || '').trim() || key;
                }
              } catch(e) {}
              const targets = resolvedTargetsFor(key);
              if(!targets.length){
                resolvedHint.textContent = '-';
                resolvedHint.classList.add('text-muted');
                return;
              }
              const head = targets.slice(0, 3);
              const more = targets.length > head.length ? ` (+${targets.length - head.length})` : '';
              resolvedHint.textContent = `${head.join(', ')}${more}`;
              resolvedHint.classList.remove('text-muted');
            }

            try { refreshResolvedHint(); } catch(e) {}

            row.appendChild(srcInp);
            row.appendChild(resolvedHint);
            row.appendChild(destInp);
            row.appendChild(pickWrap);
            row.appendChild(del);
            stack.appendChild(row);
          }

          (Array.isArray(files) ? files : []).forEach(addRow);

          const addBtn = document.createElement('button');
          addBtn.type = 'button';
          addBtn.className = 'btn btn-sm btn-outline-primary';
          addBtn.textContent = 'Add inject file';
          addBtn.addEventListener('click', ()=>{ injectsTouched = true; addRow(''); });

          listWrap.appendChild(stack);
          listWrap.appendChild(addBtn);
        }

        const existingOverride = getOverrideInjectsFromAssignment();
        if(existingOverride !== null){
          renderInjectList(existingOverride);
        } else {
          renderInjectList(getGeneratedInjectsFromAssignment());
        }

        resetBtn.addEventListener('click', ()=>{
          injectsTouched = true;
          renderInjectList(getGeneratedInjectsFromAssignment());
        });

        injectsPane.appendChild(injWrap);
      } catch(e) {}

      outputsPane.style.display = 'none';
      injectsPane.style.display = 'none';

      function setTab(which){
        const showInputs = which === 'inputs';
        const showOutputs = which === 'outputs';
        const showInjects = which === 'injects';
        inputsPane.style.display = showInputs ? '' : 'none';
        outputsPane.style.display = showOutputs ? '' : 'none';
        injectsPane.style.display = showInjects ? '' : 'none';
        btnInputs.className = showInputs ? 'btn btn-sm btn-primary' : 'btn btn-sm btn-outline-primary';
        btnOutputs.className = showOutputs ? 'btn btn-sm btn-primary' : 'btn btn-sm btn-outline-primary';
        btnInjects.className = showInjects ? 'btn btn-sm btn-primary' : 'btn btn-sm btn-outline-primary';
      }
      btnInputs.addEventListener('click', () => setTab('inputs'));
      btnOutputs.addEventListener('click', () => setTab('outputs'));
      btnInjects.addEventListener('click', () => setTab('injects'));

      ioOuter.appendChild(inputsPane);
      ioOuter.appendChild(outputsPane);
      ioOuter.appendChild(injectsPane);

      inputsBodyEl.appendChild(ioOuter);
    } catch(e) {
      // Non-fatal
    }

    // FLAG + Hints editing (persisted overrides).
    try{
      const section = document.createElement('div');
      section.className = 'border rounded p-2 mt-3';

      const hdr = document.createElement('div');
      hdr.className = 'fw-semibold';
      hdr.textContent = 'FLAG + Hints';
      section.appendChild(hdr);

      const help = document.createElement('div');
      help.className = 'small text-muted';
      help.textContent = 'Override the flag value and/or hints for this step. Leave FLAG blank to use generated output.';
      section.appendChild(help);

      // FLAG override input.
      {
        const row = document.createElement('div');
        row.className = 'mt-2';

        const label = document.createElement('div');
        label.className = 'small text-muted';
        label.textContent = 'FLAG';
        row.appendChild(label);

        const inp = document.createElement('input');
        inp.type = 'text';
        inp.className = 'form-control form-control-sm font-monospace';
        inp.placeholder = 'leave blank to use generated';
        inp.value = (fa && typeof fa.flag_override === 'string') ? String(fa.flag_override || '') : '';
        inp.addEventListener('input', ()=>{ flagTouched = true; });
        flagOverrideEl = inp;
        row.appendChild(inp);

        section.appendChild(row);
      }

      // Hints editor (override / generated).
      {
        const div = document.createElement('div');
        div.className = 'mt-3';

        const hintsHdr = document.createElement('div');
        hintsHdr.className = 'fw-semibold';
        hintsHdr.textContent = 'Hints';
        div.appendChild(hintsHdr);

        const hintsHelp = document.createElement('div');
        hintsHelp.className = 'small text-muted';
        hintsHelp.textContent = 'Override the displayed hints for this step. Must have at least one hint when overriding.';
        div.appendChild(hintsHelp);

        const toggleRow = document.createElement('div');
        toggleRow.className = 'd-flex align-items-center justify-content-between gap-2 mt-2';

        const toggleWrap = document.createElement('div');
        toggleWrap.className = 'form-check';
        hintOverrideToggleEl = document.createElement('input');
        hintOverrideToggleEl.type = 'checkbox';
        hintOverrideToggleEl.className = 'form-check-input';
        hintOverrideToggleEl.id = 'flowHintOverrideToggle_inputs_' + i;
        const toggleLabel = document.createElement('label');
        toggleLabel.className = 'form-check-label';
        toggleLabel.setAttribute('for', hintOverrideToggleEl.id);
        toggleLabel.textContent = 'Override hints';
        toggleWrap.appendChild(hintOverrideToggleEl);
        toggleWrap.appendChild(toggleLabel);

        const resetBtn = document.createElement('button');
        resetBtn.type = 'button';
        resetBtn.className = 'btn btn-sm btn-outline-secondary';
        resetBtn.textContent = 'Reset to generated';

        toggleRow.appendChild(toggleWrap);
        toggleRow.appendChild(resetBtn);
        div.appendChild(toggleRow);

        const listWrap = document.createElement('div');
        listWrap.className = 'border rounded p-2 mt-2';
        div.appendChild(listWrap);

        function normalizeHints(list){
          const out = [];
          try {
            (Array.isArray(list) ? list : []).forEach((x)=>{
              const s = String(x ?? '').trim();
              if(!s) return;
              out.push(s);
            });
          } catch(e) {}
          return out;
        }

        function getGeneratedHintsFromAssignment(){
          const cur = (fa && Array.isArray(fa.hints) && fa.hints.length) ? normalizeHints(fa.hints) : [];
          if(cur.length) return cur;
          const h = (fa && fa.hint) ? String(fa.hint || '').trim() : '';
          return h ? [h] : [];
        }

        function getOverrideHintsFromAssignment(){
          if(fa && Array.isArray(fa.hint_overrides)) return normalizeHints(fa.hint_overrides);
          return null;
        }

        function renderHintList(hints){
          hintOverrideInputs = [];
          listWrap.innerHTML = '';

          const stack = document.createElement('div');
          stack.className = 'd-flex flex-column gap-2';

          function syncRemoveDisabled(){
            const onlyOne = (hintOverrideInputs.length <= 1);
            try {
              Array.from(stack.querySelectorAll('button[data-role="remove-hint"]')).forEach((btn)=>{
                btn.disabled = onlyOne;
              });
            } catch(e) {}
          }

          function addRow(value){
            const row = document.createElement('div');
            row.className = 'd-flex gap-2 align-items-center';

            const inp = document.createElement('input');
            inp.type = 'text';
            inp.className = 'form-control form-control-sm';
            inp.placeholder = 'Hint text…';
            inp.value = String(value ?? '');
            inp.addEventListener('input', ()=>{ hintsTouched = true; });

            const del = document.createElement('button');
            del.type = 'button';
            del.className = 'btn btn-sm btn-outline-danger';
            del.textContent = 'Remove';
            del.setAttribute('data-role', 'remove-hint');
            del.addEventListener('click', ()=>{
              if(hintOverrideInputs.length <= 1) return;
              try { row.remove(); } catch(e) {}
              hintOverrideInputs = hintOverrideInputs.filter(x => x !== inp);
              hintsTouched = true;
              syncRemoveDisabled();
            });

            hintOverrideInputs.push(inp);
            row.appendChild(inp);
            row.appendChild(del);
            stack.appendChild(row);
            syncRemoveDisabled();
          }

          (Array.isArray(hints) && hints.length ? hints : ['']).forEach(addRow);

          const addBtn = document.createElement('button');
          addBtn.type = 'button';
          addBtn.className = 'btn btn-sm btn-outline-primary';
          addBtn.textContent = 'Add hint';
          addBtn.addEventListener('click', ()=>{ hintsTouched = true; addRow(''); });

          listWrap.appendChild(stack);
          listWrap.appendChild(addBtn);
        }

        function setHintOverrideEnabled(enabled){
          hintOverridesEnabled = !!enabled;
          try { if(hintOverrideToggleEl) hintOverrideToggleEl.checked = hintOverridesEnabled; } catch(e) {}
          try { listWrap.style.display = hintOverridesEnabled ? '' : 'none'; } catch(e) {}
          try { resetBtn.disabled = !hintOverridesEnabled; } catch(e) {}
        }

        const existingOverride = getOverrideHintsFromAssignment();
        if(existingOverride !== null){
          renderHintList(existingOverride);
          setHintOverrideEnabled(true);
        } else {
          renderHintList(getGeneratedHintsFromAssignment());
          setHintOverrideEnabled(false);
        }

        hintOverrideToggleEl.addEventListener('change', ()=>{
          hintsTouched = true;
          setHintOverrideEnabled(!!hintOverrideToggleEl.checked);
        });

        resetBtn.addEventListener('click', ()=>{
          hintsTouched = true;
          setHintOverrideEnabled(false);
          renderHintList(getGeneratedHintsFromAssignment());
        });

        section.appendChild(div);
      }

      inputsBodyEl.appendChild(section);
    } catch(e) {
      // Non-fatal
    }

    // Save / Clear overrides (single place).
    try{
      const box = document.createElement('div');
      box.className = 'border rounded p-2 mt-3';

      const help = document.createElement('div');
      help.className = 'small text-muted';
      help.textContent = 'Edits persist into Execute and Save.';
      box.appendChild(help);

      const actions = document.createElement('div');
      actions.className = 'd-flex justify-content-end gap-2 mt-2';
      const clearBtn = document.createElement('button');
      clearBtn.type = 'button';
      clearBtn.className = 'btn btn-sm btn-outline-secondary';
      clearBtn.textContent = 'Clear overrides';
      const saveBtn = document.createElement('button');
      saveBtn.type = 'button';
      saveBtn.className = 'btn btn-sm btn-primary';
      saveBtn.textContent = 'Save overrides';
      actions.appendChild(clearBtn);
      actions.appendChild(saveBtn);
      box.appendChild(actions);

      const localStatus = document.createElement('div');
      localStatus.className = 'small text-muted mt-2';
      localStatus.textContent = '';
      box.appendChild(localStatus);

      function setLocalStatus(msg, isError){
        localStatus.textContent = String(msg || '');
        localStatus.classList.toggle('text-danger', !!isError);
        localStatus.classList.toggle('text-muted', !isError);
        try { localStatus.style.display = msg ? '' : 'none'; } catch(e) {}
      }

      async function persistOverridesForIndex(){
        if(!Array.isArray(currentChain) || !currentChain.length) throw new Error('Generate a chain first.');
        const scenario = (scenarioEl && scenarioEl.value || '').trim();
        if(!scenario) throw new Error('No scenario selected.');
        const chain_ids = currentChain.map(n => (n && n.id) ? String(n.id) : '').filter(Boolean);
        if(!chain_ids.length) throw new Error('Missing chain ids.');

        let stepFlagOverride = undefined;
        const reqAssignments = chain_ids.map((nid, j)=>{
          const curA = (Array.isArray(currentFlagAssignments) && currentFlagAssignments[j]) ? currentFlagAssignments[j] : {};
          const curId = String((curA && (curA.id || curA.generator_id)) || '').trim();

          let resolvedInputs = (curA && typeof curA.resolved_inputs === 'object' && curA.resolved_inputs && !Array.isArray(curA.resolved_inputs))
            ? curA.resolved_inputs
            : undefined;
          let resolvedOutputs = (curA && typeof curA.resolved_outputs === 'object' && curA.resolved_outputs && !Array.isArray(curA.resolved_outputs))
            ? curA.resolved_outputs
            : undefined;
          let resolvedFlag = (curA && typeof curA.flag_value === 'string' && curA.flag_value.trim())
            ? String(curA.flag_value).trim()
            : undefined;

          let ovr = (curA && typeof curA.config_overrides === 'object' && curA.config_overrides && !Array.isArray(curA.config_overrides))
            ? curA.config_overrides
            : undefined;

          let outOvr = (curA && typeof curA.output_overrides === 'object' && curA.output_overrides && !Array.isArray(curA.output_overrides))
            ? curA.output_overrides
            : undefined;

          let injOvr = (curA && Array.isArray(curA.inject_files_override))
            ? curA.inject_files_override
            : undefined;

          let hintOvr = undefined;
          try {
            if(curA && Array.isArray(curA.hint_overrides)) hintOvr = curA.hint_overrides;
          } catch(e) {}

          let flagOvr = undefined;
          try {
            if(curA && typeof curA.flag_override === 'string' && curA.flag_override.trim()) flagOvr = String(curA.flag_override).trim();
          } catch(e) {}

          if(j === i){
            // Inputs overrides from IO table.
            const newOverrides = {};
            for(const k of Object.keys(inputOverrideElsByKey || {})){
              const el = inputOverrideElsByKey[k];
              const raw = (el && el.value !== undefined) ? String(el.value) : '';
              const trimmed = raw.trim();
              if(!trimmed) continue;
              newOverrides[k] = tryParseLooseJson(trimmed);
            }
            ovr = newOverrides;

            if(Object.keys(newOverrides).length){
              resolvedInputs = Object.assign({}, (resolvedInputs || {}), newOverrides);
            }

            // Outputs overrides from IO table.
            const newOutOverrides = {};
            for(const k of Object.keys(outputOverrideElsByKey || {})){
              const el = outputOverrideElsByKey[k];
              const raw = (el && el.value !== undefined) ? String(el.value) : '';
              const trimmed = raw.trim();
              if(!trimmed) continue;
              newOutOverrides[k] = tryParseLooseJson(trimmed);
            }
            outOvr = newOutOverrides;

            if(Object.keys(newOutOverrides).length){
              resolvedOutputs = Object.assign({}, (resolvedOutputs || {}), newOutOverrides);
            }

            // Inject override list.
            {
              const files = [];
              try {
                (injectOverrideInputs || []).forEach((el)=>{
                  const srcEl = el && el.srcEl ? el.srcEl : el;
                  const destEl = el && el.destEl ? el.destEl : null;
                  let src = String((srcEl && srcEl.value) ?? '').trim();
                  try{
                    if(srcEl && srcEl.dataset && srcEl.dataset.uploadToken){
                      src = String(srcEl.dataset.uploadToken || '').trim();
                    }
                  } catch(e) {}
                  if(!src) return;
                  const dest = String((destEl && destEl.value) ?? '').trim();
                  if(dest){
                    files.push(`${src} -> ${dest}`);
                  } else {
                    files.push(src);
                  }
                });
              } catch(e) {}
              injOvr = files;
            }

            // Hint overrides from this dialog.
            if(hintOverrideToggleEl){
              if(hintOverridesEnabled){
                const texts = [];
                try {
                  (hintOverrideInputs || []).forEach((el)=>{
                    const s = String((el && el.value) ?? '').trim();
                    if(!s) return;
                    texts.push(s);
                  });
                } catch(e) {}
                if(!texts.length){
                  throw new Error('Hints override is enabled, but there are no non-empty hints. Add at least one hint.');
                }
                hintOvr = texts;
              } else {
                if(hadHintOverrideInitially || hintsTouched){
                  hintOvr = null;
                } else {
                  hintOvr = undefined;
                }
              }
            }

            // FLAG override from this dialog.
            if(flagOverrideEl){
              const s = String((flagOverrideEl.value ?? '')).trim();
              if(s){
                flagOvr = s;
              } else {
                if(hadFlagOverrideInitially || flagTouched){
                  flagOvr = null;
                } else {
                  flagOvr = undefined;
                }
              }
            }
            stepFlagOverride = flagOvr;
            if(stepFlagOverride !== undefined){
              if(stepFlagOverride === null){
                resolvedFlag = undefined;
              } else if(typeof stepFlagOverride === 'string' && stepFlagOverride.trim()){
                resolvedFlag = stepFlagOverride.trim();
                resolvedOutputs = Object.assign({}, (resolvedOutputs || {}), { 'Flag(flag_id)': resolvedFlag });
              }
            }
          }

          const out = { node_id: nid, id: curId, config_overrides: ovr, output_overrides: outOvr, inject_files_override: injOvr };
          if(hintOvr !== undefined) out.hint_overrides = hintOvr;
          if(flagOvr !== undefined) out.flag_override = flagOvr;
          if(resolvedInputs !== undefined) out.resolved_inputs = resolvedInputs;
          if(resolvedOutputs !== undefined) out.resolved_outputs = resolvedOutputs;
          if(resolvedFlag !== undefined) out.flag_value = resolvedFlag;
          return out;
        });
        const missing = reqAssignments.find(x => !x.id);
        if(missing) throw new Error('Some chain positions have no generator assignment yet. Try Generate again.');

        const prevResolved = Array.isArray(currentFlagAssignments)
          ? currentFlagAssignments.map(a => ({
              resolved_inputs: a && a.resolved_inputs,
              resolved_outputs: a && a.resolved_outputs,
              flag_value: a && a.flag_value,
            }))
          : [];

        showLoading('Saving overrides…');
        const res = await postJson('/api/flag-sequencing/save_flow_substitutions', {
          scenario: activeScenario,
          chain_ids: chain_ids,
          preview_plan: previewPlanForRequest(),
          flag_assignments: reqAssignments,
          allow_node_duplicates: !!allowNodeDuplicates,
          initial_facts: flowInitialFactsOverride,
          goal_facts: flowGoalFactsOverride,
        }, { timeoutMs: 60000 });
        setFlowValidityFromPayload(res);
        if(res && Array.isArray(res.chain)) currentChain = res.chain.slice();
        if(res && Array.isArray(res.flag_assignments)){
          const next = res.flag_assignments.slice();
          try{
            next.forEach((a, idx) => {
              if(!a || typeof a !== 'object') return;
              const prev = prevResolved[idx];
              if(!prev || typeof prev !== 'object') return;
              if(a.resolved_inputs === undefined && prev.resolved_inputs !== undefined){
                a.resolved_inputs = prev.resolved_inputs;
              }
              if(a.resolved_outputs === undefined && prev.resolved_outputs !== undefined){
                a.resolved_outputs = prev.resolved_outputs;
              }
              if(a.flag_value === undefined && prev.flag_value !== undefined){
                a.flag_value = prev.flag_value;
              }
            });
          } catch(e) {}
          try{
            const idx = i;
            const cur = next[idx];
            if(cur && typeof cur === 'object'){
              if(cur.config_overrides && typeof cur.config_overrides === 'object'){
                cur.resolved_inputs = Object.assign({}, (cur.resolved_inputs || {}), cur.config_overrides);
              }
              if(cur.output_overrides && typeof cur.output_overrides === 'object'){
                cur.resolved_outputs = Object.assign({}, (cur.resolved_outputs || {}), cur.output_overrides);
              }
              if(stepFlagOverride !== undefined){
                if(stepFlagOverride === null){
                  cur.flag_override = null;
                  cur.flag_value = undefined;
                } else if(typeof stepFlagOverride === 'string' && stepFlagOverride.trim()){
                  cur.flag_override = stepFlagOverride.trim();
                  cur.flag_value = stepFlagOverride.trim();
                  cur.resolved_outputs = Object.assign({}, (cur.resolved_outputs || {}), { 'Flag(flag_id)': stepFlagOverride.trim() });
                }
              } else if(cur.flag_override && typeof cur.flag_override === 'string' && cur.flag_override.trim()){
                cur.flag_value = cur.flag_override.trim();
                cur.resolved_outputs = Object.assign({}, (cur.resolved_outputs || {}), { 'Flag(flag_id)': cur.flag_override.trim() });
              }
            }
          } catch(e) {}
          currentFlagAssignments = next;
        }
        // flow_plan_path no longer used
        try { persistFlowState(); } catch(e) {}
        updateMeta();
        renderChainEditor();
        return res;
      }

      clearBtn.addEventListener('click', async ()=>{
        try { clearBtn.disabled = true; saveBtn.disabled = true; } catch(e) {}
        try {
          if(!Array.isArray(currentFlagAssignments) || !currentFlagAssignments[i]) throw new Error('No assignment for this step.');
          currentFlagAssignments[i].config_overrides = {};
          currentFlagAssignments[i].output_overrides = {};
          try { currentFlagAssignments[i].inject_files_override = null; } catch(e) {}
          try { currentFlagAssignments[i].hint_overrides = null; } catch(e) {}
          try { currentFlagAssignments[i].flag_override = null; } catch(e) {}

          // Clear UI fields.
          for(const k of Object.keys(inputOverrideElsByKey || {})){
            try { inputOverrideElsByKey[k].value = ''; } catch(e) {}
          }
          for(const k of Object.keys(outputOverrideElsByKey || {})){
            try { outputOverrideElsByKey[k].value = ''; } catch(e) {}
          }
          try { if(flagOverrideEl) flagOverrideEl.value = ''; } catch(e) {}
          try { if(injectOverrideToggleEl) injectOverrideToggleEl.checked = false; } catch(e) {}
          injectOverridesEnabled = false;

          await persistOverridesForIndex();
          setLocalStatus('Overrides cleared.', false);
        } catch(e) {
          setLocalStatus('Failed to clear overrides: ' + String(e && e.message || e), true);
        } finally {
          hideLoading();
          try { clearBtn.disabled = false; saveBtn.disabled = false; } catch(e) {}
        }
      });

      saveBtn.addEventListener('click', async ()=>{
        try { clearBtn.disabled = true; saveBtn.disabled = true; } catch(e) {}
        try {
          if(!Array.isArray(currentFlagAssignments) || !currentFlagAssignments[i]) throw new Error('No assignment for this step.');
          await persistOverridesForIndex();
          setLocalStatus('Edits saved.', false);
          try {
            if(inputsDialogEl && typeof inputsDialogEl.close === 'function') inputsDialogEl.close();
          } catch(e) {}
          try {
            const prev = saveBtn.textContent;
            saveBtn.textContent = 'Saved';
            setTimeout(()=>{ try { saveBtn.textContent = prev; } catch(e) {} }, 1200);
          } catch(e) {}
        } catch(e) {
          setLocalStatus('Failed to save overrides: ' + String(e && e.message || e), true);
          try { console.error(e); } catch(err) {}
        } finally {
          hideLoading();
          try { clearBtn.disabled = false; saveBtn.disabled = false; } catch(e) {}
        }
      });

      inputsBodyEl.appendChild(box);
    } catch(e) {
      // Non-fatal
    }

    try{
      if(typeof inputsDialogEl.showModal === 'function') inputsDialogEl.showModal();
    } catch(e) {}
  }

  async function openFactsDialog(kind){
    if(!inputsDialogEl || !inputsBodyEl) return;
    const k = (String(kind || '').toLowerCase() === 'goal') ? 'goal' : 'initial';
    const title = (k === 'goal') ? 'Value Override — Goal Facts' : 'Value Override — Initial Facts';
    if(inputsTitleEl) inputsTitleEl.textContent = title;
    inputsBodyEl.innerHTML = '';

    const cur = (k === 'goal') ? flowGoalFactsOverride : flowInitialFactsOverride;
    const curArts = cur && Array.isArray(cur.artifacts) ? cur.artifacts : [];
    const curFields = cur && Array.isArray(cur.fields) ? cur.fields : [];
    const overrideArtifacts = new Set(curArts.map(x => String(x || '').trim()).filter(Boolean));
    const overrideFields = new Set(curFields.map(x => String(x || '').trim()).filter(Boolean));
    const overrideArtifactMap = {};
    const overrideFieldMap = {};
    let extraArtifactOverrides = [];
    let extraFieldOverrides = [];

    function mergeOverrideList(primary, extras){
      const out = [];
      const seen = new Set();
      (primary || []).forEach((v)=>{
        const s = String(v || '').trim();
        if(!s || seen.has(s)) return;
        seen.add(s);
        out.push(s);
      });
      (extras || []).forEach((v)=>{
        const s = String(v || '').trim();
        if(!s || seen.has(s)) return;
        seen.add(s);
        out.push(s);
      });
      return out;
    }

    function currentOverrideLists(){
      const artVals = Object.values(overrideArtifactMap).map(v => String(v || '').trim()).filter(Boolean);
      const fieldVals = Object.values(overrideFieldMap).map(v => String(v || '').trim()).filter(Boolean);
      return {
        artifacts: mergeOverrideList(artVals, extraArtifactOverrides).filter(x => !isFlagFactName(x)),
        fields: mergeOverrideList(fieldVals, extraFieldOverrides).filter(x => !isFlagFactName(x)),
      };
    }

    const wrap = document.createElement('div');
    wrap.className = 'd-flex flex-column gap-3';

    function renderResolvedInline(val){
      let resolvedText = '';
      try{
        if(Array.isArray(val)){
          resolvedText = val.map(x => (x === null || x === undefined) ? '' : String(x)).filter(Boolean).join(', ');
        } else if(val && typeof val === 'object'){
          resolvedText = JSON.stringify(val);
        } else if(val !== undefined && val !== null) {
          resolvedText = String(val);
        }
      } catch(e) { resolvedText = ''; }
      if(!resolvedText) return document.createTextNode('-');
      const vcode = document.createElement('code');
      vcode.className = 'font-monospace';
      vcode.textContent = resolvedText;
      return vcode;
    }

    function renderBoolCheckbox(checked){
      const wrap = document.createElement('div');
      wrap.className = 'form-check mb-0';
      const cb = document.createElement('input');
      cb.type = 'checkbox';
      cb.className = 'form-check-input';
      cb.disabled = true;
      cb.checked = !!checked;
      wrap.appendChild(cb);
      return wrap;
    }

    function buildInputsTable(rows, showMissing){
      const tbl = document.createElement('table');
      tbl.className = 'table table-sm mb-0';
      const thead = document.createElement('thead');
      thead.innerHTML = showMissing
        ? '<tr class="text-secondary"><th style="width: 1%; white-space: nowrap;">Variable</th><th style="width: 1%; white-space: nowrap;">Type</th><th>Resolved</th><th>Override</th><th style="width: 1%; white-space: nowrap;">From Chain</th><th style="width: 1%; white-space: nowrap;">From Sequencer</th><th style="width: 1%; white-space: nowrap;">Missing</th></tr>'
        : '<tr class="text-secondary"><th style="width: 1%; white-space: nowrap;">Variable</th><th style="width: 1%; white-space: nowrap;">Type</th><th>Resolved</th><th>Override</th><th style="width: 1%; white-space: nowrap;">From Chain</th><th style="width: 1%; white-space: nowrap;">From Sequencer</th></tr>';
      tbl.appendChild(thead);
      const tbody = document.createElement('tbody');
      (rows || []).forEach((row)=>{
        if(!row || !row.name) return;
        const tr = document.createElement('tr');
        const tdVar = document.createElement('td');
        const code = document.createElement('code');
        code.className = 'font-monospace';
        code.textContent = String(row.name || '-');
        tdVar.appendChild(code);
        const tdType = document.createElement('td');
        tdType.className = 'text-muted';
        tdType.style.whiteSpace = 'nowrap';
        tdType.textContent = String(row.kind || 'Field');
        const tdRes = document.createElement('td');
        tdRes.className = 'small';
        tdRes.appendChild(renderResolvedInline(row.resolved));
        const tdOvr = document.createElement('td');
        const ovrInput = document.createElement('input');
        ovrInput.type = 'text';
        ovrInput.className = 'form-control form-control-sm font-monospace';
        ovrInput.value = row.overrideValue || '';
        if(k === 'goal') ovrInput.disabled = true;
        ovrInput.addEventListener('input', ()=>{
          const val = String(ovrInput.value || '').trim();
          if(String(row.kind || '') === 'Artifact'){
            if(val) overrideArtifactMap[row.name] = val;
            else delete overrideArtifactMap[row.name];
          } else {
            if(val) overrideFieldMap[row.name] = val;
            else delete overrideFieldMap[row.name];
          }
          // no-op
        });
        tdOvr.appendChild(ovrInput);
        const tdFromChain = document.createElement('td');
        tdFromChain.appendChild(renderBoolCheckbox(row.fromChain));
        const tdFromSeq = document.createElement('td');
        tdFromSeq.appendChild(renderBoolCheckbox(row.fromSeq));
        tr.appendChild(tdVar);
        tr.appendChild(tdType);
        tr.appendChild(tdRes);
        tr.appendChild(tdOvr);
        tr.appendChild(tdFromChain);
        tr.appendChild(tdFromSeq);
        if(showMissing){
          const tdMiss = document.createElement('td');
          if(row.missing) tdMiss.classList.add('text-danger');
          tdMiss.appendChild(renderBoolCheckbox(row.missing));
          tr.appendChild(tdMiss);
        }
        tbody.appendChild(tr);
      });
      tbl.appendChild(tbody);
      return tbl;
    }

    function buildOutputsTable(rows){
      const tbl = document.createElement('table');
      tbl.className = 'table table-sm mb-0';
      const thead = document.createElement('thead');
      thead.innerHTML = '<tr class="text-secondary"><th style="width: 1%; white-space: nowrap;">Variable</th><th style="width: 1%; white-space: nowrap;">Type</th><th>Resolved</th><th>Override</th><th style="width: 1%; white-space: nowrap;">To Chain</th></tr>';
      tbl.appendChild(thead);
      const tbody = document.createElement('tbody');
      (rows || []).forEach((row)=>{
        if(!row || !row.name) return;
        const tr = document.createElement('tr');
        const tdVar = document.createElement('td');
        const code = document.createElement('code');
        code.className = 'font-monospace';
        code.textContent = String(row.name || '-');
        tdVar.appendChild(code);
        const tdType = document.createElement('td');
        tdType.className = 'text-muted';
        tdType.style.whiteSpace = 'nowrap';
        tdType.textContent = String(row.kind || 'Field');
        const tdRes = document.createElement('td');
        tdRes.className = 'small';
        tdRes.appendChild(renderResolvedInline(row.resolved));
        const tdOvr = document.createElement('td');
        const ovrInput = document.createElement('input');
        ovrInput.type = 'text';
        ovrInput.className = 'form-control form-control-sm font-monospace';
        ovrInput.value = row.overrideValue || '';
        if(k === 'goal') ovrInput.disabled = true;
        ovrInput.addEventListener('input', ()=>{
          const val = String(ovrInput.value || '').trim();
          if(val) overrideFieldMap[row.name] = val;
          else delete overrideFieldMap[row.name];
          // no-op
        });
        tdOvr.appendChild(ovrInput);
        const tdToChain = document.createElement('td');
        tdToChain.appendChild(renderBoolCheckbox(row.toChain));
        tr.appendChild(tdVar);
        tr.appendChild(tdType);
        tr.appendChild(tdRes);
        tr.appendChild(tdOvr);
        tr.appendChild(tdToChain);
        tbody.appendChild(tr);
      });
      tbl.appendChild(tbody);
      return tbl;
    }

    try{
      const ioOuter = document.createElement('div');
      ioOuter.className = 'mt-2';
      const tabBar = document.createElement('div');
      tabBar.className = 'd-flex align-items-center gap-2 mt-2';

      const btnInputs = document.createElement('button');
      btnInputs.type = 'button';
      btnInputs.className = (k === 'goal') ? 'btn btn-sm btn-primary' : 'btn btn-sm btn-outline-primary';
      btnInputs.textContent = 'Inputs';
      btnInputs.disabled = (k !== 'goal');

      const btnOutputs = document.createElement('button');
      btnOutputs.type = 'button';
      btnOutputs.className = (k === 'goal') ? 'btn btn-sm btn-outline-primary' : 'btn btn-sm btn-primary';
      btnOutputs.textContent = 'Outputs';
      btnOutputs.disabled = (k === 'goal');

      tabBar.appendChild(btnInputs);
      tabBar.appendChild(btnOutputs);
      ioOuter.appendChild(tabBar);

      const pane = document.createElement('div');
      pane.className = 'mt-2';

      if(k === 'goal'){
        const lastIdx = Math.max(0, (Array.isArray(currentFlagAssignments) ? currentFlagAssignments.length : 0) - 1);
        const faLast = (Array.isArray(currentFlagAssignments) && currentFlagAssignments[lastIdx]) ? currentFlagAssignments[lastIdx] : null;
        const feas = chainFeasibility(currentFlagAssignments);
        const stepGoal = (feas && feas[lastIdx]) ? feas[lastIdx] : null;
        const ri = (faLast && typeof faLast.resolved_inputs === 'object' && faLast.resolved_inputs && !Array.isArray(faLast.resolved_inputs))
          ? faLast.resolved_inputs
          : null;
        const reqArtifacts = (faLast && Array.isArray(faLast.requires)) ? faLast.requires.map(String).filter(Boolean) : [];
        const inReq = (faLast && Array.isArray(faLast.input_fields_required)) ? faLast.input_fields_required.map(String).filter(Boolean) : [];
        const inOpt = (faLast && Array.isArray(faLast.input_fields_optional)) ? faLast.input_fields_optional.map(String).filter(Boolean) : [];
        const inAll = (faLast && Array.isArray(faLast.input_fields)) ? faLast.input_fields.map(String).filter(Boolean) : [];
        const defFields = (inReq.length || inOpt.length) ? inReq.concat(inOpt) : inAll;
        const providedArtifactsChain = (stepGoal && Array.isArray(stepGoal.providing_artifacts_chain)) ? stepGoal.providing_artifacts_chain.map(String).filter(Boolean) : [];
        const providedArtifactsSeq = (stepGoal && Array.isArray(stepGoal.providing_artifacts_sequencer)) ? stepGoal.providing_artifacts_sequencer.map(String).filter(Boolean) : [];
        const missingArtifacts = (stepGoal && Array.isArray(stepGoal.missing_artifacts)) ? stepGoal.missing_artifacts.map(String).filter(Boolean) : [];
        const providedFieldsChain = (stepGoal && Array.isArray(stepGoal.providing_fields_chain)) ? stepGoal.providing_fields_chain.map(String).filter(Boolean) : [];
        const providedFieldsSeq = (stepGoal && Array.isArray(stepGoal.providing_fields_sequencer)) ? stepGoal.providing_fields_sequencer.map(String).filter(Boolean) : [];
        const missingFields = (stepGoal && Array.isArray(stepGoal.missing_fields)) ? stepGoal.missing_fields.map(String).filter(Boolean) : [];

        const rows = [];
        const reqArtifactSet = new Set(reqArtifacts);
        const provArtChainSet = new Set(providedArtifactsChain);
        const provArtSeqSet = new Set(providedArtifactsSeq);
        const missArtSet = new Set(missingArtifacts);
        const artifactNameSet = new Set();
        reqArtifacts.map(String).filter(Boolean).sort().forEach((name)=>{
          const n = String(name || '').trim();
          if(!n || isFlagFactName(n)) return;
          artifactNameSet.add(n);
          rows.push({
            name: n,
            resolved: ri ? ri[n] : undefined,
            fromChain: provArtChainSet.has(n),
            fromSeq: provArtSeqSet.has(n),
            missing: missArtSet.has(n),
            required: reqArtifactSet.has(n),
            kind: 'Artifact',
            overrideValue: overrideArtifacts.has(n) ? n : '',
          });
        });

        const fieldNameSet = new Set(defFields.map(String).filter(Boolean));
        try{
          if((!fieldNameSet.size) && ri && typeof ri === 'object' && !Array.isArray(ri)){
            Object.keys(ri).forEach(k0 => { if(String(k0 || '').trim()) fieldNameSet.add(String(k0).trim()); });
          }
        } catch(e) {}
        const reqFieldSet = new Set(inReq.map(String).filter(Boolean));
        const provFldChainSet = new Set(providedFieldsChain);
        const provFldSeqSet = new Set(providedFieldsSeq);
        const missFldSet = new Set(missingFields);
        Array.from(fieldNameSet).sort().forEach((name)=>{
          const n = String(name || '').trim();
          if(!n || isFlagFactName(n)) return;
          rows.push({
            name: n,
            resolved: ri ? ri[n] : undefined,
            fromChain: provFldChainSet.has(n),
            fromSeq: provFldSeqSet.has(n),
            missing: missFldSet.has(n),
            required: reqFieldSet.has(n),
            kind: 'Field',
            overrideValue: overrideFields.has(n) ? n : '',
          });
        });
        try{
          const artSet = new Set(Array.from(artifactNameSet));
          extraArtifactOverrides = curArts.map(String).map(s => String(s || '').trim()).filter(Boolean).filter(v => !artSet.has(v));
          curArts.map(String).map(s => String(s || '').trim()).filter(Boolean).forEach(v => { if(artSet.has(v)) overrideArtifactMap[v] = v; });
        } catch(e) { extraArtifactOverrides = []; }
        try{
          const fldSet = new Set(Array.from(fieldNameSet));
          extraFieldOverrides = curFields.map(String).map(s => String(s || '').trim()).filter(Boolean).filter(v => !fldSet.has(v));
          curFields.map(String).map(s => String(s || '').trim()).filter(Boolean).forEach(v => { if(fldSet.has(v)) overrideFieldMap[v] = v; });
        } catch(e) { extraFieldOverrides = []; }
        const showMissing = rows.some(r => r && r.missing);
        pane.appendChild(buildInputsTable(rows, showMissing));
      } else {
        const faFirst = (Array.isArray(currentFlagAssignments) && currentFlagAssignments[0]) ? currentFlagAssignments[0] : null;
        const ri = (faFirst && typeof faFirst.resolved_inputs === 'object' && faFirst.resolved_inputs && !Array.isArray(faFirst.resolved_inputs))
          ? faFirst.resolved_inputs
          : null;
        const rows = [];
        const fieldNameSet = new Set();
        if(ri && typeof ri === 'object'){
          Object.keys(ri).sort((a, b) => String(a).localeCompare(String(b))).forEach((k0)=>{
            const k1 = String(k0 || '').trim();
            if(!k1 || isFlagFactName(k1)) return;
            fieldNameSet.add(k1);
            rows.push({ name: k1, resolved: ri[k1], toChain: true, kind: 'Field', overrideValue: overrideFields.has(k1) ? k1 : '' });
          });
        }
        try{
          extraArtifactOverrides = curArts.map(String).map(s => String(s || '').trim()).filter(Boolean);
        } catch(e) { extraArtifactOverrides = []; }
        try{
          const fldSet = new Set(Array.from(fieldNameSet));
          extraFieldOverrides = curFields.map(String).map(s => String(s || '').trim()).filter(Boolean).filter(v => !fldSet.has(v));
          curFields.map(String).map(s => String(s || '').trim()).filter(Boolean).forEach(v => { if(fldSet.has(v)) overrideFieldMap[v] = v; });
        } catch(e) { extraFieldOverrides = []; }
        pane.appendChild(buildOutputsTable(rows));
      }
      ioOuter.appendChild(pane);
      wrap.appendChild(ioOuter);
    } catch(e) {}

    // No hidden textareas needed; overrides are derived from the table inputs.

    const actions = document.createElement('div');
    actions.className = 'd-flex justify-content-end gap-2';
    const clearBtn = document.createElement('button');
    clearBtn.type = 'button';
    clearBtn.className = 'btn btn-sm btn-outline-secondary';
    clearBtn.textContent = 'Clear override';
    const saveBtn = document.createElement('button');
    saveBtn.type = 'button';
    saveBtn.className = 'btn btn-sm btn-primary';
    saveBtn.textContent = 'Save Overrides';
    actions.appendChild(clearBtn);
    actions.appendChild(saveBtn);

    wrap.appendChild(actions);
    inputsBodyEl.appendChild(wrap);

    async function persistFactsOverride(nextOverride){
      if(k === 'goal') flowGoalFactsOverride = nextOverride;
      else flowInitialFactsOverride = nextOverride;

      if(!Array.isArray(currentChain) || !currentChain.length) return;
      const scenario = (scenarioEl && scenarioEl.value || '').trim();
      if(!scenario) return;
      const chain_ids = currentChain.map(n => (n && n.id) ? String(n.id) : '').filter(Boolean);
      if(!chain_ids.length) return;

      const targetIdx = (k === 'goal')
        ? Math.max(0, (Array.isArray(currentFlagAssignments) ? currentFlagAssignments.length : 0) - 1)
        : 0;

      function parseOverrideValue(raw){
        const s = String(raw ?? '').trim();
        if(!s) return undefined;
        const looksJson = s.startsWith('{') || s.startsWith('[') || s.startsWith('"') || s === 'true' || s === 'false' || s === 'null' || /^-?\d+(?:\.\d+)?$/.test(s);
        if(!looksJson) return s;
        try { return JSON.parse(s); } catch(e) { return s; }
      }

      const overridePairs = Object.assign({}, overrideArtifactMap || {}, overrideFieldMap || {});
      const overrideKeys = Object.keys(overridePairs || {});

      const reqAssignments = chain_ids.map((nid, j)=>{
        const curA = (Array.isArray(currentFlagAssignments) && currentFlagAssignments[j]) ? currentFlagAssignments[j] : {};
        const curId = String((curA && (curA.id || curA.generator_id)) || '').trim();
        const out = { node_id: nid, id: curId };
        if(curA && typeof curA.config_overrides === 'object' && curA.config_overrides && !Array.isArray(curA.config_overrides)) out.config_overrides = curA.config_overrides;
        if(curA && typeof curA.output_overrides === 'object' && curA.output_overrides && !Array.isArray(curA.output_overrides)) out.output_overrides = curA.output_overrides;
        if(curA && Array.isArray(curA.inject_files_override)) out.inject_files_override = curA.inject_files_override;
        if(curA && Array.isArray(curA.hint_overrides)) out.hint_overrides = curA.hint_overrides;
        if(curA && typeof curA.flag_override === 'string' && curA.flag_override.trim()) out.flag_override = String(curA.flag_override).trim();

        if(curA && typeof curA.resolved_inputs === 'object' && curA.resolved_inputs && !Array.isArray(curA.resolved_inputs)){
          out.resolved_inputs = curA.resolved_inputs;
        }
        if(curA && typeof curA.resolved_outputs === 'object' && curA.resolved_outputs && !Array.isArray(curA.resolved_outputs)){
          out.resolved_outputs = curA.resolved_outputs;
        }
        if(curA && typeof curA.flag_value === 'string' && curA.flag_value.trim()){
          out.flag_value = String(curA.flag_value).trim();
        }

        if(j === targetIdx && overrideKeys.length){
          const nextResolvedInputs = Object.assign({}, (out.resolved_inputs || {}));
          overrideKeys.forEach((key)=>{
            const k0 = String(key || '').trim();
            if(!k0) return;
            const v0 = parseOverrideValue(overridePairs[key]);
            if(v0 === undefined){
              delete nextResolvedInputs[k0];
            } else {
              nextResolvedInputs[k0] = v0;
            }
          });
          out.resolved_inputs = nextResolvedInputs;
        }
        return out;
      });

      const prevResolved = Array.isArray(currentFlagAssignments)
        ? currentFlagAssignments.map(a => ({
            resolved_inputs: a && a.resolved_inputs,
            resolved_outputs: a && a.resolved_outputs,
            flag_value: a && a.flag_value,
          }))
        : [];

      showLoading('Saving facts override…');
      try{
        const res = await postJson('/api/flag-sequencing/save_flow_substitutions', {
          scenario: activeScenario,
          chain_ids: chain_ids,
          preview_plan: previewPlanForRequest(),
          flag_assignments: reqAssignments,
          initial_facts: flowInitialFactsOverride,
          goal_facts: flowGoalFactsOverride,
        }, { timeoutMs: 60000 });
        setFlowValidityFromPayload(res);
        if(res && Array.isArray(res.chain)) currentChain = res.chain.slice();
        if(res && Array.isArray(res.flag_assignments)){
          const next = res.flag_assignments.slice();
          try{
            next.forEach((a, idx) => {
              if(!a || typeof a !== 'object') return;
              const prev = prevResolved[idx];
              if(!prev || typeof prev !== 'object') return;
              if(a.resolved_inputs === undefined && prev.resolved_inputs !== undefined){
                a.resolved_inputs = prev.resolved_inputs;
              }
              if(a.resolved_outputs === undefined && prev.resolved_outputs !== undefined){
                a.resolved_outputs = prev.resolved_outputs;
              }
              if(a.flag_value === undefined && prev.flag_value !== undefined){
                a.flag_value = prev.flag_value;
              }
            });
          } catch(e) {}
          try{
            if(overrideKeys.length && next[targetIdx] && typeof next[targetIdx] === 'object'){
              const cur = next[targetIdx];
              const nextResolvedInputs = Object.assign({}, (cur.resolved_inputs || {}));
              overrideKeys.forEach((key)=>{
                const k0 = String(key || '').trim();
                if(!k0) return;
                const v0 = parseOverrideValue(overridePairs[key]);
                if(v0 === undefined){
                  delete nextResolvedInputs[k0];
                } else {
                  nextResolvedInputs[k0] = v0;
                }
              });
              cur.resolved_inputs = nextResolvedInputs;
            }
          } catch(e) {}
          currentFlagAssignments = next;
        }
        // flow_plan_path no longer used
        try { persistFlowState(); } catch(e) {}
        renderChainEditor();
        try { if(typeof inputsDialogEl.close === 'function') inputsDialogEl.close(); } catch(e) {}
      } finally {
        hideLoading();
      }
    }

    clearBtn.addEventListener('click', ()=>{
      if(k === 'goal') flowGoalFactsOverride = null;
      else flowInitialFactsOverride = null;
      try { Object.keys(overrideArtifactMap).forEach(k0 => { delete overrideArtifactMap[k0]; }); } catch(e) {}
      try { Object.keys(overrideFieldMap).forEach(k0 => { delete overrideFieldMap[k0]; }); } catch(e) {}
      extraArtifactOverrides = [];
      extraFieldOverrides = [];
      persistFactsOverride(null);
    });

    saveBtn.addEventListener('click', ()=>{
      const lists = currentOverrideLists();
      const next = normalizeFactsOverride({
        artifacts: lists.artifacts,
        fields: lists.fields,
      });
      persistFactsOverride(next);
    });

    try{
      if(typeof inputsDialogEl.showModal === 'function') inputsDialogEl.showModal();
    } catch(e) {}
  }

  function openSubstituteDialog(idx){
    if(!substituteDialogEl || !substituteBodyEl) return;
    const i = Number.isFinite(+idx) ? (+idx) : -1;
    if(!Array.isArray(currentChain) || i < 0 || i >= currentChain.length) return;
    const node = currentChain[i] || {};
    const fa = (Array.isArray(currentFlagAssignments) && currentFlagAssignments[i]) ? currentFlagAssignments[i] : null;

    // Hint overrides editor state (scoped to this dialog open).
    let hintOverridesEnabled = false;
    let hintOverrideToggleEl = null;
    let hintOverrideInputs = [];

    const seq = toRoman(i + 1);
    const nodeName = (node && node.name) ? String(node.name) : ('Node ' + (i + 1));
    if(substituteTitleEl) substituteTitleEl.textContent = 'Edit Flag + Hints — ' + (seq ? (seq + '. ') : '') + nodeName;

    substituteBodyEl.innerHTML = '';

    // Header summary.
    try{
      const genId = fa && fa.id ? String(fa.id) : '-';
      const genType = (fa && fa.type) ? String(fa.type) : '-';
      const genSource = (fa && fa.flag_generator) ? String(fa.flag_generator) : '-';
      const hdr = document.createElement('div');
      hdr.className = 'mb-2';
      const label = document.createElement('div');
      label.className = 'small text-muted';
      label.textContent = 'Current generator';
      hdr.appendChild(label);

      const row = document.createElement('div');
      row.className = 'd-flex flex-wrap gap-2 align-items-center';
      const idCode = document.createElement('code');
      idCode.textContent = genId;
      row.appendChild(idCode);

      const typeLabel = document.createElement('span');
      typeLabel.className = 'text-muted small';
      typeLabel.textContent = 'type';
      row.appendChild(typeLabel);
      const typeCode = document.createElement('code');
      typeCode.textContent = genType;
      row.appendChild(typeCode);

      const srcLabel = document.createElement('span');
      srcLabel.className = 'text-muted small';
      srcLabel.textContent = 'source';
      row.appendChild(srcLabel);
      const srcCode = document.createElement('code');
      srcCode.textContent = genSource;
      row.appendChild(srcCode);

      hdr.appendChild(row);
      substituteBodyEl.appendChild(hdr);
    } catch(e) {}

    // Substitute generator UI (always expanded).
    try{
      const isVuln = !!(node && (node.is_vuln || node.is_vulnerability || node.isVuln));
      const currentType = (fa && fa.type) ? String(fa.type) : (isVuln ? 'flag-generator' : 'flag-node-generator');
      const currentSource = (fa && fa.flag_generator) ? String(fa.flag_generator) : '';

      const help = document.createElement('div');
      help.className = 'small text-muted';
      help.textContent = isVuln
        ? 'Flag-generator type (fixed for vulnerabilities)'
        : 'Non-vulnerability nodes use flag-node-generators.';
      substituteBodyEl.appendChild(help);

      const form = document.createElement('div');
      form.className = 'border rounded p-2 mt-2';

      const row1 = document.createElement('div');
      row1.className = 'd-flex align-items-center gap-2';

      const nodeLabel = document.createElement('div');
      nodeLabel.className = 'small text-muted';
      nodeLabel.textContent = 'Node:';
      row1.appendChild(nodeLabel);

      const nodeSel = document.createElement('select');
      nodeSel.className = 'form-select form-select-sm';
      nodeSel.style.width = '360px';
      row1.appendChild(nodeSel);

      const kindLabel = document.createElement('div');
      kindLabel.className = 'small text-muted';
      kindLabel.textContent = 'Type:';
      row1.appendChild(kindLabel);

      const kindSel = document.createElement('select');
      kindSel.className = 'form-select form-select-sm';
      kindSel.style.width = '220px';
      const optFg = document.createElement('option');
      optFg.value = 'flag-generator';
      optFg.textContent = 'flag-generator';
      const optFng = document.createElement('option');
      optFng.value = 'flag-node-generator';
      optFng.textContent = 'flag-node-generator';
      if(isVuln){
        kindSel.appendChild(optFg);
        kindSel.value = 'flag-generator';
      } else {
        kindSel.appendChild(optFng);
        kindSel.value = 'flag-node-generator';
      }
      kindSel.disabled = true;
      row1.appendChild(kindSel);

      const sourceLabel = document.createElement('div');
      sourceLabel.className = 'small text-muted ms-1';
      sourceLabel.textContent = 'Source:';
      row1.appendChild(sourceLabel);

      const sourceSel = document.createElement('select');
      sourceSel.className = 'form-select form-select-sm';
      sourceSel.style.width = '320px';
      row1.appendChild(sourceSel);

      form.appendChild(row1);

      const row2 = document.createElement('div');
      row2.className = 'd-flex flex-column gap-1 mt-2';

      const entryInput = document.createElement('input');
      entryInput.type = 'text';
      entryInput.className = 'form-control form-control-sm d-none';
      entryInput.placeholder = 'Filter (string or /regex/)';

      const entryErr = document.createElement('div');
      entryErr.className = 'small text-danger d-none';

      const candWrap = document.createElement('div');
      candWrap.className = 'border rounded';
      candWrap.style.maxHeight = '240px';
      candWrap.style.overflow = 'auto';

      const candTable = document.createElement('table');
      candTable.className = 'table table-sm mb-0 align-middle';
      const candHead = document.createElement('thead');
      const candHeadTr = document.createElement('tr');
      ;['Pick','Generator','Source','Incompatibility'].forEach((h)=>{
        const th = document.createElement('th');
        th.className = 'small text-muted';
        th.style.whiteSpace = 'nowrap';
        th.textContent = h;
        candHeadTr.appendChild(th);
      });
      candHead.appendChild(candHeadTr);
      const candBody = document.createElement('tbody');
      candTable.appendChild(candHead);
      candTable.appendChild(candBody);
      candWrap.appendChild(candTable);

      let selectedCandidateId = '';
      let selectedNodeId = '';
      let nodeCandidatesCache = [];

      function isHoldActive(){
        try { return !!(heldChainIndices && heldChainIndices.has(i)); } catch(e) { return false; }
      }

      function chain_ids_with_selected_node(){
        const base = Array.isArray(currentChain)
          ? currentChain.map(n => (n && n.id) ? String(n.id) : '').filter(Boolean)
          : [];
        if(!base.length) return [];
        if(isHoldActive()) return base;
        const chosen = String(selectedNodeId || '').trim();
        if(!chosen) return base;
        return base.map((cid, j) => (j === i ? chosen : cid));
      }

      function refreshNodeOptionsFromResponse(resp){
        const list = (resp && Array.isArray(resp.node_candidates)) ? resp.node_candidates.slice() : [];
        nodeCandidatesCache = list;
        const curId = (Array.isArray(currentChain) && currentChain[i] && currentChain[i].id) ? String(currentChain[i].id) : '';
        if(!selectedNodeId){
          selectedNodeId = curId;
        }
        nodeSel.innerHTML = '';
        if(!list.length){
          const opt = document.createElement('option');
          opt.value = curId || '';
          opt.textContent = curId ? ('Current: ' + curId) : '(no nodes)';
          nodeSel.appendChild(opt);
          nodeSel.value = opt.value;
          return;
        }
        for(const n of list){
          const nid = String((n && n.id) || '').trim();
          if(!nid) continue;
          const nm = String((n && n.name) || '').trim();
          const isDocker = !!(n && n.is_docker);
          const isVuln = !!(n && n.is_vuln);
          const ok = !!(n && n.compatible);
          const label = (nm ? (nid + ' — ' + nm) : nid)
            + (isDocker ? ' [docker]' : '')
            + (isVuln ? ' [vuln]' : '')
            + (!ok ? ' (incompatible)' : '');
          const opt = document.createElement('option');
          opt.value = nid;
          opt.textContent = label;
          opt.disabled = !ok;
          nodeSel.appendChild(opt);
        }
        const hasSelected = Array.from(nodeSel.options).some(o => o.value === selectedNodeId && !o.disabled);
        if(!hasSelected){
          const curOk = Array.from(nodeSel.options).find(o => o.value === curId && !o.disabled);
          const firstOk = Array.from(nodeSel.options).find(o => !o.disabled);
          const pick = curOk || firstOk;
          selectedNodeId = pick ? pick.value : (curId || '');
        }
        if(isHoldActive()){
          selectedNodeId = curId;
          try { nodeSel.value = curId; } catch(e) {}
          try { nodeSel.disabled = true; } catch(e) {}
        } else {
          nodeSel.value = selectedNodeId;
          try { nodeSel.disabled = false; } catch(e) {}
        }
      }

      function syncKindAvailabilityForSelectedNode(){
        const nid = String(nodeSel.value || '').trim();
        selectedNodeId = nid;
        const info = (nodeCandidatesCache || []).find(x => String((x && x.id) || '').trim() === nid) || null;
        const isVuln = !!(info && info.is_vuln);
        const isDocker = !!(info && info.is_docker);
        const allowNodeGen = (!!isDocker && !isVuln);
        if(!allowNodeGen){
          kindSel.value = 'flag-generator';
        }
        try {
          const opt = Array.from(kindSel.options).find(o => String(o.value) === 'flag-node-generator');
          if(opt){
            opt.disabled = !allowNodeGen;
            if(!allowNodeGen && kindSel.value === 'flag-node-generator') kindSel.value = 'flag-generator';
          }
        } catch(e) {}
      }

      row2.appendChild(entryInput);
      row2.appendChild(entryErr);
      row2.appendChild(candWrap);
      form.appendChild(row2);

      // Hints editor (override / generated).
      try {
        const hintsDivider = document.createElement('hr');
        hintsDivider.className = 'my-3';
        form.appendChild(hintsDivider);

        const hintsHdr = document.createElement('div');
        hintsHdr.className = 'fw-semibold';
        hintsHdr.textContent = 'Hints';
        form.appendChild(hintsHdr);

        const hintsHelp = document.createElement('div');
        hintsHelp.className = 'small text-muted';
        hintsHelp.textContent = 'Override the displayed hints for this step. If disabled, hints are generated from the selected generator templates.';
        form.appendChild(hintsHelp);

        const toggleRow = document.createElement('div');
        toggleRow.className = 'd-flex align-items-center justify-content-between gap-2 mt-2';

        const toggleWrap = document.createElement('div');
        toggleWrap.className = 'form-check';
        hintOverrideToggleEl = document.createElement('input');
        hintOverrideToggleEl.type = 'checkbox';
        hintOverrideToggleEl.className = 'form-check-input';
        hintOverrideToggleEl.id = 'flowHintOverrideToggle_' + i;
        const toggleLabel = document.createElement('label');
        toggleLabel.className = 'form-check-label';
        toggleLabel.setAttribute('for', hintOverrideToggleEl.id);
        toggleLabel.textContent = 'Override hints';
        toggleWrap.appendChild(hintOverrideToggleEl);
        toggleWrap.appendChild(toggleLabel);

        const resetBtn = document.createElement('button');
        resetBtn.type = 'button';
        resetBtn.className = 'btn btn-sm btn-outline-secondary';
        resetBtn.textContent = 'Reset to generated';

        toggleRow.appendChild(toggleWrap);
        toggleRow.appendChild(resetBtn);
        form.appendChild(toggleRow);

        const listWrap = document.createElement('div');
        listWrap.className = 'border rounded p-2 mt-2';
        form.appendChild(listWrap);

        function normalizeHints(list){
          const out = [];
          try {
            (Array.isArray(list) ? list : []).forEach((x)=>{
              const s = String(x ?? '').trim();
              if(!s) return;
              out.push(s);
            });
          } catch(e) {}
          return out;
        }

        function getGeneratedHintsFromAssignment(){
          const cur = (fa && Array.isArray(fa.hints) && fa.hints.length) ? normalizeHints(fa.hints) : [];
          if(cur.length) return cur;
          const h = (fa && fa.hint) ? String(fa.hint || '').trim() : '';
          return h ? [h] : [];
        }

        function getOverrideHintsFromAssignment(){
          if(fa && Array.isArray(fa.hint_overrides)) return normalizeHints(fa.hint_overrides);
          return null;
        }

        function renderHintList(hints){
          hintOverrideInputs = [];
          listWrap.innerHTML = '';

          const stack = document.createElement('div');
          stack.className = 'd-flex flex-column gap-2';

          function addRow(value){
            const row = document.createElement('div');
            row.className = 'd-flex gap-2 align-items-center';

            const inp = document.createElement('input');
            inp.type = 'text';
            inp.className = 'form-control form-control-sm';
            inp.placeholder = 'Hint text…';
            inp.value = String(value ?? '');

            const del = document.createElement('button');
            del.type = 'button';
            del.className = 'btn btn-sm btn-outline-danger';
            del.textContent = 'Remove';
            del.addEventListener('click', ()=>{
              try { row.remove(); } catch(e) {}
              hintOverrideInputs = hintOverrideInputs.filter(x => x !== inp);
            });

            hintOverrideInputs.push(inp);
            row.appendChild(inp);
            row.appendChild(del);
            stack.appendChild(row);
          }

          (Array.isArray(hints) && hints.length ? hints : ['']).forEach(addRow);

          const addBtn = document.createElement('button');
          addBtn.type = 'button';
          addBtn.className = 'btn btn-sm btn-outline-primary';
          addBtn.textContent = 'Add hint';
          addBtn.addEventListener('click', ()=> addRow(''));

          listWrap.appendChild(stack);
          listWrap.appendChild(addBtn);
        }

        function setHintOverrideEnabled(enabled){
          hintOverridesEnabled = !!enabled;
          try { if(hintOverrideToggleEl) hintOverrideToggleEl.checked = hintOverridesEnabled; } catch(e) {}
          try { listWrap.style.display = hintOverridesEnabled ? '' : 'none'; } catch(e) {}
          try { resetBtn.disabled = !hintOverridesEnabled; } catch(e) {}
        }

        const existingOverride = getOverrideHintsFromAssignment();
        if(existingOverride !== null){
          renderHintList(existingOverride);
          setHintOverrideEnabled(true);
        } else {
          renderHintList(getGeneratedHintsFromAssignment());
          setHintOverrideEnabled(false);
        }

        hintOverrideToggleEl.addEventListener('change', ()=>{
          setHintOverrideEnabled(!!hintOverrideToggleEl.checked);
        });

        resetBtn.addEventListener('click', ()=>{
          setHintOverrideEnabled(false);
          renderHintList(getGeneratedHintsFromAssignment());
        });
      } catch(e) {
        // Non-fatal
      }

      const row3 = document.createElement('div');
      row3.className = 'd-flex align-items-center justify-content-between gap-2 mt-2';

      const cur = document.createElement('div');
      cur.className = 'small text-muted';
      cur.textContent = (fa && (fa.id || fa.name))
        ? ('Current: ' + String(fa.id || '') + (currentSource ? (' (' + currentSource + ')') : ''))
        : 'Current: -';

      const actions = document.createElement('div');
      actions.className = 'd-flex gap-2';
      const cancelBtn = document.createElement('button');
      cancelBtn.type = 'button';
      cancelBtn.className = 'btn btn-sm btn-outline-secondary';
      cancelBtn.textContent = 'Cancel';
      const applyBtn = document.createElement('button');
      applyBtn.type = 'button';
      applyBtn.className = 'btn btn-sm btn-primary';
      applyBtn.textContent = 'Apply';
      actions.appendChild(cancelBtn);
      actions.appendChild(applyBtn);

      row3.appendChild(cur);
      row3.appendChild(actions);
      form.appendChild(row3);

      substituteBodyEl.appendChild(form);

      function getCatalogForKind(kind){
        const cat = (String(kind) === 'flag-node-generator')
          ? (Array.isArray(_flagNodeGeneratorsCatalog) ? _flagNodeGeneratorsCatalog : [])
          : (Array.isArray(_flagGeneratorsCatalog) ? _flagGeneratorsCatalog : []);
        return (cat || []).filter(g => !(g && g._disabled));
      }

      function rebuildSourceOptions(){
        const kind = String(kindSel.value || 'flag-generator');
        const cat = getCatalogForKind(kind);
        const sources = new Set();
        (cat || []).forEach(g => {
          try {
            const s = String((g && g._source_name) || '').trim();
            if(s) sources.add(s);
          } catch(e) {}
        });
        const sorted = Array.from(sources).sort((a,b)=>String(a).localeCompare(String(b)));
        sourceSel.innerHTML = '';
        const anyOpt = document.createElement('option');
        anyOpt.value = '__any__';
        anyOpt.textContent = '(Any source)';
        sourceSel.appendChild(anyOpt);
        for(const s of sorted){
          const o = document.createElement('option');
          o.value = s;
          o.textContent = s;
          sourceSel.appendChild(o);
        }
        const entryOpt = document.createElement('option');
        entryOpt.value = '__entry__';
        entryOpt.textContent = 'Entry…';
        sourceSel.appendChild(entryOpt);
        if(currentSource && sorted.includes(currentSource)){
          sourceSel.value = currentSource;
        } else {
          sourceSel.value = '__any__';
        }
      }

      function rebuildGeneratorOptions(){
        const kind = String(kindSel.value || 'flag-generator');
        const cat = getCatalogForKind(kind);
        const source = String(sourceSel.value || '__any__');

        entryErr.classList.add('d-none');
        entryErr.textContent = '';

        let filtered = (cat || []).slice();

        if(source === '__entry__'){
          entryInput.classList.remove('d-none');
          const compiled = compileStringOrRegex(entryInput.value);
          if(!compiled.ok){
            entryErr.textContent = compiled.error;
            entryErr.classList.remove('d-none');
            filtered = [];
          } else if(compiled.regex){
            filtered = filtered.filter(g => {
              const gid = String((g && g.id) || '');
              const gname = String((g && g.name) || '');
              return compiled.regex.test(gid) || compiled.regex.test(gname);
            });
          }
        } else {
          entryInput.classList.add('d-none');
          if(source !== '__any__'){
            filtered = filtered.filter(g => String((g && g._source_name) || '').trim() === source);
          }
        }

        // Cap for UI sanity.
        filtered = filtered.slice(0, 250);

        // Default selection to current.
        try {
          const curId = (fa && fa.id) ? String(fa.id) : '';
          selectedCandidateId = curId || '';
        } catch(e) {
          selectedCandidateId = '';
        }

        // Ask server to compute compatibility against the current chain context.
        const chain_ids = chain_ids_with_selected_node();
        const reqAssignments = chain_ids.map((nid, j)=>{
          const curA = (Array.isArray(currentFlagAssignments) && currentFlagAssignments[j]) ? currentFlagAssignments[j] : {};
          const curId = String((curA && (curA.id || curA.generator_id)) || '').trim();
          return { node_id: nid, id: curId };
        });
        const candidateIds = filtered.map(g => String((g && g.id) || '').trim()).filter(Boolean);

        // Render optimistic placeholder.
        candBody.innerHTML = '';
        if(!candidateIds.length){
          const tr = document.createElement('tr');
          const td = document.createElement('td');
          td.colSpan = 4;
          td.className = 'text-muted small';
          td.textContent = 'No matches.';
          tr.appendChild(td);
          candBody.appendChild(tr);
          return;
        }

        (async ()=>{
          let candidates = [];
          try {
            const res = await postJson('/api/flag-sequencing/substitution_candidates', {
              scenario: activeScenario,
              preview_plan: previewPlanForRequest(),
              chain_ids: chain_ids,
              flag_assignments: reqAssignments,
              index: i,
              kind,
              candidate_ids: candidateIds,
              allow_node_duplicates: !!allowNodeDuplicates,
            }, { timeoutMs: 45000 });
            try { refreshNodeOptionsFromResponse(res); } catch(e) {}
            try { syncKindAvailabilityForSelectedNode(); } catch(e) {}
            candidates = (res && Array.isArray(res.candidates)) ? res.candidates.slice() : [];
          } catch(e) {
            // If this fails, fall back to showing everything as selectable.
            candidates = candidateIds.map((gid)=>{
              const g = filtered.find(x => String((x && x.id) || '').trim() === gid) || {};
              return {
                id: String(gid),
                name: String((g && g.name) || ''),
                source: String((g && g._source_name) || '').trim() || 'unknown',
                compatible: true,
                blocked_by: [],
              };
            });
          }

          // Ensure ordering: compatible first.
          candidates.sort((a,b)=>{
            const ak = (a && a.compatible) ? 0 : 1;
            const bk = (b && b.compatible) ? 0 : 1;
            if(ak !== bk) return ak - bk;
            const an = String((a && a.name) || '').toLowerCase();
            const bn = String((b && b.name) || '').toLowerCase();
            if(an < bn) return -1;
            if(an > bn) return 1;
            return String((a && a.id) || '').localeCompare(String((b && b.id) || ''));
          });

          candBody.innerHTML = '';
          for(const c of candidates){
            const cid = String((c && c.id) || '').trim();
            if(!cid) continue;
            const tr = document.createElement('tr');
            const ok = !!(c && c.compatible);
            if(!ok){
              tr.classList.add('text-muted');
              tr.style.opacity = '0.6';
            }

            const tdPick = document.createElement('td');
            tdPick.style.width = '1%';
            tdPick.style.whiteSpace = 'nowrap';
            const radio = document.createElement('input');
            radio.type = 'radio';
            radio.name = 'flowSubstitutePick';
            radio.value = cid;
            radio.checked = !!(selectedCandidateId && selectedCandidateId === cid);
            radio.addEventListener('change', ()=>{ selectedCandidateId = cid; });
            tdPick.appendChild(radio);

            const tdGen = document.createElement('td');
            tdGen.style.whiteSpace = 'nowrap';
            const nm = String((c && c.name) || '').trim();
            tdGen.textContent = nm ? (cid + ' — ' + nm) : cid;

            const tdSrc = document.createElement('td');
            tdSrc.style.whiteSpace = 'nowrap';
            tdSrc.textContent = String((c && c.source) || '').trim() || '-';

            const tdWhy = document.createElement('td');
            tdWhy.className = 'small';
            const blocked = (c && Array.isArray(c.blocked_by)) ? c.blocked_by.map(x => String(x || '').trim()).filter(Boolean) : [];
            tdWhy.textContent = ok ? '' : (blocked.length ? blocked.join(' · ') : 'incompatible');

            tr.appendChild(tdPick);
            tr.appendChild(tdGen);
            tr.appendChild(tdSrc);
            tr.appendChild(tdWhy);

            tr.addEventListener('click', ()=>{
              selectedCandidateId = cid;
              try { radio.checked = true; } catch(e) {}
            });

            candBody.appendChild(tr);
          }

          if(selectedCandidateId){
            const found = candidates.find(x => String((x && x.id) || '') === selectedCandidateId);
            if(!found) selectedCandidateId = '';
          }
        })();
      }

      nodeSel.addEventListener('change', ()=>{
        try { syncKindAvailabilityForSelectedNode(); } catch(e) {}
        rebuildSourceOptions();
        rebuildGeneratorOptions();
      });

      kindSel.addEventListener('change', ()=>{
        try { syncKindAvailabilityForSelectedNode(); } catch(e) {}
        rebuildSourceOptions();
        rebuildGeneratorOptions();
      });
      sourceSel.addEventListener('change', ()=>{
        rebuildGeneratorOptions();
      });
      entryInput.addEventListener('input', ()=>{
        if(String(sourceSel.value || '') === '__entry__') rebuildGeneratorOptions();
      });

      cancelBtn.addEventListener('click', ()=>{
        try {
          if(typeof substituteDialogEl.close === 'function') substituteDialogEl.close();
        } catch(e) {}
      });

      applyBtn.addEventListener('click', async ()=>{
        const chosenId = String(selectedCandidateId || '').trim();
        if(!chosenId){
          setStatus('Select a generator first.', true);
          return;
        }
        try { applyBtn.disabled = true; } catch(e) {}
        try { cancelBtn.disabled = true; } catch(e) {}
        try{
          if(!Array.isArray(currentChain) || currentChain.length === 0){
            throw new Error('Generate a chain first.');
          }
          const chain_ids = chain_ids_with_selected_node();
          if(!chain_ids.length) throw new Error('Missing chain ids.');

          const currentNodeId = (Array.isArray(currentChain) && currentChain[i] && currentChain[i].id) ? String(currentChain[i].id) : '';
          const reqAssignments = chain_ids.map((nid, j)=>{
            const curA = (Array.isArray(currentFlagAssignments) && currentFlagAssignments[j]) ? currentFlagAssignments[j] : {};
            const curId = String((curA && (curA.id || curA.generator_id)) || '').trim();
            const idOut = (j === i) ? chosenId : curId;

            let ovr = (curA && typeof curA.config_overrides === 'object' && curA.config_overrides && !Array.isArray(curA.config_overrides))
              ? curA.config_overrides
              : undefined;
            if(j === i){
              if(String(nid) !== String(currentNodeId) || String(idOut) !== String(curId)){
                ovr = undefined;
              }
            }

            // Preserve hint overrides for other steps. For this step:
            // - if override enabled: send list
            // - else: send null to clear any previous override (use generated templates)
            let hintOvr = undefined;
            try {
              if(curA && Array.isArray(curA.hint_overrides)) hintOvr = curA.hint_overrides;
            } catch(e) {}

            if(j === i){
              if(hintOverridesEnabled){
                const texts = [];
                try {
                  (hintOverrideInputs || []).forEach((el)=>{
                    const s = String((el && el.value) ?? '').trim();
                    if(!s) return;
                    texts.push(s);
                  });
                } catch(e) {}
                hintOvr = texts;
              } else {
                hintOvr = null;
              }

              if((String(nid) !== String(currentNodeId) || String(idOut) !== String(curId)) && !hintOverridesEnabled){
                hintOvr = null;
              }
            }

            const out = { node_id: nid, id: idOut, config_overrides: ovr };
            if(hintOvr !== undefined) out.hint_overrides = hintOvr;
            return out;
          });
          const missing = reqAssignments.find(x => !x.id);
          if(missing){
            throw new Error('Cannot save substitution because some chain positions have no generator assignment yet. Try Generate again.');
          }

          showLoading('Saving substitution…');
          const res = await postJson('/api/flag-sequencing/save_flow_substitutions', {
            scenario: activeScenario,
            chain_ids: chain_ids,
            preview_plan: previewPlanForRequest(),
            flag_assignments: reqAssignments,
            initial_facts: flowInitialFactsOverride,
            goal_facts: flowGoalFactsOverride,
          }, { timeoutMs: 60000 });

          setFlowValidityFromPayload(res);
          if(res && Array.isArray(res.chain)) currentChain = res.chain.slice();
          if(res && Array.isArray(res.flag_assignments)) currentFlagAssignments = res.flag_assignments.slice();
          // flow_plan_path no longer used
          updateMeta();
          renderChainEditor();
          setStatus('Edits saved. Saving XML…', false);

          try {
            if(typeof substituteDialogEl.close === 'function') substituteDialogEl.close();
          } catch(e) {}

          try {
            await saveXmlOnly({});
          } catch(e) {
            setStatus('Saved edits, but Save XML failed: ' + String(e && e.message || e), true);
          }
        } catch(e){
          setStatus('Failed to save edits: ' + String(e && e.message || e), true);
        } finally {
          try { applyBtn.disabled = false; } catch(e) {}
          try { cancelBtn.disabled = false; } catch(e) {}
          hideLoading();
        }
      });

      // Load generator catalogs immediately.
      (async ()=>{
        try{
          showLoading('Loading generator catalog…');
          await ensureGeneratorCatalogsLoaded();
          rebuildSourceOptions();
          rebuildGeneratorOptions();
        } catch(e){
          setStatus('Failed to load generator catalog: ' + String(e && e.message || e), true);
        } finally {
          hideLoading();
        }
      })();
    } catch(e) {
      // Non-fatal
    }

    try{
      if(typeof substituteDialogEl.showModal === 'function') substituteDialogEl.showModal();
    } catch(e) {}
  }

  function selectChainIndex(idx){
    selectedChainIndex = Number.isFinite(+idx) ? (+idx) : -1;
    if(selectedChainIndex < 0 || !Array.isArray(currentChain) || selectedChainIndex >= currentChain.length){
      selectedChainIndex = -1;
      renderChainEditor();
      return;
    }
    renderChainEditor();
  }

  function updateMeta(){
    if(metaScenarioEl) metaScenarioEl.textContent = (activeScenario || '') ? String(activeScenario) : '-';
    if(metaPreviewEl) metaPreviewEl.textContent = lastPreviewPlanPath ? basenameFromPath(lastPreviewPlanPath) : '-';
    if(metaStatsEl) metaStatsEl.textContent = formatStats(lastStats) || '-';
  }

  async function refreshAssignmentsFromChain(){
    if(!Array.isArray(currentChain) || currentChain.length === 0) return;
    setStatus('Updating…', false);
    try{
      // Recompute assignments + validity based on the current chain order.
      const data = await postJson('/api/flag-sequencing/afb_from_chain', { scenario: activeScenario, chain: currentChain });
      currentFlagAssignments = Array.isArray(data.flag_assignments) ? data.flag_assignments.slice() : currentFlagAssignments;
      setFlowValidityFromPayload(data);
      if(jsonEl){
        jsonEl.textContent = JSON.stringify({
          scenario: (data && data.scenario) ? data.scenario : activeScenario,
          length: (data && Number.isFinite(+data.length)) ? (+data.length) : (Array.isArray(currentChain) ? currentChain.length : 0),
          chain: Array.isArray(currentChain) ? currentChain : [],
          flag_assignments: Array.isArray(currentFlagAssignments) ? currentFlagAssignments : [],
          flow_valid: !!(data && data.flow_valid),
          flow_errors: Array.isArray(data && data.flow_errors) ? data.flow_errors : [],
          flags_enabled: !!(data && data.flags_enabled),
        }, null, 2);
      }
      const diagram = buildMermaid(currentChain);
      await renderMermaid(diagram);
      updateMeta();
      setStatus('Ready.', false);
    } catch(err){
      setStatus(String(err && err.message || err), true);
    }
  }

  function formatStats(stats){
    if(!stats || typeof stats !== 'object') return '';
    const fg = Number.isFinite(+stats.flag_generator_eligible_total) ? (+stats.flag_generator_eligible_total) : (Number.isFinite(+stats.eligible_total) ? (+stats.eligible_total) : null);
    const fng = Number.isFinite(+stats.flag_node_generator_eligible_total) ? (+stats.flag_node_generator_eligible_total) : (Number.isFinite(+stats.docker_nonvuln_total) ? (+stats.docker_nonvuln_total) : null);
    const v = Number.isFinite(+stats.vuln_total) ? (+stats.vuln_total) : null;
    const dOther = Number.isFinite(+stats.docker_nonvuln_total) ? (+stats.docker_nonvuln_total) : null;
    if(fg === null && fng === null && v === null && dOther === null) return '';
    const parts = [];
    if(fg !== null) parts.push('Flag-Generator eligible: ' + fg);
    if(fng !== null) parts.push('Flag-Node-Generator eligible: ' + fng);
    if(v !== null) parts.push('Vuln nodes: ' + v);
    if(dOther !== null) parts.push('Other Docker Nodes: ' + dOther);
    return parts.join(' · ');
  }

  function buildMermaid(chain){
    const lines = ['flowchart LR'];
    if(!Array.isArray(chain) || chain.length === 0){
      lines.push('  A[No chain available]');
      return lines.join('\n');
    }
    for(let i=0;i<chain.length;i++){
      const node = chain[i];
      const safeId = 'N' + i;
      const label = (node && node.name) ? node.name : ('Node ' + (i+1));
      const seq = toRoman(i + 1);
      const prefixed = (seq ? (seq + '. ') : '') + String(label || '');
      lines.push(`  ${safeId}[${prefixed.replace(/\]/g,'')}]`);
      if(i>0){
        lines.push(`  N${i-1} --> ${safeId}`);
      }
    }
    for(let i=0;i<chain.length;i++){
      lines.push(`  click N${i} flowSelectNode "Show details"`);
    }
    return lines.join('\n');
  }

  async function renderMermaid(diagramText){
    try {
      if(window.mermaid){
        mermaid.initialize({ startOnLoad: false, securityLevel: 'loose' });
        const wrap = document.getElementById('flowDiagram');
        wrap.textContent = diagramText;
        wrap.removeAttribute('data-processed');
        await mermaid.run({ querySelector: '#flowDiagram' });
      }
    } catch(e) {
      // If rendering fails, keep plaintext.
      const wrap = document.getElementById('flowDiagram');
      if(wrap) wrap.textContent = diagramText;
    }
  }

  function shouldOfferBestEffort(err){
    try{
      const p = err && err.payload && typeof err.payload === 'object' ? err.payload : null;
      const available = p && Number.isFinite(+p.available) ? (+p.available) : null;
      if(!available || available <= 0) return null;
      const msg = (p && (p.error || p.message)) ? String(p.error || p.message) : '';
      if(msg && !msg.toLowerCase().includes('eligible')) return null;
      return { available, message: msg, requested: p && Number.isFinite(+p.requested_length) ? (+p.requested_length) : null };
    } catch(e){
      return null;
    }
  }

  async function generate(preferPreview, opts){
    const options = (opts && typeof opts === 'object') ? opts : {};
    const usePreview = !!preferPreview;
    const scenario = (scenarioEl && scenarioEl.value || '').trim();
    const preset = (presetEl && presetEl.value) ? String(presetEl.value).trim() : '';
    let length = preset ? 3 : (parseInt((lengthEl && lengthEl.value) || '5', 10) || 5);
    let lastResolvePayload = null;

    // User-click Generate should be deterministic: save current settings, produce a fresh
    // preview plan, then build the flow chain from that exact snapshot.
    const runSavePreviewResolve = !!(usePreview && options && options.savePreviewResolve);
    const resolveOnGenerate = (options && options.resolveOnGenerate !== undefined)
      ? !!options.resolveOnGenerate
      : !!runSavePreviewResolve;

    const params = new URLSearchParams();
    if(scenario) params.set('scenario', scenario);
    params.set('length', String(length));
    if(preset) params.set('preset', preset);
    // Only force preview selection when the user explicitly clicks Generate.
    if(usePreview){
      params.set('prefer_preview', '1');
      params.set('force_preview', '1');
    } else {
      // Auto-load should prefer the saved Flow plan when available.
      params.set('prefer_flow', '1');
      if(lastPreviewPlanPath){
        params.delete('preview_plan');
      }
    }

    const allowDupes = !!options.allow_node_duplicates;
    if(allowDupes){
      params.set('allow_node_duplicates', '1');
    }

    const buildAttackflowPreviewUrl = (p) => {
      const base = new URLSearchParams(p ? p.toString() : params.toString());
      try{
        const xmlPath = (typeof window.coretgGetLatestXmlPathForScenario === 'function') ? window.coretgGetLatestXmlPathForScenario(activeScenario) : '';
        if(xmlPath) base.set('xml_path', String(xmlPath));
      } catch(e) {}
      return '/api/flag-sequencing/attackflow_preview?' + base.toString();
    };
    if(downloadAfbLink) downloadAfbLink.href = '#';

    setStatus('Generating…', false);
    setLoginLinkVisible(false);
    showLoading('Generating flow…');
    if(metaScenarioEl) metaScenarioEl.textContent = '';
    if(metaPreviewEl) metaPreviewEl.textContent = '';
    if(metaStatsEl) metaStatsEl.textContent = '';
    if(jsonEl) jsonEl.textContent = '';

    const progressSteps = ['Saving XML', 'Generating preview plan', 'Sequencing chain', 'Resolving values'];
    let resolvedOk = false;
    let usedBestEffort = false;
    try {
      if(runSavePreviewResolve){
        const scenLabel = (scenario || activeScenario || '').toString().trim();
        const msg = scenLabel
          ? ('Generate will save current Topology / VM Access settings for scenario "' + scenLabel + '" and then build a Flag Sequencing chain.\n\nContinue?')
          : 'Generate will save current Topology / VM Access settings and then build a Flag Sequencing chain.\n\nContinue?';
        const ok = confirm(msg);
        if(!ok){
          hideLoading();
          setStatus('Generate cancelled.', false);
          return;
        }
        if(typeof window.coretgSaveXmlViaApi !== 'function' || typeof window.coretgPostJson !== 'function'){
          throw new Error('Save helper unavailable; refresh and try again.');
        }

        setStatus('Saving XML…', false);
        showLoading('Saving XML…');
        setLoadingSteps(progressSteps, 0);
        clearLoadingLog();
        appendLoadingLog(`Preset: ${preset || 'Random'} | Length: ${length}`);
        const xmlPath = await window.coretgSaveXmlViaApi({ persistPreviewPlan: false });
        if(!xmlPath){
          throw new Error('Save did not return xml_path');
        }
        try {
          const xmlPathInput = document.getElementById('scenariosPreviewXmlPath');
          if(xmlPathInput) xmlPathInput.value = String(xmlPath);
        } catch(e) {}

        setStatus('Generating preview plan…', false);
        showLoading('Generating preview plan…');
        setLoadingSteps(progressSteps, 1);
        appendLoadingLog('Ensuring planner plan');
        let seed = null;
        try {
          if (scenario && typeof window.coretgEnsureSeedForScenario === 'function') {
            seed = window.coretgEnsureSeedForScenario(scenario);
          }
        } catch(e) { seed = null; }
        const persisted = await window.coretgPostJson('/api/planner/ensure_plan', { xml_path: xmlPath, scenario, seed });
        try {
          if (scenario && persisted && persisted.seed !== undefined && typeof window.coretgSetSeedForScenario === 'function') {
            window.coretgSetSeedForScenario(scenario, persisted.seed);
          }
        } catch(e) {}
        const previewPlan = (persisted && persisted.preview_plan_path) ? String(persisted.preview_plan_path) : '';
        if(!previewPlan){
          throw new Error('Failed to persist preview plan');
        }
        try {
          if (scenario && typeof window.coretgSetPreviewPlanPathForScenario === 'function') {
            window.coretgSetPreviewPlanPathForScenario(scenario, previewPlan);
          }
        } catch(e) {}
        try {
          if (scenario && typeof window.coretgSetPreviewPlanPathForScenario === 'function') {
            window.coretgSetPreviewPlanPathForScenario(scenario, previewPlan);
          }
        } catch(e) {}
        lastPreviewPlanPath = previewPlan;
        params.delete('preview_plan');
      }

      let data;
      let retriesRemaining = 0;
      try{
        if(generateMaxRetriesEl){
          retriesRemaining = Math.max(0, Math.min(50, parseInt(generateMaxRetriesEl.value || '0', 10) || 0));
        }
      } catch(e) { retriesRemaining = 0; }
      let attemptedRetries = 0;
      let retryIndex = 0;
      const _resolvedFlagValue = (fa) => {
        try{
          if(fa && typeof fa.flag_value === 'string' && fa.flag_value.trim()) return fa.flag_value.trim();
        } catch(e) {}
        try{
          const ro = (fa && typeof fa.resolved_outputs === 'object' && fa.resolved_outputs && !Array.isArray(fa.resolved_outputs)) ? fa.resolved_outputs : null;
          if(ro){
            const rf = ro['Flag(flag_id)'] || ro['flag'] || ro['FLAG'] || '';
            if(typeof rf === 'string' && rf.trim()) return rf.trim();
          }
        } catch(e) {}
        return '';
      };
      const _hasDuplicates = (chain, assigns) => {
        try{
          const nodeIds = chain.map(n => String((n && n.id) || '').trim()).filter(Boolean);
          if(new Set(nodeIds).size !== nodeIds.length) return true;
          const flags = assigns.map(a => _resolvedFlagValue(a)).filter(Boolean);
          if(new Set(flags).size !== flags.length) return true;
        } catch(e) {}
        return false;
      };
      const _isDuplicateFlagError = (err) => {
        try{
          const msg = String(err && err.message || '').toLowerCase();
          if(msg.includes('duplicate flag')) return true;
        } catch(e) {}
        try{
          const payload = err && err.payload;
          if(payload && Array.isArray(payload.generation_failures)){
            return payload.generation_failures.some((x)=>{
              const em = String((x && x.error) || '').toLowerCase();
              return em.includes('duplicate flag');
            });
          }
        } catch(e) {}
        return false;
      };
      while(true){
        try{
          if(!allowDupes){
            params.set('retry_index', String(retryIndex));
          }
          if(runSavePreviewResolve){
            setStatus('Sequencing chain…', false);
            showLoading('Sequencing chain…');
            setLoadingSteps(progressSteps, 2);
            appendLoadingLog(`Sequencing attempt ${retryIndex + 1}`);
            data = await postJson('/api/flag-sequencing/sequence_preview_plan', {
              scenario,
              length,
              preset,
              preview_plan: previewPlanForRequest(),
              allow_node_duplicates: !!allowDupes,
              retry_index: retryIndex,
              xml_path: (typeof window.coretgGetLatestXmlPathForScenario === 'function') ? window.coretgGetLatestXmlPathForScenario(scenario) : '',
              initial_facts: flowInitialFactsOverride,
              goal_facts: flowGoalFactsOverride,
            }, { timeoutMs: 60000 });
          } else {
            data = await fetchJson(buildAttackflowPreviewUrl(params));
          }
          if(!allowDupes){
            const chainData = Array.isArray(data && data.chain) ? data.chain : [];
            let assignsData = Array.isArray(data && data.flag_assignments) ? data.flag_assignments : [];
            try { assignsData = alignAssignmentsToChain(chainData, assignsData); } catch(e) {}
            if(_hasDuplicates(chainData, assignsData)){
              if(retriesRemaining > 0){
                attemptedRetries += 1;
                retriesRemaining -= 1;
                retryIndex += 1;
                setStatus(`Generate produced duplicates; retrying (${attemptedRetries})…`, true);
                showLoading('Retrying generate…');
                appendLoadingLog(`Retrying (${attemptedRetries}) due to duplicates in chain`);
                continue;
              }
            }
          }
          try{
            if(data && data.warning){
              const okReuse = shouldAllowGeneratorReuse(data.warning);
              if(!okReuse){
                clearFlowState('Generation cancelled (generator reuse declined).');
                hideLoading();
                return;
              }
            }
          } catch(e) {}
          break;
        } catch(err){
          // If Generate requested a longer chain than available, ask user whether to
          // retry in best-effort mode (clamp to available) or cancel.
          const offer = usePreview ? shouldOfferBestEffort(err) : null;
          if(offer){
            appendLoadingLog(`Eligible nodes: ${offer.available}; requested ${offer.requested || length}`);
            const want = confirm(`Only ${offer.available} eligible nodes are available for this scenario.\n\nRun Generate in best-effort mode (use ${offer.available})?`);
            if(!want){
              hideLoading();
              setStatus('Generate cancelled.', false);
              return;
            }
            if(runSavePreviewResolve){
              appendLoadingLog(`Retrying best-effort length ${offer.available}`);
              data = await postJson('/api/flag-sequencing/sequence_preview_plan', {
                scenario,
                length,
                preset,
                preview_plan: previewPlanForRequest(),
                allow_node_duplicates: !!allowDupes,
                best_effort: true,
                xml_path: (typeof window.coretgGetLatestXmlPathForScenario === 'function') ? window.coretgGetLatestXmlPathForScenario(scenario) : '',
                initial_facts: flowInitialFactsOverride,
                goal_facts: flowGoalFactsOverride,
              }, { timeoutMs: 60000 });
            } else {
              const params2 = new URLSearchParams(params.toString());
              params2.set('best_effort', '1');
              const retryUrl = buildAttackflowPreviewUrl(params2);
              data = await fetchJson(retryUrl);
            }
            usedBestEffort = true;
            break;
          }

          if(retriesRemaining > 0){
            attemptedRetries += 1;
            retriesRemaining -= 1;
            retryIndex += 1;
            setStatus(`Generate failed; retrying (${attemptedRetries})…`, true);
            showLoading('Retrying generate…');
            appendLoadingLog(`Retrying (${attemptedRetries}) after error: ${String(err && err.message || err)}`);
            continue;
          }

          const reduce = confirm('Generate failed after retries. Reduce chain length and retry?');
          if(reduce){
            const nextLenRaw = prompt('New chain length:', String(Math.max(1, (parseInt(length, 10) || 1) - 1)));
            const nextLen = parseInt(nextLenRaw || '', 10);
            if(Number.isFinite(nextLen) && nextLen > 0){
              length = Math.max(1, Math.min(50, nextLen));
              if(lengthEl) lengthEl.value = String(length);
              params.set('length', String(length));
              retriesRemaining = 0;
              attemptedRetries = 0;
              retryIndex = 0;
              appendLoadingLog(`Reduced chain length to ${length} and retrying`);
              continue;
            }
          }
          throw err;
        }
      }
      currentChain = Array.isArray(data.chain) ? data.chain.slice() : [];
      currentFlagAssignments = Array.isArray(data.flag_assignments) ? data.flag_assignments.slice() : [];
      currentFlagAssignments = alignAssignmentsToChain(currentChain, currentFlagAssignments);
      if(!runSavePreviewResolve){
        const fs = getFlowStateForScenario(scenario);
        if(fs){
          mergeResolvedFromFlowState(fs, currentChain);
          showRestoreBadge('Restored saved flow state');
        } else {
          mergeResolvedFromSavedState(scenario, currentChain);
        }
      }
      currentFlagAssignments = alignAssignmentsToChain(currentChain, currentFlagAssignments);
      setFlowValidityFromPayload(data);
      lastStats = data.stats || null;
      lastPreviewPlanPath = data.preview_plan_path || '';
      try {
        const summary = summarizeChainForLog(currentChain, currentFlagAssignments);
        appendLoadingLog(summary.chain);
        appendLoadingLog(summary.gens);
      } catch(e) {}
      try {
        if (scenario && lastPreviewPlanPath && typeof window.coretgSetPreviewPlanPathForScenario === 'function') {
          window.coretgSetPreviewPlanPathForScenario(scenario, lastPreviewPlanPath);
        }
      } catch(e) {}
      // flow_plan_path no longer used
      try {
        // If the backend loaded a saved chain whose effective length differs from the
        // current input value (e.g. page reload reset to default), keep the UI in sync.
        const effLen = Number.isFinite(+data.length) ? (+data.length) : null;
        if (effLen !== null && lengthEl) lengthEl.value = String(effLen);
      } catch(e) {}
      updateMeta();
      selectedChainIndex = -1;
      renderChainEditor();
      persistFlowState();

      // Resolve values immediately after sequencing so hints/IPs/flags appear on this page.
      if(resolveOnGenerate && Array.isArray(currentChain) && currentChain.length){
        let resolved = false;
        let resolveAttempts = 0;
        let resolveRetriesRemaining = Math.max(0, retriesRemaining || 0);
        while(!resolved){
          resolveAttempts += 1;
          try{
            setStatus('Resolving values…', false);
            showLoading('Resolving values…');
            setLoadingSteps(['Saving XML', 'Generating preview plan', 'Sequencing chain', 'Resolving values'], 3);
            appendLoadingLog(`Resolving values via prepare_preview_for_execute (attempt ${resolveAttempts})`);
            const chain_ids = currentChain.map(n => (n && n.id) ? String(n.id) : '').filter(Boolean);
            const prepData = await postJson(
              '/api/flag-sequencing/prepare_preview_for_execute',
              {
                scenario,
                length: chain_ids.length,
                preset,
                chain_ids: chain_ids,
                preview_plan: previewPlanForRequest(),
                allow_node_duplicates: !!allowDupes,
                mode: 'resolve',
                best_effort: true,
                timeout_s: 120,
                initial_facts: flowInitialFactsOverride,
                goal_facts: flowGoalFactsOverride,
              },
              { timeoutMs: 120000 }
            );
            lastResolvePayload = prepData;
            setFlowValidityFromPayload(prepData);
            if(prepData && Array.isArray(prepData.chain)){
              currentChain = prepData.chain.slice();
            }
            if(prepData && Array.isArray(prepData.flag_assignments)){
              currentFlagAssignments = prepData.flag_assignments.slice();
            try{
              if(prepData && prepData.warning){
                const okReuse = shouldAllowGeneratorReuse(prepData.warning);
                if(!okReuse){
                  clearFlowState('Resolve cancelled (generator reuse declined).');
                  hideLoading();
                  break;
                }
              }
            } catch(e) {}
              currentFlagAssignments = alignAssignmentsToChain(currentChain, currentFlagAssignments);
            }
            if(prepData && prepData.preview_plan_path){
              lastPreviewPlanPath = String(prepData.preview_plan_path);
              try {
                if (scenario && typeof window.coretgSetPreviewPlanPathForScenario === 'function') {
                  window.coretgSetPreviewPlanPathForScenario(scenario, lastPreviewPlanPath);
                }
              } catch(e) {}
            }
            // flow_plan_path no longer used
            updateMeta();
            renderChainEditor();
            try {
              let resolvedInputsCount = 0;
              let resolvedOutputsCount = 0;
              for(const a of (currentFlagAssignments || [])){
                if(a && typeof a === 'object'){
                  const ri = (a.resolved_inputs && typeof a.resolved_inputs === 'object' && !Array.isArray(a.resolved_inputs)) ? Object.keys(a.resolved_inputs).length : 0;
                  const ro = (a.resolved_outputs && typeof a.resolved_outputs === 'object' && !Array.isArray(a.resolved_outputs)) ? Object.keys(a.resolved_outputs).length : 0;
                  resolvedInputsCount += ri;
                  resolvedOutputsCount += ro;
                }
              }
              appendLoadingLog(`Resolved inputs: ${resolvedInputsCount}, outputs: ${resolvedOutputsCount}`);
              if(resolvedInputsCount === 0 && resolvedOutputsCount === 0){
                setStatus('Resolve completed, but no resolved values were returned.', true);
              }
            } catch(e) {}
            if(jsonEl){
              jsonEl.textContent = JSON.stringify({
                scenario: (prepData && prepData.scenario) ? prepData.scenario : (activeScenario || scenario),
                length: (prepData && Number.isFinite(+prepData.length)) ? (+prepData.length) : (Array.isArray(currentChain) ? currentChain.length : 0),
                chain: Array.isArray(currentChain) ? currentChain : [],
                flag_assignments: Array.isArray(currentFlagAssignments) ? currentFlagAssignments : [],
                flow_valid: !!(prepData && prepData.flow_valid),
                flow_errors: Array.isArray(prepData && prepData.flow_errors) ? prepData.flow_errors : [],
                flags_enabled: !!(prepData && prepData.flags_enabled),
              }, null, 2);
            }
            const diagram2 = buildMermaid(currentChain);
            await renderMermaid(diagram2);
            resolved = true;
          } catch(e) {
            if(_isDuplicateFlagError(e) && resolveRetriesRemaining > 0){
              resolveRetriesRemaining -= 1;
              attemptedRetries += 1;
              retryIndex += 1;
              setStatus(`Resolve hit duplicate flags; retrying (${attemptedRetries})…`, true);
              showLoading('Retrying resolve…');
              appendLoadingLog(`Duplicate flags during resolve; resequencing attempt ${retryIndex + 1}`);
              const data2 = await postJson('/api/flag-sequencing/sequence_preview_plan', {
                scenario,
                length,
                preset,
                preview_plan: previewPlanForRequest(),
                allow_node_duplicates: !!allowDupes,
                retry_index: retryIndex,
                xml_path: (typeof window.coretgGetLatestXmlPathForScenario === 'function') ? window.coretgGetLatestXmlPathForScenario(scenario) : '',
                initial_facts: flowInitialFactsOverride,
                goal_facts: flowGoalFactsOverride,
              }, { timeoutMs: 60000 });
              currentChain = Array.isArray(data2.chain) ? data2.chain.slice() : [];
              currentFlagAssignments = Array.isArray(data2.flag_assignments) ? data2.flag_assignments.slice() : [];
              currentFlagAssignments = alignAssignmentsToChain(currentChain, currentFlagAssignments);
              setFlowValidityFromPayload(data2);
              lastStats = data2.stats || null;
              lastPreviewPlanPath = data2.preview_plan_path || '';
              updateMeta();
              renderChainEditor();
              continue;
            }
            try{
              const payload = e && e.payload ? e.payload : null;
              const msg = String((payload && (payload.error || payload.message)) || (e && e.message) || e || 'Resolve failed');
              appendLoadingLog(`Resolve error: ${msg}`);
              if(payload && payload.flag_assignments && Array.isArray(payload.flag_assignments)){
                const ids = payload.flag_assignments.map(a => String((a && (a.id || a.generator_id)) || '').trim()).filter(Boolean);
                if(ids.length){
                  appendLoadingLog(`Generators: ${ids.join(', ')}`);
                }
              }
            } catch(_) {}
            setStatus('Resolve failed: ' + String(e && e.message || e), true);
            break;
          }
        }
      }

      // Persist the generated chain so hard refresh restores it (best-effort).
      try{
        const scenario = (scenarioEl && scenarioEl.value || '').trim();
        const chain_ids = Array.isArray(currentChain) ? currentChain.map(n => (n && n.id) ? String(n.id) : '').filter(Boolean) : [];
        if(scenario && chain_ids.length && typeof window.coretgSetSavedFlowStateForScenario === 'function'){
          window.coretgSetSavedFlowStateForScenario(scenario, {
            preset,
            length: chain_ids.length,
            chain_ids: chain_ids,
            flag_assignments: buildPersistAssignments(chain_ids),
            allow_node_duplicates: !!allowNodeDuplicates,
            initial_facts: flowInitialFactsOverride,
            goal_facts: flowGoalFactsOverride,
          });
        }
      } catch(e) {}

      if(jsonEl){
        jsonEl.textContent = JSON.stringify({
          scenario: (data && data.scenario) ? data.scenario : activeScenario,
          length: (data && Number.isFinite(+data.length)) ? (+data.length) : (Array.isArray(currentChain) ? currentChain.length : 0),
          chain: Array.isArray(currentChain) ? currentChain : [],
          flag_assignments: Array.isArray(currentFlagAssignments) ? currentFlagAssignments : [],
          flow_valid: !!(data && data.flow_valid),
          flow_errors: Array.isArray(data && data.flow_errors) ? data.flow_errors : [],
          flags_enabled: !!(data && data.flags_enabled),
        }, null, 2);
      }
      try {
        if(lastResolvePayload){
          const chain_ids = currentChain.map(n => (n && n.id) ? String(n.id) : '').filter(Boolean);
          const flowStatePayload = {
            scenario,
            preset,
            length: chain_ids.length,
            chain_ids: chain_ids,
            flag_assignments: buildPersistAssignments(chain_ids),
            allow_node_duplicates: !!allowNodeDuplicates,
            initial_facts: flowInitialFactsOverride,
            goal_facts: flowGoalFactsOverride,
            updated_at: Date.now(),
          };
          let xmlPath = (lastResolvePayload && lastResolvePayload.xml_path) ? String(lastResolvePayload.xml_path) : (document.getElementById('scenariosPreviewXmlPath')?.value || '').trim();
          if(!xmlPath && typeof window.coretgGetLatestXmlPathForScenario === 'function'){
            try {
              xmlPath = String(window.coretgGetLatestXmlPathForScenario(scenario) || '').trim();
            } catch(e) {}
          }
          if(xmlPath){
            await postJson('/api/flag-sequencing/save_flow_state_to_xml', {
              xml_path: xmlPath,
              scenario,
              flow_state: flowStatePayload,
            });
          }
          try{
            const key = normalizeScenarioNorm(scenario);
            if(key && flowStateByScenario && typeof flowStateByScenario === 'object'){
              flowStateByScenario[key] = flowStatePayload;
            }
          } catch(e) {}
        }
      } catch(e) {}
      const diagram = buildMermaid(currentChain);
      await renderMermaid(diagram);

      // New flow: no automatic resolve step on Generate.

      setStatus('Ready.', false);
    } catch(err){
      setStatus(String(err && err.message || err), true);
      setLoginLinkVisible(!!(err && err.loginRequired));
      const payload = err && err.payload ? err.payload : null;
      setFlowValidityFromPayload(payload);
      lastStats = payload && payload.stats ? payload.stats : null;
      lastPreviewPlanPath = payload && payload.preview_plan_path ? String(payload.preview_plan_path) : '';
      // flow_plan_path no longer used
      updateMeta();
      currentChain = [];
      currentFlagAssignments = [];
      selectedChainIndex = -1;
      renderChainEditor();
      const diagram = buildMermaid([]);
      await renderMermaid(diagram);
    } finally {
      hideLoading();
    }
  }

  async function execute(){
    const scenario = (scenarioEl && scenarioEl.value || '').trim();
    const preset = (presetEl && presetEl.value) ? String(presetEl.value).trim() : '';
    const length = (Array.isArray(currentChain) && currentChain.length) ? currentChain.length : (parseInt((lengthEl && lengthEl.value) || '5', 10) || 5);
    if(!scenario){
      setStatus('No scenario selected.', true);
      return;
    }
    // If the shared Execute button is gated (CORE VM not verified), it won't be clickable,
    // but keep this guard anyway in case something calls execute() programmatically.
    if(execEl && execEl.disabled){
      setStatus('Verify a CORE VM in VM / Access to enable Execute.', true);
      return;
    }
    if(execEl) execEl.disabled = true;
    setStatus('Preparing preview for execution…', false);
    setLoginLinkVisible(false);
    showLoading('Resolving hint values…');
    try{
      if(!Array.isArray(currentChain) || currentChain.length === 0){
        throw new Error('Generate a chain first.');
      }
      const chain_ids = currentChain.map(n => (n && n.id) ? String(n.id) : '').filter(Boolean);
      const planPath = '';
      const prepData = await postJson(
        '/api/flag-sequencing/prepare_preview_for_execute',
        {
          scenario,
          length,
          preset,
          chain_ids: chain_ids,
          preview_plan: previewPlanForRequest(),
          allow_node_duplicates: !!allowNodeDuplicates,
        },
        { timeoutMs: 480000 }
      );
      setFlowValidityFromPayload(prepData);
      // Prefer server-returned (possibly enriched) assignments so the UI can show
      // generator run status/mismatch info before scenario execution.
      if(prepData && Array.isArray(prepData.flag_assignments)){
        currentFlagAssignments = prepData.flag_assignments.slice();
        renderChainEditor();
      }
      const xmlPath = (prepData && prepData.xml_path) ? String(prepData.xml_path) : '';
      const previewPlan = (prepData && prepData.preview_plan_path) ? String(prepData.preview_plan_path) : '';
      if(!xmlPath || !previewPlan){
        throw new Error('Prepare step did not return xml_path/preview_plan_path');
      }
      setStatus('Starting async execution…', false);
      const runData = await postJson('/run_cli_async', { xml_path: xmlPath, preview_plan: previewPlan, scenario });
      const runId = runData && runData.run_id ? String(runData.run_id) : '';
      if(runId){
        setStatus('Run started: ' + runId + ' (see Core/Reports pages).', false);
      } else {
        setStatus('Run started (missing run_id).', false);
      }
    } catch(err){
      setStatus(String(err && err.message || err), true);
      setLoginLinkVisible(!!(err && err.loginRequired));
    } finally {
      hideLoading();
      try {
        if (typeof window.coretgRefreshScenariosExecuteButtonState === 'function') {
          window.coretgRefreshScenariosExecuteButtonState();
        } else if (execEl) {
          execEl.disabled = false;
        }
      } catch (e) {
        if (execEl) execEl.disabled = false;
      }
    }
  }

  async function preview(){
    // Save XML, persist a preview plan, persist flow sequencing, then redirect to Preview.
    try {
      const scenario = (scenarioEl && scenarioEl.value || '').trim();
      if(!scenario){
        setStatus('No scenario selected.', true);
        return;
      }
      persistFlowState();
      if(typeof window.coretgSaveXmlViaApi !== 'function' || typeof window.coretgPostJson !== 'function'){
        setStatus('Save helper unavailable; refresh and try again.', true);
        return;
      }

      if(execEl) execEl.disabled = true;
      setStatus('Saving XML…', false);
      showLoading('Saving XML…');
      const xmlPath = await window.coretgSaveXmlViaApi({ persistPreviewPlan: false });
      if(!xmlPath){
        throw new Error('Save did not return xml_path');
      }

      // Persist chain + assignments into the plan so Preview can render sequence numerals.
      try {
        const chain_ids = Array.isArray(currentChain) ? currentChain.map(n => (n && n.id) ? String(n.id) : '').filter(Boolean) : [];
        const assignments = chain_ids.length ? buildPersistAssignments(chain_ids) : [];
        const missingGen = assignments.some(a => !a || !a.id || !String(a.id).trim());
        if(chain_ids.length && !missingGen){
          await postJson('/api/flag-sequencing/save_flow_substitutions', {
            scenario,
            chain_ids: chain_ids,
            preview_plan: previewPlanForRequest(),
            flag_assignments: assignments,
            allow_node_duplicates: !!allowNodeDuplicates,
            initial_facts: flowInitialFactsOverride,
            goal_facts: flowGoalFactsOverride,
          }, { timeoutMs: 60000 });
        }
      } catch(e) {
        try { console.warn('Failed to persist flow substitutions before preview', e); } catch(_e) {}
      }

      // Navigate to Preview tab.
      const baseUrl = String(document.getElementById('scenariosPreviewTabLink')?.dataset?.previewBaseUrl || '/scenarios/preview');
      const url = baseUrl + '?xml_path=' + encodeURIComponent(xmlPath) + '&scenario=' + encodeURIComponent(scenario);
      window.location.href = url;
    } catch(e) {
      setStatus('Preview failed: ' + String(e && e.message || e), true);
    } finally {
      hideLoading();
      try {
        if (typeof window.coretgRefreshScenariosExecuteButtonState === 'function') {
          window.coretgRefreshScenariosExecuteButtonState();
        } else if (execEl) {
          execEl.disabled = false;
        }
      } catch (e) {
        if (execEl) execEl.disabled = false;
      }
    }
  }

  async function saveXmlStay(){
    try {
      persistFlowState();
      if(typeof window.coretgSaveXmlViaApi !== 'function'){
        setStatus('Save helper unavailable; refresh and try again.', true);
        return;
      }
      if(saveXmlEl) saveXmlEl.disabled = true;
      showLoading('Saving XML…');

      const scenario = (scenarioEl && scenarioEl.value || activeScenario || '').trim();
      const preset = (presetEl && presetEl.value) ? String(presetEl.value).trim() : '';
      const length = (Array.isArray(currentChain) && currentChain.length) ? currentChain.length : (parseInt((lengthEl && lengthEl.value) || '5', 10) || 5);

      const xmlPath = await window.coretgSaveXmlViaApi({ persistPreviewPlan: false });
      if(xmlPath){
        let hintResolveFailed = false;
        try {
          const xmlPathInput = document.getElementById('scenariosPreviewXmlPath');
          if(xmlPathInput) xmlPathInput.value = String(xmlPath);
        } catch(e) {}
        try {
          if(downloadXmlEl){
            downloadXmlEl.disabled = false;
            downloadXmlEl.removeAttribute('title');
          }
        } catch(e) {}

        if(!hintResolveFailed){
          setStatus('Saved XML: ' + basenameFromPath(xmlPath), false);
        }
        try { await refreshXmlDockPreview({ force: true }); } catch(e) {}
      } else {
        setStatus('Saved XML (missing path).', false);
      }
    } catch(e){
      setStatus('Save failed: ' + String(e && e.message || e), true);
    } finally {
      hideLoading();
      if(saveXmlEl) saveXmlEl.disabled = false;
    }
  }

  // Bottom-bar buttons: Save XML saves and stays; Preview saves then redirects.
  document.addEventListener('DOMContentLoaded', () => {
    try {
      if(saveXmlEl){
        saveXmlEl.addEventListener('click', (ev) => {
          try { ev.preventDefault(); } catch(e) {}
          saveXmlStay();
        });
      }
    } catch(e) {}
    try {
      if(execEl){
        execEl.addEventListener('click', (ev) => {
          try { ev.preventDefault(); } catch(e) {}
          preview();
        });
      }
    } catch(e) {}
  });

  async function saveXmlOnly(opts){
    const options = (opts && typeof opts === 'object') ? opts : {};
    const scenario = (scenarioEl && scenarioEl.value || '').trim();
    const preset = (presetEl && presetEl.value) ? String(presetEl.value).trim() : '';
    const length = (Array.isArray(currentChain) && currentChain.length) ? currentChain.length : (parseInt((lengthEl && lengthEl.value) || '5', 10) || 5);
    if(!scenario){
      setStatus('No scenario selected.', true);
      return '';
    }
    if(saveXmlEl) saveXmlEl.disabled = true;
    setStatus('Saving XML…', false);
    setLoginLinkVisible(false);
    showLoading('Saving XML…');
    try{
      const xmlPath = await window.coretgSaveXmlViaApi();
      if(!xmlPath){
        throw new Error('Save did not return xml_path');
      }
      updateMeta();
      try {
        const xmlPathInput = document.getElementById('scenariosPreviewXmlPath');
        if(xmlPathInput) xmlPathInput.value = xmlPath;
      } catch(e) {}
      try {
        if(downloadXmlEl){
          downloadXmlEl.disabled = false;
          downloadXmlEl.removeAttribute('title');
        }
      } catch(e) {}
      setStatus('Saved XML: ' + basenameFromPath(xmlPath), false);
      try { await refreshXmlDockPreview({ force: true }); } catch(e) {}
      return xmlPath;
    } catch(err){
      setStatus(String(err && err.message || err), true);
      setLoginLinkVisible(!!(err && err.loginRequired));
      // If preview requested, surface failure by throwing so caller does not redirect.
      if (options && options.redirectAfter) throw err;
      return '';
    } finally {
      hideLoading();
      if(saveXmlEl) saveXmlEl.disabled = false;
    }
  }

  function downloadXml(){
    try {
      const xmlPath = (document.getElementById('scenariosPreviewXmlPath')?.value || '').trim();
      if(!xmlPath){
        setStatus('Save XML first to download.', true);
        return;
      }
      window.location.href = '/download_report?path=' + encodeURIComponent(xmlPath);
    } catch(err){
      setStatus(String(err && err.message || err), true);
    }
  }

  // Expose a mermaid click callback; it receives the nodeId like "N0".
  window.flowSelectNode = function(nodeId){
    try{
      const m = String(nodeId || '').match(/^N(\d+)$/);
      if(!m) return;
      const idx = parseInt(m[1], 10);
      if(Number.isFinite(idx)){
        selectChainIndex(idx);
        openNodeDetailsDialog(idx);
      }
    } catch(e) {}
  };

  // Allow clicking the backdrop to close the node dialog.
  try{
    if(nodeDetailsDialogEl){
      nodeDetailsDialogEl.addEventListener('click', (ev)=>{
        try {
          if(ev && ev.target === nodeDetailsDialogEl && typeof nodeDetailsDialogEl.close === 'function'){
            nodeDetailsDialogEl.close();
          }
        } catch(e) {}
      });
    }
  } catch(e) {}

  // Generate options dialog.
  try{
    if(generateOptionsDialogEl){
      try{
        if(generateNoDuplicatesEl){
          generateNoDuplicatesEl.checked = !!allowNodeDuplicates;
        }
      } catch(e) {}
      generateOptionsDialogEl.addEventListener('close', ()=>{
        try{
          const rv = String(generateOptionsDialogEl.returnValue || '');
          if(rv !== 'generate') return;
          const allowDupes = generateNoDuplicatesEl ? !!generateNoDuplicatesEl.checked : false;
          allowNodeDuplicates = !!allowDupes;
          generate(true, { savePreviewResolve: true, allow_node_duplicates: !!allowNodeDuplicates, resolveOnGenerate: true });
        } catch(e) {}
      });
    }
  } catch(e) {}

  if(btnEl) btnEl.addEventListener('click', (e)=>{
    try { e.preventDefault(); } catch(_) {}
    try{
      if(generateOptionsDialogEl && typeof generateOptionsDialogEl.showModal === 'function'){
        generateOptionsDialogEl.showModal();
        return;
      }
    } catch(_) {}
    // Fallback: behave like old Generate (no duplicates).
    allowNodeDuplicates = false;
    generate(true, { savePreviewResolve: true, allow_node_duplicates: false, resolveOnGenerate: true });
  });
  // Handlers for Save/Preview are registered above.
  if(downloadXmlEl) downloadXmlEl.addEventListener('click', (e)=>{ e.preventDefault(); downloadXml(); });

  if(downloadAfbLink){
    downloadAfbLink.addEventListener('click', async (e)=>{
      try{
        e.preventDefault();
        if(!Array.isArray(currentChain) || currentChain.length === 0){
          setStatus('Nothing to download yet (generate first).', true);
          return;
        }

        // Keep UI validity state in sync before exporting.
        try{ await refreshAssignmentsFromChain(); } catch(err) {}

        setStatus('Building .afb…', false);
        const data = await postJson('/api/flag-sequencing/afb_from_chain', { scenario: activeScenario, chain: currentChain });
        setFlowValidityFromPayload(data);
        const afb = data && data.afb ? data.afb : null;
        if(!afb){
          setStatus('No .afb returned by server.', true);
          return;
        }
        const scenario = (scenarioEl && scenarioEl.value || activeScenario || 'scenario').toString().trim();
        const norm = normalizeScenarioNorm(scenario).replace(/\s+/g,'_') || 'scenario';
        const fname = 'attackflow_builder_' + norm + '_' + String(Array.isArray(currentChain)?currentChain.length:0) + '.afb';
        const blob = new Blob([JSON.stringify(afb, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = fname;
        document.body.appendChild(a);
        a.click();
        a.remove();
        setTimeout(()=>URL.revokeObjectURL(url), 1000);
        setStatus('Ready.', false);
      } catch(err){
        setStatus(String(err && err.message || err), true);
      }
    });
  }

  if(downloadAttackGraphJsonLink){
    downloadAttackGraphJsonLink.addEventListener('click', async (e)=>{
      try{
        e.preventDefault();
        if(!Array.isArray(currentChain) || currentChain.length === 0){
          setStatus('Nothing to download yet (generate first).', true);
          return;
        }

        // Keep UI validity state in sync before exporting.
        try{ await refreshAssignmentsFromChain(); } catch(err) {}

        setStatus('Building attack graph…', false);
        const data = await postJson('/api/flag-sequencing/afb_from_chain', { scenario: activeScenario, chain: currentChain });
        setFlowValidityFromPayload(data);
        const graph = data && data.attack_graph ? data.attack_graph : null;
        if(!graph){
          setStatus('No attack graph returned by server.', true);
          return;
        }
        const scenario = (scenarioEl && scenarioEl.value || activeScenario || 'scenario').toString().trim();
        const norm = normalizeScenarioNorm(scenario).replace(/\s+/g,'_') || 'scenario';
        const fname = 'attack_graph_' + norm + '_' + String(Array.isArray(currentChain)?currentChain.length:0) + '.json';
        const blob = new Blob([JSON.stringify(graph, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = fname;
        document.body.appendChild(a);
        a.click();
        a.remove();
        setTimeout(()=>URL.revokeObjectURL(url), 1000);
        setStatus('Ready.', false);
      } catch(err){
        setStatus(String(err && err.message || err), true);
      }
    });
  }

  if(downloadAttackGraphDotLink){
    downloadAttackGraphDotLink.addEventListener('click', async (e)=>{
      try{
        e.preventDefault();
        if(!Array.isArray(currentChain) || currentChain.length === 0){
          setStatus('Nothing to download yet (generate first).', true);
          return;
        }

        // Keep UI validity state in sync before exporting.
        try{ await refreshAssignmentsFromChain(); } catch(err) {}

        setStatus('Building attack graph (.dot)…', false);
        const data = await postJson('/api/flag-sequencing/afb_from_chain', { scenario: activeScenario, chain: currentChain });
        setFlowValidityFromPayload(data);
        const dot = data && data.attack_graph_dot ? String(data.attack_graph_dot) : '';
        if(!dot){
          setStatus('No attack graph .dot returned by server.', true);
          return;
        }
        const scenario = (scenarioEl && scenarioEl.value || activeScenario || 'scenario').toString().trim();
        const norm = normalizeScenarioNorm(scenario).replace(/\s+/g,'_') || 'scenario';
        const fname = 'attack_graph_' + norm + '_' + String(Array.isArray(currentChain)?currentChain.length:0) + '.dot';
        const blob = new Blob([dot], { type: 'text/vnd.graphviz' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = fname;
        document.body.appendChild(a);
        a.click();
        a.remove();
        setTimeout(()=>URL.revokeObjectURL(url), 1000);
        setStatus('Ready.', false);
      } catch(err){
        setStatus(String(err && err.message || err), true);
      }
    });
  }

  if(downloadAttackGraphPdfLink){
    downloadAttackGraphPdfLink.addEventListener('click', async (e)=>{
      try{
        e.preventDefault();
        if(!Array.isArray(currentChain) || currentChain.length === 0){
          setStatus('Nothing to download yet (generate first).', true);
          return;
        }

        // Keep UI validity state in sync before exporting.
        try{ await refreshAssignmentsFromChain(); } catch(err) {}

        setStatus('Building attack graph (.pdf)…', false);
        const data = await postJson('/api/flag-sequencing/afb_from_chain', { scenario: activeScenario, chain: currentChain });
        setFlowValidityFromPayload(data);
        const b64 = data && data.attack_graph_pdf_base64 ? String(data.attack_graph_pdf_base64) : '';
        if(!b64){
          setStatus('Attack graph PDF unavailable (Graphviz not installed).', true);
          return;
        }
        const scenario = (scenarioEl && scenarioEl.value || activeScenario || 'scenario').toString().trim();
        const norm = normalizeScenarioNorm(scenario).replace(/\s+/g,'_') || 'scenario';
        const fname = 'attack_graph_' + norm + '_' + String(Array.isArray(currentChain)?currentChain.length:0) + '.pdf';
        const bin = Uint8Array.from(atob(b64), c => c.charCodeAt(0));
        const blob = new Blob([bin], { type: 'application/pdf' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = fname;
        document.body.appendChild(a);
        a.click();
        a.remove();
        setTimeout(()=>URL.revokeObjectURL(url), 1000);
        setStatus('Ready.', false);
      } catch(err){
        setStatus(String(err && err.message || err), true);
      }
    });
  }

  // Wire scenario list.
  if(scenarioListEl){
    scenarioListEl.querySelectorAll('[data-scen-name]').forEach(btn => {
      btn.addEventListener('click', async ()=>{
        const name = btn.getAttribute('data-scen-name') || '';
        if(!name || name === activeScenario) return;
        await setScenario(name);
      });
    });
  }
  if(clearScenarioBtn){
    clearScenarioBtn.addEventListener('click', async ()=>{
      const def = defaultScenarioName();
      if(def && def !== activeScenario) await setScenario(def);
    });
  }

  // Auto-generate on load (per-scenario page). If there are no scenarios, disable.
  if(!activeScenario){
    setStatus('No scenarios available yet.', true);
    if(btnEl) btnEl.disabled = true;
    return;
  }
  if(scenarioEl && !scenarioEl.value) scenarioEl.value = activeScenario;
  if(scenarioLabelEl && !scenarioLabelEl.textContent) scenarioLabelEl.textContent = activeScenario;
  updateScenarioQueryParam();
  updateScenarioFilterControls();
  refreshParticipantNavForScenario(activeScenario);
  rememberActiveScenario();
  if(seedToggleBtn && !seedToggleBtn.dataset.boundSeedToggle){
    seedToggleBtn.addEventListener('click', (ev)=>{
      try { ev.preventDefault(); } catch(e) {}
      const next = !getSidebarShowSeed();
      setSidebarShowSeed(next);
      updateScenarioSeedBadges();
    });
    seedToggleBtn.dataset.boundSeedToggle = '1';
  }
  updateScenarioSeedBadges();
  // Auto-generate on load (prefer any saved Flow state).
  try { refreshXmlDockPreview({ force: false }); } catch(e) {}
  try {
    const xmlPath = (document.getElementById('scenariosPreviewXmlPath')?.value || '').trim();
    if(xmlPath && !isAutosaveXmlPath(xmlPath) && typeof window.coretgSetLatestXmlPathForScenario === 'function'){
      window.coretgSetLatestXmlPathForScenario(activeScenario, xmlPath);
    }
  } catch(e) {}
  clearPreviewPlanCacheForScenario(activeScenario);
  await refreshLatestPreviewPlanPathForScenario(activeScenario);
  const restored = await restoreSavedFlowForScenario(activeScenario);
  if(!restored){
    try {
      await generate(false, { autoLoad: true, resolveOnGenerate: false });
    } catch(e) {
      setStatus('No saved flow chain. Click Generate to start.', false);
    }
  }
})();
</script>
{% endblock %}
  // Scenarios header Preview tab: route to /scenarios/preview.
  document.addEventListener('DOMContentLoaded', ()=>{
    const link = document.getElementById('scenariosPreviewTabLink');
    if(!link) return;
    link.addEventListener('click', (ev)=>{
      try {
        ev.preventDefault();
        const xmlPath = (document.getElementById('scenariosPreviewXmlPath')?.value || '').trim();
        const scen = (document.getElementById('flowScenario')?.value || document.getElementById('scenariosPreviewScenario')?.value || '').trim();
        if(!xmlPath){
          alert('Save XML first to preview.');
          return;
        }
        const baseUrl = String(link.dataset?.previewBaseUrl || '/scenarios/preview');
        const url = baseUrl + '?xml_path=' + encodeURIComponent(xmlPath) + (scen ? ('&scenario=' + encodeURIComponent(scen)) : '');
        window.location.href = url;
      } catch(e){}
    });
  });

