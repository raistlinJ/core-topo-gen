{% extends 'layout.html' %}
{% block title %}Flag Sequencing{% endblock %}
{% block active_page %}{% set active_page='scenarios' %}{% endblock %}
{% block header_icon %}<i class="bi bi-bezier2 fs-4"></i>{% endblock %}
{% block header_title %}Flag Sequencing{% endblock %}

{% block extra_head %}
<script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
<style>
  body { padding-bottom: 0; }
  #flowLayoutRow { min-height: calc(100vh - 200px); }
  /* Prevent long <pre>/<svg> content from forcing the Bootstrap row to wrap columns. */
  #flowLayoutRow > [class*='col-'] { min-width: 0; }
  @media (max-width: 992px) {
    #flowLayoutRow { min-height: 0; }
  }
</style>
{% endblock %}

{% block content %}
{% set scenario_tab = (active_scenario or request.args.get('scenario','')) %}
{% set scenarios_active_tab = 'flag-sequencing' %}
{% include 'partials/scenarios_tabs.html' with context %}
<div class="container-fluid mt-3 d-flex flex-column" id="flowPageWrap">
  <div class="row g-3 flex-grow-1 align-items-stretch" id="flowLayoutRow">
    <div class="col-12 col-lg-3 d-flex">
      <div class="card shadow-sm mb-3 flex-fill d-flex flex-column">
        <div class="card-header d-flex justify-content-between align-items-center">
          <span class="fw-bold">Scenarios</span>
          <button class="btn btn-sm btn-outline-secondary {% if not active_scenario %}d-none{% endif %}" id="flowScenarioFilterClear" type="button" title="Clear">Clear</button>
        </div>
        <div class="list-group list-group-flush flex-grow-1 overflow-auto" id="flowScenarioList" style="min-height:0;">
          {% if scenarios %}
            {% for s in scenarios %}
            <button type="button" class="list-group-item list-group-item-action py-1 {% if active_scenario and active_scenario==s %}active bg-primary text-white{% endif %}" data-scen-name="{{ s }}">{{ s }}</button>
            {% endfor %}
          {% else %}
            <div class="p-3 text-muted small">No scenarios yet</div>
          {% endif %}
        </div>
      </div>
    </div>

    <div class="col-12 col-lg-9 d-flex">
      <div class="flex-fill d-flex flex-column">
        <div class="d-flex align-items-center justify-content-between flex-wrap gap-2 mb-3">
          <div class="fw-semibold">Generate an Attack Flow from the latest preview plan</div>
        </div>

        <div class="card mb-3">
          <div class="card-body">
            <input id="flowScenario" class="form-control d-none" value="{{ active_scenario or request.args.get('scenario','') }}">
            <div class="row g-2 align-items-end">
              <div class="col-sm-6 col-md-2">
                <label class="form-label">Chain Length</label>
                <input id="flowLength" class="form-control" type="number" min="1" max="50" value="5">
              </div>
              <div class="col-sm-6 col-md-4">
                <label class="form-label">Preset</label>
                <select id="flowPreset" class="form-select">
                  <option value="">Random (default)</option>
                  <option value="sample_reverse_nfs_ssh">Sample: reverse_nfs_ssh</option>
                </select>
              </div>
              <div class="col-md-6">
                <div class="d-flex gap-2 flex-nowrap">
                  <button id="flowGenerateBtn" class="btn btn-primary text-nowrap" type="button">Generate</button>
                  <a id="flowBundleDownloadLink" class="btn btn-outline-primary text-nowrap" href="#" role="button">Download Attack Flow STIX Bundle</a>
                </div>
              </div>
              <div class="col-md-4">
                <div class="small">
                  <span id="flowStatus" class="text-muted"></span>
                  <a id="flowLoginLink" class="ms-2 d-none" href="/login">Login</a>
                </div>
              </div>
            </div>
            <div class="small text-muted mt-2">Current rule: flags are placed on Docker-role nodes and vulnerability nodes. Vulnerability nodes are only assigned <span class="font-monospace">flag-generator</span> flags (not <span class="font-monospace">flag-node-generator</span>). Default chain order is randomized; you can tweak it below.</div>
          </div>
        </div>

        <div id="flowValidityAlert" class="alert alert-danger d-none" role="alert"></div>

        <div class="card mb-3">
          <div class="card-header d-flex align-items-center justify-content-between">
            <div class="fw-semibold">Visualization</div>
          </div>
          <div class="card-body">
            <div class="row g-2 small text-muted align-items-center mb-2" id="flowMetaRow">
              <div class="col-12 col-md-3">
                <span class="text-secondary">Scenario:</span>
                <span class="ms-1" id="flowMetaScenario"></span>
              </div>
              <div class="col-12 col-md-3" style="min-width: 0;">
                <span class="text-secondary">Preview:</span>
                <span class="ms-1 text-truncate d-inline-block align-middle" id="flowMetaPreview" style="max-width: 100%;"></span>
              </div>
              <div class="col-12 col-md-6">
                <span class="text-secondary">Eligibility:</span>
                <span class="ms-1" id="flowMetaStats"></span>
              </div>
            </div>
            <div id="flowDiagramWrap" class="border rounded p-2" style="min-height: 180px; overflow-x: auto;">
              <div id="flowDiagram" class="mermaid">graph LR\n  A[Generate] --> B[Flow]</div>
            </div>

            <dialog id="flowNodeDetailsDialog" class="p-0 border rounded" style="max-width: 1150px; width: calc(100% - 2rem); max-height: 85vh; overflow: hidden;">
              <form method="dialog" class="m-0" style="display:flex;flex-direction:column;max-height:85vh;">
                <div class="p-3 border-bottom d-flex align-items-center justify-content-between" style="flex:0 0 auto;">
                  <div class="fw-semibold" id="flowNodeDetailsTitle">Node</div>
                  <button class="btn btn-sm btn-outline-secondary" value="close" type="submit">Close</button>
                </div>
                <div class="p-3" style="flex:1 1 auto; overflow: auto;">
                  <div id="flowNodeDetailsBody" class="small"></div>
                </div>
              </form>
            </dialog>
          </div>
        </div>

        <div class="card mb-3">
          <div class="card-header d-flex align-items-center justify-content-between">
            <div class="fw-semibold">Chain Order</div>
            <div class="small text-muted">Use ↑/↓ to reorder</div>
          </div>
          <div class="card-body">
            <div class="small text-muted mb-1" aria-hidden="true" style="display:grid;grid-template-columns:84px 1fr 76px;gap:.5rem;align-items:center;">
              <div class="pe-2" style="border-right: 1px solid var(--bs-border-color, #dee2e6);">Sequence</div>
              <div>Details</div>
              <div class="text-end">Reorder</div>
            </div>
            <div id="flowChainList" class="list-group"></div>
            <div class="small text-muted mt-2">Reordering updates the bundle and download.</div>
          </div>
        </div>

      </div>
    </div>
  </div>
</div>
{% endblock %}

{% block body_container %}
{{ super() }}
{% set xml_preview_enabled = True %}
{% set xml_preview_text = xml_preview %}
{% include 'partials/dock.html' %}

<!-- Loading overlay shown during slow operations (e.g., resolving hint templates via generator runs). -->
<div id="flowLoadingOverlay" class="position-fixed top-0 start-0 w-100 h-100 d-none" style="z-index: 2000;">
  <div class="position-absolute top-0 start-0 w-100 h-100 bg-dark bg-opacity-50"></div>
  <div class="position-absolute top-50 start-50 translate-middle bg-white rounded shadow p-3" style="min-width: 320px; max-width: 560px;">
    <div class="d-flex align-items-center gap-2">
      <div class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></div>
      <div class="fw-semibold" id="flowLoadingText">Loading…</div>
    </div>
    <div class="small text-muted mt-2">This can take a few seconds while generators run and hints resolve.</div>
  </div>
</div>

<script>
(function(){
  const statusEl = document.getElementById('flowStatus');
  const loginLinkEl = document.getElementById('flowLoginLink');
  const scenarioEl = document.getElementById('flowScenario');
  const scenarioLabelEl = document.getElementById('flowScenarioLabel');
  const lengthEl = document.getElementById('flowLength');
  const presetEl = document.getElementById('flowPreset');
  const btnEl = document.getElementById('flowGenerateBtn');
  const saveXmlEl = document.getElementById('saveXmlBtn');
  const execEl = document.getElementById('scenariosExecuteBtn');
  const downloadXmlEl = document.getElementById('downloadXmlBtn');
  const jsonEl = document.getElementById('flowJson');
  const metaScenarioEl = document.getElementById('flowMetaScenario');
  const metaPreviewEl = document.getElementById('flowMetaPreview');
  const metaStatsEl = document.getElementById('flowMetaStats');

  const nodeDetailsDialogEl = document.getElementById('flowNodeDetailsDialog');
  const nodeDetailsTitleEl = document.getElementById('flowNodeDetailsTitle');
  const nodeDetailsBodyEl = document.getElementById('flowNodeDetailsBody');
  const downloadLink = document.getElementById('flowBundleDownloadLink');
  const scenarioListEl = document.getElementById('flowScenarioList');
  const clearScenarioBtn = document.getElementById('flowScenarioFilterClear');
  const validityAlertEl = document.getElementById('flowValidityAlert');
  const loadingOverlayEl = document.getElementById('flowLoadingOverlay');
  const loadingTextEl = document.getElementById('flowLoadingText');

  const participantUrlFlags = {{ (participant_url_flags or {})|tojson }};
  const scenarioNamesCache = {{ (scenarios or [])|tojson }};
  const initialScenario = {{ (active_scenario or '')|tojson }};
  let activeScenario = (initialScenario || (Array.isArray(scenarioNamesCache) && scenarioNamesCache.length ? String(scenarioNamesCache[0]) : '')).trim();

  let currentChain = [];
  let currentBundle = null;
  let lastStats = null;
  let lastPreviewPlanPath = '';
  let lastFlowPlanPath = '';
  let currentFlagAssignments = [];
  let selectedChainIndex = -1;
  let lastFlowValid = true;
  let lastFlowErrors = [];
  let lastFlagsEnabled = true;

  let _flagGeneratorsCatalog = null;
  let _flagNodeGeneratorsCatalog = null;

  async function ensureGeneratorCatalogsLoaded(){
    if(Array.isArray(_flagGeneratorsCatalog) && Array.isArray(_flagNodeGeneratorsCatalog)) return;
    try {
      const [fg, fng] = await Promise.all([
        fetchJson('/flag_generators_data'),
        fetchJson('/flag_node_generators_data'),
      ]);
      _flagGeneratorsCatalog = (fg && Array.isArray(fg.generators)) ? fg.generators.slice() : [];
      _flagNodeGeneratorsCatalog = (fng && Array.isArray(fng.generators)) ? fng.generators.slice() : [];
    } catch(e) {
      _flagGeneratorsCatalog = Array.isArray(_flagGeneratorsCatalog) ? _flagGeneratorsCatalog : [];
      _flagNodeGeneratorsCatalog = Array.isArray(_flagNodeGeneratorsCatalog) ? _flagNodeGeneratorsCatalog : [];
      throw e;
    }
  }

  function compileStringOrRegex(input){
    const raw = String(input || '').trim();
    if(!raw) return { ok: true, regex: null, isRegex: false, error: '' };
    // Mirror the vulnerability chooser: accept /regex/ syntax.
    if(raw.length >= 2 && raw.startsWith('/') && raw.lastIndexOf('/') > 0){
      const lastSlash = raw.lastIndexOf('/');
      const body = raw.slice(1, lastSlash);
      const flags = raw.slice(lastSlash + 1);
      try {
        const re = new RegExp(body, flags || 'i');
        return { ok: true, regex: re, isRegex: true, error: '' };
      } catch(e) {
        return { ok: false, regex: null, isRegex: true, error: String(e && e.message || e || 'Invalid regex') };
      }
    }
    // Plain string match (case-insensitive substring).
    try {
      const escaped = raw.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
      return { ok: true, regex: new RegExp(escaped, 'i'), isRegex: false, error: '' };
    } catch(e) {
      return { ok: false, regex: null, isRegex: false, error: String(e && e.message || e || 'Invalid filter') };
    }
  }

  function persistFlowState(){
    try {
      const scenario = (scenarioEl && scenarioEl.value || '').trim();
      if(!scenario) return;
      const preset = (presetEl && presetEl.value) ? String(presetEl.value).trim() : '';
      const chainIds = Array.isArray(currentChain) ? currentChain.map(n => (n && n.id) ? String(n.id) : '').filter(Boolean) : [];
      if(!chainIds.length) return;
      if(typeof window.coretgSetSavedFlowStateForScenario !== 'function') return;
      window.coretgSetSavedFlowStateForScenario(scenario, {
        preset,
        length: chainIds.length,
        chain_ids: chainIds,
      });
    } catch(e) {}
  }

  function toRoman(n){
    const num = parseInt(n, 10);
    if(!Number.isFinite(num) || num <= 0) return '';
    const map = [
      [1000,'M'], [900,'CM'], [500,'D'], [400,'CD'],
      [100,'C'], [90,'XC'], [50,'L'], [40,'XL'],
      [10,'X'], [9,'IX'], [5,'V'], [4,'IV'], [1,'I']
    ];
    let x = num;
    let out = '';
    for(const [v,s] of map){
      while(x >= v){
        out += s;
        x -= v;
      }
    }
    return out;
  }

  function showLoading(text){
    try{
      if(!loadingOverlayEl) return;
      if(loadingTextEl) loadingTextEl.textContent = (text || 'Loading…').toString();
      loadingOverlayEl.classList.remove('d-none');
    } catch(e) {}
  }

  function hideLoading(){
    try{
      if(!loadingOverlayEl) return;
      loadingOverlayEl.classList.add('d-none');
    } catch(e) {}
  }

  function setFlowValidityFromPayload(payload){
    const p = payload && typeof payload === 'object' ? payload : null;
    const flowValid = p && ('flow_valid' in p) ? !!p.flow_valid : true;
    const flagsEnabled = p && ('flags_enabled' in p) ? !!p.flags_enabled : true;
    const flowErrors = (p && Array.isArray(p.flow_errors)) ? p.flow_errors.slice() : [];
    lastFlowValid = flowValid;
    lastFlagsEnabled = flagsEnabled;
    lastFlowErrors = flowErrors;
    if(!validityAlertEl) return;
    if(flowValid && flagsEnabled){
      validityAlertEl.classList.add('d-none');
      validityAlertEl.textContent = '';
      return;
    }
    const base = 'Invalid flag dependency order: execution will NOT include flags.';
    const details = flowErrors.length ? (' ' + flowErrors.join(' | ')) : '';
    validityAlertEl.textContent = base + details;
    validityAlertEl.classList.remove('d-none');
  }

  async function refreshXmlDockPreview({ force = false } = {}){
    const xmlPre = document.getElementById('xmlPre');
    if(!xmlPre) return;
    const xmlPath = (document.getElementById('scenariosPreviewXmlPath')?.value || '').trim();
    const lastPath = (xmlPre.dataset.xmlPreviewPath || '').trim();
    if(!xmlPath){
      if(force){
        try { xmlPre.textContent = ''; } catch(e) {}
        try { xmlPre.dataset.xmlPreviewPath = ''; } catch(e) {}
      }
      return;
    }
    if(!force && xmlPre.textContent.trim() && lastPath === xmlPath) return;
    try {
      const res = await fetch('/download_report?path=' + encodeURIComponent(xmlPath), { credentials: 'same-origin' });
      if(!res.ok) return;
      const txt = await res.text();
      try { xmlPre.textContent = txt || ''; } catch(e) {}
      try { xmlPre.dataset.xmlPreviewPath = xmlPath; } catch(e) {}
    } catch(e) {}
  }

  function normalizeScenarioNorm(raw){
    return (raw || '').toString().trim().toLowerCase().replace(/\s+/g, ' ');
  }

  function defaultScenarioName(){
    return (Array.isArray(scenarioNamesCache) && scenarioNamesCache.length) ? String(scenarioNamesCache[0]) : null;
  }

  function updateScenarioQueryParam(){
    try {
      const url = new URL(window.location.href);
      if(activeScenario){
        url.searchParams.set('scenario', activeScenario);
      } else {
        url.searchParams.delete('scenario');
      }
      window.history.replaceState({}, '', url.toString());
    } catch(e) {}
  }

  function updateScenarioFilterControls(){
    try {
      if(clearScenarioBtn){
        const def = defaultScenarioName();
        const show = !!activeScenario && !!def && activeScenario !== def;
        clearScenarioBtn.classList.toggle('d-none', !show);
      }
      if(!scenarioListEl) return;
      scenarioListEl.querySelectorAll('[data-scen-name]').forEach(btn => {
        const name = btn.getAttribute('data-scen-name');
        const isActive = !!activeScenario && name === activeScenario;
        btn.classList.toggle('active', isActive);
        btn.classList.toggle('bg-primary', isActive);
        btn.classList.toggle('text-white', isActive);
      });
    } catch(e) {}
  }

  function refreshParticipantNavForScenario(scenarioName){
    try {
      const scen = (scenarioName || '').toString().trim();
      if (typeof window.CORETG_PATCH_SCENARIO_NAV === 'function') {
        window.CORETG_PATCH_SCENARIO_NAV(scen);
      }
      const norm = normalizeScenarioNorm(scen);
      const hasParticipant = !!participantUrlFlags[norm];
      if (typeof window.CORETG_SET_PARTICIPANT_NAV_VISIBLE === 'function') {
        window.CORETG_SET_PARTICIPANT_NAV_VISIBLE(hasParticipant);
      }
    } catch(e) {}
  }

  async function setScenario(value){
    activeScenario = (value || defaultScenarioName() || '').toString().trim();
    if(scenarioEl) scenarioEl.value = activeScenario;
    if(scenarioLabelEl) scenarioLabelEl.textContent = activeScenario;
    updateScenarioQueryParam();
    updateScenarioFilterControls();
    refreshParticipantNavForScenario(activeScenario);
    // When switching scenarios (or loading after refresh), prefer any saved Flow state.
    await generate(false);
  }

  function setStatus(msg, isError){
    if(!statusEl) return;
    statusEl.textContent = msg || '';
    statusEl.classList.toggle('text-danger', !!isError);
    statusEl.classList.toggle('text-muted', !isError);
  }

  function setLoginLinkVisible(visible){
    try{
      if(!loginLinkEl) return;
      loginLinkEl.classList.toggle('d-none', !visible);
    } catch(e) {}
  }

  function basenameFromPath(p){
    try{
      const s = (p||'').toString();
      const parts = s.split('/');
      return parts[parts.length-1] || s;
    } catch(e){
      return (p||'').toString();
    }
  }

  async function fetchJson(url, opts){
    opts = opts || {};
    const timeoutMs = Number.isFinite(+opts.timeoutMs) ? (+opts.timeoutMs) : 0;
    const controller = (typeof AbortController !== 'undefined') ? new AbortController() : null;
    const signal = controller ? controller.signal : undefined;
    let t = null;
    if(controller && timeoutMs > 0){
      t = setTimeout(() => { try{ controller.abort(); } catch(e){} }, timeoutMs);
    }
    let res;
    try{
      res = await fetch(url, { credentials: 'same-origin', signal });
    } catch(e){
      if(controller && e && (e.name === 'AbortError')){
        const err = new Error('Request timed out.');
        err.isTimeout = true;
        throw err;
      }
      throw e;
    } finally {
      if(t) clearTimeout(t);
    }
    const ct = (res.headers.get('content-type') || '').toLowerCase();
    if(!ct.includes('application/json')){
      const text = await res.text();
      if(res.redirected || (text && text.includes('<html'))){
        const err = new Error('Login required.');
        err.loginRequired = true;
        throw err;
      }
      throw new Error('Non-JSON response');
    }
    const data = await res.json();
    if(!res.ok){
      const err = new Error((data && (data.error || data.message)) || ('HTTP ' + res.status));
      err.payload = data;
      if(res.status === 401) err.loginRequired = true;
      throw err;
    }
    return data;
  }

  async function postJson(url, payload, opts){
    opts = opts || {};
    const timeoutMs = Number.isFinite(+opts.timeoutMs) ? (+opts.timeoutMs) : 0;
    const controller = (typeof AbortController !== 'undefined') ? new AbortController() : null;
    const signal = controller ? controller.signal : undefined;
    let t = null;
    if(controller && timeoutMs > 0){
      t = setTimeout(() => { try{ controller.abort(); } catch(e){} }, timeoutMs);
    }
    let res;
    try{
      res = await fetch(url, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      credentials: 'same-origin',
      body: JSON.stringify(payload || {}),
      signal,
      });
    } catch(e){
      if(controller && e && (e.name === 'AbortError')){
        const err = new Error('Request timed out.');
        err.isTimeout = true;
        throw err;
      }
      throw e;
    } finally {
      if(t) clearTimeout(t);
    }
    const ct = (res.headers.get('content-type') || '').toLowerCase();
    if(!ct.includes('application/json')){
      const text = await res.text();
      if(res.redirected || (text && text.includes('<html'))){
        const err = new Error('Login required.');
        err.loginRequired = true;
        throw err;
      }
      throw new Error('Non-JSON response');
    }
    const data = await res.json();
    if(!res.ok){
      const err = new Error((data && (data.error || data.message)) || ('HTTP ' + res.status));
      err.payload = data;
      if(res.status === 401) err.loginRequired = true;
      throw err;
    }
    return data;
  }

  function chainFeasibility(assignments){
    // Returns per-index feasibility based on cumulative outputs.
    // Shape: {ok:boolean, missing:string[], missing_artifacts:string[], missing_fields:string[]}
    const out = [];
    // Keep in sync with server-side synthesized Flow inputs (see _flow_default_generator_config).
    const synthesizedFields = ['seed','secret','env_name','challenge','flag_prefix','username_prefix','key_len','node_name'];
    const haveEffective = new Set(synthesizedFields);
    const haveArtifacts = new Set();
    const haveFields = new Set(synthesizedFields);
    if(!Array.isArray(assignments)) return out;
    for(let i=0;i<assignments.length;i++){
      const a = assignments[i] || {};

      const hasSplit = Array.isArray(a.requires) || Array.isArray(a.input_fields_required) || Array.isArray(a.input_fields);
      if(hasSplit){
        const reqArtifacts = Array.isArray(a.requires) ? a.requires.map(String) : [];
        const reqFields = Array.isArray(a.input_fields_required)
          ? a.input_fields_required.map(String)
          : (Array.isArray(a.input_fields) ? a.input_fields.map(String) : []);
        const optFields = Array.isArray(a.input_fields_optional) ? a.input_fields_optional.map(String) : [];
        const optSet = new Set(optFields.filter(Boolean));

        const missingArtifacts = reqArtifacts.filter(k => k && !optSet.has(k) && !haveArtifacts.has(k));
        const missingFields = reqFields.filter(k => k && !haveFields.has(k));
        const missing = missingArtifacts.concat(missingFields);
        out.push({ ok: missing.length === 0, missing, missing_artifacts: missingArtifacts, missing_fields: missingFields });
      } else {
        const reqEffective = Array.isArray(a.inputs) ? a.inputs.map(String) : [];
        const missing = reqEffective.filter(k => k && !haveEffective.has(k));
        out.push({ ok: missing.length === 0, missing, missing_artifacts: [], missing_fields: [] });
      }

      const provEffective = Array.isArray(a.outputs) ? a.outputs.map(String) : [];
      provEffective.forEach(k => { if(k) haveEffective.add(k); });

      if(Array.isArray(a.produces)){
        a.produces.map(String).forEach(k => { if(k) haveArtifacts.add(k); });
      }
      if(Array.isArray(a.output_fields)){
        a.output_fields.map(String).forEach(k => { if(k) haveFields.add(k); });
      }
    }
    return out;
  }

  function renderChainEditor(){
    const wrap = document.getElementById('flowChainList');
    if(!wrap) return;
    wrap.innerHTML = '';
    if(!Array.isArray(currentChain) || currentChain.length === 0){
      const empty = document.createElement('div');
      empty.className = 'text-muted small';
      empty.textContent = 'Generate a flow to populate the chain.';
      wrap.appendChild(empty);
      return;
    }
    currentChain.forEach((node, idx) => {
      const item = document.createElement('div');
      item.className = 'list-group-item';
      item.style.cursor = 'default';
      item.style.display = 'grid';
      item.style.gridTemplateColumns = '84px 1fr 76px';
      item.style.columnGap = '.5rem';
      item.style.alignItems = 'start';

      const seq = document.createElement('div');
      seq.className = 'text-muted small fw-semibold';
      seq.style.width = '84px';
      seq.style.whiteSpace = 'nowrap';
      seq.style.borderRight = '1px solid var(--bs-border-color, #dee2e6)';
      seq.style.paddingRight = '.5rem';
      seq.textContent = toRoman(idx + 1);

      const left = document.createElement('div');
      left.className = 'd-flex flex-column';
      left.style.minWidth = '0';
      left.style.justifySelf = 'stretch';
      const title = document.createElement('div');
      title.className = 'fw-semibold';
      title.textContent = (node && node.name) ? String(node.name) : ('Node ' + (idx+1));
      left.appendChild(title);

      // Sub-details: compact table for readability.
      const details = document.createElement('div');
      details.className = 'mt-1';
      const tbl = document.createElement('table');
      tbl.className = 'table table-sm table-borderless mb-0 small';
      const tbody = document.createElement('tbody');

      function addRow(label, valueElOrText, { danger = false } = {}){
        const tr = document.createElement('tr');
        const tdL = document.createElement('td');
        tdL.className = 'text-muted';
        tdL.style.whiteSpace = 'nowrap';
        tdL.style.width = '1%';
        tdL.textContent = String(label || '').trim() ? (String(label).trim() + ':') : '';
        const tdV = document.createElement('td');
        if(danger) tdV.classList.add('text-danger');
        if(valueElOrText && typeof valueElOrText === 'object' && valueElOrText.nodeType){
          tdV.appendChild(valueElOrText);
        } else {
          tdV.textContent = String(valueElOrText || '-');
        }
        tr.appendChild(tdL);
        tr.appendChild(tdV);
        tbody.appendChild(tr);
      }

      const fa = (Array.isArray(currentFlagAssignments) && currentFlagAssignments[idx]) ? currentFlagAssignments[idx] : null;
      const genId = fa && fa.id ? String(fa.id) : '-';
      const genName = fa && fa.name ? String(fa.name) : '-';
      addRow('generator', (genName && genName !== '-' && genName !== genId)
        ? (genId + ' | ' + genName)
        : genId);

      const genLabel = fa && fa.flag_generator ? String(fa.flag_generator) : '-';
      addRow('source', genLabel);

      // Realized flag value (populated after prepare_preview_for_execute).
      try{
        const fv = (fa && typeof fa.flag_value === 'string') ? fa.flag_value.trim() : '';
        if(fv){
          const code = document.createElement('code');
          code.className = 'font-monospace';
          code.style.whiteSpace = 'pre-wrap';
          code.textContent = fv;
          addRow('flag', code);
        }
      } catch(e) {}

      const descList = (fa && Array.isArray(fa.description_hints) && fa.description_hints.length)
        ? fa.description_hints.map(x => String(x || '').trim()).filter(Boolean)
        : [];
      if(descList.length > 1){
        const wrap = document.createElement('div');
        const ul = document.createElement('ol');
        ul.className = 'mb-0 ps-3';
        descList.forEach((ht) => {
          const li = document.createElement('li');
          li.textContent = ht;
          ul.appendChild(li);
        });
        wrap.appendChild(ul);
        addRow('description hints', wrap);
      } else if(descList.length === 1){
        addRow('description hints', descList[0]);
      }

      const hintList = (fa && Array.isArray(fa.hints) && fa.hints.length)
        ? fa.hints.map(x => String(x || '').trim()).filter(Boolean)
        : [];
      if(hintList.length > 1){
        const wrap = document.createElement('div');
        const ul = document.createElement('ol');
        ul.className = 'mb-0 ps-3';
        hintList.forEach((ht) => {
          const li = document.createElement('li');
          li.textContent = ht;
          ul.appendChild(li);
        });
        wrap.appendChild(ul);
        addRow('hints', wrap);
      } else {
        const hintText = hintList.length ? hintList[0] : (fa && fa.hint ? String(fa.hint) : '');
        addRow('hint', hintText || '-');
      }

      const feas = chainFeasibility(currentFlagAssignments);
      const step = feas && feas[idx] ? feas[idx] : null;
        addRow('requires (artifacts)', fa && Array.isArray(fa.requires) && fa.requires.length ? fa.requires.join(', ') : '-');
        addRow('produces (artifacts)', fa && Array.isArray(fa.produces) && fa.produces.length ? fa.produces.join(', ') : '-');
        const inReq = (fa && Array.isArray(fa.input_fields_required)) ? fa.input_fields_required.map(String).filter(Boolean) : [];
        const inOpt = (fa && Array.isArray(fa.input_fields_optional)) ? fa.input_fields_optional.map(String).filter(Boolean) : [];
        const inAll = (fa && Array.isArray(fa.input_fields)) ? fa.input_fields.map(String).filter(Boolean) : [];
        const inputsDisplay = (inReq.length || inOpt.length)
          ? (inReq.concat(inOpt.map(x => x + ' (optional)')).join(', '))
          : (inAll.length ? inAll.join(', ') : '-');
        addRow('inputs (fields)', inputsDisplay);
        addRow('outputs (fields)', fa && Array.isArray(fa.output_fields) && fa.output_fields.length ? fa.output_fields.join(', ') : '-');
      if(step && step.ok === false){
          const ma = Array.isArray(step.missing_artifacts) ? step.missing_artifacts : [];
          const mf = Array.isArray(step.missing_fields) ? step.missing_fields : [];
          if(ma.length || mf.length){
            addRow('missing inputs (artifacts)', ma.join(', ') || '-', { danger: true });
            addRow('missing inputs (fields)', mf.join(', ') || '-', { danger: true });
          } else {
            addRow('missing', (step.missing || []).join(', ') || '-', { danger: true });
          }
      }

      // After prepare_preview_for_execute, the backend may attach runtime validation
      // fields like outputs_match/outputs_mismatch to help validate generator specs.
      try {
        if(fa && fa.inputs_match === false){
          const mm = fa.inputs_mismatch || {};
          const missingReq = Array.isArray(mm.missing_required) ? mm.missing_required : [];
          const unsetReq = Array.isArray(mm.unset_required) ? mm.unset_required : [];
          const dropped = Array.isArray(mm.dropped) ? mm.dropped : [];

          const parts = [];
          if(missingReq.length){
            const msg = missingReq.map(k => String(k || '').trim()).filter(Boolean)
              .map(k => `${k} (required by catalog inputs, but not provided in generator config)`)
              .join('; ');
            parts.push('missing required: ' + (msg || missingReq.join(', ')));
          }
          if(unsetReq.length){
            const msg = unsetReq.map(k => String(k || '').trim()).filter(Boolean)
              .map(k => `${k} (provided but empty/null)`)
              .join('; ');
            parts.push('unset required: ' + (msg || unsetReq.join(', ')));
          }
          if(dropped.length){
            const msg = dropped.map(k => String(k || '').trim()).filter(Boolean)
              .map(k => `${k} (not declared by generator inputs; not passed)`)
              .join('; ');
            parts.push('dropped: ' + (msg || dropped.join(', ')));
          }
          addRow('inputs mismatch', parts.length ? parts.join(' | ') : 'inputs mismatch', { danger: true });
        }
        if(fa && fa.outputs_match === false){
          const mm = fa.outputs_mismatch || {};
          const missing = Array.isArray(mm.missing) ? mm.missing : [];
          const extra = Array.isArray(mm.extra) ? mm.extra : [];
          const parts = [];
          if(missing.length){
            const msg = missing.map(k => String(k || '').trim()).filter(Boolean)
              .map(k => `${k} (declared in catalog output_fields, but not present in outputs.json)`)
              .join('; ');
            parts.push('missing: ' + (msg || missing.join(', ')));
          }
          if(extra.length){
            const msg = extra.map(k => String(k || '').trim()).filter(Boolean)
              .map(k => `${k} (present in outputs.json, but not declared in catalog output_fields)`)
              .join('; ');
            parts.push('extra: ' + (msg || extra.join(', ')));
          }
          addRow('outputs mismatch', parts.length ? parts.join(' | ') : 'outputs mismatch', { danger: true });
        }
      } catch(e) {}

      tbl.appendChild(tbody);
      details.appendChild(tbl);
      left.appendChild(details);

      // Row-level Substitute shortcut (bottom-right of Details column).
      try {
        const shortcutRow = document.createElement('div');
        shortcutRow.className = 'd-flex justify-content-end mt-2';
        const subBtn = document.createElement('button');
        subBtn.type = 'button';
        subBtn.className = 'btn btn-sm btn-outline-primary';
        subBtn.textContent = 'Substitute';
        subBtn.addEventListener('click', (ev)=>{
          try { ev && ev.preventDefault && ev.preventDefault(); } catch(e) {}
          try { ev && ev.stopPropagation && ev.stopPropagation(); } catch(e) {}
          try { selectChainIndex(idx); } catch(e) {}
          try { openNodeDetailsDialog(idx, { openSubstitute: true }); } catch(e) {}
        });
        shortcutRow.appendChild(subBtn);
        left.appendChild(shortcutRow);
      } catch(e) {}

      const right = document.createElement('div');
      right.className = 'btn-group btn-group-sm';
      right.style.justifySelf = 'end';
      const up = document.createElement('button');
      up.type = 'button';
      up.className = 'btn btn-outline-secondary';
      up.textContent = '↑';
      up.disabled = idx === 0;
      up.addEventListener('click', async () => {
        if(idx === 0) return;
        const tmp = currentChain[idx-1];
        currentChain[idx-1] = currentChain[idx];
        currentChain[idx] = tmp;
        renderChainEditor();
        persistFlowState();
        await refreshBundleFromChain();
      });
      const down = document.createElement('button');
      down.type = 'button';
      down.className = 'btn btn-outline-secondary';
      down.textContent = '↓';
      down.disabled = idx === currentChain.length - 1;
      down.addEventListener('click', async () => {
        if(idx === currentChain.length - 1) return;
        const tmp = currentChain[idx+1];
        currentChain[idx+1] = currentChain[idx];
        currentChain[idx] = tmp;
        renderChainEditor();
        persistFlowState();
        await refreshBundleFromChain();
      });
      right.appendChild(up);
      right.appendChild(down);

      item.appendChild(seq);
      item.appendChild(left);
      item.appendChild(right);
      wrap.appendChild(item);
    });
  }

  function openNodeDetailsDialog(idx, opts){
    if(!nodeDetailsDialogEl || !nodeDetailsBodyEl) return;
    const options = (opts && typeof opts === 'object') ? opts : {};
    const openSubstitute = !!options.openSubstitute;
    const i = Number.isFinite(+idx) ? (+idx) : -1;
    if(!Array.isArray(currentChain) || i < 0 || i >= currentChain.length) return;
    const node = currentChain[i] || {};
    const fa = (Array.isArray(currentFlagAssignments) && currentFlagAssignments[i]) ? currentFlagAssignments[i] : null;

    const seq = toRoman(i + 1);
    const nodeName = (node && node.name) ? String(node.name) : ('Node ' + (i + 1));
    if(nodeDetailsTitleEl) nodeDetailsTitleEl.textContent = (seq ? (seq + '. ') : '') + nodeName;

    nodeDetailsBodyEl.innerHTML = '';

    const tbl = document.createElement('table');
    tbl.className = 'table table-sm table-borderless mb-0';
    const tbody = document.createElement('tbody');

    function addRow(label, valueElOrText){
      const tr = document.createElement('tr');
      const tdL = document.createElement('td');
      tdL.className = 'text-muted';
      tdL.style.whiteSpace = 'nowrap';
      tdL.style.width = '1%';
      tdL.textContent = String(label || '').trim() ? (String(label).trim() + ':') : '';
      const tdV = document.createElement('td');
      if(valueElOrText && typeof valueElOrText === 'object' && valueElOrText.nodeType){
        tdV.appendChild(valueElOrText);
      } else {
        tdV.textContent = String(valueElOrText || '-');
      }
      tr.appendChild(tdL);
      tr.appendChild(tdV);
      tbody.appendChild(tr);
    }

    function addFullRow(valueElOrText){
      const tr = document.createElement('tr');
      const td = document.createElement('td');
      td.colSpan = 2;
      if(valueElOrText && typeof valueElOrText === 'object' && valueElOrText.nodeType){
        td.appendChild(valueElOrText);
      } else {
        td.textContent = String(valueElOrText || '');
      }
      tr.appendChild(td);
      tbody.appendChild(tr);
    }

    // Flag(s) assigned to this node (currently 1-per-chain-position).
    if(fa && (fa.id || fa.name)){
      const genId = fa && fa.id ? String(fa.id) : '-';
      const genName = fa && fa.name ? String(fa.name) : '-';
      const genType = (fa && fa.type) ? String(fa.type) : '';
      const genSource = (fa && fa.flag_generator) ? String(fa.flag_generator) : '';
      // Render a structured summary (more readable than a pipe-delimited string).
      const flagEl = document.createElement('div');
      flagEl.className = 'd-flex flex-column';

      const line1 = document.createElement('div');
      line1.className = 'small';
      const typeLabel = document.createElement('span');
      typeLabel.className = 'text-muted';
      typeLabel.textContent = 'Type:';
      const typeVal = document.createElement('code');
      typeVal.className = 'ms-1';
      typeVal.textContent = genType || '-';
      line1.appendChild(typeLabel);
      line1.appendChild(typeVal);

      const sourceLabel = document.createElement('span');
      sourceLabel.className = 'text-muted ms-2';
      sourceLabel.textContent = 'Source:';
      const sourceVal = document.createElement('code');
      sourceVal.className = 'ms-1';
      sourceVal.textContent = genSource || '-';
      line1.appendChild(sourceLabel);
      line1.appendChild(sourceVal);

      const line2 = document.createElement('div');
      // Keep the ID visually distinct; name is optional.
      const idVal = document.createElement('code');
      idVal.textContent = genId || '-';
      line2.appendChild(idVal);
      if(genName && genName !== '-' && genName !== genId){
        const nameSpan = document.createElement('span');
        nameSpan.className = 'ms-2';
        nameSpan.textContent = genName;
        line2.appendChild(nameSpan);
      }

      flagEl.appendChild(line1);
      flagEl.appendChild(line2);
      addRow('flag', flagEl);
    } else {
      addRow('flag', '-');
    }

    // (Intentionally compact) omit flag value and hint descriptions here.

    tbl.appendChild(tbody);
    nodeDetailsBodyEl.appendChild(tbl);

    // Substitute generator UI.
    try{
      const isVuln = !!(node && (node.is_vuln || node.is_vulnerability || node.isVuln));
      const currentType = (fa && fa.type) ? String(fa.type) : (isVuln ? 'flag-generator' : 'flag-generator');
      const currentSource = (fa && fa.flag_generator) ? String(fa.flag_generator) : '';

      const box = document.createElement('div');
      box.className = 'd-flex flex-column gap-2';

      const topRow = document.createElement('div');
      topRow.className = 'd-flex align-items-center justify-content-between gap-2';
      const help = document.createElement('div');
      help.className = 'small text-muted';
      help.textContent = isVuln
        ? 'Flag generator type (fixed for vulnerabilities)'
        : 'Choose a compatible flag-generator or flag-node-generator.';
      const btn = document.createElement('button');
      btn.type = 'button';
      btn.className = 'btn btn-sm btn-outline-primary';
      btn.textContent = 'Substitute';
      topRow.appendChild(help);
      topRow.appendChild(btn);
      box.appendChild(topRow);

      const form = document.createElement('div');
      form.className = 'd-none border rounded p-2';

      const row1 = document.createElement('div');
      row1.className = 'd-flex align-items-center gap-2';

      const kindLabel = document.createElement('div');
      kindLabel.className = 'small text-muted';
      kindLabel.textContent = 'Type:';
      row1.appendChild(kindLabel);

      const kindSel = document.createElement('select');
      kindSel.className = 'form-select form-select-sm';
      kindSel.style.width = '220px';
      const optFg = document.createElement('option');
      optFg.value = 'flag-generator';
      optFg.textContent = 'flag-generator';
      kindSel.appendChild(optFg);
      const optFng = document.createElement('option');
      optFng.value = 'flag-node-generator';
      optFng.textContent = 'flag-node-generator';
      if(!isVuln){
        kindSel.appendChild(optFng);
      }
      kindSel.value = (currentType === 'flag-node-generator' && !isVuln) ? 'flag-node-generator' : 'flag-generator';
      if(isVuln){
        kindSel.disabled = true;
      }
      row1.appendChild(kindSel);

      const sourceLabel = document.createElement('div');
      sourceLabel.className = 'small text-muted ms-1';
      sourceLabel.textContent = 'Source:';
      row1.appendChild(sourceLabel);

      const sourceSel = document.createElement('select');
      sourceSel.className = 'form-select form-select-sm';
      sourceSel.style.width = '320px';
      row1.appendChild(sourceSel);

      form.appendChild(row1);

      const row2 = document.createElement('div');
      row2.className = 'd-flex flex-column gap-1 mt-2';

      const entryInput = document.createElement('input');
      entryInput.type = 'text';
      entryInput.className = 'form-control form-control-sm d-none';
      entryInput.placeholder = 'Filter (string or /regex/)';

      const entryErr = document.createElement('div');
      entryErr.className = 'small text-danger d-none';

      const candWrap = document.createElement('div');
      candWrap.className = 'border rounded';
      candWrap.style.maxHeight = '240px';
      candWrap.style.overflow = 'auto';

      const candTable = document.createElement('table');
      candTable.className = 'table table-sm mb-0 align-middle';
      const candHead = document.createElement('thead');
      const candHeadTr = document.createElement('tr');
      ;['Pick','Generator','Source','Incompatibility'].forEach((h)=>{
        const th = document.createElement('th');
        th.className = 'small text-muted';
        th.style.whiteSpace = 'nowrap';
        th.textContent = h;
        candHeadTr.appendChild(th);
      });
      candHead.appendChild(candHeadTr);
      const candBody = document.createElement('tbody');
      candTable.appendChild(candHead);
      candTable.appendChild(candBody);
      candWrap.appendChild(candTable);

      let selectedCandidateId = '';

      row2.appendChild(entryInput);
      row2.appendChild(entryErr);
      row2.appendChild(candWrap);
      form.appendChild(row2);

      const row3 = document.createElement('div');
      row3.className = 'd-flex align-items-center justify-content-between gap-2 mt-2';

      const cur = document.createElement('div');
      cur.className = 'small text-muted';
      cur.textContent = (fa && (fa.id || fa.name))
        ? ('Current: ' + String(fa.id || '') + (currentSource ? (' (' + currentSource + ')') : ''))
        : 'Current: -';

      const actions = document.createElement('div');
      actions.className = 'd-flex gap-2';
      const cancelBtn = document.createElement('button');
      cancelBtn.type = 'button';
      cancelBtn.className = 'btn btn-sm btn-outline-secondary';
      cancelBtn.textContent = 'Cancel';
      const applyBtn = document.createElement('button');
      applyBtn.type = 'button';
      applyBtn.className = 'btn btn-sm btn-primary';
      applyBtn.textContent = 'Apply';
      actions.appendChild(cancelBtn);
      actions.appendChild(applyBtn);

      row3.appendChild(cur);
      row3.appendChild(actions);
      form.appendChild(row3);
      box.appendChild(form);

      async function showSubstituteUI(){
        // Disable while the substitute UI is open.
        if(!form.classList.contains('d-none')) return;
        btn.disabled = true;
        form.classList.remove('d-none');
        try{
          showLoading('Loading generator catalog…');
          await ensureGeneratorCatalogsLoaded();
          rebuildSourceOptions();
          rebuildGeneratorOptions();
        } catch(e){
          setStatus('Failed to load generator catalog: ' + String(e && e.message || e), true);
          // If we couldn't load options, close the substitute UI and re-enable.
          try { form.classList.add('d-none'); } catch(_) {}
          btn.disabled = false;
        } finally {
          hideLoading();
        }
      }

      function getCatalogForKind(kind){
        return (String(kind) === 'flag-node-generator')
          ? (Array.isArray(_flagNodeGeneratorsCatalog) ? _flagNodeGeneratorsCatalog : [])
          : (Array.isArray(_flagGeneratorsCatalog) ? _flagGeneratorsCatalog : []);
      }

      function rebuildSourceOptions(){
        const kind = String(kindSel.value || 'flag-generator');
        const cat = getCatalogForKind(kind);
        const sources = new Set();
        (cat || []).forEach(g => {
          try {
            const s = String((g && g._source_name) || '').trim();
            if(s) sources.add(s);
          } catch(e) {}
        });
        const sorted = Array.from(sources).sort((a,b)=>String(a).localeCompare(String(b)));
        sourceSel.innerHTML = '';
        const anyOpt = document.createElement('option');
        anyOpt.value = '__any__';
        anyOpt.textContent = '(Any source)';
        sourceSel.appendChild(anyOpt);
        for(const s of sorted){
          const o = document.createElement('option');
          o.value = s;
          o.textContent = s;
          sourceSel.appendChild(o);
        }
        const entryOpt = document.createElement('option');
        entryOpt.value = '__entry__';
        entryOpt.textContent = 'Entry…';
        sourceSel.appendChild(entryOpt);

        // Default selection: keep current source if it exists, else Any.
        if(currentSource && sorted.includes(currentSource)){
          sourceSel.value = currentSource;
        } else {
          sourceSel.value = '__any__';
        }
      }

      function rebuildGeneratorOptions(){
        const kind = String(kindSel.value || 'flag-generator');
        const cat = getCatalogForKind(kind);
        const source = String(sourceSel.value || '__any__');

        entryErr.classList.add('d-none');
        entryErr.textContent = '';

        let filtered = (cat || []).slice();

        if(source === '__entry__'){
          entryInput.classList.remove('d-none');
          const compiled = compileStringOrRegex(entryInput.value);
          if(!compiled.ok){
            entryErr.textContent = compiled.error;
            entryErr.classList.remove('d-none');
            filtered = [];
          } else if(compiled.regex){
            filtered = filtered.filter(g => {
              const gid = String((g && g.id) || '');
              const gname = String((g && g.name) || '');
              return compiled.regex.test(gid) || compiled.regex.test(gname);
            });
          }
        } else {
          entryInput.classList.add('d-none');
          if(source !== '__any__'){
            filtered = filtered.filter(g => String((g && g._source_name) || '').trim() === source);
          }
        }

        // Cap for UI sanity.
        filtered = filtered.slice(0, 250);

        // Default selection to current.
        try {
          const curId = (fa && fa.id) ? String(fa.id) : '';
          selectedCandidateId = curId || '';
        } catch(e) {
          selectedCandidateId = '';
        }

        // Ask server to compute compatibility against the current chain context.
        const chainIds = Array.isArray(currentChain)
          ? currentChain.map(n => (n && n.id) ? String(n.id) : '').filter(Boolean)
          : [];
        const reqAssignments = chainIds.map((nid, j)=>{
          const curA = (Array.isArray(currentFlagAssignments) && currentFlagAssignments[j]) ? currentFlagAssignments[j] : {};
          const curId = String((curA && (curA.id || curA.generator_id)) || '').trim();
          return { node_id: nid, id: curId };
        });
        const candidateIds = filtered.map(g => String((g && g.id) || '').trim()).filter(Boolean);

        // Render optimistic placeholder.
        candBody.innerHTML = '';
        if(!candidateIds.length){
          const tr = document.createElement('tr');
          const td = document.createElement('td');
          td.colSpan = 4;
          td.className = 'text-muted small';
          td.textContent = 'No matches.';
          tr.appendChild(td);
          candBody.appendChild(tr);
          return;
        }

        (async ()=>{
          let candidates = [];
          try {
            const res = await postJson('/api/flag-sequencing/substitution_candidates', {
              scenario: activeScenario,
              preview_plan: (lastPreviewPlanPath || lastFlowPlanPath || ''),
              chain_ids: chainIds,
              flag_assignments: reqAssignments,
              index: i,
              kind,
              candidate_ids: candidateIds,
            }, { timeoutMs: 45000 });
            candidates = (res && Array.isArray(res.candidates)) ? res.candidates.slice() : [];
          } catch(e) {
            // If this fails, fall back to showing everything as selectable.
            candidates = candidateIds.map((gid)=>{
              const g = filtered.find(x => String((x && x.id) || '').trim() === gid) || {};
              return {
                id: String(gid),
                name: String((g && g.name) || ''),
                source: String((g && g._source_name) || '').trim() || 'unknown',
                compatible: true,
                blocked_by: [],
              };
            });
          }

          // Ensure ordering: compatible first (server already does this, but be safe).
          candidates.sort((a,b)=>{
            const ak = (a && a.compatible) ? 0 : 1;
            const bk = (b && b.compatible) ? 0 : 1;
            if(ak !== bk) return ak - bk;
            const an = String((a && a.name) || '').toLowerCase();
            const bn = String((b && b.name) || '').toLowerCase();
            if(an < bn) return -1;
            if(an > bn) return 1;
            return String((a && a.id) || '').localeCompare(String((b && b.id) || ''));
          });

          candBody.innerHTML = '';
          for(const c of candidates){
            const cid = String((c && c.id) || '').trim();
            if(!cid) continue;
            const tr = document.createElement('tr');
            const ok = !!(c && c.compatible);
            if(!ok){
              tr.classList.add('text-muted');
              tr.style.opacity = '0.6';
            }

            const tdPick = document.createElement('td');
            tdPick.style.width = '1%';
            tdPick.style.whiteSpace = 'nowrap';
            const radio = document.createElement('input');
            radio.type = 'radio';
            radio.name = 'flowSubstitutePick';
            radio.value = cid;
            radio.checked = !!(selectedCandidateId && selectedCandidateId === cid);
            radio.addEventListener('change', ()=>{
              selectedCandidateId = cid;
            });
            tdPick.appendChild(radio);

            const tdGen = document.createElement('td');
            tdGen.style.whiteSpace = 'nowrap';
            const nm = String((c && c.name) || '').trim();
            tdGen.textContent = nm ? (cid + ' — ' + nm) : cid;

            const tdSrc = document.createElement('td');
            tdSrc.style.whiteSpace = 'nowrap';
            tdSrc.textContent = String((c && c.source) || '').trim() || '-';

            const tdWhy = document.createElement('td');
            tdWhy.className = 'small';
            const blocked = (c && Array.isArray(c.blocked_by)) ? c.blocked_by.map(x => String(x || '').trim()).filter(Boolean) : [];
            tdWhy.textContent = ok ? '' : (blocked.length ? blocked.join(' · ') : 'incompatible');

            tr.appendChild(tdPick);
            tr.appendChild(tdGen);
            tr.appendChild(tdSrc);
            tr.appendChild(tdWhy);

            // Clicking a compatible row selects it.
            tr.addEventListener('click', ()=>{
              selectedCandidateId = cid;
              try { radio.checked = true; } catch(e) {}
            });

            candBody.appendChild(tr);
          }

          // If current selection is not present, clear it.
          if(selectedCandidateId){
            const found = candidates.find(x => String((x && x.id) || '') === selectedCandidateId);
            if(!found){
              selectedCandidateId = '';
            }
          }
        })();
      }

      btn.addEventListener('click', async ()=>{
        await showSubstituteUI();
      });

      cancelBtn.addEventListener('click', ()=>{
        form.classList.add('d-none');
        btn.disabled = false;
        try {
          if(typeof nodeDetailsDialogEl.close === 'function') nodeDetailsDialogEl.close();
        } catch(e) {}
      });

      kindSel.addEventListener('change', ()=>{
        rebuildSourceOptions();
        rebuildGeneratorOptions();
      });
      sourceSel.addEventListener('change', ()=>{
        rebuildGeneratorOptions();
      });
      entryInput.addEventListener('input', ()=>{
        // live filter for Entry mode
        if(String(sourceSel.value || '') === '__entry__') rebuildGeneratorOptions();
      });

      applyBtn.addEventListener('click', async ()=>{
        const chosenId = String(selectedCandidateId || '').trim();
        if(!chosenId){
          setStatus('Select a generator first.', true);
          return;
        }
        // Prevent double submits while we persist + save.
        try { applyBtn.disabled = true; } catch(e) {}
        try { cancelBtn.disabled = true; } catch(e) {}
        try{
          if(!Array.isArray(currentChain) || currentChain.length === 0){
            throw new Error('Generate a chain first.');
          }
          const chainIds = currentChain.map(n => (n && n.id) ? String(n.id) : '').filter(Boolean);
          if(!chainIds.length) throw new Error('Missing chain ids.');

          const reqAssignments = chainIds.map((nid, j)=>{
            const curA = (Array.isArray(currentFlagAssignments) && currentFlagAssignments[j]) ? currentFlagAssignments[j] : {};
            const curId = String((curA && (curA.id || curA.generator_id)) || '').trim();
            const idOut = (j === i) ? chosenId : curId;
            return { node_id: nid, id: idOut };
          });
          // Ensure all entries have ids.
          const missing = reqAssignments.find(x => !x.id);
          if(missing){
            throw new Error('Cannot save substitution because some chain positions have no generator assignment yet. Try Generate again.');
          }

          showLoading('Saving substitution…');
          const res = await postJson('/api/flag-sequencing/save_flow_substitutions', {
            scenario: activeScenario,
            chain_ids: chainIds,
            preview_plan: (lastPreviewPlanPath || lastFlowPlanPath || ''),
            flag_assignments: reqAssignments,
          }, { timeoutMs: 60000 });

          setFlowValidityFromPayload(res);
          if(res && Array.isArray(res.chain)){
            currentChain = res.chain.slice();
          }
          if(res && Array.isArray(res.flag_assignments)){
            currentFlagAssignments = res.flag_assignments.slice();
          }
          if(res && res.flow_plan_path){
            lastFlowPlanPath = String(res.flow_plan_path);
          }
          updateMeta();
          renderChainEditor();
          form.classList.add('d-none');
          btn.disabled = false;
          setStatus('Substitution saved. Saving XML…', false);

          // Close immediately so the user doesn't see the substitute UI while hints resolve.
          try {
            if(typeof nodeDetailsDialogEl.close === 'function') nodeDetailsDialogEl.close();
          } catch(e) {}

          // Save XML (this also resolves hints / runs generators) so the UI shows
          // updated flag values and rendered hints immediately.
          try {
            await saveXmlOnly({});
          } catch(e) {
            // Non-fatal; substitution was persisted.
            setStatus('Saved substitution, but Save XML failed: ' + String(e && e.message || e), true);
          }
        } catch(e){
          setStatus('Failed to save substitution: ' + String(e && e.message || e), true);
        } finally {
          try { applyBtn.disabled = false; } catch(e) {}
          try { cancelBtn.disabled = false; } catch(e) {}
          hideLoading();
        }
      });

      // If invoked from the Chain Order row Substitute button, open the substitute
      // UI immediately.
      if(openSubstitute){
        try { showSubstituteUI(); } catch(e) {}
      }

      // Full-width so the substitute box starts at the far left.
      addFullRow(box);
    } catch(e) {
      // Non-fatal
    }

    try{
      if(typeof nodeDetailsDialogEl.showModal === 'function'){
        nodeDetailsDialogEl.showModal();
      }
    } catch(e) {
      // If dialog isn't supported, do nothing.
    }
  }

  function selectChainIndex(idx){
    selectedChainIndex = Number.isFinite(+idx) ? (+idx) : -1;
    if(selectedChainIndex < 0 || !Array.isArray(currentChain) || selectedChainIndex >= currentChain.length){
      selectedChainIndex = -1;
      renderChainEditor();
      return;
    }
    renderChainEditor();
  }

  function updateMeta(){
    if(metaScenarioEl) metaScenarioEl.textContent = (activeScenario || '') ? String(activeScenario) : '-';
    if(metaPreviewEl) metaPreviewEl.textContent = lastPreviewPlanPath ? basenameFromPath(lastPreviewPlanPath) : '-';
    if(metaStatsEl) metaStatsEl.textContent = formatStats(lastStats) || '-';
  }

  async function refreshBundleFromChain(){
    if(!Array.isArray(currentChain) || currentChain.length === 0) return;
    setStatus('Updating bundle…', false);
    try{
      const data = await postJson('/api/flag-sequencing/bundle_from_chain', { scenario: activeScenario, chain: currentChain });
      currentBundle = data.bundle;
      currentFlagAssignments = Array.isArray(data.flag_assignments) ? data.flag_assignments.slice() : currentFlagAssignments;
      setFlowValidityFromPayload(data);
      if(jsonEl) jsonEl.textContent = JSON.stringify(currentBundle, null, 2);
      const diagram = buildMermaid(currentChain);
      await renderMermaid(diagram);
      updateMeta();
      setStatus('Ready.', false);
    } catch(err){
      setStatus(String(err && err.message || err), true);
    }
  }

  function formatStats(stats){
    if(!stats || typeof stats !== 'object') return '';
    const fg = Number.isFinite(+stats.flag_generator_eligible_total) ? (+stats.flag_generator_eligible_total) : (Number.isFinite(+stats.eligible_total) ? (+stats.eligible_total) : null);
    const fng = Number.isFinite(+stats.flag_node_generator_eligible_total) ? (+stats.flag_node_generator_eligible_total) : (Number.isFinite(+stats.docker_nonvuln_total) ? (+stats.docker_nonvuln_total) : null);
    const v = Number.isFinite(+stats.vuln_total) ? (+stats.vuln_total) : null;
    const dOther = Number.isFinite(+stats.docker_nonvuln_total) ? (+stats.docker_nonvuln_total) : null;
    if(fg === null && fng === null && v === null && dOther === null) return '';
    const parts = [];
    if(fg !== null) parts.push('Flag-Generator eligible: ' + fg);
    if(fng !== null) parts.push('Flag-Node-Generator eligible: ' + fng);
    if(v !== null) parts.push('Vuln nodes: ' + v);
    if(dOther !== null) parts.push('Other Docker Nodes: ' + dOther);
    return parts.join(' · ');
  }

  function buildMermaid(chain){
    const lines = ['flowchart LR'];
    if(!Array.isArray(chain) || chain.length === 0){
      lines.push('  A[No chain available]');
      return lines.join('\n');
    }
    for(let i=0;i<chain.length;i++){
      const node = chain[i];
      const safeId = 'N' + i;
      const label = (node && node.name) ? node.name : ('Node ' + (i+1));
      const seq = toRoman(i + 1);
      const prefixed = (seq ? (seq + '. ') : '') + String(label || '');
      lines.push(`  ${safeId}[${prefixed.replace(/\]/g,'')}]`);
      if(i>0){
        lines.push(`  N${i-1} --> ${safeId}`);
      }
    }
    for(let i=0;i<chain.length;i++){
      lines.push(`  click N${i} flowSelectNode "Show details"`);
    }
    return lines.join('\n');
  }

  async function renderMermaid(diagramText){
    try {
      if(window.mermaid){
        mermaid.initialize({ startOnLoad: false, securityLevel: 'loose' });
        const wrap = document.getElementById('flowDiagram');
        wrap.textContent = diagramText;
        wrap.removeAttribute('data-processed');
        await mermaid.run({ querySelector: '#flowDiagram' });
      }
    } catch(e) {
      // If rendering fails, keep plaintext.
      const wrap = document.getElementById('flowDiagram');
      if(wrap) wrap.textContent = diagramText;
    }
  }

  function shouldOfferBestEffort(err){
    try{
      const p = err && err.payload && typeof err.payload === 'object' ? err.payload : null;
      const available = p && Number.isFinite(+p.available) ? (+p.available) : null;
      if(!available || available <= 0) return null;
      const msg = (p && (p.error || p.message)) ? String(p.error || p.message) : '';
      if(msg && !msg.toLowerCase().includes('eligible')) return null;
      return { available, message: msg, requested: p && Number.isFinite(+p.requested_length) ? (+p.requested_length) : null };
    } catch(e){
      return null;
    }
  }

  async function generate(preferPreview){
    const usePreview = !!preferPreview;
    const scenario = (scenarioEl && scenarioEl.value || '').trim();
    const preset = (presetEl && presetEl.value) ? String(presetEl.value).trim() : '';
    const length = preset ? 3 : (parseInt((lengthEl && lengthEl.value) || '5', 10) || 5);

    const params = new URLSearchParams();
    if(scenario) params.set('scenario', scenario);
    params.set('length', String(length));
    if(preset) params.set('preset', preset);
    // Only force preview selection when the user explicitly clicks Generate.
    if(usePreview){
      params.set('prefer_preview', '1');
      params.set('force_preview', '1');
    }

    const baseApiUrl = '/api/flag-sequencing/attackflow_preview?' + params.toString();
    if(downloadLink) downloadLink.href = '#';

    setStatus('Generating…', false);
    setLoginLinkVisible(false);
    showLoading('Generating flow…');
    if(metaScenarioEl) metaScenarioEl.textContent = '';
    if(metaPreviewEl) metaPreviewEl.textContent = '';
    if(metaStatsEl) metaStatsEl.textContent = '';
    if(jsonEl) jsonEl.textContent = '';

    try {
      let data;
      try{
        data = await fetchJson(baseApiUrl);
      } catch(err){
        // If Generate requested a longer chain than available, ask user whether to
        // retry in best-effort mode (clamp to available) or cancel.
        const offer = usePreview ? shouldOfferBestEffort(err) : null;
        if(offer){
          const want = confirm(`Only ${offer.available} eligible nodes are available for this scenario.\n\nRun Generate in best-effort mode (use ${offer.available})?`);
          if(!want){
            hideLoading();
            setStatus('Generate cancelled.', false);
            return;
          }
          const params2 = new URLSearchParams(params.toString());
          params2.set('best_effort', '1');
          const retryUrl = '/api/flag-sequencing/attackflow_preview?' + params2.toString();
          data = await fetchJson(retryUrl);
        } else {
          throw err;
        }
      }
      currentChain = Array.isArray(data.chain) ? data.chain.slice() : [];
      currentBundle = data.bundle || null;
      currentFlagAssignments = Array.isArray(data.flag_assignments) ? data.flag_assignments.slice() : [];
      setFlowValidityFromPayload(data);
      lastStats = data.stats || null;
      lastPreviewPlanPath = data.preview_plan_path || '';
      lastFlowPlanPath = data.flow_plan_path || lastFlowPlanPath;
      try {
        // If the backend loaded a saved chain whose effective length differs from the
        // current input value (e.g. page reload reset to default), keep the UI in sync.
        const effLen = Number.isFinite(+data.length) ? (+data.length) : null;
        if (effLen !== null && lengthEl) lengthEl.value = String(effLen);
      } catch(e) {}
      updateMeta();
      selectedChainIndex = -1;
      renderChainEditor();
      persistFlowState();

      if(jsonEl) jsonEl.textContent = JSON.stringify(currentBundle, null, 2);
      const diagram = buildMermaid(currentChain);
      await renderMermaid(diagram);

      // Optional (user-click only): run the prepare step so generator outputs can resolve
      // hint templates immediately (e.g., IPs/ports/usernames) without requiring a refresh.
      if(usePreview){
        try{
          if(Array.isArray(currentChain) && currentChain.length){
            showLoading('Resolving hint values…');
            setStatus('Resolving hint values…', false);
            const chainIds = currentChain.map(n => (n && n.id) ? String(n.id) : '').filter(Boolean);
            const prepData = await postJson(
              '/api/flag-sequencing/prepare_preview_for_execute',
              {
                scenario,
                length: currentChain.length,
                preset,
                chain_ids: chainIds,
                preview_plan: (lastFlowPlanPath || lastPreviewPlanPath || ''),
                mode: 'hint',
                best_effort: true,
                timeout_s: 30
              },
              { timeoutMs: 35000 }
            );
            setFlowValidityFromPayload(prepData);

            // If the server adjusted the chain (rare, e.g. preset repair), keep UI in sync.
            const oldIds = chainIds.join('|');
            const newChain = (prepData && Array.isArray(prepData.chain)) ? prepData.chain.slice() : null;
            const newIds = (newChain || []).map(n => (n && n.id) ? String(n.id) : '').filter(Boolean).join('|');
            if(newChain && newChain.length){
              currentChain = newChain;
            }

            if(prepData && Array.isArray(prepData.flag_assignments)){
              currentFlagAssignments = prepData.flag_assignments.slice();
              renderChainEditor();
            }
            if(prepData && prepData.preview_plan_path){
              lastPreviewPlanPath = String(prepData.preview_plan_path);
              updateMeta();
            }
            if(prepData && prepData.flow_plan_path){
              lastFlowPlanPath = String(prepData.flow_plan_path);
            }

            // If chain changed, regenerate the bundle to match (keep resolved hints in UI).
            if(newChain && newIds && oldIds !== newIds){
              await refreshBundleFromChain();
              if(prepData && Array.isArray(prepData.flag_assignments)){
                currentFlagAssignments = prepData.flag_assignments.slice();
                renderChainEditor();
              }
              const diagram2 = buildMermaid(currentChain);
              await renderMermaid(diagram2);
            }
          }
        } catch(e) {
          // Non-fatal: the flow/bundle is still usable even if hints aren't resolved.
          try {
            const msg = (e && e.message) ? String(e.message) : String(e || 'prepare failed');
            setStatus('Hint resolution failed: ' + msg, true);
          } catch(_) {}
        }
      }

      setStatus('Ready.', false);
    } catch(err){
      setStatus(String(err && err.message || err), true);
      setLoginLinkVisible(!!(err && err.loginRequired));
      const payload = err && err.payload ? err.payload : null;
      setFlowValidityFromPayload(payload);
      lastStats = payload && payload.stats ? payload.stats : null;
      lastPreviewPlanPath = payload && payload.preview_plan_path ? String(payload.preview_plan_path) : '';
      lastFlowPlanPath = payload && payload.flow_plan_path ? String(payload.flow_plan_path) : lastFlowPlanPath;
      updateMeta();
      currentChain = [];
      currentBundle = null;
      currentFlagAssignments = [];
      selectedChainIndex = -1;
      renderChainEditor();
      const diagram = buildMermaid([]);
      await renderMermaid(diagram);
    } finally {
      hideLoading();
    }
  }

  async function execute(){
    const scenario = (scenarioEl && scenarioEl.value || '').trim();
    const preset = (presetEl && presetEl.value) ? String(presetEl.value).trim() : '';
    const length = (Array.isArray(currentChain) && currentChain.length) ? currentChain.length : (parseInt((lengthEl && lengthEl.value) || '5', 10) || 5);
    if(!scenario){
      setStatus('No scenario selected.', true);
      return;
    }
    // If the shared Execute button is gated (CORE VM not verified), it won't be clickable,
    // but keep this guard anyway in case something calls execute() programmatically.
    if(execEl && execEl.disabled){
      setStatus('Verify a CORE VM in VM / Access to enable Execute.', true);
      return;
    }
    if(execEl) execEl.disabled = true;
    setStatus('Preparing preview for execution…', false);
    setLoginLinkVisible(false);
    showLoading('Resolving hint values…');
    try{
      if(!Array.isArray(currentChain) || currentChain.length === 0){
        throw new Error('Generate a chain first.');
      }
      const chainIds = currentChain.map(n => (n && n.id) ? String(n.id) : '').filter(Boolean);
      const planPath = (lastFlowPlanPath || lastPreviewPlanPath || '');
      const prepData = await postJson(
        '/api/flag-sequencing/prepare_preview_for_execute',
        {
          scenario,
          length,
          preset,
          chain_ids: chainIds,
          preview_plan: planPath
        },
        { timeoutMs: 480000 }
      );
      setFlowValidityFromPayload(prepData);
      // Prefer server-returned (possibly enriched) assignments so the UI can show
      // generator run status/mismatch info before scenario execution.
      if(prepData && Array.isArray(prepData.flag_assignments)){
        currentFlagAssignments = prepData.flag_assignments.slice();
        renderChainEditor();
      }
      const xmlPath = (prepData && prepData.xml_path) ? String(prepData.xml_path) : '';
      const previewPlan = (prepData && prepData.preview_plan_path) ? String(prepData.preview_plan_path) : '';
      const flowPlan = (prepData && prepData.flow_plan_path) ? String(prepData.flow_plan_path) : '';
      if(!xmlPath || !previewPlan){
        throw new Error('Prepare step did not return xml_path/preview_plan_path');
      }
      if(flowPlan) lastFlowPlanPath = flowPlan;
      setStatus('Starting async execution…', false);
      const runData = await postJson('/run_cli_async', { xml_path: xmlPath, preview_plan: (flowPlan || planPath || previewPlan), scenario });
      const runId = runData && runData.run_id ? String(runData.run_id) : '';
      if(runId){
        setStatus('Run started: ' + runId + ' (see Core/Reports pages).', false);
      } else {
        setStatus('Run started (missing run_id).', false);
      }
    } catch(err){
      setStatus(String(err && err.message || err), true);
      setLoginLinkVisible(!!(err && err.loginRequired));
    } finally {
      hideLoading();
      try {
        if (typeof window.coretgRefreshScenariosExecuteButtonState === 'function') {
          window.coretgRefreshScenariosExecuteButtonState();
        } else if (execEl) {
          execEl.disabled = false;
        }
      } catch (e) {
        if (execEl) execEl.disabled = false;
      }
    }
  }

  async function preview(){
    // Save XML, persist a preview plan, persist flow sequencing, then redirect to Preview.
    try {
      const scenario = (scenarioEl && scenarioEl.value || '').trim();
      if(!scenario){
        setStatus('No scenario selected.', true);
        return;
      }
      persistFlowState();
      if(typeof window.coretgSaveXmlViaApi !== 'function' || typeof window.coretgPostJson !== 'function'){
        setStatus('Save helper unavailable; refresh and try again.', true);
        return;
      }

      if(execEl) execEl.disabled = true;
      setStatus('Saving XML…', false);
      showLoading('Saving XML…');
      const xmlPath = await window.coretgSaveXmlViaApi();
      if(!xmlPath){
        throw new Error('Save did not return xml_path');
      }

      // Ensure we have a persisted preview plan artifact to base Flow changes on.
      setStatus('Preparing preview plan…', false);
      showLoading('Preparing preview plan…');
      const persisted = await window.coretgPostJson('/api/plan/persist_preview_plan', { xml_path: xmlPath, scenario });
      const previewPlan = (persisted && persisted.preview_plan_path) ? String(persisted.preview_plan_path) : '';
      if(!previewPlan){
        throw new Error('Failed to persist preview plan');
      }

      // Persist the current chain into a flow-modified plan immediately.
      const preset = (presetEl && presetEl.value) ? String(presetEl.value).trim() : '';
      const chainIds = Array.isArray(currentChain) ? currentChain.map(n => (n && n.id) ? String(n.id) : '').filter(Boolean) : [];
      if(chainIds.length){
        setStatus('Saving Flag Sequencing…', false);
        showLoading('Saving Flag Sequencing…');
        await window.coretgPostJson('/api/flag-sequencing/prepare_preview_for_execute', {
          scenario,
          preset,
          length: chainIds.length,
          chain_ids: chainIds,
          preview_plan: previewPlan,
        });
      }

      // Navigate to Preview tab.
      const baseUrl = String(document.getElementById('scenariosPreviewTabLink')?.dataset?.previewBaseUrl || '/scenarios/preview');
      const url = baseUrl + '?xml_path=' + encodeURIComponent(xmlPath) + '&scenario=' + encodeURIComponent(scenario);
      window.location.href = url;
    } catch(e) {
      setStatus('Preview failed: ' + String(e && e.message || e), true);
    } finally {
      hideLoading();
      try {
        if (typeof window.coretgRefreshScenariosExecuteButtonState === 'function') {
          window.coretgRefreshScenariosExecuteButtonState();
        } else if (execEl) {
          execEl.disabled = false;
        }
      } catch (e) {
        if (execEl) execEl.disabled = false;
      }
    }
  }

  async function saveXmlStay(){
    try {
      persistFlowState();
      if(typeof window.coretgSaveXmlViaApi !== 'function'){
        setStatus('Save helper unavailable; refresh and try again.', true);
        return;
      }
      if(saveXmlEl) saveXmlEl.disabled = true;
      showLoading('Saving XML…');
      const xmlPath = await window.coretgSaveXmlViaApi();
      if(xmlPath){
        try {
          const xmlPathInput = document.getElementById('scenariosPreviewXmlPath');
          if(xmlPathInput) xmlPathInput.value = String(xmlPath);
        } catch(e) {}
        try {
          if(downloadXmlEl){
            downloadXmlEl.disabled = false;
            downloadXmlEl.removeAttribute('title');
          }
        } catch(e) {}
        setStatus('Saved XML: ' + basenameFromPath(xmlPath), false);
        try { await refreshXmlDockPreview({ force: true }); } catch(e) {}
      } else {
        setStatus('Saved XML (missing path).', false);
      }
    } catch(e){
      setStatus('Save failed: ' + String(e && e.message || e), true);
    } finally {
      hideLoading();
      if(saveXmlEl) saveXmlEl.disabled = false;
    }
  }

  // Bottom-bar buttons: Save XML saves and stays; Preview saves then redirects.
  document.addEventListener('DOMContentLoaded', () => {
    try {
      if(saveXmlEl){
        saveXmlEl.addEventListener('click', (ev) => {
          try { ev.preventDefault(); } catch(e) {}
          saveXmlStay();
        });
      }
    } catch(e) {}
    try {
      if(execEl){
        execEl.addEventListener('click', (ev) => {
          try { ev.preventDefault(); } catch(e) {}
          preview();
        });
      }
    } catch(e) {}
  });

  async function saveXmlOnly(opts){
    const options = (opts && typeof opts === 'object') ? opts : {};
    const scenario = (scenarioEl && scenarioEl.value || '').trim();
    const preset = (presetEl && presetEl.value) ? String(presetEl.value).trim() : '';
    const length = (Array.isArray(currentChain) && currentChain.length) ? currentChain.length : (parseInt((lengthEl && lengthEl.value) || '5', 10) || 5);
    if(!scenario){
      setStatus('No scenario selected.', true);
      return '';
    }
    if(saveXmlEl) saveXmlEl.disabled = true;
    setStatus('Preparing preview and saving XML…', false);
    setLoginLinkVisible(false);
    showLoading('Resolving hint values…');
    try{
      if(!Array.isArray(currentChain) || currentChain.length === 0){
        throw new Error('Generate a chain first.');
      }
      const chainIds = currentChain.map(n => (n && n.id) ? String(n.id) : '').filter(Boolean);
      const planPath = (lastFlowPlanPath || lastPreviewPlanPath || '');
      const prepData = await postJson('/api/flag-sequencing/prepare_preview_for_execute', { scenario, length, preset, chain_ids: chainIds, preview_plan: planPath });
      setFlowValidityFromPayload(prepData);
      if(prepData && Array.isArray(prepData.flag_assignments)){
        currentFlagAssignments = prepData.flag_assignments.slice();
        renderChainEditor();
      }
      const xmlPath = (prepData && prepData.xml_path) ? String(prepData.xml_path) : '';
      const previewPlan = (prepData && prepData.preview_plan_path) ? String(prepData.preview_plan_path) : '';
      if(!xmlPath || !previewPlan){
        throw new Error('Prepare step did not return xml_path/preview_plan_path');
      }
      lastPreviewPlanPath = previewPlan;
      try {
        if(prepData && prepData.flow_plan_path) lastFlowPlanPath = String(prepData.flow_plan_path);
      } catch(e) {}
      updateMeta();
      try {
        const xmlPathInput = document.getElementById('scenariosPreviewXmlPath');
        if(xmlPathInput) xmlPathInput.value = xmlPath;
      } catch(e) {}
      try {
        if(downloadXmlEl){
          downloadXmlEl.disabled = false;
          downloadXmlEl.removeAttribute('title');
        }
      } catch(e) {}
      setStatus('Saved XML: ' + basenameFromPath(xmlPath), false);
      try { await refreshXmlDockPreview({ force: true }); } catch(e) {}
      return xmlPath;
    } catch(err){
      setStatus(String(err && err.message || err), true);
      setLoginLinkVisible(!!(err && err.loginRequired));
      // If preview requested, surface failure by throwing so caller does not redirect.
      if (options && options.redirectAfter) throw err;
      return '';
    } finally {
      hideLoading();
      if(saveXmlEl) saveXmlEl.disabled = false;
    }
  }

  function downloadXml(){
    try {
      const xmlPath = (document.getElementById('scenariosPreviewXmlPath')?.value || '').trim();
      if(!xmlPath){
        setStatus('Save XML first to download.', true);
        return;
      }
      window.location.href = '/download_report?path=' + encodeURIComponent(xmlPath);
    } catch(err){
      setStatus(String(err && err.message || err), true);
    }
  }

  // Expose a mermaid click callback; it receives the nodeId like "N0".
  window.flowSelectNode = function(nodeId){
    try{
      const m = String(nodeId || '').match(/^N(\d+)$/);
      if(!m) return;
      const idx = parseInt(m[1], 10);
      if(Number.isFinite(idx)){
        selectChainIndex(idx);
        openNodeDetailsDialog(idx);
      }
    } catch(e) {}
  };

  // Allow clicking the backdrop to close the node dialog.
  try{
    if(nodeDetailsDialogEl){
      nodeDetailsDialogEl.addEventListener('click', (ev)=>{
        try {
          if(ev && ev.target === nodeDetailsDialogEl && typeof nodeDetailsDialogEl.close === 'function'){
            nodeDetailsDialogEl.close();
          }
        } catch(e) {}
      });
    }
  } catch(e) {}

  if(btnEl) btnEl.addEventListener('click', (e)=>{ e.preventDefault(); generate(true); });
  // Handlers for Save/Preview are registered above.
  if(downloadXmlEl) downloadXmlEl.addEventListener('click', (e)=>{ e.preventDefault(); downloadXml(); });

  if(downloadLink){
    downloadLink.addEventListener('click', (e)=>{
      try{
        e.preventDefault();
        if(!currentBundle){
          setStatus('Nothing to download yet (generate first).', true);
          return;
        }
        const scenario = (scenarioEl && scenarioEl.value || activeScenario || 'scenario').toString().trim();
        const norm = normalizeScenarioNorm(scenario).replace(/\s+/g,'_') || 'scenario';
        const fname = 'attackflow_' + norm + '_' + String(Array.isArray(currentChain)?currentChain.length:0) + '.json';
        const blob = new Blob([JSON.stringify(currentBundle, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = fname;
        document.body.appendChild(a);
        a.click();
        a.remove();
        setTimeout(()=>URL.revokeObjectURL(url), 1000);
      } catch(err){
        setStatus(String(err && err.message || err), true);
      }
    });
  }

  // Wire scenario list.
  if(scenarioListEl){
    scenarioListEl.querySelectorAll('[data-scen-name]').forEach(btn => {
      btn.addEventListener('click', async ()=>{
        const name = btn.getAttribute('data-scen-name') || '';
        if(!name || name === activeScenario) return;
        await setScenario(name);
      });
    });
  }
  if(clearScenarioBtn){
    clearScenarioBtn.addEventListener('click', async ()=>{
      const def = defaultScenarioName();
      if(def && def !== activeScenario) await setScenario(def);
    });
  }

  // Auto-generate on load (per-scenario page). If there are no scenarios, disable.
  if(!activeScenario){
    setStatus('No scenarios available yet.', true);
    if(btnEl) btnEl.disabled = true;
    return;
  }
  if(scenarioEl && !scenarioEl.value) scenarioEl.value = activeScenario;
  if(scenarioLabelEl && !scenarioLabelEl.textContent) scenarioLabelEl.textContent = activeScenario;
  updateScenarioQueryParam();
  updateScenarioFilterControls();
  refreshParticipantNavForScenario(activeScenario);
  // Auto-generate on load (prefer any saved Flow state).
  try { refreshXmlDockPreview({ force: false }); } catch(e) {}
  generate(false);
})();
</script>
{% endblock %}
  // Scenarios header Preview tab: route to /scenarios/preview.
  document.addEventListener('DOMContentLoaded', ()=>{
    const link = document.getElementById('scenariosPreviewTabLink');
    if(!link) return;
    link.addEventListener('click', (ev)=>{
      try {
        ev.preventDefault();
        const xmlPath = (document.getElementById('scenariosPreviewXmlPath')?.value || '').trim();
        const scen = (document.getElementById('flowScenario')?.value || document.getElementById('scenariosPreviewScenario')?.value || '').trim();
        if(!xmlPath){
          alert('Save XML first to preview.');
          return;
        }
        const baseUrl = String(link.dataset?.previewBaseUrl || '/scenarios/preview');
        const url = baseUrl + '?xml_path=' + encodeURIComponent(xmlPath) + (scen ? ('&scenario=' + encodeURIComponent(scen)) : '');
        window.location.href = url;
      } catch(e){}
    });
  });

