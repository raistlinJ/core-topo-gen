{% extends 'layout.html' %}
{% block title %}Flag Sequencing{% endblock %}
{% block active_page %}{% set active_page='scenarios' %}{% endblock %}
{% block header_icon %}<i class="bi bi-bezier2 fs-4"></i>{% endblock %}
{% block header_title %}Flag Sequencing{% endblock %}

{% block extra_head %}
<script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
<style>
  body { padding-bottom: 0; }
  #flowLayoutRow { min-height: calc(100vh - 200px); }
  /* Prevent long <pre>/<svg> content from forcing the Bootstrap row to wrap columns. */
  #flowLayoutRow > [class*='col-'] { min-width: 0; }
  @media (max-width: 992px) {
    #flowLayoutRow { min-height: 0; }
  }
</style>
{% endblock %}

{% block content %}
{% set scenario_tab = (active_scenario or request.args.get('scenario','')) %}
{% set scenarios_active_tab = 'flag-sequencing' %}
{% include 'partials/scenarios_tabs.html' with context %}
<div class="container-fluid mt-3 d-flex flex-column" id="flowPageWrap">
  <div class="row g-3 flex-grow-1 align-items-stretch" id="flowLayoutRow">
    <div class="col-12 col-lg-3 d-flex">
      <div class="card shadow-sm mb-3 flex-fill d-flex flex-column">
        <div class="card-header d-flex justify-content-between align-items-center">
          <span class="fw-bold">Scenarios</span>
          <button class="btn btn-sm btn-outline-secondary {% if not active_scenario %}d-none{% endif %}" id="flowScenarioFilterClear" type="button" title="Clear">Clear</button>
        </div>
        <div class="list-group list-group-flush flex-grow-1 overflow-auto" id="flowScenarioList" style="min-height:0;">
          {% if scenarios %}
            {% for s in scenarios %}
            <button type="button" class="list-group-item list-group-item-action py-1 {% if active_scenario and active_scenario==s %}active bg-primary text-white{% endif %}" data-scen-name="{{ s }}">{{ s }}</button>
            {% endfor %}
          {% else %}
            <div class="p-3 text-muted small">No scenarios yet</div>
          {% endif %}
        </div>
      </div>
    </div>

    <div class="col-12 col-lg-9 d-flex">
      <div class="flex-fill d-flex flex-column">
        <div class="d-flex align-items-center justify-content-between flex-wrap gap-2 mb-3">
          <div class="fw-semibold">Generate an Attack Flow from the latest preview plan</div>
        </div>

        <div class="card mb-3">
          <div class="card-body">
            <input id="flowScenario" class="form-control d-none" value="{{ active_scenario or request.args.get('scenario','') }}">
            <div class="row g-2 align-items-end">
              <div class="col-sm-6 col-md-2">
                <label class="form-label">Chain Length</label>
                <input id="flowLength" class="form-control" type="number" min="1" max="50" value="5">
              </div>
              <div class="col-sm-6 col-md-4">
                <label class="form-label">Preset</label>
                <select id="flowPreset" class="form-select">
                  <option value="">Random (default)</option>
                  <option value="sample_reverse_nfs_ssh">Sample: reverse_nfs_ssh</option>
                </select>
              </div>
              <div class="col-md-6">
                <div class="d-flex gap-2 flex-nowrap">
                  <button id="flowGenerateBtn" class="btn btn-primary text-nowrap" type="button">Generate</button>
                  <a id="flowBundleDownloadLink" class="btn btn-outline-primary text-nowrap" href="#" role="button">Download Attack Flow STIX Bundle</a>
                </div>
              </div>
              <div class="col-md-4">
                <div class="small">
                  <span id="flowStatus" class="text-muted"></span>
                  <a id="flowLoginLink" class="ms-2 d-none" href="/login">Login</a>
                </div>
              </div>
            </div>
            <div class="small text-muted mt-2">Current rule: flags are placed on Docker-role nodes and vulnerability nodes. Vulnerability nodes are only assigned <span class="font-monospace">flag-generator</span> flags (not <span class="font-monospace">flag-node-generator</span>). Default chain order is randomized; you can tweak it below.</div>
          </div>
        </div>

        <div id="flowValidityAlert" class="alert alert-danger d-none" role="alert"></div>

        <div class="card mb-3">
          <div class="card-header d-flex align-items-center justify-content-between">
            <div class="fw-semibold">Visualization</div>
          </div>
          <div class="card-body">
            <div class="row g-2 small text-muted align-items-center mb-2" id="flowMetaRow">
              <div class="col-12 col-md-4">
                <span class="text-secondary">Scenario:</span>
                <span class="ms-1" id="flowMetaScenario"></span>
              </div>
              <div class="col-12 col-md-5">
                <span class="text-secondary">Preview:</span>
                <span class="ms-1" id="flowMetaPreview"></span>
              </div>
              <div class="col-12 col-md-3">
                <span class="text-secondary">Docker/Vuln:</span>
                <span class="ms-1" id="flowMetaStats"></span>
              </div>
            </div>
            <div id="flowDiagramWrap" class="border rounded p-2" style="min-height: 180px; overflow-x: auto;">
              <div id="flowDiagram" class="mermaid">graph LR\n  A[Generate] --> B[Flow]</div>
            </div>
          </div>
        </div>

        <div class="card mb-3">
          <div class="card-header d-flex align-items-center justify-content-between">
            <div class="fw-semibold">Chain Order</div>
            <div class="small text-muted">Use ↑/↓ to reorder</div>
          </div>
          <div class="card-body">
            <div id="flowChainList" class="list-group"></div>
            <div class="small text-muted mt-2">Reordering updates the bundle and download.</div>
          </div>
        </div>

      </div>
    </div>
  </div>
</div>
{% endblock %}

{% block body_container %}
{{ super() }}
{% set xml_preview_enabled = True %}
{% set xml_preview_text = xml_preview %}
{% include 'partials/dock.html' %}

<!-- Loading overlay shown during slow operations (e.g., resolving hint templates via generator runs). -->
<div id="flowLoadingOverlay" class="position-fixed top-0 start-0 w-100 h-100 d-none" style="z-index: 2000;">
  <div class="position-absolute top-0 start-0 w-100 h-100 bg-dark bg-opacity-50"></div>
  <div class="position-absolute top-50 start-50 translate-middle bg-white rounded shadow p-3" style="min-width: 320px; max-width: 560px;">
    <div class="d-flex align-items-center gap-2">
      <div class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></div>
      <div class="fw-semibold" id="flowLoadingText">Loading…</div>
    </div>
    <div class="small text-muted mt-2">This can take a few seconds while generators run and hints resolve.</div>
  </div>
</div>

<script>
(function(){
  const statusEl = document.getElementById('flowStatus');
  const loginLinkEl = document.getElementById('flowLoginLink');
  const scenarioEl = document.getElementById('flowScenario');
  const scenarioLabelEl = document.getElementById('flowScenarioLabel');
  const lengthEl = document.getElementById('flowLength');
  const presetEl = document.getElementById('flowPreset');
  const btnEl = document.getElementById('flowGenerateBtn');
  const saveXmlEl = document.getElementById('saveXmlBtn');
  const execEl = document.getElementById('scenariosExecuteBtn');
  const downloadXmlEl = document.getElementById('downloadXmlBtn');
  const jsonEl = document.getElementById('flowJson');
  const metaScenarioEl = document.getElementById('flowMetaScenario');
  const metaPreviewEl = document.getElementById('flowMetaPreview');
  const metaStatsEl = document.getElementById('flowMetaStats');
  const downloadLink = document.getElementById('flowBundleDownloadLink');
  const scenarioListEl = document.getElementById('flowScenarioList');
  const clearScenarioBtn = document.getElementById('flowScenarioFilterClear');
  const validityAlertEl = document.getElementById('flowValidityAlert');
  const loadingOverlayEl = document.getElementById('flowLoadingOverlay');
  const loadingTextEl = document.getElementById('flowLoadingText');

  const participantUrlFlags = {{ (participant_url_flags or {})|tojson }};
  const scenarioNamesCache = {{ (scenarios or [])|tojson }};
  const initialScenario = {{ (active_scenario or '')|tojson }};
  let activeScenario = (initialScenario || (Array.isArray(scenarioNamesCache) && scenarioNamesCache.length ? String(scenarioNamesCache[0]) : '')).trim();

  let currentChain = [];
  let currentBundle = null;
  let lastStats = null;
  let lastPreviewPlanPath = '';
  let currentFlagAssignments = [];
  let selectedChainIndex = -1;
  let lastFlowValid = true;
  let lastFlowErrors = [];
  let lastFlagsEnabled = true;

  function showLoading(text){
    try{
      if(!loadingOverlayEl) return;
      if(loadingTextEl) loadingTextEl.textContent = (text || 'Loading…').toString();
      loadingOverlayEl.classList.remove('d-none');
    } catch(e) {}
  }

  function hideLoading(){
    try{
      if(!loadingOverlayEl) return;
      loadingOverlayEl.classList.add('d-none');
    } catch(e) {}
  }

  function setFlowValidityFromPayload(payload){
    const p = payload && typeof payload === 'object' ? payload : null;
    const flowValid = p && ('flow_valid' in p) ? !!p.flow_valid : true;
    const flagsEnabled = p && ('flags_enabled' in p) ? !!p.flags_enabled : true;
    const flowErrors = (p && Array.isArray(p.flow_errors)) ? p.flow_errors.slice() : [];
    lastFlowValid = flowValid;
    lastFlagsEnabled = flagsEnabled;
    lastFlowErrors = flowErrors;
    if(!validityAlertEl) return;
    if(flowValid && flagsEnabled){
      validityAlertEl.classList.add('d-none');
      validityAlertEl.textContent = '';
      return;
    }
    const base = 'Invalid flag dependency order: execution will run WITHOUT flags.';
    const details = flowErrors.length ? (' ' + flowErrors.join(' | ')) : '';
    validityAlertEl.textContent = base + details;
    validityAlertEl.classList.remove('d-none');
  }

  async function refreshXmlDockPreview({ force = false } = {}){
    const xmlPre = document.getElementById('xmlPre');
    if(!xmlPre) return;
    const xmlPath = (document.getElementById('scenariosPreviewXmlPath')?.value || '').trim();
    const lastPath = (xmlPre.dataset.xmlPreviewPath || '').trim();
    if(!xmlPath){
      if(force){
        try { xmlPre.textContent = ''; } catch(e) {}
        try { xmlPre.dataset.xmlPreviewPath = ''; } catch(e) {}
      }
      return;
    }
    if(!force && xmlPre.textContent.trim() && lastPath === xmlPath) return;
    try {
      const res = await fetch('/download_report?path=' + encodeURIComponent(xmlPath), { credentials: 'same-origin' });
      if(!res.ok) return;
      const txt = await res.text();
      try { xmlPre.textContent = txt || ''; } catch(e) {}
      try { xmlPre.dataset.xmlPreviewPath = xmlPath; } catch(e) {}
    } catch(e) {}
  }

  function normalizeScenarioNorm(raw){
    return (raw || '').toString().trim().toLowerCase().replace(/\s+/g, ' ');
  }

  function defaultScenarioName(){
    return (Array.isArray(scenarioNamesCache) && scenarioNamesCache.length) ? String(scenarioNamesCache[0]) : null;
  }

  function updateScenarioQueryParam(){
    try {
      const url = new URL(window.location.href);
      if(activeScenario){
        url.searchParams.set('scenario', activeScenario);
      } else {
        url.searchParams.delete('scenario');
      }
      window.history.replaceState({}, '', url.toString());
    } catch(e) {}
  }

  function updateScenarioFilterControls(){
    try {
      if(clearScenarioBtn){
        const def = defaultScenarioName();
        const show = !!activeScenario && !!def && activeScenario !== def;
        clearScenarioBtn.classList.toggle('d-none', !show);
      }
      if(!scenarioListEl) return;
      scenarioListEl.querySelectorAll('[data-scen-name]').forEach(btn => {
        const name = btn.getAttribute('data-scen-name');
        const isActive = !!activeScenario && name === activeScenario;
        btn.classList.toggle('active', isActive);
        btn.classList.toggle('bg-primary', isActive);
        btn.classList.toggle('text-white', isActive);
      });
    } catch(e) {}
  }

  function refreshParticipantNavForScenario(scenarioName){
    try {
      const scen = (scenarioName || '').toString().trim();
      if (typeof window.CORETG_PATCH_SCENARIO_NAV === 'function') {
        window.CORETG_PATCH_SCENARIO_NAV(scen);
      }
      const norm = normalizeScenarioNorm(scen);
      const hasParticipant = !!participantUrlFlags[norm];
      if (typeof window.CORETG_SET_PARTICIPANT_NAV_VISIBLE === 'function') {
        window.CORETG_SET_PARTICIPANT_NAV_VISIBLE(hasParticipant);
      }
    } catch(e) {}
  }

  async function setScenario(value){
    activeScenario = (value || defaultScenarioName() || '').toString().trim();
    if(scenarioEl) scenarioEl.value = activeScenario;
    if(scenarioLabelEl) scenarioLabelEl.textContent = activeScenario;
    updateScenarioQueryParam();
    updateScenarioFilterControls();
    refreshParticipantNavForScenario(activeScenario);
    // When switching scenarios (or loading after refresh), prefer any saved Flow state.
    await generate(false);
  }

  function setStatus(msg, isError){
    if(!statusEl) return;
    statusEl.textContent = msg || '';
    statusEl.classList.toggle('text-danger', !!isError);
    statusEl.classList.toggle('text-muted', !isError);
  }

  function setLoginLinkVisible(visible){
    try{
      if(!loginLinkEl) return;
      loginLinkEl.classList.toggle('d-none', !visible);
    } catch(e) {}
  }

  function basenameFromPath(p){
    try{
      const s = (p||'').toString();
      const parts = s.split('/');
      return parts[parts.length-1] || s;
    } catch(e){
      return (p||'').toString();
    }
  }

  async function fetchJson(url){
    const res = await fetch(url, { credentials: 'same-origin' });
    const ct = (res.headers.get('content-type') || '').toLowerCase();
    if(!ct.includes('application/json')){
      const text = await res.text();
      if(res.redirected || (text && text.includes('<html'))){
        const err = new Error('Login required.');
        err.loginRequired = true;
        throw err;
      }
      throw new Error('Non-JSON response');
    }
    const data = await res.json();
    if(!res.ok){
      const err = new Error((data && (data.error || data.message)) || ('HTTP ' + res.status));
      err.payload = data;
      if(res.status === 401) err.loginRequired = true;
      throw err;
    }
    return data;
  }

  async function postJson(url, payload){
    const res = await fetch(url, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      credentials: 'same-origin',
      body: JSON.stringify(payload || {})
    });
    const ct = (res.headers.get('content-type') || '').toLowerCase();
    if(!ct.includes('application/json')){
      const text = await res.text();
      if(res.redirected || (text && text.includes('<html'))){
        const err = new Error('Login required.');
        err.loginRequired = true;
        throw err;
      }
      throw new Error('Non-JSON response');
    }
    const data = await res.json();
    if(!res.ok){
      const err = new Error((data && (data.error || data.message)) || ('HTTP ' + res.status));
      err.payload = data;
      if(res.status === 401) err.loginRequired = true;
      throw err;
    }
    return data;
  }

  function chainFeasibility(assignments){
    // Returns per-index feasibility based on cumulative outputs.
    // Shape: {ok:boolean, missing:string[], missing_artifacts:string[], missing_fields:string[]}
    const out = [];
    // Keep in sync with server-side synthesized Flow inputs (see _flow_default_generator_config).
    const synthesizedFields = ['seed','secret','env_name','challenge','flag_prefix','username_prefix','key_len','node_name'];
    const haveEffective = new Set(synthesizedFields);
    const haveArtifacts = new Set();
    const haveFields = new Set(synthesizedFields);
    if(!Array.isArray(assignments)) return out;
    for(let i=0;i<assignments.length;i++){
      const a = assignments[i] || {};

      const reqEffective = Array.isArray(a.inputs) ? a.inputs.map(String) : [];
      const missing = reqEffective.filter(k => k && !haveEffective.has(k));

      const hasSplit = Array.isArray(a.requires) || Array.isArray(a.input_fields_required) || Array.isArray(a.input_fields);
      const reqArtifacts = Array.isArray(a.requires) ? a.requires.map(String) : [];
      const reqFields = Array.isArray(a.input_fields_required)
        ? a.input_fields_required.map(String)
        : (Array.isArray(a.input_fields) ? a.input_fields.map(String) : []);
      const missingArtifacts = hasSplit
        ? reqArtifacts.filter(k => k && !haveArtifacts.has(k))
        : [];
      const missingFields = hasSplit
        ? reqFields.filter(k => k && !haveFields.has(k))
        : missing;

      out.push({ ok: missing.length === 0, missing, missing_artifacts: missingArtifacts, missing_fields: missingFields });

      const provEffective = Array.isArray(a.outputs) ? a.outputs.map(String) : [];
      provEffective.forEach(k => { if(k) haveEffective.add(k); });

      if(Array.isArray(a.produces)){
        a.produces.map(String).forEach(k => { if(k) haveArtifacts.add(k); });
      }
      if(Array.isArray(a.output_fields)){
        a.output_fields.map(String).forEach(k => { if(k) haveFields.add(k); });
      }
    }
    return out;
  }

  function renderChainEditor(){
    const wrap = document.getElementById('flowChainList');
    if(!wrap) return;
    wrap.innerHTML = '';
    if(!Array.isArray(currentChain) || currentChain.length === 0){
      const empty = document.createElement('div');
      empty.className = 'text-muted small';
      empty.textContent = 'Generate a flow to populate the chain.';
      wrap.appendChild(empty);
      return;
    }
    currentChain.forEach((node, idx) => {
      const item = document.createElement('div');
      item.className = 'list-group-item d-flex align-items-center justify-content-between gap-2';
      item.style.cursor = 'pointer';
      item.classList.toggle('active', idx === selectedChainIndex);

      const left = document.createElement('div');
      left.className = 'd-flex flex-column';
      const title = document.createElement('div');
      title.className = 'fw-semibold';
      title.textContent = (node && node.name) ? String(node.name) : ('Node ' + (idx+1));
      left.appendChild(title);

      // Sub-details: compact table for readability.
      const details = document.createElement('div');
      details.className = 'mt-1';
      const tbl = document.createElement('table');
      tbl.className = 'table table-sm table-borderless mb-0 small';
      const tbody = document.createElement('tbody');

      function addRow(label, valueElOrText, { danger = false } = {}){
        const tr = document.createElement('tr');
        const tdL = document.createElement('td');
        tdL.className = 'text-muted';
        tdL.style.whiteSpace = 'nowrap';
        tdL.style.width = '1%';
        tdL.textContent = String(label || '').trim() ? (String(label).trim() + ':') : '';
        const tdV = document.createElement('td');
        if(danger) tdV.classList.add('text-danger');
        if(valueElOrText && typeof valueElOrText === 'object' && valueElOrText.nodeType){
          tdV.appendChild(valueElOrText);
        } else {
          tdV.textContent = String(valueElOrText || '-');
        }
        tr.appendChild(tdL);
        tr.appendChild(tdV);
        tbody.appendChild(tr);
      }

      const fa = (Array.isArray(currentFlagAssignments) && currentFlagAssignments[idx]) ? currentFlagAssignments[idx] : null;
      const genId = fa && fa.id ? String(fa.id) : '-';
      const genName = fa && fa.name ? String(fa.name) : '-';
      addRow('generator', (genName && genName !== '-' && genName !== genId)
        ? (genId + ' | ' + genName)
        : genId);

      const genLabel = fa && fa.flag_generator ? String(fa.flag_generator) : '-';
      addRow('source', genLabel);

      const hintList = (fa && Array.isArray(fa.hints) && fa.hints.length)
        ? fa.hints.map(x => String(x || '').trim()).filter(Boolean)
        : [];
      if(hintList.length > 1){
        const wrap = document.createElement('div');
        const ul = document.createElement('ol');
        ul.className = 'mb-0 ps-3';
        hintList.forEach((ht) => {
          const li = document.createElement('li');
          li.textContent = ht;
          ul.appendChild(li);
        });
        wrap.appendChild(ul);
        addRow('hints', wrap);
      } else {
        const hintText = hintList.length ? hintList[0] : (fa && fa.hint ? String(fa.hint) : '');
        addRow('hint', hintText || '-');
      }

      const feas = chainFeasibility(currentFlagAssignments);
      const step = feas && feas[idx] ? feas[idx] : null;
        addRow('requires (artifacts)', fa && Array.isArray(fa.requires) && fa.requires.length ? fa.requires.join(', ') : '-');
        addRow('produces (artifacts)', fa && Array.isArray(fa.produces) && fa.produces.length ? fa.produces.join(', ') : '-');
        const inReq = (fa && Array.isArray(fa.input_fields_required)) ? fa.input_fields_required.map(String).filter(Boolean) : [];
        const inOpt = (fa && Array.isArray(fa.input_fields_optional)) ? fa.input_fields_optional.map(String).filter(Boolean) : [];
        const inAll = (fa && Array.isArray(fa.input_fields)) ? fa.input_fields.map(String).filter(Boolean) : [];
        const inputsDisplay = (inReq.length || inOpt.length)
          ? (inReq.concat(inOpt.map(x => x + ' (optional)')).join(', '))
          : (inAll.length ? inAll.join(', ') : '-');
        addRow('inputs (fields)', inputsDisplay);
        addRow('outputs (fields)', fa && Array.isArray(fa.output_fields) && fa.output_fields.length ? fa.output_fields.join(', ') : '-');
      if(step && step.ok === false){
          const ma = Array.isArray(step.missing_artifacts) ? step.missing_artifacts : [];
          const mf = Array.isArray(step.missing_fields) ? step.missing_fields : [];
          if(ma.length || mf.length){
            addRow('missing artifacts', ma.join(', ') || '-', { danger: true });
            addRow('missing fields', mf.join(', ') || '-', { danger: true });
          } else {
            addRow('missing', (step.missing || []).join(', ') || '-', { danger: true });
          }
      }

      // After prepare_preview_for_execute, the backend may attach runtime validation
      // fields like outputs_match/outputs_mismatch to help validate generator specs.
      try {
        if(fa && fa.outputs_match === false){
          const mm = fa.outputs_mismatch || {};
          const missing = Array.isArray(mm.missing) ? mm.missing : [];
          const extra = Array.isArray(mm.extra) ? mm.extra : [];
          const parts = [];
          if(missing.length) parts.push('missing: ' + missing.join(', '));
          if(extra.length) parts.push('extra: ' + extra.join(', '));
          addRow('outputs mismatch', parts.length ? parts.join(' | ') : 'outputs mismatch', { danger: true });
        }
      } catch(e) {}

      tbl.appendChild(tbody);
      details.appendChild(tbl);
      left.appendChild(details);

      const right = document.createElement('div');
      right.className = 'btn-group btn-group-sm';
      const up = document.createElement('button');
      up.type = 'button';
      up.className = 'btn btn-outline-secondary';
      up.textContent = '↑';
      up.disabled = idx === 0;
      up.addEventListener('click', async () => {
        if(idx === 0) return;
        const tmp = currentChain[idx-1];
        currentChain[idx-1] = currentChain[idx];
        currentChain[idx] = tmp;
        renderChainEditor();
        await refreshBundleFromChain();
      });
      const down = document.createElement('button');
      down.type = 'button';
      down.className = 'btn btn-outline-secondary';
      down.textContent = '↓';
      down.disabled = idx === currentChain.length - 1;
      down.addEventListener('click', async () => {
        if(idx === currentChain.length - 1) return;
        const tmp = currentChain[idx+1];
        currentChain[idx+1] = currentChain[idx];
        currentChain[idx] = tmp;
        renderChainEditor();
        await refreshBundleFromChain();
      });
      right.appendChild(up);
      right.appendChild(down);

      item.appendChild(left);
      item.appendChild(right);
      item.addEventListener('click', (e)=>{
        // Avoid selecting when clicking reorder buttons.
        const t = e && e.target;
        if(t && t.tagName && String(t.tagName).toLowerCase() === 'button') return;
        selectChainIndex(idx);
      });
      wrap.appendChild(item);
    });
  }

  function selectChainIndex(idx){
    selectedChainIndex = Number.isFinite(+idx) ? (+idx) : -1;
    if(selectedChainIndex < 0 || !Array.isArray(currentChain) || selectedChainIndex >= currentChain.length){
      selectedChainIndex = -1;
      renderChainEditor();
      return;
    }
    renderChainEditor();
  }

  function updateMeta(){
    if(metaScenarioEl) metaScenarioEl.textContent = (activeScenario || '') ? String(activeScenario) : '-';
    if(metaPreviewEl) metaPreviewEl.textContent = lastPreviewPlanPath ? basenameFromPath(lastPreviewPlanPath) : '-';
    if(metaStatsEl) metaStatsEl.textContent = formatStats(lastStats) || '-';
  }

  async function refreshBundleFromChain(){
    if(!Array.isArray(currentChain) || currentChain.length === 0) return;
    setStatus('Updating bundle…', false);
    try{
      const data = await postJson('/api/flag-sequencing/bundle_from_chain', { scenario: activeScenario, chain: currentChain });
      currentBundle = data.bundle;
      currentFlagAssignments = Array.isArray(data.flag_assignments) ? data.flag_assignments.slice() : currentFlagAssignments;
      setFlowValidityFromPayload(data);
      if(jsonEl) jsonEl.textContent = JSON.stringify(currentBundle, null, 2);
      const diagram = buildMermaid(currentChain);
      await renderMermaid(diagram);
      updateMeta();
      setStatus('Ready.', false);
    } catch(err){
      setStatus(String(err && err.message || err), true);
    }
  }

  function formatStats(stats){
    if(!stats || typeof stats !== 'object') return '';
    const d = Number.isFinite(+stats.docker_total) ? (+stats.docker_total) : null;
    const v = Number.isFinite(+stats.vuln_total) ? (+stats.vuln_total) : null;
    const c = Number.isFinite(+stats.compose_backed_total) ? (+stats.compose_backed_total) : null;
    const e = Number.isFinite(+stats.eligible_total) ? (+stats.eligible_total) : null;
    if(d === null && v === null && c === null && e === null) return '';
    const inner = [];
    if(v !== null) inner.push('vuln: ' + v);
    if(c !== null) inner.push('compose-backed: ' + c);
    if(e !== null) inner.push('eligible: ' + e);
    if(d !== null){
      return String(d) + (inner.length ? (' (' + inner.join(', ') + ')') : '');
    }
    if(v !== null){
      return 'vuln: ' + v + (inner.length ? (' (' + inner.join(', ') + ')') : '');
    }
    return inner.length ? inner.join(', ') : '';
  }

  function buildMermaid(chain){
    const lines = ['flowchart LR'];
    if(!Array.isArray(chain) || chain.length === 0){
      lines.push('  A[No chain available]');
      return lines.join('\n');
    }
    for(let i=0;i<chain.length;i++){
      const node = chain[i];
      const safeId = 'N' + i;
      const label = (node && node.name) ? node.name : ('Node ' + (i+1));
      lines.push(`  ${safeId}[${label.replace(/\]/g,'')}]`);
      if(i>0){
        lines.push(`  N${i-1} --> ${safeId}`);
      }
    }
    for(let i=0;i<chain.length;i++){
      lines.push(`  click N${i} flowSelectNode "Show details"`);
    }
    return lines.join('\n');
  }

  async function renderMermaid(diagramText){
    try {
      if(window.mermaid){
        mermaid.initialize({ startOnLoad: false, securityLevel: 'loose' });
        const wrap = document.getElementById('flowDiagram');
        wrap.textContent = diagramText;
        wrap.removeAttribute('data-processed');
        await mermaid.run({ querySelector: '#flowDiagram' });
      }
    } catch(e) {
      // If rendering fails, keep plaintext.
      const wrap = document.getElementById('flowDiagram');
      if(wrap) wrap.textContent = diagramText;
    }
  }

  async function generate(preferPreview){
    const usePreview = !!preferPreview;
    const scenario = (scenarioEl && scenarioEl.value || '').trim();
    const preset = (presetEl && presetEl.value) ? String(presetEl.value).trim() : '';
    const length = preset ? 3 : (parseInt((lengthEl && lengthEl.value) || '5', 10) || 5);

    const params = new URLSearchParams();
    if(scenario) params.set('scenario', scenario);
    params.set('length', String(length));
    if(preset) params.set('preset', preset);
    // Only force preview selection when the user explicitly clicks Generate.
    if(usePreview){
      params.set('prefer_preview', '1');
      params.set('force_preview', '1');
    }

    const apiUrl = '/api/flag-sequencing/attackflow_preview?' + params.toString();
    if(downloadLink) downloadLink.href = '#';

    setStatus('Generating…', false);
    setLoginLinkVisible(false);
    showLoading('Generating flow…');
    if(metaScenarioEl) metaScenarioEl.textContent = '';
    if(metaPreviewEl) metaPreviewEl.textContent = '';
    if(metaStatsEl) metaStatsEl.textContent = '';
    if(jsonEl) jsonEl.textContent = '';

    try {
      const data = await fetchJson(apiUrl);
      currentChain = Array.isArray(data.chain) ? data.chain.slice() : [];
      currentBundle = data.bundle || null;
      currentFlagAssignments = Array.isArray(data.flag_assignments) ? data.flag_assignments.slice() : [];
      setFlowValidityFromPayload(data);
      lastStats = data.stats || null;
      lastPreviewPlanPath = data.preview_plan_path || '';
      try {
        // If the backend loaded a saved chain whose effective length differs from the
        // current input value (e.g. page reload reset to default), keep the UI in sync.
        const effLen = Number.isFinite(+data.length) ? (+data.length) : null;
        if (effLen !== null && lengthEl) lengthEl.value = String(effLen);
      } catch(e) {}
      updateMeta();
      selectedChainIndex = -1;
      renderChainEditor();

      if(jsonEl) jsonEl.textContent = JSON.stringify(currentBundle, null, 2);
      const diagram = buildMermaid(currentChain);
      await renderMermaid(diagram);

      // Optional (user-click only): run the prepare step so generator outputs can resolve
      // hint templates immediately (e.g., IPs/ports/usernames) without requiring a refresh.
      if(usePreview){
        try{
          if(Array.isArray(currentChain) && currentChain.length){
            showLoading('Resolving hint values…');
            setStatus('Resolving hint values…', false);
            const chainIds = currentChain.map(n => (n && n.id) ? String(n.id) : '').filter(Boolean);
            const prepData = await postJson('/api/flag-sequencing/prepare_preview_for_execute', { scenario, length: currentChain.length, preset, chain_ids: chainIds });
            setFlowValidityFromPayload(prepData);

            // If the server adjusted the chain (rare, e.g. preset repair), keep UI in sync.
            const oldIds = chainIds.join('|');
            const newChain = (prepData && Array.isArray(prepData.chain)) ? prepData.chain.slice() : null;
            const newIds = (newChain || []).map(n => (n && n.id) ? String(n.id) : '').filter(Boolean).join('|');
            if(newChain && newChain.length){
              currentChain = newChain;
            }

            if(prepData && Array.isArray(prepData.flag_assignments)){
              currentFlagAssignments = prepData.flag_assignments.slice();
              renderChainEditor();
            }
            if(prepData && prepData.preview_plan_path){
              lastPreviewPlanPath = String(prepData.preview_plan_path);
              updateMeta();
            }

            // If chain changed, regenerate the bundle to match (keep resolved hints in UI).
            if(newChain && newIds && oldIds !== newIds){
              await refreshBundleFromChain();
              if(prepData && Array.isArray(prepData.flag_assignments)){
                currentFlagAssignments = prepData.flag_assignments.slice();
                renderChainEditor();
              }
              const diagram2 = buildMermaid(currentChain);
              await renderMermaid(diagram2);
            }
          }
        } catch(e) {
          // Non-fatal: the flow/bundle is still usable even if hints aren't resolved.
          try {
            const msg = (e && e.message) ? String(e.message) : String(e || 'prepare failed');
            setStatus('Hint resolution failed: ' + msg, true);
          } catch(_) {}
        }
      }

      setStatus('Ready.', false);
    } catch(err){
      setStatus(String(err && err.message || err), true);
      setLoginLinkVisible(!!(err && err.loginRequired));
      const payload = err && err.payload ? err.payload : null;
      setFlowValidityFromPayload(payload);
      lastStats = payload && payload.stats ? payload.stats : null;
      lastPreviewPlanPath = payload && payload.preview_plan_path ? String(payload.preview_plan_path) : '';
      updateMeta();
      currentChain = [];
      currentBundle = null;
      currentFlagAssignments = [];
      selectedChainIndex = -1;
      renderChainEditor();
      const diagram = buildMermaid([]);
      await renderMermaid(diagram);
    } finally {
      hideLoading();
    }
  }

  async function execute(){
    const scenario = (scenarioEl && scenarioEl.value || '').trim();
    const preset = (presetEl && presetEl.value) ? String(presetEl.value).trim() : '';
    const length = (Array.isArray(currentChain) && currentChain.length) ? currentChain.length : (parseInt((lengthEl && lengthEl.value) || '5', 10) || 5);
    if(!scenario){
      setStatus('No scenario selected.', true);
      return;
    }
    // If the shared Execute button is gated (CORE VM not verified), it won't be clickable,
    // but keep this guard anyway in case something calls execute() programmatically.
    if(execEl && execEl.disabled){
      setStatus('Verify a CORE VM in VM / Access to enable Execute.', true);
      return;
    }
    if(execEl) execEl.disabled = true;
    setStatus('Preparing preview for execution…', false);
    setLoginLinkVisible(false);
    showLoading('Resolving hint values…');
    try{
      if(!Array.isArray(currentChain) || currentChain.length === 0){
        throw new Error('Generate a chain first.');
      }
      const chainIds = currentChain.map(n => (n && n.id) ? String(n.id) : '').filter(Boolean);
      const prepData = await postJson('/api/flag-sequencing/prepare_preview_for_execute', { scenario, length, preset, chain_ids: chainIds });
      setFlowValidityFromPayload(prepData);
      // Prefer server-returned (possibly enriched) assignments so the UI can show
      // generator run status/mismatch info before scenario execution.
      if(prepData && Array.isArray(prepData.flag_assignments)){
        currentFlagAssignments = prepData.flag_assignments.slice();
        renderChainEditor();
      }
      const xmlPath = (prepData && prepData.xml_path) ? String(prepData.xml_path) : '';
      const previewPlan = (prepData && prepData.preview_plan_path) ? String(prepData.preview_plan_path) : '';
      if(!xmlPath || !previewPlan){
        throw new Error('Prepare step did not return xml_path/preview_plan_path');
      }
      setStatus('Starting async execution…', false);
      const runData = await postJson('/run_cli_async', { xml_path: xmlPath, preview_plan: previewPlan, scenario });
      const runId = runData && runData.run_id ? String(runData.run_id) : '';
      if(runId){
        setStatus('Run started: ' + runId + ' (see Core/Reports pages).', false);
      } else {
        setStatus('Run started (missing run_id).', false);
      }
    } catch(err){
      setStatus(String(err && err.message || err), true);
      setLoginLinkVisible(!!(err && err.loginRequired));
    } finally {
      hideLoading();
      try {
        if (typeof window.coretgRefreshScenariosExecuteButtonState === 'function') {
          window.coretgRefreshScenariosExecuteButtonState();
        } else if (execEl) {
          execEl.disabled = false;
        }
      } catch (e) {
        if (execEl) execEl.disabled = false;
      }
    }
  }

  async function saveXmlOnly(){
    const scenario = (scenarioEl && scenarioEl.value || '').trim();
    const preset = (presetEl && presetEl.value) ? String(presetEl.value).trim() : '';
    const length = (Array.isArray(currentChain) && currentChain.length) ? currentChain.length : (parseInt((lengthEl && lengthEl.value) || '5', 10) || 5);
    if(!scenario){
      setStatus('No scenario selected.', true);
      return;
    }
    if(saveXmlEl) saveXmlEl.disabled = true;
    setStatus('Preparing preview and saving XML…', false);
    setLoginLinkVisible(false);
    showLoading('Resolving hint values…');
    try{
      if(!Array.isArray(currentChain) || currentChain.length === 0){
        throw new Error('Generate a chain first.');
      }
      const chainIds = currentChain.map(n => (n && n.id) ? String(n.id) : '').filter(Boolean);
      const prepData = await postJson('/api/flag-sequencing/prepare_preview_for_execute', { scenario, length, preset, chain_ids: chainIds });
      setFlowValidityFromPayload(prepData);
      if(prepData && Array.isArray(prepData.flag_assignments)){
        currentFlagAssignments = prepData.flag_assignments.slice();
        renderChainEditor();
      }
      const xmlPath = (prepData && prepData.xml_path) ? String(prepData.xml_path) : '';
      const previewPlan = (prepData && prepData.preview_plan_path) ? String(prepData.preview_plan_path) : '';
      if(!xmlPath || !previewPlan){
        throw new Error('Prepare step did not return xml_path/preview_plan_path');
      }
      lastPreviewPlanPath = previewPlan;
      updateMeta();
      try {
        const xmlPathInput = document.getElementById('scenariosPreviewXmlPath');
        if(xmlPathInput) xmlPathInput.value = xmlPath;
      } catch(e) {}
      try {
        if(downloadXmlEl){
          downloadXmlEl.disabled = false;
          downloadXmlEl.removeAttribute('title');
        }
      } catch(e) {}
      setStatus('Saved XML: ' + basenameFromPath(xmlPath), false);
      try { await refreshXmlDockPreview({ force: true }); } catch(e) {}
    } catch(err){
      setStatus(String(err && err.message || err), true);
      setLoginLinkVisible(!!(err && err.loginRequired));
    } finally {
      hideLoading();
      if(saveXmlEl) saveXmlEl.disabled = false;
    }
  }

  function downloadXml(){
    try {
      const xmlPath = (document.getElementById('scenariosPreviewXmlPath')?.value || '').trim();
      if(!xmlPath){
        setStatus('Save XML first to download.', true);
        return;
      }
      window.location.href = '/download_report?path=' + encodeURIComponent(xmlPath);
    } catch(err){
      setStatus(String(err && err.message || err), true);
    }
  }

  // Expose a mermaid click callback; it receives the nodeId like "N0".
  window.flowSelectNode = function(nodeId){
    try{
      const m = String(nodeId || '').match(/^N(\d+)$/);
      if(!m) return;
      const idx = parseInt(m[1], 10);
      if(Number.isFinite(idx)) selectChainIndex(idx);
    } catch(e) {}
  };

  if(btnEl) btnEl.addEventListener('click', (e)=>{ e.preventDefault(); generate(true); });
  if(saveXmlEl) saveXmlEl.addEventListener('click', (e)=>{ e.preventDefault(); saveXmlOnly(); });
  if(execEl) execEl.addEventListener('click', (e)=>{ e.preventDefault(); execute(); });
  if(downloadXmlEl) downloadXmlEl.addEventListener('click', (e)=>{ e.preventDefault(); downloadXml(); });

  if(downloadLink){
    downloadLink.addEventListener('click', (e)=>{
      try{
        e.preventDefault();
        if(!currentBundle){
          setStatus('Nothing to download yet (generate first).', true);
          return;
        }
        const scenario = (scenarioEl && scenarioEl.value || activeScenario || 'scenario').toString().trim();
        const norm = normalizeScenarioNorm(scenario).replace(/\s+/g,'_') || 'scenario';
        const fname = 'attackflow_' + norm + '_' + String(Array.isArray(currentChain)?currentChain.length:0) + '.json';
        const blob = new Blob([JSON.stringify(currentBundle, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = fname;
        document.body.appendChild(a);
        a.click();
        a.remove();
        setTimeout(()=>URL.revokeObjectURL(url), 1000);
      } catch(err){
        setStatus(String(err && err.message || err), true);
      }
    });
  }

  // Wire scenario list.
  if(scenarioListEl){
    scenarioListEl.querySelectorAll('[data-scen-name]').forEach(btn => {
      btn.addEventListener('click', async ()=>{
        const name = btn.getAttribute('data-scen-name') || '';
        if(!name || name === activeScenario) return;
        await setScenario(name);
      });
    });
  }
  if(clearScenarioBtn){
    clearScenarioBtn.addEventListener('click', async ()=>{
      const def = defaultScenarioName();
      if(def && def !== activeScenario) await setScenario(def);
    });
  }

  // Auto-generate on load (per-scenario page). If there are no scenarios, disable.
  if(!activeScenario){
    setStatus('No scenarios available yet.', true);
    if(btnEl) btnEl.disabled = true;
    return;
  }
  if(scenarioEl && !scenarioEl.value) scenarioEl.value = activeScenario;
  if(scenarioLabelEl && !scenarioLabelEl.textContent) scenarioLabelEl.textContent = activeScenario;
  updateScenarioQueryParam();
  updateScenarioFilterControls();
  refreshParticipantNavForScenario(activeScenario);
  // Auto-generate on load (prefer any saved Flow state).
  try { refreshXmlDockPreview({ force: false }); } catch(e) {}
  generate(false);
})();
</script>
{% endblock %}
  // Scenarios header Preview tab: route to /scenarios/preview.
  document.addEventListener('DOMContentLoaded', ()=>{
    const link = document.getElementById('scenariosPreviewTabLink');
    if(!link) return;
    link.addEventListener('click', (ev)=>{
      try {
        ev.preventDefault();
        const xmlPath = (document.getElementById('scenariosPreviewXmlPath')?.value || '').trim();
        const scen = (document.getElementById('flowScenario')?.value || document.getElementById('scenariosPreviewScenario')?.value || '').trim();
        if(!xmlPath){
          alert('Save XML first to preview.');
          return;
        }
        const baseUrl = String(link.dataset?.previewBaseUrl || '/scenarios/preview');
        const url = baseUrl + '?xml_path=' + encodeURIComponent(xmlPath) + (scen ? ('&scenario=' + encodeURIComponent(scen)) : '');
        window.location.href = url;
      } catch(e){}
    });
  });

