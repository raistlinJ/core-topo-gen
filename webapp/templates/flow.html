{% extends 'layout.html' %}
{% block title %}Flag Sequencing{% endblock %}
{% block active_page %}{% set active_page='scenarios' %}{% endblock %}
{% block header_icon %}<i class="bi bi-bezier2 fs-4"></i>{% endblock %}
{% block header_title %}Flag Sequencing{% endblock %}

{% block extra_head %}
<script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
<style>
  body { padding-bottom: 0; }
  #flowLayoutRow { min-height: calc(100vh - 200px); }
  /* Prevent long <pre>/<svg> content from forcing the Bootstrap row to wrap columns. */
  #flowLayoutRow > [class*='col-'] { min-width: 0; }
  @media (max-width: 992px) {
    #flowLayoutRow { min-height: 0; }
  }
</style>
{% endblock %}

{% block content %}
{% set scenario_tab = (active_scenario or request.args.get('scenario','')) %}
{% set scenarios_active_tab = 'flag-sequencing' %}
{% include 'partials/scenarios_tabs.html' with context %}
<div class="container-fluid mt-3 d-flex flex-column" id="flowPageWrap">
  <div class="row g-3 flex-grow-1 align-items-stretch" id="flowLayoutRow">
    <div class="col-12 col-lg-3 d-flex">
      <div class="card shadow-sm mb-3 flex-fill d-flex flex-column">
        <div class="card-header d-flex justify-content-between align-items-center">
          <span class="fw-bold">Scenarios</span>
          <button class="btn btn-sm btn-outline-secondary {% if not active_scenario %}d-none{% endif %}" id="flowScenarioFilterClear" type="button" title="Clear">Clear</button>
        </div>
        <div class="list-group list-group-flush flex-grow-1 overflow-auto" id="flowScenarioList" style="min-height:0;">
          {% if scenarios %}
            {% for s in scenarios %}
            <button type="button" class="list-group-item list-group-item-action py-1 {% if active_scenario and active_scenario==s %}active bg-primary text-white{% endif %}" data-scen-name="{{ s }}">{{ s }}</button>
            {% endfor %}
          {% else %}
            <div class="p-3 text-muted small">No scenarios yet</div>
          {% endif %}
        </div>
      </div>
    </div>

    <div class="col-12 col-lg-9 d-flex">
      <div class="flex-fill d-flex flex-column">
        <div class="d-flex align-items-center justify-content-between flex-wrap gap-2 mb-3">
          <div class="fw-semibold">Generate an Attack Flow from the latest preview plan</div>
        </div>

        <div class="card mb-3">
          <div class="card-body">
            <input id="flowScenario" class="form-control d-none" value="{{ active_scenario or request.args.get('scenario','') }}">
            <div class="row g-2 align-items-end">
              <div class="col-sm-6 col-md-2">
                <label class="form-label">Chain Length</label>
                <input id="flowLength" class="form-control" type="number" min="1" max="50" value="5">
              </div>
              <div class="col-md-6">
                <div class="d-flex gap-2 flex-nowrap">
                  <button id="flowGenerateBtn" class="btn btn-primary text-nowrap" type="button">Generate</button>
                  <a id="flowBundleDownloadLink" class="btn btn-outline-primary text-nowrap" href="#" role="button">Download Attack Flow STIX Bundle</a>
                </div>
              </div>
              <div class="col-md-4">
                <div class="small">
                  <span id="flowStatus" class="text-muted"></span>
                  <a id="flowLoginLink" class="ms-2 d-none" href="/login">Login</a>
                </div>
              </div>
            </div>
            <div class="small text-muted mt-2">Current rule: flags are placed on any Docker nodes (scenario Docker role + vulnerability Docker nodes). Default chain order is randomized; you can tweak it below.</div>
          </div>
        </div>

        <div class="card mb-3">
          <div class="card-header d-flex align-items-center justify-content-between">
            <div class="fw-semibold">Visualization</div>
          </div>
          <div class="card-body">
            <div class="row g-2 small text-muted align-items-center mb-2" id="flowMetaRow">
              <div class="col-12 col-md-4">
                <span class="text-secondary">Scenario:</span>
                <span class="ms-1" id="flowMetaScenario"></span>
              </div>
              <div class="col-12 col-md-5">
                <span class="text-secondary">Preview:</span>
                <span class="ms-1" id="flowMetaPreview"></span>
              </div>
              <div class="col-12 col-md-3">
                <span class="text-secondary">Docker:</span>
                <span class="ms-1" id="flowMetaStats"></span>
              </div>
            </div>
            <div id="flowDiagramWrap" class="border rounded p-2" style="min-height: 180px; overflow-x: auto;">
              <div id="flowDiagram" class="mermaid">graph LR\n  A[Generate] --> B[Flow]</div>
            </div>
          </div>
        </div>

        <div class="card mb-3">
          <div class="card-header d-flex align-items-center justify-content-between">
            <div class="fw-semibold">Chain Order</div>
            <div class="small text-muted">Use ↑/↓ to reorder</div>
          </div>
          <div class="card-body">
            <div id="flowChainList" class="list-group"></div>
            <div class="small text-muted mt-2">Reordering updates the bundle and download.</div>
          </div>
        </div>

      </div>
    </div>
  </div>
</div>
{% endblock %}

{% block body_container %}
{{ super() }}
{% set xml_preview_enabled = True %}
{% set xml_preview_text = xml_preview %}
{% include 'partials/dock.html' %}
<script>
(function(){
  const statusEl = document.getElementById('flowStatus');
  const loginLinkEl = document.getElementById('flowLoginLink');
  const scenarioEl = document.getElementById('flowScenario');
  const scenarioLabelEl = document.getElementById('flowScenarioLabel');
  const lengthEl = document.getElementById('flowLength');
  const btnEl = document.getElementById('flowGenerateBtn');
  const saveXmlEl = document.getElementById('saveXmlBtn');
  const execEl = document.getElementById('scenariosExecuteBtn');
  const downloadXmlEl = document.getElementById('downloadXmlBtn');
  const jsonEl = document.getElementById('flowJson');
  const metaScenarioEl = document.getElementById('flowMetaScenario');
  const metaPreviewEl = document.getElementById('flowMetaPreview');
  const metaStatsEl = document.getElementById('flowMetaStats');
  const downloadLink = document.getElementById('flowBundleDownloadLink');
  const scenarioListEl = document.getElementById('flowScenarioList');
  const clearScenarioBtn = document.getElementById('flowScenarioFilterClear');

  const participantUrlFlags = {{ (participant_url_flags or {})|tojson }};
  const scenarioNamesCache = {{ (scenarios or [])|tojson }};
  const initialScenario = {{ (active_scenario or '')|tojson }};
  let activeScenario = (initialScenario || (Array.isArray(scenarioNamesCache) && scenarioNamesCache.length ? String(scenarioNamesCache[0]) : '')).trim();

  let currentChain = [];
  let currentBundle = null;
  let lastStats = null;
  let lastPreviewPlanPath = '';
  let currentFlagAssignments = [];
  let selectedChainIndex = -1;

  async function refreshXmlDockPreview({ force = false } = {}){
    const xmlPre = document.getElementById('xmlPre');
    if(!xmlPre) return;
    const xmlPath = (document.getElementById('scenariosPreviewXmlPath')?.value || '').trim();
    const lastPath = (xmlPre.dataset.xmlPreviewPath || '').trim();
    if(!xmlPath){
      if(force){
        try { xmlPre.textContent = ''; } catch(e) {}
        try { xmlPre.dataset.xmlPreviewPath = ''; } catch(e) {}
      }
      return;
    }
    if(!force && xmlPre.textContent.trim() && lastPath === xmlPath) return;
    try {
      const res = await fetch('/download_report?path=' + encodeURIComponent(xmlPath), { credentials: 'same-origin' });
      if(!res.ok) return;
      const txt = await res.text();
      try { xmlPre.textContent = txt || ''; } catch(e) {}
      try { xmlPre.dataset.xmlPreviewPath = xmlPath; } catch(e) {}
    } catch(e) {}
  }

  function normalizeScenarioNorm(raw){
    return (raw || '').toString().trim().toLowerCase().replace(/\s+/g, ' ');
  }

  function defaultScenarioName(){
    return (Array.isArray(scenarioNamesCache) && scenarioNamesCache.length) ? String(scenarioNamesCache[0]) : null;
  }

  function updateScenarioQueryParam(){
    try {
      const url = new URL(window.location.href);
      if(activeScenario){
        url.searchParams.set('scenario', activeScenario);
      } else {
        url.searchParams.delete('scenario');
      }
      window.history.replaceState({}, '', url.toString());
    } catch(e) {}
  }

  function updateScenarioFilterControls(){
    try {
      if(clearScenarioBtn){
        const def = defaultScenarioName();
        const show = !!activeScenario && !!def && activeScenario !== def;
        clearScenarioBtn.classList.toggle('d-none', !show);
      }
      if(!scenarioListEl) return;
      scenarioListEl.querySelectorAll('[data-scen-name]').forEach(btn => {
        const name = btn.getAttribute('data-scen-name');
        const isActive = !!activeScenario && name === activeScenario;
        btn.classList.toggle('active', isActive);
        btn.classList.toggle('bg-primary', isActive);
        btn.classList.toggle('text-white', isActive);
      });
    } catch(e) {}
  }

  function refreshParticipantNavForScenario(scenarioName){
    try {
      const scen = (scenarioName || '').toString().trim();
      if (typeof window.CORETG_PATCH_SCENARIO_NAV === 'function') {
        window.CORETG_PATCH_SCENARIO_NAV(scen);
      }
      const norm = normalizeScenarioNorm(scen);
      const hasParticipant = !!participantUrlFlags[norm];
      if (typeof window.CORETG_SET_PARTICIPANT_NAV_VISIBLE === 'function') {
        window.CORETG_SET_PARTICIPANT_NAV_VISIBLE(hasParticipant);
      }
    } catch(e) {}
  }

  async function setScenario(value){
    activeScenario = (value || defaultScenarioName() || '').toString().trim();
    if(scenarioEl) scenarioEl.value = activeScenario;
    if(scenarioLabelEl) scenarioLabelEl.textContent = activeScenario;
    updateScenarioQueryParam();
    updateScenarioFilterControls();
    refreshParticipantNavForScenario(activeScenario);
    // When switching scenarios (or loading after refresh), prefer any saved Flow state.
    await generate(false);
  }

  function setStatus(msg, isError){
    if(!statusEl) return;
    statusEl.textContent = msg || '';
    statusEl.classList.toggle('text-danger', !!isError);
    statusEl.classList.toggle('text-muted', !isError);
  }

  function setLoginLinkVisible(visible){
    try{
      if(!loginLinkEl) return;
      loginLinkEl.classList.toggle('d-none', !visible);
    } catch(e) {}
  }

  function basenameFromPath(p){
    try{
      const s = (p||'').toString();
      const parts = s.split('/');
      return parts[parts.length-1] || s;
    } catch(e){
      return (p||'').toString();
    }
  }

  async function fetchJson(url){
    const res = await fetch(url, { credentials: 'same-origin' });
    const ct = (res.headers.get('content-type') || '').toLowerCase();
    if(!ct.includes('application/json')){
      const text = await res.text();
      if(res.redirected || (text && text.includes('<html'))){
        const err = new Error('Login required.');
        err.loginRequired = true;
        throw err;
      }
      throw new Error('Non-JSON response');
    }
    const data = await res.json();
    if(!res.ok){
      const err = new Error((data && (data.error || data.message)) || ('HTTP ' + res.status));
      err.payload = data;
      if(res.status === 401) err.loginRequired = true;
      throw err;
    }
    return data;
  }

  async function postJson(url, payload){
    const res = await fetch(url, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      credentials: 'same-origin',
      body: JSON.stringify(payload || {})
    });
    const ct = (res.headers.get('content-type') || '').toLowerCase();
    if(!ct.includes('application/json')){
      const text = await res.text();
      if(res.redirected || (text && text.includes('<html'))){
        const err = new Error('Login required.');
        err.loginRequired = true;
        throw err;
      }
      throw new Error('Non-JSON response');
    }
    const data = await res.json();
    if(!res.ok){
      const err = new Error((data && (data.error || data.message)) || ('HTTP ' + res.status));
      err.payload = data;
      if(res.status === 401) err.loginRequired = true;
      throw err;
    }
    return data;
  }

  function chainFeasibility(assignments){
    // Returns per-index {ok:boolean, missing:string[]} based on cumulative outputs.
    const out = [];
    // Keep in sync with server-side synthesized Flow inputs (see _flow_default_generator_config).
    const have = new Set(['seed','secret','env_name','challenge','flag_prefix','username_prefix','key_len']);
    if(!Array.isArray(assignments)) return out;
    for(let i=0;i<assignments.length;i++){
      const a = assignments[i] || {};
      const req = Array.isArray(a.inputs) ? a.inputs.map(String) : [];
      const missing = req.filter(k => k && !have.has(k));
      out.push({ ok: missing.length === 0, missing });
      const prov = Array.isArray(a.outputs) ? a.outputs.map(String) : [];
      prov.forEach(k => { if(k) have.add(k); });
    }
    return out;
  }

  function renderChainEditor(){
    const wrap = document.getElementById('flowChainList');
    if(!wrap) return;
    wrap.innerHTML = '';
    if(!Array.isArray(currentChain) || currentChain.length === 0){
      const empty = document.createElement('div');
      empty.className = 'text-muted small';
      empty.textContent = 'Generate a flow to populate the chain.';
      wrap.appendChild(empty);
      return;
    }
    currentChain.forEach((node, idx) => {
      const item = document.createElement('div');
      item.className = 'list-group-item d-flex align-items-center justify-content-between gap-2';
      item.style.cursor = 'pointer';
      item.classList.toggle('active', idx === selectedChainIndex);

      const left = document.createElement('div');
      left.className = 'd-flex flex-column';
      const title = document.createElement('div');
      title.className = 'fw-semibold';
      title.textContent = (node && node.name) ? String(node.name) : ('Node ' + (idx+1));
      left.appendChild(title);

      const flagSub = document.createElement('div');
      flagSub.className = 'small text-muted';
      const fa = (Array.isArray(currentFlagAssignments) && currentFlagAssignments[idx]) ? currentFlagAssignments[idx] : null;
      const flagLabel = fa && (fa.name || fa.id) ? String(fa.name || fa.id) : '-';
      flagSub.textContent = 'flag: ' + flagLabel;
      left.appendChild(flagSub);

      const genUsedSub = document.createElement('div');
      genUsedSub.className = 'small text-muted';
      const genId = fa && fa.id ? String(fa.id) : '-';
      const genName = fa && fa.name ? String(fa.name) : '-';
      genUsedSub.textContent = (genName && genName !== '-' && genName !== genId)
        ? ('generator: ' + genId + ' | ' + genName)
        : ('generator: ' + genId);
      left.appendChild(genUsedSub);

      const genSub = document.createElement('div');
      genSub.className = 'small text-muted';
      const genLabel = fa && fa.flag_generator ? String(fa.flag_generator) : '-';
      genSub.textContent = 'flag-generator: ' + genLabel;
      left.appendChild(genSub);

      const hintSub = document.createElement('div');
      hintSub.className = 'small';
      const hintText = fa && fa.hint ? String(fa.hint) : '';
      hintSub.textContent = hintText ? ('hint: ' + hintText) : 'hint: -';
      left.appendChild(hintSub);

      const feas = chainFeasibility(currentFlagAssignments);
      const step = feas && feas[idx] ? feas[idx] : null;
      const ioSub = document.createElement('div');
      ioSub.className = 'small text-muted';
      const req = fa && Array.isArray(fa.inputs) && fa.inputs.length ? ('requires: ' + fa.inputs.join(', ')) : 'requires: -';
      const prov = fa && Array.isArray(fa.outputs) && fa.outputs.length ? ('provides: ' + fa.outputs.join(', ')) : 'provides: -';
      ioSub.textContent = req + ' | ' + prov;
      if(step && step.ok === false){
        ioSub.classList.add('text-danger');
        ioSub.textContent = req + ' | ' + prov + ' | missing: ' + (step.missing || []).join(', ');
      }
      left.appendChild(ioSub);

      // After prepare_preview_for_execute, the backend may attach runtime validation
      // fields like outputs_match/outputs_mismatch to help validate generator specs.
      try {
        if(fa && fa.outputs_match === false){
          const mm = fa.outputs_mismatch || {};
          const missing = Array.isArray(mm.missing) ? mm.missing : [];
          const extra = Array.isArray(mm.extra) ? mm.extra : [];
          const warn = document.createElement('div');
          warn.className = 'small text-danger';
          const parts = [];
          if(missing.length) parts.push('missing: ' + missing.join(', '));
          if(extra.length) parts.push('extra: ' + extra.join(', '));
          warn.textContent = parts.length ? ('outputs mismatch (' + parts.join(' | ') + ')') : 'outputs mismatch';
          left.appendChild(warn);
        }
      } catch(e) {}

      const right = document.createElement('div');
      right.className = 'btn-group btn-group-sm';
      const up = document.createElement('button');
      up.type = 'button';
      up.className = 'btn btn-outline-secondary';
      up.textContent = '↑';
      up.disabled = idx === 0;
      up.addEventListener('click', async () => {
        if(idx === 0) return;
        const tmp = currentChain[idx-1];
        currentChain[idx-1] = currentChain[idx];
        currentChain[idx] = tmp;
        renderChainEditor();
        await refreshBundleFromChain();
      });
      const down = document.createElement('button');
      down.type = 'button';
      down.className = 'btn btn-outline-secondary';
      down.textContent = '↓';
      down.disabled = idx === currentChain.length - 1;
      down.addEventListener('click', async () => {
        if(idx === currentChain.length - 1) return;
        const tmp = currentChain[idx+1];
        currentChain[idx+1] = currentChain[idx];
        currentChain[idx] = tmp;
        renderChainEditor();
        await refreshBundleFromChain();
      });
      right.appendChild(up);
      right.appendChild(down);

      item.appendChild(left);
      item.appendChild(right);
      item.addEventListener('click', (e)=>{
        // Avoid selecting when clicking reorder buttons.
        const t = e && e.target;
        if(t && t.tagName && String(t.tagName).toLowerCase() === 'button') return;
        selectChainIndex(idx);
      });
      wrap.appendChild(item);
    });
  }

  function selectChainIndex(idx){
    selectedChainIndex = Number.isFinite(+idx) ? (+idx) : -1;
    if(selectedChainIndex < 0 || !Array.isArray(currentChain) || selectedChainIndex >= currentChain.length){
      selectedChainIndex = -1;
      renderChainEditor();
      return;
    }
    renderChainEditor();
  }

  function updateMeta(){
    if(metaScenarioEl) metaScenarioEl.textContent = (activeScenario || '') ? String(activeScenario) : '-';
    if(metaPreviewEl) metaPreviewEl.textContent = lastPreviewPlanPath ? basenameFromPath(lastPreviewPlanPath) : '-';
    if(metaStatsEl) metaStatsEl.textContent = formatStats(lastStats) || '-';
  }

  async function refreshBundleFromChain(){
    if(!Array.isArray(currentChain) || currentChain.length === 0) return;
    setStatus('Updating bundle…', false);
    try{
      const data = await postJson('/api/flag-sequencing/bundle_from_chain', { scenario: activeScenario, chain: currentChain });
      currentBundle = data.bundle;
      currentFlagAssignments = Array.isArray(data.flag_assignments) ? data.flag_assignments.slice() : currentFlagAssignments;
      if(jsonEl) jsonEl.textContent = JSON.stringify(currentBundle, null, 2);
      const diagram = buildMermaid(currentChain);
      await renderMermaid(diagram);
      updateMeta();
      setStatus('Ready.', false);
    } catch(err){
      setStatus(String(err && err.message || err), true);
    }
  }

  function formatStats(stats){
    if(!stats || typeof stats !== 'object') return '';
    const d = Number.isFinite(+stats.docker_total) ? (+stats.docker_total) : null;
    const c = Number.isFinite(+stats.compose_backed_total) ? (+stats.compose_backed_total) : null;
    const e = Number.isFinite(+stats.eligible_total) ? (+stats.eligible_total) : null;
    if(d === null && c === null && e === null) return '';
    const inner = [];
    if(c !== null) inner.push('compose-backed: ' + c);
    if(e !== null) inner.push('eligible: ' + e);
    if(d !== null && inner.length){
      return 'Detected docker nodes: ' + d + ' (' + inner.join(', ') + ')';
    }
    if(d !== null) return 'Detected docker nodes: ' + d;
    return inner.length ? inner.join(', ') : '';
  }

  function buildMermaid(chain){
    const lines = ['flowchart LR'];
    if(!Array.isArray(chain) || chain.length === 0){
      lines.push('  A[No chain available]');
      return lines.join('\n');
    }
    for(let i=0;i<chain.length;i++){
      const node = chain[i];
      const safeId = 'N' + i;
      const label = (node && node.name) ? node.name : ('Node ' + (i+1));
      lines.push(`  ${safeId}[${label.replace(/\]/g,'')}]`);
      if(i>0){
        lines.push(`  N${i-1} --> ${safeId}`);
      }
    }
    for(let i=0;i<chain.length;i++){
      lines.push(`  click N${i} flowSelectNode "Show details"`);
    }
    return lines.join('\n');
  }

  async function renderMermaid(diagramText){
    try {
      if(window.mermaid){
        mermaid.initialize({ startOnLoad: false, securityLevel: 'loose' });
        const wrap = document.getElementById('flowDiagram');
        wrap.textContent = diagramText;
        wrap.removeAttribute('data-processed');
        await mermaid.run({ querySelector: '#flowDiagram' });
      }
    } catch(e) {
      // If rendering fails, keep plaintext.
      const wrap = document.getElementById('flowDiagram');
      if(wrap) wrap.textContent = diagramText;
    }
  }

  async function generate(preferPreview){
    const usePreview = !!preferPreview;
    const scenario = (scenarioEl && scenarioEl.value || '').trim();
    const length = parseInt((lengthEl && lengthEl.value) || '5', 10) || 5;

    const params = new URLSearchParams();
    if(scenario) params.set('scenario', scenario);
    params.set('length', String(length));
    // Only force preview selection when the user explicitly clicks Generate.
    if(usePreview){
      params.set('prefer_preview', '1');
      params.set('force_preview', '1');
    }

    const apiUrl = '/api/flag-sequencing/attackflow_preview?' + params.toString();
    if(downloadLink) downloadLink.href = '#';

    setStatus('Generating…', false);
    setLoginLinkVisible(false);
    if(metaScenarioEl) metaScenarioEl.textContent = '';
    if(metaPreviewEl) metaPreviewEl.textContent = '';
    if(metaStatsEl) metaStatsEl.textContent = '';
    if(jsonEl) jsonEl.textContent = '';

    try {
      const data = await fetchJson(apiUrl);
      currentChain = Array.isArray(data.chain) ? data.chain.slice() : [];
      currentBundle = data.bundle || null;
      currentFlagAssignments = Array.isArray(data.flag_assignments) ? data.flag_assignments.slice() : [];
      lastStats = data.stats || null;
      lastPreviewPlanPath = data.preview_plan_path || '';
      try {
        // If the backend loaded a saved chain whose effective length differs from the
        // current input value (e.g. page reload reset to default), keep the UI in sync.
        const effLen = Number.isFinite(+data.length) ? (+data.length) : null;
        if (effLen !== null && lengthEl) lengthEl.value = String(effLen);
      } catch(e) {}
      updateMeta();
      selectedChainIndex = -1;
      renderChainEditor();

      if(jsonEl) jsonEl.textContent = JSON.stringify(currentBundle, null, 2);
      const diagram = buildMermaid(currentChain);
      await renderMermaid(diagram);
      setStatus('Ready.', false);
    } catch(err){
      setStatus(String(err && err.message || err), true);
      setLoginLinkVisible(!!(err && err.loginRequired));
      const payload = err && err.payload ? err.payload : null;
      lastStats = payload && payload.stats ? payload.stats : null;
      lastPreviewPlanPath = payload && payload.preview_plan_path ? String(payload.preview_plan_path) : '';
      updateMeta();
      currentChain = [];
      currentBundle = null;
      currentFlagAssignments = [];
      selectedChainIndex = -1;
      renderChainEditor();
      const diagram = buildMermaid([]);
      await renderMermaid(diagram);
    }
  }

  async function execute(){
    const scenario = (scenarioEl && scenarioEl.value || '').trim();
    const length = (Array.isArray(currentChain) && currentChain.length) ? currentChain.length : (parseInt((lengthEl && lengthEl.value) || '5', 10) || 5);
    if(!scenario){
      setStatus('No scenario selected.', true);
      return;
    }
    if(execEl) execEl.disabled = true;
    setStatus('Preparing preview for execution…', false);
    setLoginLinkVisible(false);
    try{
      if(!Array.isArray(currentChain) || currentChain.length === 0){
        throw new Error('Generate a chain first.');
      }
      const chainIds = currentChain.map(n => (n && n.id) ? String(n.id) : '').filter(Boolean);
      const prepData = await postJson('/api/flag-sequencing/prepare_preview_for_execute', { scenario, length, chain_ids: chainIds });
      // Prefer server-returned (possibly enriched) assignments so the UI can show
      // generator run status/mismatch info before scenario execution.
      if(prepData && Array.isArray(prepData.flag_assignments)){
        currentFlagAssignments = prepData.flag_assignments.slice();
        renderChainEditor();
      }
      const xmlPath = (prepData && prepData.xml_path) ? String(prepData.xml_path) : '';
      const previewPlan = (prepData && prepData.preview_plan_path) ? String(prepData.preview_plan_path) : '';
      if(!xmlPath || !previewPlan){
        throw new Error('Prepare step did not return xml_path/preview_plan_path');
      }
      setStatus('Starting async execution…', false);
      const runData = await postJson('/run_cli_async', { xml_path: xmlPath, preview_plan: previewPlan, scenario });
      const runId = runData && runData.run_id ? String(runData.run_id) : '';
      if(runId){
        setStatus('Run started: ' + runId + ' (see Core/Reports pages).', false);
      } else {
        setStatus('Run started (missing run_id).', false);
      }
    } catch(err){
      setStatus(String(err && err.message || err), true);
      setLoginLinkVisible(!!(err && err.loginRequired));
    } finally {
      if(execEl) execEl.disabled = false;
    }
  }

  async function saveXmlOnly(){
    const scenario = (scenarioEl && scenarioEl.value || '').trim();
    const length = (Array.isArray(currentChain) && currentChain.length) ? currentChain.length : (parseInt((lengthEl && lengthEl.value) || '5', 10) || 5);
    if(!scenario){
      setStatus('No scenario selected.', true);
      return;
    }
    if(saveXmlEl) saveXmlEl.disabled = true;
    setStatus('Preparing preview and saving XML…', false);
    setLoginLinkVisible(false);
    try{
      if(!Array.isArray(currentChain) || currentChain.length === 0){
        throw new Error('Generate a chain first.');
      }
      const chainIds = currentChain.map(n => (n && n.id) ? String(n.id) : '').filter(Boolean);
      const prepData = await postJson('/api/flag-sequencing/prepare_preview_for_execute', { scenario, length, chain_ids: chainIds });
      if(prepData && Array.isArray(prepData.flag_assignments)){
        currentFlagAssignments = prepData.flag_assignments.slice();
        renderChainEditor();
      }
      const xmlPath = (prepData && prepData.xml_path) ? String(prepData.xml_path) : '';
      const previewPlan = (prepData && prepData.preview_plan_path) ? String(prepData.preview_plan_path) : '';
      if(!xmlPath || !previewPlan){
        throw new Error('Prepare step did not return xml_path/preview_plan_path');
      }
      lastPreviewPlanPath = previewPlan;
      updateMeta();
      try {
        const xmlPathInput = document.getElementById('scenariosPreviewXmlPath');
        if(xmlPathInput) xmlPathInput.value = xmlPath;
      } catch(e) {}
      try {
        if(downloadXmlEl){
          downloadXmlEl.disabled = false;
          downloadXmlEl.removeAttribute('title');
        }
      } catch(e) {}
      setStatus('Saved XML: ' + basenameFromPath(xmlPath), false);
      try { await refreshXmlDockPreview({ force: true }); } catch(e) {}
    } catch(err){
      setStatus(String(err && err.message || err), true);
      setLoginLinkVisible(!!(err && err.loginRequired));
    } finally {
      if(saveXmlEl) saveXmlEl.disabled = false;
    }
  }

  function downloadXml(){
    try {
      const xmlPath = (document.getElementById('scenariosPreviewXmlPath')?.value || '').trim();
      if(!xmlPath){
        setStatus('Save XML first to download.', true);
        return;
      }
      window.location.href = '/download_report?path=' + encodeURIComponent(xmlPath);
    } catch(err){
      setStatus(String(err && err.message || err), true);
    }
  }

  // Expose a mermaid click callback; it receives the nodeId like "N0".
  window.flowSelectNode = function(nodeId){
    try{
      const m = String(nodeId || '').match(/^N(\d+)$/);
      if(!m) return;
      const idx = parseInt(m[1], 10);
      if(Number.isFinite(idx)) selectChainIndex(idx);
    } catch(e) {}
  };

  if(btnEl) btnEl.addEventListener('click', (e)=>{ e.preventDefault(); generate(true); });
  if(saveXmlEl) saveXmlEl.addEventListener('click', (e)=>{ e.preventDefault(); saveXmlOnly(); });
  if(execEl) execEl.addEventListener('click', (e)=>{ e.preventDefault(); execute(); });
  if(downloadXmlEl) downloadXmlEl.addEventListener('click', (e)=>{ e.preventDefault(); downloadXml(); });

  if(downloadLink){
    downloadLink.addEventListener('click', (e)=>{
      try{
        e.preventDefault();
        if(!currentBundle){
          setStatus('Nothing to download yet (generate first).', true);
          return;
        }
        const scenario = (scenarioEl && scenarioEl.value || activeScenario || 'scenario').toString().trim();
        const norm = normalizeScenarioNorm(scenario).replace(/\s+/g,'_') || 'scenario';
        const fname = 'attackflow_' + norm + '_' + String(Array.isArray(currentChain)?currentChain.length:0) + '.json';
        const blob = new Blob([JSON.stringify(currentBundle, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = fname;
        document.body.appendChild(a);
        a.click();
        a.remove();
        setTimeout(()=>URL.revokeObjectURL(url), 1000);
      } catch(err){
        setStatus(String(err && err.message || err), true);
      }
    });
  }

  // Wire scenario list.
  if(scenarioListEl){
    scenarioListEl.querySelectorAll('[data-scen-name]').forEach(btn => {
      btn.addEventListener('click', async ()=>{
        const name = btn.getAttribute('data-scen-name') || '';
        if(!name || name === activeScenario) return;
        await setScenario(name);
      });
    });
  }
  if(clearScenarioBtn){
    clearScenarioBtn.addEventListener('click', async ()=>{
      const def = defaultScenarioName();
      if(def && def !== activeScenario) await setScenario(def);
    });
  }

  // Auto-generate on load (per-scenario page). If there are no scenarios, disable.
  if(!activeScenario){
    setStatus('No scenarios available yet.', true);
    if(btnEl) btnEl.disabled = true;
    return;
  }
  if(scenarioEl && !scenarioEl.value) scenarioEl.value = activeScenario;
  if(scenarioLabelEl && !scenarioLabelEl.textContent) scenarioLabelEl.textContent = activeScenario;
  updateScenarioQueryParam();
  updateScenarioFilterControls();
  refreshParticipantNavForScenario(activeScenario);
  // Auto-generate on load (prefer any saved Flow state).
  try { refreshXmlDockPreview({ force: false }); } catch(e) {}
  generate(false);
})();
</script>
{% endblock %}
  // Scenarios header Preview tab: route to /scenarios/preview.
  document.addEventListener('DOMContentLoaded', ()=>{
    const link = document.getElementById('scenariosPreviewTabLink');
    if(!link) return;
    link.addEventListener('click', (ev)=>{
      try {
        ev.preventDefault();
        const xmlPath = (document.getElementById('scenariosPreviewXmlPath')?.value || '').trim();
        const scen = (document.getElementById('flowScenario')?.value || document.getElementById('scenariosPreviewScenario')?.value || '').trim();
        if(!xmlPath){
          alert('Save XML first to preview.');
          return;
        }
        const baseUrl = String(link.dataset?.previewBaseUrl || '/scenarios/preview');
        const url = baseUrl + '?xml_path=' + encodeURIComponent(xmlPath) + (scen ? ('&scenario=' + encodeURIComponent(scen)) : '');
        window.location.href = url;
      } catch(e){}
    });
  });

