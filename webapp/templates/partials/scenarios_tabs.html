{# Shared Scenarios sub-navigation: Topology + Flag Sequencing, with a common Preview button. #}
{% set scenario_tab = (scenario_tab|default('')|string) %}
{% set scenarios_active_tab = (scenarios_active_tab|default('topology')|string) %}
{% set preview_xml_path = (preview_xml_path|default('')|string) %}

<style>
  /* Reserve space for the shared fixed-bottom Execute bar on all Scenarios sub-tabs. */
  :root { --coretg-execbar-height: 64px; }
  body { padding-bottom: 64px; }
</style>

<div class="d-flex align-items-center justify-content-between flex-wrap gap-2 mb-3">
  <ul class="nav nav-tabs mb-0">
    <li class="nav-item">
      <a class="nav-link {% if scenarios_active_tab == 'connection-setup' %}active{% endif %}" {% if scenarios_active_tab == 'connection-setup' %}aria-current="page"{% endif %} href="{{ url_for('index', scenario=scenario_tab, tab='connection-setup') if scenario_tab else url_for('index', tab='connection-setup') }}">VM / Access</a>
    </li>
    <li class="nav-item">
      <a class="nav-link {% if scenarios_active_tab == 'topology' %}active{% endif %}" {% if scenarios_active_tab == 'topology' %}aria-current="page"{% endif %} href="{{ url_for('index', scenario=scenario_tab) if scenario_tab else url_for('index') }}">Topology</a>
    </li>
    <li class="nav-item">
      <a class="nav-link {% if scenarios_active_tab == 'flag-sequencing' %}active{% endif %}" {% if scenarios_active_tab == 'flag-sequencing' %}aria-current="page"{% endif %} href="{{ url_for('flow_page', scenario=scenario_tab) if scenario_tab else url_for('flow_page') }}">Flag Sequencing</a>
    </li>
    <li class="nav-item">
      <a
        class="nav-link {% if scenarios_active_tab == 'preview' %}active{% endif %}"
        {% if scenarios_active_tab == 'preview' %}aria-current="page"{% endif %}
        href="{{ url_for('scenarios_preview_page', scenario=scenario_tab, xml_path=preview_xml_path) if scenario_tab else url_for('scenarios_preview_page', xml_path=preview_xml_path) }}"
        id="scenariosPreviewTabLink"
        data-preview-base-url="{{ url_for('scenarios_preview_page') }}"
        title="Generate a full preview for the selected scenario"
      >Preview</a>
    </li>
  </ul>

  {# Defaults used by JS; Preview tab can override with live editor state. #}
  <input type="hidden" id="scenariosPreviewXmlPath" value="{{ preview_xml_path }}">
  <input type="hidden" id="scenariosPreviewScenario" value="{{ scenario_tab }}">
</div>

<div class="position-fixed start-0 end-0 bg-body border-top" style="bottom: var(--coretg-dock-height, 0px); z-index: 1045;">
  <div class="container-fluid py-2">
    <div class="d-flex justify-content-end gap-2">
      {% if (not is_builder_view) and scenarios_active_tab in ['connection-setup', 'topology', 'flag-sequencing'] %}
        <button id="saveXmlBtn" class="btn btn-outline-success px-4 py-2 shadow-sm" type="button">Save XML</button>
        <button id="downloadXmlBtn" class="btn btn-outline-info px-4 py-2 shadow-sm" type="button" {% if not preview_xml_path %}disabled title="Save XML first"{% endif %}>Download XML</button>
      {% endif %}
      <button id="scenariosExecuteBtn" class="btn btn-success px-4 py-2 shadow-sm" type="button">{% if scenarios_active_tab == 'preview' %}Execute{% else %}Preview{% endif %}</button>
    </div>
  </div>
</div>

<script>
(function(){
  const PROJECT_STATE_STORAGE_KEY = 'coretg_project_state_map_v1';
  const LAST_PROJECT_KEY_STORAGE_KEY = 'coretg_last_project_key';
  const PROJECT_ACTIVE_IDX_STORAGE_KEY = 'coretg_project_active_idx_map_v1';
  const LATEST_XML_BY_SCENARIO_STORAGE_KEY = 'coretg_latest_xml_by_scenario_v1';
  const SEED_BY_SCENARIO_STORAGE_KEY = 'coretg_seed_by_scenario_v1';
  const PREVIEW_PLAN_BY_SCENARIO_STORAGE_KEY = 'coretg_preview_plan_by_scenario_v1';

  function readJsonFromLocalStorage(key, fallback){
    try {
      const raw = localStorage.getItem(key);
      if (!raw) return fallback;
      const parsed = JSON.parse(raw);
      return (parsed === null || parsed === undefined) ? fallback : parsed;
    } catch (e) {
      return fallback;
    }
  }

  function readLatestXmlMap(){
    return readJsonFromLocalStorage(LATEST_XML_BY_SCENARIO_STORAGE_KEY, {});
  }

  function readSeedMap(){
    return readJsonFromLocalStorage(SEED_BY_SCENARIO_STORAGE_KEY, {});
  }

  function readPreviewPlanMap(){
    return readJsonFromLocalStorage(PREVIEW_PLAN_BY_SCENARIO_STORAGE_KEY, {});
  }

  function getPreviewPlanPathForScenario(scenarioName){
    try {
      const key = normalizeScenarioKey(scenarioName);
      if (!key) return '';
      const map = readPreviewPlanMap();
      const entry = (map && typeof map === 'object') ? map[key] : null;
      const path = entry && typeof entry === 'object' ? (entry.preview_plan_path || entry.previewPlanPath || '') : '';
      return (path || '').toString().trim();
    } catch (e) {
      return '';
    }
  }

  function setPreviewPlanPathForScenario(scenarioName, previewPlanPath){
    try {
      const key = normalizeScenarioKey(scenarioName);
      const path = (previewPlanPath || '').toString().trim();
      if (!key || !path) return;
      const map = readPreviewPlanMap();
      const next = (map && typeof map === 'object') ? map : {};
      next[key] = {
        scenario: (scenarioName || '').toString().trim(),
        preview_plan_path: path,
        updated_at: Date.now(),
      };
      localStorage.setItem(PREVIEW_PLAN_BY_SCENARIO_STORAGE_KEY, JSON.stringify(next));
    } catch (e) {}
  }

  function stableSeedFromScenario(scenarioName){
    try {
      // Prefer project key if available so seeds are stable within a project.
      const projKey = (localStorage.getItem(LAST_PROJECT_KEY_STORAGE_KEY) || '').trim();
      const scenKey = normalizeScenarioKey(scenarioName) || '__default__';
      const base = (projKey ? (projKey + '|') : '') + scenKey;

      // Small deterministic hash -> 31-bit positive int.
      let h = 2166136261;
      for (let i = 0; i < base.length; i++) {
        h ^= base.charCodeAt(i);
        h = Math.imul(h, 16777619);
      }
      const seed = (h >>> 0) % 2147483647;
      return seed || 1;
    } catch (e) {
      return 1;
    }
  }

  function getSeedForScenario(scenarioName){
    try {
      const key = normalizeScenarioKey(scenarioName);
      if (!key) return null;
      const map = readSeedMap();
      const entry = (map && typeof map === 'object') ? map[key] : null;
      const raw = entry && typeof entry === 'object' ? (entry.seed ?? null) : null;
      if (raw === null || raw === undefined || raw === '') {
        return null;
      }
      const n = parseInt(String(raw), 10);
      return Number.isFinite(n) ? n : null;
    } catch (e) {
      return null;
    }
  }

  function ensureSeedForScenario(scenarioName){
    try {
      const key = normalizeScenarioKey(scenarioName);
      if (!key) return null;
      const existing = getSeedForScenario(scenarioName);
      if (existing !== null) return existing;
      const seed = stableSeedFromScenario(scenarioName);
      setSeedForScenario(scenarioName, seed);
      return seed;
    } catch (e) {
      return null;
    }
  }

  function setSeedForScenario(scenarioName, seed){
    try {
      const key = normalizeScenarioKey(scenarioName);
      if (!key) return;
      const n = parseInt(String(seed ?? ''), 10);
      if (!Number.isFinite(n)) return;
      const map = readSeedMap();
      const next = (map && typeof map === 'object') ? map : {};
      next[key] = {
        scenario: (scenarioName || '').toString().trim(),
        seed: n,
        updated_at: Date.now(),
      };
      localStorage.setItem(SEED_BY_SCENARIO_STORAGE_KEY, JSON.stringify(next));
    } catch (e) {}
  }

  function getLatestXmlPathForScenario(scenarioName){
    try {
      const key = normalizeScenarioKey(scenarioName);
      if (!key) return '';
      const map = readLatestXmlMap();
      const entry = (map && typeof map === 'object') ? map[key] : null;
      const path = entry && typeof entry === 'object' ? (entry.xml_path || entry.xmlPath || '') : '';
      return (path || '').toString().trim();
    } catch (e) {
      return '';
    }
  }

  function setLatestXmlPathForScenario(scenarioName, xmlPath){
    try {
      const key = normalizeScenarioKey(scenarioName);
      const path = (xmlPath || '').toString().trim();
      if (!key || !path) return;
      const map = readLatestXmlMap();
      const next = (map && typeof map === 'object') ? map : {};
      next[key] = {
        scenario: (scenarioName || '').toString().trim(),
        xml_path: path,
        updated_at: Date.now(),
      };
      localStorage.setItem(LATEST_XML_BY_SCENARIO_STORAGE_KEY, JSON.stringify(next));
    } catch (e) {}
  }

  function pickBestLocalSnapshotByScenarioCount(snapshotMap){
    try {
      if (!snapshotMap || typeof snapshotMap !== 'object') return null;
      let best = null;
      let bestCount = 0;
      Object.keys(snapshotMap).forEach(key => {
        const entry = snapshotMap[key];
        const scenarios = Array.isArray(entry?.scenarios) ? entry.scenarios : null;
        if (!scenarios || !scenarios.length) return;
        if (scenarios.length > bestCount) {
          bestCount = scenarios.length;
          best = entry;
        }
      });
      return best;
    } catch (e) {
      return null;
    }
  }

  function resolveScenarioNameHint(){
    try {
      const params = new URLSearchParams(window.location.search || '');
      const qp = (params.get('scenario') || '').trim();
      if (qp) return qp;
    } catch (e) {}
    try {
      const hidden = document.getElementById('scenariosPreviewScenario');
      const val = (hidden && typeof hidden.value === 'string') ? hidden.value.trim() : '';
      if (val) return val;
    } catch (e) {}
    return '';
  }

  function getCurrentProjectSnapshot(){
    const projectStateMap = readJsonFromLocalStorage(PROJECT_STATE_STORAGE_KEY, {});
    const key = (localStorage.getItem(LAST_PROJECT_KEY_STORAGE_KEY) || '').trim();
    if (key && projectStateMap && typeof projectStateMap === 'object' && projectStateMap[key]) {
      return projectStateMap[key];
    }
    return pickBestLocalSnapshotByScenarioCount(projectStateMap);
  }

  function resolveActiveScenarioFromSnapshot(snapshot){
    const scenarios = Array.isArray(snapshot?.scenarios) ? snapshot.scenarios : [];
    if (!scenarios.length) return null;

    const hint = resolveScenarioNameHint();
    if (hint) {
      const normHint = hint.toLowerCase();
      const found = scenarios.find(s => (s?.name ?? '').toString().trim().toLowerCase() === normHint);
      if (found) return found;
    }

    let idx = Number.isInteger(snapshot?.active_index) ? snapshot.active_index : null;
    if (!Number.isInteger(idx)) {
      try {
        const key = (localStorage.getItem(LAST_PROJECT_KEY_STORAGE_KEY) || '').trim();
        const idxMap = readJsonFromLocalStorage(PROJECT_ACTIVE_IDX_STORAGE_KEY, {});
        const mapped = (idxMap && typeof idxMap === 'object' && key) ? idxMap[key] : null;
        if (Number.isInteger(mapped)) idx = mapped;
      } catch (e) {}
    }
    if (!Number.isInteger(idx)) {
      const raw = (localStorage.getItem('coretg_active_idx') || '').trim();
      const parsed = parseInt(raw || '0', 10);
      idx = Number.isNaN(parsed) ? 0 : parsed;
    }
    idx = Math.min(Math.max(0, idx || 0), scenarios.length - 1);
    return scenarios[idx] || scenarios[0] || null;
  }

  function isScenarioCoreVmVerifiedForProject(scenario){
    try {
      if (!scenario || typeof scenario !== 'object') return false;
      const hitl = (scenario.hitl && typeof scenario.hitl === 'object') ? scenario.hitl : {};
      const prox = (hitl.proxmox && typeof hitl.proxmox === 'object') ? hitl.proxmox : {};
      const core = (hitl.core && typeof hitl.core === 'object') ? hitl.core : {};
      const vmKey = (core?.vm_key ?? '').toString().trim();
      const proxSecretId = (prox?.secret_id ?? '').toString().trim();
      const coreSecretId = (core?.core_secret_id ?? core?.secret_id ?? '').toString().trim();
      const proxValidated = !!prox?.validated;
      const coreValidated = !!core?.validated;
      return !!(vmKey && proxSecretId && coreSecretId && proxValidated && coreValidated);
    } catch (e) {
      return false;
    }
  }

  function refreshScenariosExecuteButtonState(){
    const btn = document.getElementById('scenariosExecuteBtn');
    if (!btn) return;
    // Preview is always available; CORE VM verification is only required for execution.
    btn.disabled = false;
    btn.removeAttribute('title');
  }

  const FLOW_STATE_STORAGE_KEY = 'coretg_flow_state_by_scenario_v1';

  function normalizeScenarioKey(raw){
    try {
      return (raw || '').toString().trim().toLowerCase().replace(/\s+/g, ' ');
    } catch (e) {
      return '';
    }
  }

  function readFlowStateMap(){
    return readJsonFromLocalStorage(FLOW_STATE_STORAGE_KEY, {});
  }

  function getSavedFlowStateForScenario(scenarioName){
    try {
      const key = normalizeScenarioKey(scenarioName);
      if (!key) return null;
      const map = readFlowStateMap();
      const entry = (map && typeof map === 'object') ? map[key] : null;
      if (!entry || typeof entry !== 'object') return null;
      const scenario = (entry.scenario || scenarioName || '').toString();
      const preset = (entry.preset || '').toString();
      const length = Number.isFinite(+entry.length) ? (+entry.length) : null;
      const chain_ids = Array.isArray(entry.chain_ids) ? entry.chain_ids.map(x => String(x || '').trim()).filter(Boolean) : [];
      if (!chain_ids.length) return null;
      return { scenario, preset, length: length || chain_ids.length, chain_ids };
    } catch (e) {
      return null;
    }
  }

  function setSavedFlowStateForScenario(scenarioName, state){
    try {
      const key = normalizeScenarioKey(scenarioName);
      if (!key) return;
      const map = readFlowStateMap();
      const next = (map && typeof map === 'object') ? map : {};
      const s = (state && typeof state === 'object') ? state : {};
      next[key] = {
        scenario: (scenarioName || '').toString().trim(),
        preset: (s.preset || '').toString(),
        length: Number.isFinite(+s.length) ? (+s.length) : null,
        chain_ids: Array.isArray(s.chain_ids) ? s.chain_ids.map(x => String(x || '').trim()).filter(Boolean) : [],
        updated_at: Date.now(),
      };
      localStorage.setItem(FLOW_STATE_STORAGE_KEY, JSON.stringify(next));
    } catch (e) {}
  }

  async function postJson(url, payload){
    const res = await fetch(url, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      credentials: 'same-origin',
      body: JSON.stringify(payload || {}),
    });
    let data = null;
    try { data = await res.json(); } catch (e) { data = null; }
    if (!res.ok) {
      const msg = (data && data.error) ? String(data.error) : ('HTTP ' + res.status);
      throw new Error(msg);
    }
    if (data && data.ok === false) {
      throw new Error(String(data.error || 'Request failed'));
    }
    return data;
  }

  function resolveScenarioNameForSave(){
    try {
      if (window.state && Array.isArray(window.state.scenarios)) {
        const idx = (typeof window.state.active_index === 'number') ? window.state.active_index : 0;
        const sc = window.state.scenarios[idx] || window.state.scenarios[0];
        const nm = (sc && sc.name) ? String(sc.name).trim() : '';
        if (nm) return nm;
      }
    } catch (e) {}
    try {
      const snap = getCurrentProjectSnapshot();
      const active = resolveActiveScenarioFromSnapshot(snap);
      const nm = (active && active.name) ? String(active.name).trim() : '';
      if (nm) return nm;
    } catch (e) {}
    return resolveScenarioNameHint();
  }

  function buildSaveXmlApiPayload(){
    // Prefer in-memory editor state when present (Topology page), else fall back to local snapshot.
    try {
      if (window.state && Array.isArray(window.state.scenarios) && window.state.scenarios.length) {
        const active_index = (typeof window.state.active_index === 'number') ? window.state.active_index : 0;
        const core = (typeof window.getCoreConfig === 'function') ? window.getCoreConfig(true) : (window.state.core || null);
        const project_key_hint = (window.currentProjectKey || '').toString().trim();
        const scenario_query = (typeof window.resolveScenarioQueryHint === 'function') ? window.resolveScenarioQueryHint() : '';
        return {
          scenarios: window.state.scenarios,
          core: core,
          active_index,
          project_key_hint,
          scenario_query,
        };
      }
    } catch (e) {}

    const snap = getCurrentProjectSnapshot();
    const scenarios = Array.isArray(snap?.scenarios) ? snap.scenarios : [];
    const core = (snap && typeof snap === 'object') ? (snap.core || null) : null;
    const active_index = Number.isInteger(snap?.active_index) ? snap.active_index : null;
    const project_key_hint = (snap && typeof snap === 'object' && snap.project_key_hint) ? String(snap.project_key_hint) : '';
    const scenario_query = (snap && typeof snap === 'object' && snap.scenario_query) ? String(snap.scenario_query) : '';
    return { scenarios, core, active_index, project_key_hint, scenario_query };
  }

  async function saveXmlViaApi(){
    const payload = buildSaveXmlApiPayload();
    if (!Array.isArray(payload.scenarios) || !payload.scenarios.length) {
      throw new Error('No scenarios available to save.');
    }
    const data = await postJson('/save_xml_api', payload);
    const xmlPath = (data && data.result_path) ? String(data.result_path) : '';
    if (!xmlPath) throw new Error('Save succeeded but returned no result_path.');

    // Remember the latest saved XML path for this scenario so other tabs (Preview/Flow)
    // can refer to the same snapshot.
    try {
      const scenarioName = resolveScenarioNameForSave();
      if (scenarioName) setLatestXmlPathForScenario(scenarioName, xmlPath);
    } catch (e) {}

    // Preserve a stable per-scenario seed across saves so Preview/Flow do not "re-roll"
    // just because the XML path changes.
    try {
      const scenarioName = resolveScenarioNameForSave();
      if (scenarioName) ensureSeedForScenario(scenarioName);
    } catch (e) {}

    // If the Topology page state is present, keep it in sync.
    try {
      if (window.state && typeof window.state === 'object') {
        window.state.result_path = xmlPath;
      }
    } catch (e) {}

    try {
      const xmlPathInput = document.getElementById('scenariosPreviewXmlPath');
      if (xmlPathInput) xmlPathInput.value = xmlPath;
    } catch (e) {}
    try {
      const dl = document.getElementById('downloadXmlBtn');
      if (dl) {
        dl.disabled = false;
        dl.removeAttribute('title');
      }
    } catch (e) {}
    return xmlPath;
  }

  async function saveAllAndGoPreview(opts){
    const options = (opts && typeof opts === 'object') ? opts : {};
    const xmlPath = await saveXmlViaApi();
    const scenario = (options.scenarioOverride || '').toString().trim() || resolveScenarioNameForSave();
    const baseUrl = String(document.getElementById('scenariosPreviewTabLink')?.dataset?.previewBaseUrl || '/scenarios/preview');
    const url = baseUrl + '?xml_path=' + encodeURIComponent(xmlPath) + (scenario ? ('&scenario=' + encodeURIComponent(scenario)) : '');
    window.location.href = url;
  }

  window.coretgPostJson = postJson;
  window.coretgSaveXmlViaApi = saveXmlViaApi;
  window.coretgSaveAllAndGoPreview = saveAllAndGoPreview;
  window.coretgGetSavedFlowStateForScenario = getSavedFlowStateForScenario;
  window.coretgSetSavedFlowStateForScenario = setSavedFlowStateForScenario;
  window.coretgGetLatestXmlPathForScenario = getLatestXmlPathForScenario;
  window.coretgSetLatestXmlPathForScenario = setLatestXmlPathForScenario;
  window.coretgGetSeedForScenario = getSeedForScenario;
  window.coretgEnsureSeedForScenario = ensureSeedForScenario;
  window.coretgSetSeedForScenario = setSeedForScenario;
  window.coretgGetPreviewPlanPathForScenario = getPreviewPlanPathForScenario;
  window.coretgSetPreviewPlanPathForScenario = setPreviewPlanPathForScenario;

  window.coretgRefreshScenariosExecuteButtonState = refreshScenariosExecuteButtonState;
  document.addEventListener('DOMContentLoaded', refreshScenariosExecuteButtonState);
  window.addEventListener('storage', (ev) => {
    try {
      if (!ev || !ev.key) return;
      if (ev.key === PROJECT_STATE_STORAGE_KEY || ev.key === LAST_PROJECT_KEY_STORAGE_KEY || ev.key === PROJECT_ACTIVE_IDX_STORAGE_KEY) {
        refreshScenariosExecuteButtonState();
      }
    } catch (e) {}
  });
})();
</script>
