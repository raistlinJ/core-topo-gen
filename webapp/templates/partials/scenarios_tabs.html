{# Shared Scenarios sub-navigation: Topology + Flag Sequencing, with a common Preview button. #}
{% set scenario_tab = (scenario_tab|default('')|string) %}
{% set scenarios_active_tab = (scenarios_active_tab|default('topology')|string) %}
{% set preview_xml_path = (preview_xml_path|default('')|string) %}

<style>
  /* Reserve space for the shared fixed-bottom Execute bar on all Scenarios sub-tabs. */
  :root { --coretg-execbar-height: 64px; }
  body { padding-bottom: 64px; }
</style>

<div class="d-flex align-items-center justify-content-between flex-wrap gap-2 mb-3">
  <ul class="nav nav-tabs mb-0">
    <li class="nav-item">
      <a class="nav-link {% if scenarios_active_tab == 'connection-setup' %}active{% endif %}" {% if scenarios_active_tab == 'connection-setup' %}aria-current="page"{% endif %} href="{{ url_for('index', scenario=scenario_tab, tab='connection-setup') if scenario_tab else url_for('index', tab='connection-setup') }}">VM / Access</a>
    </li>
    <li class="nav-item">
      <a class="nav-link {% if scenarios_active_tab == 'topology' %}active{% endif %}" {% if scenarios_active_tab == 'topology' %}aria-current="page"{% endif %} href="{{ url_for('index', scenario=scenario_tab) if scenario_tab else url_for('index') }}">Topology</a>
    </li>
    <li class="nav-item">
      <a class="nav-link {% if scenarios_active_tab == 'flag-sequencing' %}active{% endif %}" {% if scenarios_active_tab == 'flag-sequencing' %}aria-current="page"{% endif %} href="{{ url_for('flow_page', scenario=scenario_tab) if scenario_tab else url_for('flow_page') }}">Flag Sequencing</a>
    </li>
    <li class="nav-item">
      <a
        class="nav-link {% if scenarios_active_tab == 'preview' %}active{% endif %}"
        {% if scenarios_active_tab == 'preview' %}aria-current="page"{% endif %}
        href="{{ url_for('scenarios_preview_page', scenario=scenario_tab, xml_path=preview_xml_path) if scenario_tab else url_for('scenarios_preview_page', xml_path=preview_xml_path) }}"
        id="scenariosPreviewTabLink"
        data-preview-base-url="{{ url_for('scenarios_preview_page') }}"
        title="Generate a full preview for the selected scenario"
      >Preview</a>
    </li>
    {% if nav_participant_url %}
    <li class="nav-item">
      <a class="nav-link" href="{{ url_for('participant_ui_page', scenario=scenario_tab) if scenario_tab else url_for('participant_ui_page') }}" title="Participant-UI">Participant-UI</a>
    </li>
    {% endif %}
  </ul>

  {# Defaults used by JS; Preview tab can override with live editor state. #}
  <input type="hidden" id="scenariosPreviewXmlPath" value="{{ preview_xml_path }}">
  <input type="hidden" id="scenariosPreviewScenario" value="{{ scenario_tab }}">
</div>

<div class="position-fixed start-0 end-0 bg-body border-top" style="bottom: var(--coretg-dock-height, 0px); z-index: 1045;">
  <div class="container-fluid py-2">
    <div class="d-flex justify-content-end gap-2">
      {% if (not is_builder_view) and scenarios_active_tab in ['connection-setup', 'topology', 'flag-sequencing'] %}
        <button id="saveXmlBtn" class="btn btn-outline-success px-4 py-2 shadow-sm" type="button">Save XML</button>
        <button id="downloadXmlBtn" class="btn btn-outline-info px-4 py-2 shadow-sm" type="button" {% if not preview_xml_path %}disabled title="Save XML first"{% endif %}>Download XML</button>
      {% endif %}
      <button
        id="scenariosExecuteBtn"
        class="btn btn-success px-4 py-2 shadow-sm"
        type="button"
        {% if scenarios_active_tab == 'topology' %}data-coretg-action="continue" data-coretg-scenario="{{ scenario_tab }}" title="Continue to Flag Sequencing"{% elif scenarios_active_tab == 'connection-setup' %}data-coretg-action="continue-topology" data-coretg-scenario="{{ scenario_tab }}" title="Continue to Topology"{% endif %}
      >{% if scenarios_active_tab == 'preview' %}Execute{% elif scenarios_active_tab in ['topology', 'connection-setup'] %}Continue{% else %}Preview{% endif %}</button>
    </div>
  </div>
</div>

<!-- Progress overlay for long-running Save XML work (e.g., checking vuln readiness) -->
<div id="coretgProgressOverlay" style="display:none; position:fixed; inset:0; z-index: 4000; background: rgba(0,0,0,0.35); align-items:center; justify-content:center;">
  <div style="width: min(560px, calc(100vw - 24px)); background:#fff; border-radius:14px; padding:16px 16px 14px 16px; box-shadow: 0 20px 60px rgba(0,0,0,0.25);">
    <div style="display:flex; align-items:flex-start; justify-content:space-between; gap:12px;">
      <div style="min-width: 0;">
        <div id="coretgProgressTitle" style="font-weight:600; font-size:14px;">Working…</div>
        <div id="coretgProgressMessage" style="margin-top:4px; font-size:13px; color: rgba(0,0,0,0.72); white-space: pre-wrap; overflow-wrap: anywhere;">Starting…</div>
      </div>
      <div id="coretgProgressPercent" style="white-space:nowrap; font-variant-numeric: tabular-nums; font-weight:600; color: rgba(0,0,0,0.72);">0%</div>
    </div>
    <div style="margin-top:12px; height:10px; background: rgba(0,0,0,0.10); border-radius: 999px; overflow:hidden;">
      <div id="coretgProgressBar" style="height: 100%; width: 0%; background: #0d6efd; border-radius: 999px;"></div>
    </div>
    <div style="margin-top:10px; font-size:12px; color: rgba(0,0,0,0.55);">This may take a moment while checking Docker images.</div>
  </div>
</div>

<script>
(function(){
  const PROJECT_STATE_STORAGE_KEY = 'coretg_project_state_map_v1';
  const LAST_PROJECT_KEY_STORAGE_KEY = 'coretg_last_project_key';
  const PROJECT_ACTIVE_IDX_STORAGE_KEY = 'coretg_project_active_idx_map_v1';
  const LATEST_XML_BY_SCENARIO_STORAGE_KEY = 'coretg_latest_xml_by_scenario_v1';
  const SEED_BY_SCENARIO_STORAGE_KEY = 'coretg_seed_by_scenario_v1';
  const PREVIEW_PLAN_BY_SCENARIO_STORAGE_KEY = 'coretg_preview_plan_by_scenario_v1';
  const FLOW_DIRTY_BY_SCENARIO_STORAGE_KEY = 'coretg_flow_dirty_by_scenario_v1';
  const TOPOLOGY_SIGNATURE_BY_SCENARIO_STORAGE_KEY = 'coretg_topology_signature_by_scenario_v1';
  const TOPOLOGY_CONTINUE_STORAGE_KEY = 'coretg_topology_continue_after_save_v1';
  const LAST_SELECTED_SCENARIO_STORAGE_KEY = 'coretg_last_selected_scenario_v1';

  function getActiveTabName(){
    try {
      const v = (window.CORETG_SCENARIOS_ACTIVE_TAB ?? window.SCENARIOS_ACTIVE_TAB ?? '').toString();
      if (v) return v;
    } catch (e) {}
    // Fall back to URL heuristics.
    try {
      const p = (window.location && window.location.pathname) ? String(window.location.pathname) : '';
      if (p.includes('/scenarios/flag-sequencing')) return 'flag-sequencing';
      if (p.includes('/scenarios/preview')) return 'preview';
      return 'topology';
    } catch (e) {}
    return 'topology';
  }

  function setFixedPreviewButtonMode(mode, scenarioName){
    try {
      const btn = document.getElementById('scenariosExecuteBtn');
      if (!btn) return;
      const m = (mode || '').toString().trim().toLowerCase();
      if (m === 'continue') {
        btn.textContent = 'Continue';
        btn.dataset.coretgAction = 'continue';
        btn.dataset.coretgScenario = (scenarioName || '').toString();
        btn.disabled = false;
        btn.setAttribute('title', 'Continue to Flag Sequencing');
        return;
      }
      if (m === 'continue-topology') {
        btn.textContent = 'Continue';
        btn.dataset.coretgAction = 'continue-topology';
        btn.dataset.coretgScenario = (scenarioName || '').toString();
        btn.disabled = false;
        btn.setAttribute('title', 'Continue to Topology');
        return;
      }
      // default: return to normal label
      btn.dataset.coretgAction = '';
      btn.dataset.coretgScenario = '';
      btn.removeAttribute('data-coretg-action');
      btn.removeAttribute('data-coretg-scenario');
      btn.removeAttribute('title');
      // Let other logic decide enablement; only fix the label here.
      const activeTab = getActiveTabName();
      if (activeTab === 'topology') {
        btn.textContent = 'Continue';
        btn.dataset.coretgAction = 'continue';
        btn.dataset.coretgScenario = (scenarioName || '').toString();
        btn.setAttribute('title', 'Continue to Flag Sequencing');
      } else if (activeTab === 'connection-setup') {
        btn.textContent = 'Continue';
        btn.dataset.coretgAction = 'continue-topology';
        btn.dataset.coretgScenario = (scenarioName || '').toString();
        btn.setAttribute('title', 'Continue to Topology');
      } else {
        btn.textContent = (activeTab === 'preview') ? 'Execute' : 'Preview';
      }
    } catch (e) {}
  }

  function rememberContinueAfterSave(scenarioName){
    try {
      const payload = {
        scenario: (scenarioName || '').toString().trim(),
        updated_at: Date.now(),
      };
      sessionStorage.setItem(TOPOLOGY_CONTINUE_STORAGE_KEY, JSON.stringify(payload));
    } catch (e) {}
  }

  function clearContinueAfterSave(){
    try { sessionStorage.removeItem(TOPOLOGY_CONTINUE_STORAGE_KEY); } catch (e) {}
  }

  function restoreContinueAfterSaveIfAny(){
    try {
      const activeTab = getActiveTabName();
      if (activeTab !== 'topology') {
        clearContinueAfterSave();
        return;
      }
      const raw = sessionStorage.getItem(TOPOLOGY_CONTINUE_STORAGE_KEY);
      if (!raw) return;
      let obj = null;
      try { obj = JSON.parse(raw); } catch (e) { obj = null; }
      const scen = (obj && typeof obj === 'object') ? (obj.scenario || '') : '';
      if (!String(scen || '').trim()) return;
      setFixedPreviewButtonMode('continue', scen);
    } catch (e) {}
  }

  // Progress overlay helpers (used by Save XML).
  function setProgressUI(payload){
    try {
      const p = (payload && typeof payload === 'object') ? payload : {};
      const overlay = document.getElementById('coretgProgressOverlay');
      const titleEl = document.getElementById('coretgProgressTitle');
      const msgEl = document.getElementById('coretgProgressMessage');
      const pctEl = document.getElementById('coretgProgressPercent');
      const barEl = document.getElementById('coretgProgressBar');
      if (!overlay || !titleEl || !msgEl || !pctEl || !barEl) return;
      const pct = Math.max(0, Math.min(100, Number.isFinite(+p.percent) ? (+p.percent) : 0));
      if (typeof p.title === 'string' && p.title.trim()) titleEl.textContent = p.title;
      if (typeof p.message === 'string') msgEl.textContent = p.message;
      pctEl.textContent = `${Math.round(pct)}%`;
      barEl.style.width = `${pct}%`;
    } catch (e) {}
  }

  window.coretgShowProgress = function(payload){
    try {
      const overlay = document.getElementById('coretgProgressOverlay');
      if (!overlay) return;
      overlay.style.display = 'flex';
      setProgressUI(payload || { title: 'Working…', message: 'Starting…', percent: 0 });
    } catch (e) {}
  };
  window.coretgUpdateProgress = function(payload){
    setProgressUI(payload);
  };
  window.coretgHideProgress = function(){
    try {
      const overlay = document.getElementById('coretgProgressOverlay');
      if (overlay) overlay.style.display = 'none';
    } catch (e) {}
  };

  // Restore any pending "Continue" mode after reloads.
  try { document.addEventListener('DOMContentLoaded', restoreContinueAfterSaveIfAny); } catch (e) {}

  function readJsonFromLocalStorage(key, fallback){
    try {
      const raw = localStorage.getItem(key);
      if (!raw) return fallback;
      const parsed = JSON.parse(raw);
      return (parsed === null || parsed === undefined) ? fallback : parsed;
    } catch (e) {
      return fallback;
    }
  }

  function readLatestXmlMap(){
    return readJsonFromLocalStorage(LATEST_XML_BY_SCENARIO_STORAGE_KEY, {});
  }

  function readSeedMap(){
    return readJsonFromLocalStorage(SEED_BY_SCENARIO_STORAGE_KEY, {});
  }

  function readPreviewPlanMap(){
    return readJsonFromLocalStorage(PREVIEW_PLAN_BY_SCENARIO_STORAGE_KEY, {});
  }

  function readFlowDirtyMap(){
    return readJsonFromLocalStorage(FLOW_DIRTY_BY_SCENARIO_STORAGE_KEY, {});
  }

  function readTopologySignatureMap(){
    return readJsonFromLocalStorage(TOPOLOGY_SIGNATURE_BY_SCENARIO_STORAGE_KEY, {});
  }

  function getTopologySignatureForScenario(scenarioName){
    try {
      const key = normalizeScenarioKey(scenarioName);
      if (!key) return null;
      const map = readTopologySignatureMap();
      const entry = (map && typeof map === 'object') ? map[key] : null;
      const sig = entry && typeof entry === 'object' ? (entry.signature ?? null) : null;
      return (typeof sig === 'string' && sig) ? sig : null;
    } catch (e) {
      return null;
    }
  }

  function setTopologySignatureForScenario(scenarioName, signature){
    try {
      const key = normalizeScenarioKey(scenarioName);
      if (!key) return;
      if (!signature || typeof signature !== 'string') return;
      const map = readTopologySignatureMap();
      const next = (map && typeof map === 'object') ? map : {};
      next[key] = {
        scenario: (scenarioName || '').toString().trim(),
        signature: signature,
        updated_at: Date.now(),
      };
      localStorage.setItem(TOPOLOGY_SIGNATURE_BY_SCENARIO_STORAGE_KEY, JSON.stringify(next));
    } catch (e) {}
  }

  function getPreviewPlanPathForScenario(scenarioName){
    return '';
  }

  function setPreviewPlanPathForScenario(scenarioName, previewPlanPath){
    try {
      const key = normalizeScenarioKey(scenarioName);
      if (!key) return;
      const map = readPreviewPlanMap();
      const next = (map && typeof map === 'object') ? map : {};
      try { delete next[key]; } catch (e) {}
      localStorage.setItem(PREVIEW_PLAN_BY_SCENARIO_STORAGE_KEY, JSON.stringify(next));
    } catch (e) {}
  }

  function isFlowDirtyForScenario(scenarioName){
    try {
      const key = normalizeScenarioKey(scenarioName);
      if (!key) return false;
      const map = readFlowDirtyMap();
      const entry = (map && typeof map === 'object') ? map[key] : null;
      return !!(entry && typeof entry === 'object' && entry.dirty);
    } catch (e) {
      return false;
    }
  }

  function setFlowDirtyForScenario(scenarioName, dirty, reason, xmlPath){
    try {
      const key = normalizeScenarioKey(scenarioName);
      if (!key) return;
      const map = readFlowDirtyMap();
      const next = (map && typeof map === 'object') ? map : {};
      if (!dirty) {
        try { delete next[key]; } catch (e) {}
        localStorage.setItem(FLOW_DIRTY_BY_SCENARIO_STORAGE_KEY, JSON.stringify(next));
        return;
      }
      next[key] = {
        scenario: (scenarioName || '').toString().trim(),
        dirty: true,
        reason: (reason || 'topology_changed').toString(),
        xml_path: (xmlPath || '').toString(),
        updated_at: Date.now(),
      };
      localStorage.setItem(FLOW_DIRTY_BY_SCENARIO_STORAGE_KEY, JSON.stringify(next));
    } catch (e) {}
  }

  function stableSeedFromScenario(scenarioName){
    try {
      // Prefer project key if available so seeds are stable within a project.
      const projKey = (localStorage.getItem(LAST_PROJECT_KEY_STORAGE_KEY) || '').trim();
      const scenKey = normalizeScenarioKey(scenarioName) || '__default__';
      const base = (projKey ? (projKey + '|') : '') + scenKey;

      // Small deterministic hash -> 31-bit positive int.
      let h = 2166136261;
      for (let i = 0; i < base.length; i++) {
        h ^= base.charCodeAt(i);
        h = Math.imul(h, 16777619);
      }
      const seed = (h >>> 0) % 2147483647;
      return seed || 1;
    } catch (e) {
      return 1;
    }
  }

  function getSeedForScenario(scenarioName){
    try {
      const key = normalizeScenarioKey(scenarioName);
      if (!key) return null;
      const map = readSeedMap();
      const entry = (map && typeof map === 'object') ? map[key] : null;
      const raw = entry && typeof entry === 'object' ? (entry.seed ?? null) : null;
      if (raw === null || raw === undefined || raw === '') {
        return null;
      }
      const n = parseInt(String(raw), 10);
      return Number.isFinite(n) ? n : null;
    } catch (e) {
      return null;
    }
  }

  function ensureSeedForScenario(scenarioName){
    try {
      const key = normalizeScenarioKey(scenarioName);
      if (!key) return null;
      const existing = getSeedForScenario(scenarioName);
      if (existing !== null) return existing;
      const seed = stableSeedFromScenario(scenarioName);
      setSeedForScenario(scenarioName, seed);
      return seed;
    } catch (e) {
      return null;
    }
  }

  function setSeedForScenario(scenarioName, seed){
    try {
      const key = normalizeScenarioKey(scenarioName);
      if (!key) return;
      const n = parseInt(String(seed ?? ''), 10);
      if (!Number.isFinite(n)) return;

      // If the seed changes, any previously persisted preview plan becomes stale
      // (it was generated with a different seed). Clear it so Preview recomputes.
      try {
        const prev = getSeedForScenario(scenarioName);
        if (prev !== null && prev !== undefined) {
          const prevN = parseInt(String(prev), 10);
          if (Number.isFinite(prevN) && prevN > 0 && prevN !== n) {
            setPreviewPlanPathForScenario(scenarioName, '');
          }
        }
      } catch (e) {}

      const map = readSeedMap();
      const next = (map && typeof map === 'object') ? map : {};
      next[key] = {
        scenario: (scenarioName || '').toString().trim(),
        seed: n,
        updated_at: Date.now(),
      };
      localStorage.setItem(SEED_BY_SCENARIO_STORAGE_KEY, JSON.stringify(next));
    } catch (e) {}
  }

  function getLatestXmlPathForScenario(scenarioName){
    try {
      const key = normalizeScenarioKey(scenarioName);
      if (!key) return '';
      const map = readLatestXmlMap();
      const entry = (map && typeof map === 'object') ? map[key] : null;
      const path = entry && typeof entry === 'object' ? (entry.xml_path || entry.xmlPath || '') : '';
      return (path || '').toString().trim();
    } catch (e) {
      return '';
    }
  }

  function setLatestXmlPathForScenario(scenarioName, xmlPath){
    try {
      const key = normalizeScenarioKey(scenarioName);
      const path = (xmlPath || '').toString().trim();
      if (!key || !path) return;
      const map = readLatestXmlMap();
      const next = (map && typeof map === 'object') ? map : {};
      next[key] = {
        scenario: (scenarioName || '').toString().trim(),
        xml_path: path,
        updated_at: Date.now(),
      };
      localStorage.setItem(LATEST_XML_BY_SCENARIO_STORAGE_KEY, JSON.stringify(next));
    } catch (e) {}
  }

  function pickBestLocalSnapshotByScenarioCount(snapshotMap){
    try {
      if (!snapshotMap || typeof snapshotMap !== 'object') return null;
      let best = null;
      let bestCount = 0;
      Object.keys(snapshotMap).forEach(key => {
        const entry = snapshotMap[key];
        const scenarios = Array.isArray(entry?.scenarios) ? entry.scenarios : null;
        if (!scenarios || !scenarios.length) return;
        if (scenarios.length > bestCount) {
          bestCount = scenarios.length;
          best = entry;
        }
      });
      return best;
    } catch (e) {
      return null;
    }
  }

  function resolveScenarioNameHint(){
    try {
      const params = new URLSearchParams(window.location.search || '');
      const qp = (params.get('scenario') || '').trim();
      if (qp) return qp;
    } catch (e) {}
    try {
      const hidden = document.getElementById('scenariosPreviewScenario');
      const val = (hidden && typeof hidden.value === 'string') ? hidden.value.trim() : '';
      if (val) return val;
    } catch (e) {}
    return '';
  }

  function getCurrentProjectSnapshot(){
    const projectStateMap = readJsonFromLocalStorage(PROJECT_STATE_STORAGE_KEY, {});
    const key = (localStorage.getItem(LAST_PROJECT_KEY_STORAGE_KEY) || '').trim();
    if (key && projectStateMap && typeof projectStateMap === 'object' && projectStateMap[key]) {
      return projectStateMap[key];
    }
    return pickBestLocalSnapshotByScenarioCount(projectStateMap);
  }

  function resolveActiveScenarioFromSnapshot(snapshot){
    const scenarios = Array.isArray(snapshot?.scenarios) ? snapshot.scenarios : [];
    if (!scenarios.length) return null;

    const hint = resolveScenarioNameHint();
    if (hint) {
      const normHint = hint.toLowerCase();
      const found = scenarios.find(s => (s?.name ?? '').toString().trim().toLowerCase() === normHint);
      if (found) return found;
    }

    let idx = Number.isInteger(snapshot?.active_index) ? snapshot.active_index : null;
    if (!Number.isInteger(idx)) {
      try {
        const key = (localStorage.getItem(LAST_PROJECT_KEY_STORAGE_KEY) || '').trim();
        const idxMap = readJsonFromLocalStorage(PROJECT_ACTIVE_IDX_STORAGE_KEY, {});
        const mapped = (idxMap && typeof idxMap === 'object' && key) ? idxMap[key] : null;
        if (Number.isInteger(mapped)) idx = mapped;
      } catch (e) {}
    }
    if (!Number.isInteger(idx)) {
      const raw = (localStorage.getItem('coretg_active_idx') || '').trim();
      const parsed = parseInt(raw || '0', 10);
      idx = Number.isNaN(parsed) ? 0 : parsed;
    }
    idx = Math.min(Math.max(0, idx || 0), scenarios.length - 1);
    return scenarios[idx] || scenarios[0] || null;
  }

  function isScenarioCoreVmVerifiedForProject(scenario){
    try {
      if (!scenario || typeof scenario !== 'object') return false;
      const hitl = (scenario.hitl && typeof scenario.hitl === 'object') ? scenario.hitl : {};
      const prox = (hitl.proxmox && typeof hitl.proxmox === 'object') ? hitl.proxmox : {};
      const core = (hitl.core && typeof hitl.core === 'object') ? hitl.core : {};
      const vmKey = (core?.vm_key ?? '').toString().trim();
      const proxSecretId = (prox?.secret_id ?? '').toString().trim();
      const coreSecretId = (core?.core_secret_id ?? core?.secret_id ?? '').toString().trim();
      const proxValidated = !!prox?.validated;
      const coreValidated = !!core?.validated;
      return !!(vmKey && proxSecretId && coreSecretId && proxValidated && coreValidated);
    } catch (e) {
      return false;
    }
  }

  function refreshScenariosExecuteButtonState(){
    const btn = document.getElementById('scenariosExecuteBtn');
    if (!btn) return;
    // Preview is always available; CORE VM verification is only required for execution.
    btn.disabled = false;
    btn.removeAttribute('title');
  }

  const FLOW_STATE_STORAGE_KEY = 'coretg_flow_state_by_scenario_v1';

  function normalizeScenarioKey(raw){
    try {
      return (raw || '').toString().trim().toLowerCase().replace(/\s+/g, ' ');
    } catch (e) {
      return '';
    }
  }

  function setLastSelectedScenario(scenarioName){
    try {
      const s = (scenarioName || '').toString().trim();
      if (!s) return;
      localStorage.setItem(LAST_SELECTED_SCENARIO_STORAGE_KEY, s);
    } catch (e) {}
  }

  function getLastSelectedScenario(){
    try {
      const s = (localStorage.getItem(LAST_SELECTED_SCENARIO_STORAGE_KEY) || '').toString().trim();
      return s;
    } catch (e) {
      return '';
    }
  }

  function resolveScenarioNameFromUrlOrHidden(){
    try {
      const params = new URLSearchParams(window.location.search || '');
      const qp = (params.get('scenario') || '').trim();
      if (qp) return qp;
    } catch (e) {}
    try {
      const hidden = document.getElementById('scenariosPreviewScenario');
      const val = (hidden && typeof hidden.value === 'string') ? hidden.value.trim() : '';
      if (val) return val;
    } catch (e) {}
    return '';
  }

  function syncScenarioTabLinks(scenarioName){
    try {
      const scen = (scenarioName || '').toString().trim();
      let xmlPath = '';
      try {
        if (scen && typeof getLatestXmlPathForScenario === 'function') {
          xmlPath = (getLatestXmlPathForScenario(scen) || '').toString().trim();
        }
      } catch (e) { xmlPath = ''; }

      // Keep shared hidden field in sync for Preview handoff logic.
      try {
        const hidden = document.getElementById('scenariosPreviewScenario');
        if (hidden) hidden.value = scen;
      } catch (e) {}

      // Update all scenario sub-tab links to carry the active scenario.
      const links = document.querySelectorAll('ul.nav.nav-tabs a.nav-link');
      links.forEach(a => {
        try {
          const href = a.getAttribute('href') || '';
          if (!href || href === '#') return;
          const url = new URL(href, window.location.origin);
          if (scen) url.searchParams.set('scenario', scen);
          else url.searchParams.delete('scenario');
          if (xmlPath && (url.pathname.includes('/scenarios/flag-sequencing') || url.pathname.includes('/scenarios/preview'))){
            url.searchParams.set('xml_path', xmlPath);
          } else if (url.pathname.includes('/scenarios/flag-sequencing') || url.pathname.includes('/scenarios/preview')) {
            url.searchParams.delete('xml_path');
          }
          const next = url.pathname + (url.search ? url.search : '') + (url.hash || '');
          a.setAttribute('href', next);
        } catch (e) {
          // ignore
        }
      });
    } catch (e) {}
  }

  function ensureScenarioPersistedAndTabsSynced(){
    try {
      const scen = resolveScenarioNameFromUrlOrHidden() || getLastSelectedScenario();
      if (scen) setLastSelectedScenario(scen);
      syncScenarioTabLinks(scen);
    } catch (e) {}
  }

  function readFlowStateMap(){
    return readJsonFromLocalStorage(FLOW_STATE_STORAGE_KEY, {});
  }

  function getSavedFlowStateForScenario(scenarioName){
    try {
      const key = normalizeScenarioKey(scenarioName);
      if (!key) return null;
      const map = readFlowStateMap();
      const entry = (map && typeof map === 'object') ? map[key] : null;
      if (!entry || typeof entry !== 'object') return null;
      const scenario = (entry.scenario || scenarioName || '').toString();
      const preset = (entry.preset || '').toString();
      const length = Number.isFinite(+entry.length) ? (+entry.length) : null;
      const chain_ids = Array.isArray(entry.chain_ids) ? entry.chain_ids.map(x => String(x || '').trim()).filter(Boolean) : [];
      if (!chain_ids.length) return null;
      const flag_assignments = Array.isArray(entry.flag_assignments) ? entry.flag_assignments : null;
      const allow_node_duplicates = !!entry.allow_node_duplicates;
      const initial_facts = entry.initial_facts || null;
      const goal_facts = entry.goal_facts || null;
      return {
        scenario,
        preset,
        length: length || chain_ids.length,
        chain_ids,
        flag_assignments,
        allow_node_duplicates,
        initial_facts,
        goal_facts,
      };
    } catch (e) {
      return null;
    }
  }

  function setSavedFlowStateForScenario(scenarioName, state){
    try {
      const key = normalizeScenarioKey(scenarioName);
      if (!key) return;
      const map = readFlowStateMap();
      const next = (map && typeof map === 'object') ? map : {};
      const s = (state && typeof state === 'object') ? state : {};
      next[key] = {
        scenario: (scenarioName || '').toString().trim(),
        preset: (s.preset || '').toString(),
        length: Number.isFinite(+s.length) ? (+s.length) : null,
        chain_ids: Array.isArray(s.chain_ids) ? s.chain_ids.map(x => String(x || '').trim()).filter(Boolean) : [],
        flag_assignments: Array.isArray(s.flag_assignments) ? s.flag_assignments : null,
        allow_node_duplicates: !!s.allow_node_duplicates,
        initial_facts: s.initial_facts || null,
        goal_facts: s.goal_facts || null,
        updated_at: Date.now(),
      };
      localStorage.setItem(FLOW_STATE_STORAGE_KEY, JSON.stringify(next));
    } catch (e) {}
  }

  async function postJson(url, payload){
    const res = await fetch(url, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      credentials: 'same-origin',
      body: JSON.stringify(payload || {}),
    });
    let data = null;
    try { data = await res.json(); } catch (e) { data = null; }
    if (!res.ok) {
      const msg = (data && data.error) ? String(data.error) : ('HTTP ' + res.status);
      throw new Error(msg);
    }
    if (data && data.ok === false) {
      throw new Error(String(data.error || 'Request failed'));
    }
    return data;
  }

  function resolveScenarioNameForSave(){
    try {
      if (window.state && Array.isArray(window.state.scenarios)) {
        const idx = (typeof window.state.active_index === 'number') ? window.state.active_index : 0;
        const sc = window.state.scenarios[idx] || window.state.scenarios[0];
        const nm = (sc && sc.name) ? String(sc.name).trim() : '';
        if (nm) return nm;
      }
    } catch (e) {}
    try {
      const snap = getCurrentProjectSnapshot();
      const active = resolveActiveScenarioFromSnapshot(snap);
      const nm = (active && active.name) ? String(active.name).trim() : '';
      if (nm) return nm;
    } catch (e) {}
    return resolveScenarioNameHint();
  }

  function buildSaveXmlApiPayload(){
    // Prefer in-memory editor state when present (Topology page), else fall back to local snapshot.
    try {
      if (window.state && Array.isArray(window.state.scenarios) && window.state.scenarios.length) {
        const active_index = (typeof window.state.active_index === 'number') ? window.state.active_index : 0;

        // Topology UX: when the user saves, freeze any visible "Random" dropdowns into
        // deterministic concrete values and re-render so the UI reflects what was saved.
        try {
          if (typeof window.concretizeRandomSelectionsForSave === 'function') {
            window.state.scenarios = window.concretizeRandomSelectionsForSave(window.state.scenarios);
            try {
              const hidden = document.getElementById('scenarios_json');
              if (hidden) hidden.value = JSON.stringify({ scenarios: window.state.scenarios, active_index });
            } catch (e) {}
            try {
              const n = Number(window.__coretg_last_concretize_count || 0);
              if (n > 0 && typeof window.showToast === 'function') {
                let msg = '';
                try {
                  if (typeof window.formatConcretizeSummaryToast === 'function') {
                    msg = window.formatConcretizeSummaryToast(window.__coretg_last_concretize_summary || null);
                  }
                } catch (e) { msg = ''; }
                if (!msg) msg = `Resolved ${n} Random value${n === 1 ? '' : 's'} on save.`;
                try { window.showToast(msg, { force: true, autohide: true, delay: 4200 }); } catch (_) {}
              }
            } catch (e) {}
            try {
              if (typeof window.renderMain === 'function') window.renderMain();
              else if (typeof window.render === 'function') window.render();
            } catch (e) {}
          }
        } catch (e) {}

        const core = (typeof window.getCoreConfig === 'function') ? window.getCoreConfig(true) : (window.state.core || null);
        const project_key_hint = (window.currentProjectKey || '').toString().trim();
        const scenario_query = (typeof window.resolveScenarioQueryHint === 'function') ? window.resolveScenarioQueryHint() : '';
        const scenariosOut = Array.isArray(window.state.scenarios) ? window.state.scenarios.map(s => (s && typeof s === 'object') ? s : {}) : [];
        try {
          if (typeof window.coretgGetSavedFlowStateForScenario === 'function') {
            scenariosOut.forEach((sc) => {
              const nm = (sc && sc.name) ? String(sc.name).trim() : '';
              if(!nm) return;
              const flowState = window.coretgGetSavedFlowStateForScenario(nm);
              if(flowState) sc.flow_state = flowState;
            });
          }
        } catch (e) {}
        return {
          scenarios: scenariosOut,
          core: core,
          active_index,
          project_key_hint,
          scenario_query,
        };
      }
    } catch (e) {}

    const snap = getCurrentProjectSnapshot();
    const scenarios = Array.isArray(snap?.scenarios) ? snap.scenarios.map(s => (s && typeof s === 'object') ? s : {}) : [];
    try {
      if (typeof window.coretgGetSavedFlowStateForScenario === 'function') {
        scenarios.forEach((sc) => {
          const nm = (sc && sc.name) ? String(sc.name).trim() : '';
          if(!nm) return;
          const flowState = window.coretgGetSavedFlowStateForScenario(nm);
          if(flowState) sc.flow_state = flowState;
        });
      }
    } catch (e) {}
    const core = (snap && typeof snap === 'object') ? (snap.core || null) : null;
    const active_index = Number.isInteger(snap?.active_index) ? snap.active_index : null;
    const project_key_hint = (snap && typeof snap === 'object' && snap.project_key_hint) ? String(snap.project_key_hint) : '';
    const scenario_query = (snap && typeof snap === 'object' && snap.scenario_query) ? String(snap.scenario_query) : '';
    return { scenarios, core, active_index, project_key_hint, scenario_query };
  }

  function buildTopologySignature(payload){
    try {
      if (!payload || typeof payload !== 'object') return null;
      const cloned = JSON.parse(JSON.stringify(payload));
      if (cloned && Array.isArray(cloned.scenarios)) {
        cloned.scenarios.forEach((sc) => {
          if (!sc || typeof sc !== 'object') return;
          try { delete sc.flow_state; } catch (e) {}
          try { delete sc.plan_preview; } catch (e) {}
          try { delete sc.planPreview; } catch (e) {}
          try { delete sc.preview_plan; } catch (e) {}
          try { delete sc.previewPlan; } catch (e) {}
          try { delete sc.preview_plan_path; } catch (e) {}
          try { delete sc.previewPlanPath; } catch (e) {}
          try { delete sc.full_preview; } catch (e) {}
          try { delete sc.fullPreview; } catch (e) {}
          try { delete sc.preview; } catch (e) {}
        });
      }
      return JSON.stringify({
        scenarios: cloned.scenarios || [],
        core: cloned.core || null,
        active_index: cloned.active_index ?? null,
      });
    } catch (e) {
      return null;
    }
  }

  async function saveXmlViaApi(opts){
    const options = (opts && typeof opts === 'object') ? opts : {};
    const persistPreviewPlan = (options.persistPreviewPlan !== false) && (options.skipPreviewPlan !== true);
    let progressShown = false;
    let hideTimer = null;
    const logInfoSafe = (msg) => {
      try {
        if (typeof window.logInfo === 'function') window.logInfo(msg);
        else if (typeof logInfo === 'function') logInfo(msg);
      } catch (e) {}
    };
    const logWarnSafe = (msg) => {
      try {
        if (typeof window.logWarn === 'function') window.logWarn(msg);
        else if (typeof logWarn === 'function') logWarn(msg);
      } catch (e) {}
    };
    const isAutosaveXmlPath = (value) => {
      if (!value || typeof value !== 'string') return false;
      const normalized = value.replace(/\\/g, '/');
      return normalized.includes('/outputs/autosave/') || /\bautosave[-_]/i.test(normalized);
    };
    const applyScenarioSavedPaths = (pathMap) => {
      try {
        if (!pathMap || !window.state || !Array.isArray(window.state.scenarios)) return;
        const scenarios = window.state.scenarios;
        if (Array.isArray(pathMap)) {
          window.state.saved_xml_paths_by_index = pathMap.slice();
          scenarios.forEach((scen, idx) => {
            if (!scen || typeof scen !== 'object') return;
            const path = (pathMap[idx] || '').toString().trim();
            if (!path || !path.endsWith('.xml') || isAutosaveXmlPath(path)) return;
            scen.saved_xml_path = path;
          });
          return;
        }
        if (typeof pathMap !== 'object') return;
        const lookup = new Map();
        Object.entries(pathMap).forEach(([key, val]) => {
          const nameKey = normalizeScenarioKey(key || '');
          const path = (typeof val === 'string') ? val.trim() : '';
          if (nameKey && path && path.endsWith('.xml') && !isAutosaveXmlPath(path)) {
            lookup.set(nameKey, path);
          }
        });
        if (!lookup.size) return;
        const indexPaths = Array.isArray(window.state.saved_xml_paths_by_index)
          ? window.state.saved_xml_paths_by_index.slice()
          : [];
        scenarios.forEach((scen, idx) => {
          if (!scen || typeof scen !== 'object') return;
          const nameKey = normalizeScenarioKey(scen.name || '');
          if (!nameKey || !lookup.has(nameKey)) return;
          const path = lookup.get(nameKey);
          scen.saved_xml_path = path;
          indexPaths[idx] = path;
        });
        if (indexPaths.length) {
          window.state.saved_xml_paths_by_index = indexPaths;
        }
      } catch (e) {}
    };
    const safeHideProgress = (immediate) => {
      try {
        if (!progressShown || typeof window.coretgHideProgress !== 'function') return;
        if (hideTimer !== null) {
          try { clearTimeout(hideTimer); } catch (e) {}
          hideTimer = null;
        }
        if (immediate) window.coretgHideProgress();
        else hideTimer = setTimeout(() => { try { window.coretgHideProgress(); } catch (e) {} }, 250);
      } catch (e) {}
    };

    try {
      if (typeof window.coretgShowProgress === 'function') {
        window.coretgShowProgress({ title: 'Saving XML', message: 'Preparing…', percent: 2 });
        progressShown = true;
      }
    } catch (e) {}

    try {

    try {
      const scen = resolveScenarioNameForSave();
      logInfoSafe(`[xml-save] Save requested via API${scen ? ` (scenario: ${scen})` : ''}`);
    } catch (e) {}
    try {
      if (typeof window.refreshXmlDockPreview === 'function') {
        window.refreshXmlDockPreview({ force: true, preferSavedPath: true, awaitReady: true, reason: 'save-start' });
      }
    } catch (e) {}

    // If we're on the Topology page, we can concretize directly against live in-memory state.
    try {
      if (window.state && Array.isArray(window.state.scenarios) && window.state.scenarios.length) {
        const active_index = (typeof window.state.active_index === 'number') ? window.state.active_index
          : ((typeof window.state.active_index === 'string') ? parseInt(window.state.active_index, 10) : null);
        const idx = Number.isInteger(active_index) ? active_index : ((typeof window.state.activeIdx === 'number') ? window.state.activeIdx : 0);

        try {
          if (typeof window.coretgUpdateProgress === 'function') {
            window.coretgUpdateProgress({ title: 'Saving XML', message: 'Freezing Random values…', percent: 10 });
          }
        } catch (e) {}

        // Progress hook: allow index.html async concretization to report vuln readiness progress.
        try {
          window.__coretg_progress_hook = function(p){
            try {
              if (typeof window.coretgUpdateProgress !== 'function') return;
              const percent = (p && Number.isFinite(+p.percent)) ? (+p.percent) : null;
              const message = (p && typeof p.message === 'string' && p.message) ? p.message : 'Working…';
              window.coretgUpdateProgress({ title: 'Saving XML', message, percent: (percent === null ? 20 : percent) });
            } catch (e) {}
          };
        } catch (e) {}

        try {
          if (typeof window.concretizeRandomSelectionsForSaveAsync === 'function') {
            window.state.scenarios = await window.concretizeRandomSelectionsForSaveAsync(window.state.scenarios);
          } else if (typeof window.concretizeRandomSelectionsForSave === 'function') {
            window.state.scenarios = window.concretizeRandomSelectionsForSave(window.state.scenarios);
          }
        } finally {
          try { delete window.__coretg_progress_hook; } catch (e) { window.__coretg_progress_hook = null; }
        }

        try {
          if (typeof window.coretgUpdateProgress === 'function') {
            window.coretgUpdateProgress({ title: 'Saving XML', message: 'Updating UI…', percent: 82 });
          }
        } catch (e) {}

        try {
          const hidden = document.getElementById('scenarios_json');
          if (hidden) hidden.value = JSON.stringify({ scenarios: window.state.scenarios, active_index: idx });
        } catch (e) {}

        try {
          if (typeof window.renderMain === 'function') window.renderMain();
          else if (typeof window.render === 'function') window.render();
        } catch (e) {}

        try {
          const sum = window.__coretg_last_concretize_summary || null;
          const n = Number(window.__coretg_last_concretize_count || 0);
          const warns = (sum && Array.isArray(sum.warnings)) ? sum.warnings : [];
          if ((n > 0 || warns.length) && typeof window.showToast === 'function') {
            let msg = '';
            try {
              if (typeof window.formatConcretizeSummaryToast === 'function') {
                msg = window.formatConcretizeSummaryToast(sum);
              }
            } catch (e) { msg = ''; }
            if (!msg && n > 0) msg = `Resolved ${n} Random value${n === 1 ? '' : 's'} on save.`;
            if (!msg && warns.length) msg = warns.slice(0, 2).join('\n');
            if (msg) {
              try { window.showToast(msg, { force: true, autohide: true, delay: 5200 }); } catch (_) {}
            }
          }
        } catch (e) {}
      }
    } catch (e) {}

    const payload = buildSaveXmlApiPayload();
    const scenarioNameForSig = resolveScenarioNameForSave();
    const topologySignature = buildTopologySignature(payload);
    let topologyChanged = null;
    try {
      if (typeof previewState !== 'undefined' && previewState && typeof previewState.dirty === 'boolean') {
        topologyChanged = !!previewState.dirty;
      }
    } catch (e) {}
    if (topologyChanged === null) {
      try {
        const prevSig = scenarioNameForSig ? getTopologySignatureForScenario(scenarioNameForSig) : null;
        if (prevSig && topologySignature) {
          topologyChanged = prevSig !== topologySignature;
        } else {
          topologyChanged = false;
        }
      } catch (e) { topologyChanged = false; }
    }
    if (!Array.isArray(payload.scenarios) || !payload.scenarios.length) {
      throw new Error('No scenarios available to save.');
    }

    try {
      if (typeof window.coretgUpdateProgress === 'function') {
        window.coretgUpdateProgress({ title: 'Saving XML', message: 'Writing XML snapshot…', percent: 88 });
      }
    } catch (e) {}
    const data = await postJson('/save_xml_api', payload);
    const xmlPath = (data && data.result_path) ? String(data.result_path) : '';
    if (!xmlPath) throw new Error('Save succeeded but returned no result_path.');

    try { logInfoSafe(`[xml-save] save_xml_api ok; result_path=${xmlPath}`); } catch (e) {}
    if (data && data.scenario_paths_by_index) {
      try { applyScenarioSavedPaths(data.scenario_paths_by_index); } catch (e) {}
      try { logInfoSafe('[xml-save] Applied per-scenario saved XML paths (by index)'); } catch (e) {}
    }
    if (data && data.scenario_paths) {
      try { applyScenarioSavedPaths(data.scenario_paths); } catch (e) {}
      try { logInfoSafe('[xml-save] Applied per-scenario saved XML paths (by name)'); } catch (e) {}
    }

    // Remember the latest saved XML path for this scenario so other tabs (Preview/Flow)
    // can refer to the same snapshot.
    try {
      const scenarioName = resolveScenarioNameForSave();
      if (scenarioName) {
        setLatestXmlPathForScenario(scenarioName, xmlPath);
        try { syncScenarioTabLinks(scenarioName); } catch (e) {}
      }
    } catch (e) {}

    // Topology workflow: after saving from Topology, turn the fixed "Preview" button into "Continue"
    // and have it navigate to Flag Sequencing.
    try {
      const activeTab = getActiveTabName();
      if (activeTab === 'topology') {
        const scenarioName = resolveScenarioNameForSave();
        if (scenarioName) {
          rememberContinueAfterSave(scenarioName);
          setFixedPreviewButtonMode('continue', scenarioName);
        }
      }
    } catch (e) {}

    // Preserve a stable per-scenario seed across saves so Preview/Flow do not "re-roll"
    // just because the XML path changes.
    try {
      const scenarioName = resolveScenarioNameForSave();
      if (scenarioName) ensureSeedForScenario(scenarioName);
    } catch (e) {}

    if (persistPreviewPlan) {
      // Always persist a fresh flow plan after Save XML so Preview/Flow stay aligned
      // and cannot display stale cached results from an older XML snapshot.
      try {
        try {
          if (typeof window.coretgUpdateProgress === 'function') {
            window.coretgUpdateProgress({ title: 'Saving XML', message: 'Persisting flow plan…', percent: 95 });
          }
        } catch (e) {}
        const scenarioName = resolveScenarioNameForSave();
        const postFn = (typeof window.coretgPostJson === 'function') ? window.coretgPostJson : postJson;
        if (scenarioName && typeof postFn === 'function') {
          let seed = null;
          try {
            if (typeof window.coretgGetSeedForScenario === 'function') {
              seed = window.coretgGetSeedForScenario(scenarioName);
            }
          } catch (e) { seed = null; }

          const persisted = await postFn('/api/plan/persist_flow_plan', {
            xml_path: xmlPath,
            scenario: scenarioName,
            seed,
          });

          try {
            if (persisted && persisted.seed !== undefined && typeof window.coretgSetSeedForScenario === 'function') {
              window.coretgSetSeedForScenario(scenarioName, persisted.seed);
            }
          } catch (e) {}

          const previewPlan = (persisted && persisted.preview_plan_path) ? String(persisted.preview_plan_path) : '';
          if (typeof window.coretgSetPreviewPlanPathForScenario === 'function') {
            window.coretgSetPreviewPlanPathForScenario(scenarioName, previewPlan);
          }
          try { logInfoSafe(`[xml-save] Persisted flow plan for scenario ${scenarioName}`); } catch (e) {}
        } else {
          try { logWarnSafe('[xml-save] Skipped flow plan persistence (scenario or postJson unavailable)'); } catch (e) {}
        }
      } catch (e) {
        // Best-effort: if flow-plan persistence failed, clear any stored plan path so
        // Preview will fall back to re-rendering from the latest XML path.
        try {
          const scenarioName = resolveScenarioNameForSave();
          if (scenarioName && typeof window.coretgSetPreviewPlanPathForScenario === 'function') {
            window.coretgSetPreviewPlanPathForScenario(scenarioName, '');
          }
        } catch (_) {}
      }
    }

    // If a saved Flag Sequencing chain exists, persist it against the latest preview plan.
    try {
      const scenarioName = resolveScenarioNameForSave();
      const flowState = (scenarioName && typeof window.coretgGetSavedFlowStateForScenario === 'function')
        ? window.coretgGetSavedFlowStateForScenario(scenarioName)
        : null;
      if (scenarioName && flowState && Array.isArray(flowState.chain_ids) && flowState.chain_ids.length) {
        const chain_ids = flowState.chain_ids;
        const flag_assignments = Array.isArray(flowState.flag_assignments) ? flowState.flag_assignments : null;
        const fallback_assignments = !flag_assignments ? chain_ids.map((nid) => ({ node_id: String(nid || ''), id: '' })) : null;
        const previewPlan = (typeof window.coretgGetPreviewPlanPathForScenario === 'function')
          ? window.coretgGetPreviewPlanPathForScenario(scenarioName)
          : '';
        if ((flag_assignments || fallback_assignments) && previewPlan && typeof window.coretgPostJson === 'function') {
          await window.coretgPostJson('/api/flag-sequencing/save_flow_substitutions', {
            scenario: scenarioName,
            chain_ids,
            preview_plan: previewPlan,
            flag_assignments: flag_assignments || fallback_assignments,
            allow_node_duplicates: !!flowState.allow_node_duplicates,
            initial_facts: flowState.initial_facts || null,
            goal_facts: flowState.goal_facts || null,
          });
          try {
            if (typeof window.coretgSetFlowDirtyForScenario === 'function') {
              window.coretgSetFlowDirtyForScenario(scenarioName, false);
            }
          } catch (_) {}
        }
      }
    } catch (e) {}

    // If a saved Flag Sequencing chain exists for this scenario, changing and saving
    // topology/VM settings can make the chain stale. Mark it dirty so Preview can
    // warn before showing potentially confusing results.
    try {
      const scenarioName = resolveScenarioNameForSave();
      const onFlowPage = String(window.location.pathname || '').includes('/scenarios/flag-sequencing');
      if (scenarioName && !onFlowPage) {
        const flowState = (typeof window.coretgGetSavedFlowStateForScenario === 'function')
          ? window.coretgGetSavedFlowStateForScenario(scenarioName)
          : null;
        if (flowState && typeof flowState === 'object' && topologyChanged === true) {
          setFlowDirtyForScenario(scenarioName, true, 'topology_saved_after_flow', xmlPath);
        }
      }
    } catch (e) {}

    // Record the latest topology signature for this scenario.
    try {
      const scenarioName = resolveScenarioNameForSave();
      if (scenarioName && topologySignature) {
        setTopologySignatureForScenario(scenarioName, topologySignature);
      }
    } catch (e) {}

    // If the Topology page state is present, keep it in sync.
    try {
      if (window.state && typeof window.state === 'object') {
        window.state.result_path = xmlPath;
      }
    } catch (e) {}

    // Topology page: ensure Full Preview / Plan buttons re-evaluate after saving.
    try {
      if (typeof window.updatePlanButtons === 'function') {
        window.updatePlanButtons();
      } else if (typeof updatePlanButtons === 'function') {
        updatePlanButtons();
      }
    } catch (e) {}

    try {
      const xmlPathInput = document.getElementById('scenariosPreviewXmlPath');
      if (xmlPathInput) xmlPathInput.value = xmlPath;
    } catch (e) {}
    try {
      const dl = document.getElementById('downloadXmlBtn');
      if (dl) {
        dl.disabled = false;
        dl.removeAttribute('title');
      }
    } catch (e) {}
    try {
      if (typeof window.coretgUpdateProgress === 'function') {
        window.coretgUpdateProgress({ title: 'Saving XML', message: 'Done.', percent: 100 });
      }
    } catch (e) {}
    try {
      if (typeof window.refreshXmlDockPreview === 'function') {
        window.refreshXmlDockPreview({ force: true, preferSavedPath: true, reason: 'save-complete' });
      }
    } catch (e) {}
    safeHideProgress(false);
    return xmlPath;
    } catch (err) {
      try { logWarnSafe(`[xml-save] Save failed: ${err?.message || err}`); } catch (e) {}
      safeHideProgress(true);
      throw err;
    }
  }

  async function saveAllAndGoPreview(opts){
    const options = (opts && typeof opts === 'object') ? opts : {};
    const xmlPath = await saveXmlViaApi();
    const scenario = (options.scenarioOverride || '').toString().trim() || resolveScenarioNameForSave();

    // If Flow is dirty, steer the user to Flag Sequencing to review/update first.
    try {
      if (scenario && isFlowDirtyForScenario(scenario)) {
        const msg = 'Topology was saved after a Flag Sequencing chain was created for this scenario.\n\nOpen Flag Sequencing to review/update the chain before Preview?';
        const goFlow = confirm(msg);
        if (goFlow) {
          window.location.href = '/scenarios/flag-sequencing?scenario=' + encodeURIComponent(scenario);
          return;
        }
      }
    } catch (e) {}

    const baseUrl = String(document.getElementById('scenariosPreviewTabLink')?.dataset?.previewBaseUrl || '/scenarios/preview');
    const url = baseUrl + '?xml_path=' + encodeURIComponent(xmlPath) + (scenario ? ('&scenario=' + encodeURIComponent(scenario)) : '');
    window.location.href = url;
  }

  window.coretgPostJson = postJson;
  window.coretgSaveXmlViaApi = saveXmlViaApi;
  window.coretgSaveAllAndGoPreview = saveAllAndGoPreview;
  window.coretgGetSavedFlowStateForScenario = getSavedFlowStateForScenario;
  window.coretgSetSavedFlowStateForScenario = setSavedFlowStateForScenario;
  window.coretgGetLatestXmlPathForScenario = getLatestXmlPathForScenario;
  window.coretgSetLatestXmlPathForScenario = setLatestXmlPathForScenario;
  window.coretgGetSeedForScenario = getSeedForScenario;
  window.coretgEnsureSeedForScenario = ensureSeedForScenario;
  window.coretgSetSeedForScenario = setSeedForScenario;
  window.coretgGetPreviewPlanPathForScenario = getPreviewPlanPathForScenario;
  window.coretgSetPreviewPlanPathForScenario = setPreviewPlanPathForScenario;
  window.coretgIsFlowDirtyForScenario = isFlowDirtyForScenario;
  window.coretgSetFlowDirtyForScenario = setFlowDirtyForScenario;

  // Cross-page scenario persistence helpers.
  window.coretgSetLastSelectedScenario = setLastSelectedScenario;
  window.coretgGetLastSelectedScenario = getLastSelectedScenario;
  window.coretgSyncScenarioTabLinks = syncScenarioTabLinks;
  window.coretgSetActiveScenarioForNav = function(scenarioName){
    try {
      const scen = (scenarioName || '').toString().trim();
      if (scen) setLastSelectedScenario(scen);
      syncScenarioTabLinks(scen);
    } catch (e) {}
  };

  window.coretgRefreshScenariosExecuteButtonState = refreshScenariosExecuteButtonState;
  document.addEventListener('DOMContentLoaded', refreshScenariosExecuteButtonState);
  document.addEventListener('DOMContentLoaded', ensureScenarioPersistedAndTabsSynced);
  window.addEventListener('storage', (ev) => {
    try {
      if (!ev || !ev.key) return;
      if (ev.key === PROJECT_STATE_STORAGE_KEY || ev.key === LAST_PROJECT_KEY_STORAGE_KEY || ev.key === PROJECT_ACTIVE_IDX_STORAGE_KEY) {
        refreshScenariosExecuteButtonState();
      }
    } catch (e) {}
  });
})();
</script>
