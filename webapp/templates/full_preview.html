{% extends 'layout.html' %}
{% block title %}Full Preview{% endblock %}
{% block active_page %}{% set active_page = 'scenarios' %}{% endblock %}
{% block content %}
<div class="container-fluid mt-3">
  {% macro render_r2r_interfaces(router_id, links) -%}
    {% set ns = namespace(items=[]) %}
    {% for link in links or [] %}
      {% set routers = link.routers or [] %}
      {% if routers|length == 2 %}
        {% set a = routers[0] %}
        {% set b = routers[1] %}
        {% if a.id == router_id %}
          {% set neighbor = b.id %}
          {% set ip = a.ip or '-' %}
        {% elif b.id == router_id %}
          {% set neighbor = a.id %}
          {% set ip = b.ip or '-' %}
        {% else %}
          {% set neighbor = None %}
        {% endif %}
        {% if neighbor is not none %}
          {% set label = 'r' ~ neighbor %}
          {% if link.subnet %}
            {% set entry = label ~ ': ' ~ ip ~ ' [' ~ link.subnet ~ ']' %}
          {% else %}
            {% set entry = label ~ ': ' ~ ip %}
          {% endif %}
          {% set ns.items = ns.items + [entry] %}
        {% endif %}
      {% endif %}
    {% endfor %}
    {{ ns.items|join('; ') if ns.items else '-' }}
  {%- endmacro %}

  {% macro render_router_switch_links(router_id, switches) -%}
    {% set ns = namespace(items=[]) %}
    {% for sw in switches or [] %}
      {% if sw.router_id == router_id %}
        {% set label = 'sw-' ~ sw.switch_id %}
        {% if sw.router_ip and sw.rsw_subnet %}
          {% set entry = label ~ ': ' ~ sw.router_ip ~ ' [' ~ sw.rsw_subnet ~ ']' %}
        {% elif sw.router_ip %}
          {% set entry = label ~ ': ' ~ sw.router_ip %}
        {% else %}
          {% set entry = label %}
        {% endif %}
        {% set ns.items = ns.items + [entry] %}
      {% endif %}
    {% endfor %}
    {{ ns.items|join('; ') if ns.items else '-' }}
  {%- endmacro %}

  <div class="d-flex align-items-center mb-2 gap-2">
    <h2 class="me-auto mb-0">Full Preview {{ scenario or '' }}</h2>
  <button id="executeRunBtn" class="btn btn-sm btn-warning" title="Execute this scenario now (invokes CLI)" data-preview-plan="{{ preview_plan_path or '' }}">Execute</button>
    <form method="post" action="/plan/full_preview_page" class="d-flex align-items-center" id="rerollForm">
      <input type="hidden" name="xml_path" value="{{ xml_path }}" />
      {% if scenario %}<input type="hidden" name="scenario" value="{{ scenario }}" />{% endif %}
      <div class="input-group input-group-sm me-2" style="width:160px;">
        <span class="input-group-text">Seed</span>
        <input type="text" class="form-control" name="seed" value="" placeholder="random" />
      </div>
      <button class="btn btn-sm btn-outline-secondary" type="submit" title="Re-run preview with new / provided seed">Re-roll</button>
    </form>
  </div>
  <p class="text-muted">Current Seed: <strong>{{ seed }}</strong> | XML: {{ xml_path }}</p>
  <div class="mb-3">
    <button id="exportJsonBtn" class="btn btn-sm btn-outline-secondary me-2">Export JSON</button>
    <button id="exportPngBtn" class="btn btn-sm btn-outline-secondary me-2">Export Graph PNG</button>
    <!-- Approval workflow removed; button/status span deleted -->
  </div>
  <div class="row">
    <div class="col-md-4">
    {% set hitl_cfg = hitl_config or {} %}
    <h5>Overview</h5>
    <ul class="list-unstyled small">
  <li>Routers: {{ (full_preview.routers or [])|length }}</li>
  <li>Hosts: {{ (full_preview.hosts or [])|length }}</li>
  <li>Switches: {{ (full_preview.switches or [])|length }}</li>
  <li>R2R Edges: {{ (full_preview.r2r_edges_preview or [])|length }}</li>
  <li>Seg Rules: {{ (full_preview.segmentation_preview.rules or [])|length if full_preview.segmentation_preview and full_preview.segmentation_preview.rules else 0 }}</li>
  <li>HITL: {{ 'Enabled' if hitl_cfg.get('enabled') else 'Disabled' }}</li>
  <li>HITL Interfaces: {{ (hitl_cfg.get('interfaces') or [])|length }}</li>
      </ul>
      <div class="d-flex justify-content-between align-items-center mb-1">
        <h6 class="mb-0">R2R Policy</h6>
        <button class="btn btn-sm btn-outline-secondary" type="button" data-preview-collapse="fp-side-r2r" data-label-collapse="Collapse" data-label-expand="Expand">Collapse</button>
      </div>
      <div id="fp-side-r2r" class="collapse">
        <pre class="small bg-light p-2">{{ full_preview.r2r_policy_preview | tojson(indent=2) }}</pre>
      </div>
      <div class="d-flex justify-content-between align-items-center mb-1 mt-3">
        <h6 class="mb-0">R2S Policy</h6>
        <button class="btn btn-sm btn-outline-secondary" type="button" data-preview-collapse="fp-side-r2s" data-label-collapse="Collapse" data-label-expand="Expand">Collapse</button>
      </div>
      <div id="fp-side-r2s" class="collapse">
        <pre class="small bg-light p-2">{{ full_preview.r2s_policy_preview | tojson(indent=2) }}</pre>
      </div>
  <div class="d-flex justify-content-between align-items-center mb-1 mt-3">
    <h6 class="mb-0">Services Preview</h6>
    <button class="btn btn-sm btn-outline-secondary" type="button" data-preview-collapse="fp-side-services" data-label-collapse="Collapse" data-label-expand="Expand">Collapse</button>
  </div>
  <div id="fp-side-services" class="collapse">
    <pre class="small bg-light p-2">{{ full_preview.services_preview | tojson(indent=2) }}</pre>
  </div>
  <div class="d-flex justify-content-between align-items-center mb-1 mt-3">
    <h6 class="mb-0">Vulnerabilities Preview</h6>
    <button class="btn btn-sm btn-outline-secondary" type="button" data-preview-collapse="fp-side-vuln" data-label-collapse="Collapse" data-label-expand="Expand">Collapse</button>
  </div>
  <div id="fp-side-vuln" class="collapse">
  {% set vuln_prev = full_preview.vulnerabilities_preview or {} %}
    {% set vuln_by_node = full_preview.vulnerabilities_by_node or {} %}
  {% if vuln_prev %}
  <pre class="small bg-light p-2">{
{% set first = True %}
{% for k,v in vuln_prev.items() %}
{# '__density_pool__' legacy key no longer produced; conditional retained for backward safety #}
{% if k != '__density_pool__' %}{% if not first %},\n{% endif %}"{{ k }}": {{ v }}{% set first = False %}{% endif %}
{% endfor %}
{% if first %}"_note": "(none)"{% endif %}
}</pre>
  {% else %}<div class="small text-muted fst-italic">(none)</div>{% endif %}
  </div>
  {% if vuln_by_node %}
  <div class="d-flex justify-content-between align-items-center mb-1 mt-3">
    <h6 class="mb-0">Vulnerabilities by Host</h6>
    <button class="btn btn-sm btn-outline-secondary" type="button" data-preview-collapse="fp-side-vuln-host" data-label-collapse="Collapse" data-label-expand="Expand">Collapse</button>
  </div>
  <div id="fp-side-vuln-host" class="collapse">
    <pre class="small bg-light p-2">{{ vuln_by_node | tojson(indent=2) }}</pre>
  </div>
  {% endif %}
    </div>
    <div class="col-md-8">
      <ul class="nav nav-tabs" id="fpTabs" role="tablist">
        <li class="nav-item"><button class="nav-link active" data-bs-toggle="tab" data-bs-target="#fp-graph" type="button">Graph</button></li>
        <li class="nav-item"><button class="nav-link" data-bs-toggle="tab" data-bs-target="#fp-routers" type="button">Routers</button></li>
        <li class="nav-item"><button class="nav-link" data-bs-toggle="tab" data-bs-target="#fp-hosts" type="button">Hosts</button></li>
        <li class="nav-item"><button class="nav-link" data-bs-toggle="tab" data-bs-target="#fp-vulnerabilities" type="button">Vulnerabilities</button></li>
        <li class="nav-item"><button class="nav-link" data-bs-toggle="tab" data-bs-target="#fp-switches" type="button">Switches</button></li>
    <li class="nav-item"><button class="nav-link" data-bs-toggle="tab" data-bs-target="#fp-interfaces" type="button">Interfaces</button></li>
  <li class="nav-item"><button class="nav-link" data-bs-toggle="tab" data-bs-target="#fp-seg" type="button">Segmentation</button></li>
  <li class="nav-item"><button class="nav-link" data-bs-toggle="tab" data-bs-target="#fp-traffic" type="button">Traffic</button></li>
        <li class="nav-item"><button class="nav-link" data-bs-toggle="tab" data-bs-target="#fp-node-sections" type="button">Node Sections</button></li>
        <li class="nav-item"><button class="nav-link" data-bs-toggle="tab" data-bs-target="#fp-json" type="button">Raw JSON</button></li>
      </ul>
      <div class="tab-content border border-top-0 p-2" id="fpTabsContent" style="min-height:680px;">
        <div class="tab-pane fade show active position-relative" id="fp-graph">
          <div id="previewGraph" style="height:640px; position:relative; background:#fafafa; border:1px solid #e0e0e0; border-radius:4px; overflow:hidden;"></div>
          <div id="graphZoomControls" class="position-absolute" style="top:6px; right:8px; z-index:10;">
            <div class="btn-group btn-group-sm shadow-sm" role="group" aria-label="Zoom controls">
              <button type="button" class="btn btn-outline-secondary" id="zoomInBtn" title="Zoom In">+</button>
              <button type="button" class="btn btn-outline-secondary" id="zoomOutBtn" title="Zoom Out">−</button>
              <button type="button" class="btn btn-outline-secondary" id="zoomResetBtn" title="Reset View">Reset</button>
            </div>
          </div>
        </div>
  <div class="tab-pane fade" id="fp-routers">
          <div class="d-flex justify-content-between align-items-center mb-2">
            <h6 class="mb-0">Routers</h6>
            <button class="btn btn-sm btn-outline-secondary" type="button" data-preview-collapse="fp-routers-body" data-label-collapse="Collapse" data-label-expand="Expand">Collapse</button>
          </div>
          <div id="fp-routers-body" class="collapse">
            <table class="table table-sm table-striped small"><thead><tr><th>ID</th><th>Name</th><th>Primary IP</th><th>R2R Interfaces</th><th>Switch Links</th></tr></thead><tbody>
            {% for r in full_preview.routers %}<tr><td>{{ r.node_id }}</td><td>{{ r.name }}</td><td>{{ r.ip4 or '-' }}</td><td>{{ render_r2r_interfaces(r.node_id, full_preview.r2r_links_preview) }}</td><td>{{ render_router_switch_links(r.node_id, full_preview.switches_detail) }}</td></tr>{% endfor %}
            </tbody></table>
          </div>
        </div>
  <div class="tab-pane fade" id="fp-hosts">
          <div class="d-flex justify-content-between align-items-center mb-2">
            <h6 class="mb-0">Hosts</h6>
            <button class="btn btn-sm btn-outline-secondary" type="button" data-preview-collapse="fp-hosts-body" data-label-collapse="Collapse" data-label-expand="Expand">Collapse</button>
          </div>
          <div id="fp-hosts-body" class="collapse">
            <table class="table table-sm table-striped small"><thead><tr><th>ID</th><th>Name</th><th>Role</th><th>IP</th><th>Router</th><th>Vulnerabilities</th></tr></thead><tbody>
            {% set hr = full_preview.host_router_map or {} %}
            {% for h in full_preview.hosts %}{% set vulns = h.vulnerabilities or [] %}<tr><td>{{ h.node_id }}</td><td>{{ h.name }}</td><td>{{ h.role }}</td><td>{{ h.ip4 }}</td><td>{{ hr[h.node_id|string] or hr[h.node_id] }}</td><td>{{ vulns|join(', ') if vulns else '-' }}</td></tr>{% endfor %}
            </tbody></table>
          </div>
        </div>
  <div class="tab-pane fade" id="fp-vulnerabilities">
          <div class="d-flex justify-content-between align-items-center mb-2">
            <h6 class="mb-0">Vulnerabilities</h6>
            <button class="btn btn-sm btn-outline-secondary" type="button" data-preview-collapse="fp-vuln-body" data-label-collapse="Collapse" data-label-expand="Expand">Collapse</button>
          </div>
          <div id="fp-vuln-body" class="collapse">
          {% set vuln_plan = full_preview.vulnerabilities_preview or {} %}
          {% set vuln_assign = full_preview.vulnerabilities_by_node or {} %}
          <div class="row g-3">
            <div class="col-md-4">
              <h6 class="mb-2">Planned Counts</h6>
              {% set plan_ns = namespace(has_rows=False) %}
              <div class="table-responsive" style="max-height:220px;overflow:auto;">
                <table class="table table-sm table-striped small align-middle">
                  <thead class="table-light"><tr><th>Vulnerability</th><th class="text-end">Count</th></tr></thead>
                  <tbody>
                  {% for v_name, v_count in vuln_plan.items() %}
                    {% if v_name != '__density_pool__' %}
                      {% set plan_ns.has_rows = True %}
                      <tr><td>{{ v_name }}</td><td class="text-end">{{ v_count }}</td></tr>
                    {% endif %}
                  {% endfor %}
                  {% if not plan_ns.has_rows %}
                    <tr><td colspan="2" class="text-muted fst-italic text-center">(no planned vulnerabilities)</td></tr>
                  {% endif %}
                  </tbody>
                </table>
              </div>
            </div>
            <div class="col-md-8">
              <h6 class="mb-2">Assignments by Host</h6>
              {% set sorted_assign = vuln_assign|dictsort %}
              {% if sorted_assign %}
              <div class="table-responsive" style="max-height:220px;overflow:auto;">
                <table class="table table-sm table-striped small align-middle">
                  <thead class="table-light"><tr><th>Host ID</th><th>Name</th><th>Role</th><th>Vulnerabilities</th></tr></thead>
                  <tbody>
                  {% set assign_ns = namespace(has_rows=False) %}
                  {% for node_id_str, vulns in sorted_assign %}
                    {% if vulns %}
                      {% set assign_ns.has_rows = True %}
                      {% set node_id = node_id_str|int %}
                      {% set host = (full_preview.hosts | selectattr('node_id','equalto', node_id) | first) %}
                      <tr>
                        <td>{{ node_id }}</td>
                        <td>{{ host.name if host else 'Host ' ~ node_id }}</td>
                        <td>{{ host.role if host and host.role else 'host' }}</td>
                        <td>{{ vulns|join(', ') }}</td>
                      </tr>
                    {% endif %}
                  {% endfor %}
                  {% if not assign_ns.has_rows %}
                    <tr><td colspan="4" class="text-muted fst-italic text-center">(no host vulnerabilities assigned)</td></tr>
                  {% endif %}
                  </tbody>
                </table>
              </div>
              {% else %}
                <div class="small text-muted fst-italic">(no host vulnerabilities assigned)</div>
              {% endif %}
            </div>
          </div>
          </div>
        </div>
  <div class="tab-pane fade" id="fp-switches">
          <div class="d-flex justify-content-between align-items-center mb-2">
            <h6 class="mb-0">Switches</h6>
            <button class="btn btn-sm btn-outline-secondary" type="button" data-preview-collapse="fp-switches-body" data-label-collapse="Collapse" data-label-expand="Expand">Collapse</button>
          </div>
          <div id="fp-switches-body" class="collapse">
            <table class="table table-sm table-striped small"><thead><tr><th>ID</th><th>Name</th><th>Router</th><th>Hosts</th><th>R/S Subnet</th><th>LAN Subnet</th></tr></thead><tbody>
            {% for sw in full_preview.switches_detail %}<tr><td>{{ sw.switch_id }}</td><td>sw-{{ sw.switch_id }}</td><td>{{ sw.router_id }}</td><td>{{ sw.hosts|join(',') }}</td><td>{{ sw.rsw_subnet }}</td><td>{{ sw.lan_subnet }}</td></tr>{% endfor %}
            </tbody></table>
          </div>
        </div>
  <div class="tab-pane fade" id="fp-interfaces">
          <div class="d-flex justify-content-between align-items-center mb-2">
            <h6 class="mb-0">Interfaces</h6>
            <button class="btn btn-sm btn-outline-secondary" type="button" data-preview-collapse="fp-interfaces-body" data-label-collapse="Collapse" data-label-expand="Expand">Collapse</button>
          </div>
          <div id="fp-interfaces-body" class="collapse">
          <div class="row g-3">
            <div class="col-12">
              <h6 class="mb-2">Router-to-Router Links</h6>
              {% set r2r_links = full_preview.r2r_links_preview or [] %}
              {% if r2r_links %}
              <div class="table-responsive" style="max-height:240px;overflow:auto;">
                <table class="table table-sm table-bordered small align-middle">
                  <thead class="table-light"><tr><th>#</th><th>Router A</th><th>Router A IP</th><th>Router B</th><th>Router B IP</th><th>Subnet</th></tr></thead>
                  <tbody>
                  {% for link in r2r_links %}
                    {% set routers = link.routers or [] %}
                    {% set ra = routers[0] if routers|length > 0 else {} %}
                    {% set rb = routers[1] if routers|length > 1 else {} %}
                    {% set ra_obj = (full_preview.routers|selectattr('node_id','equalto', ra.id)|first) %}
                    {% set rb_obj = (full_preview.routers|selectattr('node_id','equalto', rb.id)|first) %}
                    {% set ra_label = ra_obj.name if ra_obj else 'r' ~ (ra.id or '-') %}
                    {% set rb_label = rb_obj.name if rb_obj else 'r' ~ (rb.id or '-') %}
                    <tr>
                      <td>{{ link.edge_id }}</td>
                      <td>{{ ra_label }}</td>
                      <td>{{ ra.ip or '-' }}</td>
                      <td>{{ rb_label }}</td>
                      <td>{{ rb.ip or '-' }}</td>
                      <td>{{ link.subnet or '-' }}</td>
                    </tr>
                  {% endfor %}
                  </tbody>
                </table>
              </div>
              {% else %}<div class="small text-muted fst-italic">(no router-to-router links)</div>{% endif %}
            </div>
            <div class="col-12">
              <h6 class="mb-2">Router-to-Switch Links</h6>
              {% set sw_detail = full_preview.switches_detail or [] %}
              {% if sw_detail %}
              <div class="table-responsive" style="max-height:220px;overflow:auto;">
                <table class="table table-sm table-bordered small align-middle">
                  <thead class="table-light"><tr><th>Router</th><th>Switch</th><th>Router IP</th><th>Switch IP</th><th>R/S Subnet</th><th>LAN Subnet</th></tr></thead>
                  <tbody>
                  {% for sw in sw_detail %}
                    {% set router_obj = (full_preview.routers|selectattr('node_id','equalto', sw.router_id)|first) %}
                    {% set router_label = router_obj.name if router_obj else 'r' ~ (sw.router_id or '-') %}
                    <tr>
                      <td>{{ router_label }}</td>
                      <td>sw-{{ sw.switch_id }}</td>
                      <td>{{ sw.router_ip or '-' }}</td>
                      <td>{{ sw.switch_ip or '-' }}</td>
                      <td>{{ sw.rsw_subnet or '-' }}</td>
                      <td>{{ sw.lan_subnet or '-' }}</td>
                    </tr>
                  {% endfor %}
                  </tbody>
                </table>
              </div>
              {% else %}<div class="small text-muted fst-italic">(no router-to-switch links)</div>{% endif %}
            </div>
            <div class="col-12">
              <h6 class="mb-2">Switch Host Interfaces</h6>
              {% if sw_detail %}
              <div class="table-responsive" style="max-height:220px;overflow:auto;">
                <table class="table table-sm table-bordered small align-middle">
                  <thead class="table-light"><tr><th>Switch</th><th>Host ID</th><th>Host IP</th><th>LAN Subnet</th></tr></thead>
                  <tbody>
                  {% for sw in sw_detail %}
                    {% set host_ips = (sw.host_if_ips or {})|dictsort(case_sensitive=False) %}
                    {% if host_ips %}
                      {% for hid, hip in host_ips %}
                        <tr>
                          <td>sw-{{ sw.switch_id }}</td>
                          <td>{{ hid }}</td>
                          <td>{{ hip or '-' }}</td>
                          <td>{{ sw.lan_subnet or '-' }}</td>
                        </tr>
                      {% endfor %}
                    {% else %}
                      <tr>
                        <td>sw-{{ sw.switch_id }}</td>
                        <td class="text-muted" colspan="2">(no host interfaces)</td>
                        <td>{{ sw.lan_subnet or '-' }}</td>
                      </tr>
                    {% endif %}
                  {% endfor %}
                  </tbody>
                </table>
              </div>
              {% else %}<div class="small text-muted fst-italic">(no switch host assignments)</div>{% endif %}
            </div>
            <div class="col-12">
              <h6 class="mb-2">HITL Interfaces</h6>
              {% set hitl_ifaces = hitl_cfg.get('interfaces') or [] %}
              {% if hitl_ifaces %}
              <div class="small mb-2">HITL is <strong>{{ 'enabled' if hitl_cfg.get('enabled') else 'disabled' }}</strong>{% if hitl_cfg.get('scenario_key') %} (scenario key: {{ hitl_cfg.get('scenario_key') }}){% endif %}.</div>
              <div class="table-responsive" style="max-height:240px;overflow:auto;">
                <table class="table table-sm table-bordered small align-middle">
                  <thead class="table-light">
                    <tr>
                      <th>Name</th>
                      <th>Attachment</th>
                      <th>Preview Router</th>
                      <th>RJ45 IPv4</th>
                      <th>New Router IPv4</th>
                      <th>Existing Router IPv4</th>
                      <th>Link Network</th>
                      <th>IPv4 List</th>
                    </tr>
                  </thead>
                  <tbody>
                    {% for iface in hitl_ifaces %}
                    <tr>
                      <td>{{ iface.get('name') or '-' }}</td>
                      <td>{{ (iface.get('attachment') or '')|replace('_', ' ')|title }}</td>
                      <td>{{ iface.get('preview_router', {}).get('name') or '-' }}</td>
                      <td>{{ iface.get('rj45_ip4') or '-' }}</td>
                      <td>{{ iface.get('new_router_ip4') or '-' }}</td>
                      <td>{{ iface.get('existing_router_ip4') or '-' }}</td>
                      <td>{{ iface.get('link_network_cidr') or iface.get('link_network') or '-' }}</td>
                      <td>{{ iface.get('ipv4')|join(', ') if iface.get('ipv4') else '-' }}</td>
                    </tr>
                    {% endfor %}
                  </tbody>
                </table>
              </div>
              {% else %}
                <div class="small text-muted fst-italic">(no HITL interfaces declared)</div>
              {% endif %}
            </div>
          </div>
          </div>
        </div>
  <div class="tab-pane fade" id="fp-seg">
          <div class="d-flex justify-content-between align-items-center mb-2">
            <h6 class="mb-0">Segmentation</h6>
            <button class="btn btn-sm btn-outline-secondary" type="button" data-preview-collapse="fp-seg-body" data-label-collapse="Collapse" data-label-expand="Expand">Collapse</button>
          </div>
          <div id="fp-seg-body" class="collapse">
          {% set seg_prev = full_preview.segmentation_preview %}
          {% set seg_artifacts = segmentation_artifacts or (display_artifacts.segmentation if display_artifacts else None) %}
          {% set seg_rows = seg_artifacts.table_rows if seg_artifacts and seg_artifacts.table_rows else [] %}
          {% set seg_json = seg_artifacts.json if seg_artifacts else None %}
          <!-- Segmentation action buttons removed per request; only rules table remains -->
          {% if seg_rows %}
          <div class="table-responsive" style="max-height:320px;overflow:auto;">
            <table class="table table-sm table-bordered small align-middle" id="segRulesTable">
              <thead><tr><th>#</th><th>Node</th><th>Type</th><th>Summary</th><th>Src</th><th>Dst</th><th>Subnet</th><th>Internal</th><th>External</th><th>Proto</th><th>Port</th><th>Script</th></tr></thead>
              <tbody>
              {% for row in seg_rows %}
                {% set script_name = row.script_name %}
                {% if not script_name and row.script_path %}{% set script_name = row.script_path.rsplit('/', 1)[-1] %}{% endif %}
                <tr>
                  <td>{{ loop.index }}</td>
                  <td>{{ row.node_id if row.node_id is not none else '-' }}</td>
                  <td>{{ row.type or '-' }}</td>
                  <td>{{ row.summary or '-' }}</td>
                  <td>{{ row.src or '-' }}</td>
                  <td>{{ row.dst or '-' }}</td>
                  <td>{{ row.subnet or '-' }}</td>
                  <td>{{ row.internal or '-' }}</td>
                  <td>{{ row.external or '-' }}</td>
                  <td>{{ row.proto or '-' }}</td>
                  <td>{{ row.port if row.port is not none else '-' }}</td>
                  <td>
                    {% if script_name %}
                      <button class="btn btn-sm btn-outline-primary py-0 px-1 view-script-btn" data-file="{{ script_name }}" data-kind="segmentation" title="{{ row.script_path or script_name }}">View</button>
                    {% else %}-{% endif %}
                  </td>
                </tr>
              {% endfor %}
              </tbody>
            </table>
          </div>
          {% else %}
            <div class="small text-muted fst-italic">(no segmentation rules)</div>
          {% endif %}
          {% if seg_json %}
          <div class="mt-2">
            {% if seg_json.types_summary %}
            <div class="small mb-1">
              {% for t, count in seg_json.types_summary.items() %}
                <span class="badge text-bg-light border me-1">{{ t }}: {{ count }}</span>
              {% endfor %}
            </div>
            {% endif %}
            <h6 class="small text-uppercase text-muted mb-1">Segmentation Summary</h6>
            <pre class="small bg-light p-2" style="max-height:220px;overflow:auto;">{{ seg_json | tojson(indent=2) }}</pre>
          </div>
          {% endif %}
          <!-- Unified Scripts Listing Modal (segmentation + traffic) -->
          <div class="modal fade" id="scriptsListingModal" tabindex="-1" aria-labelledby="scriptsListingModalLabel" aria-hidden="true">
            <div class="modal-dialog modal-lg modal-dialog-scrollable">
              <div class="modal-content">
                <div class="modal-header">
                  <h5 class="modal-title" id="scriptsListingModalLabel">Scripts</h5>
                  <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                  <div class="d-flex flex-wrap gap-2 mb-2">
                    <div class="btn-group btn-group-sm" role="group">
                      <button type="button" class="btn btn-outline-secondary" data-kind="segmentation" data-scope="preview">Segmentation</button>
                    </div>
                    <div class="btn-group btn-group-sm" role="group">
                      <button type="button" class="btn btn-outline-success" data-kind="traffic" data-scope="preview">Traffic</button>
                    </div>
                    <span id="scriptsListingStatus" class="small text-muted align-self-center"></span>
                  </div>
                  <div class="table-responsive" style="max-height:55vh;">
                    <table class="table table-sm table-hover small align-middle mb-0" id="scriptsListingTable">
                      <thead class="table-light"><tr><th style="width:55%;">File</th><th style="width:15%;" class="text-end">Size (bytes)</th><th style="width:30%;">Actions</th></tr></thead>
                      <tbody><tr><td colspan="3" class="text-muted fst-italic">Select a scope above to load scripts.</td></tr></tbody>
                    </table>
                  </div>
                </div>
                <div class="modal-footer">
                  <button type="button" class="btn btn-sm btn-secondary" data-bs-dismiss="modal">Close</button>
                </div>
              </div>
            </div>
          </div>
          <div id="segScriptModal" class="modal" tabindex="-1">
            <div class="modal-dialog modal-lg modal-dialog-scrollable">
              <div class="modal-content">
                <div class="modal-header"><h5 class="modal-title">Script</h5><button type="button" class="btn-close" data-bs-dismiss="modal"></button></div>
                <div class="modal-body"><pre class="small mb-0" id="segScriptContent" style="max-height:60vh;overflow:auto;"></pre></div>
                <div class="modal-footer"><button class="btn btn-sm btn-secondary" data-bs-dismiss="modal">Close</button></div>
              </div>
            </div>
          </div>
          {% if seg_prev and seg_prev.runtime_summary %}
          <hr class="my-2" />
          <h6 class="mt-2">Runtime Segmentation Summary (segmentation_summary.json)</h6>
          <pre class="small bg-light p-2" style="max-height:260px;overflow:auto;">{{ seg_prev.runtime_summary | tojson(indent=2) }}</pre>
          {% endif %}
          {% if seg_prev and seg_prev.scripts_hash_sha256 %}
          <div class="small text-muted">Scripts Hash (SHA-256): <code>{{ seg_prev.scripts_hash_sha256 }}</code></div>
          {% endif %}
          </div>
        </div>
  <div class="tab-pane fade" id="fp-node-sections">
          <div class="d-flex justify-content-between align-items-center mb-2">
            <h6 class="mb-0">Node Sections</h6>
            <button class="btn btn-sm btn-outline-secondary" type="button" data-preview-collapse="fp-node-sections-body" data-label-collapse="Collapse" data-label-expand="Expand">Collapse</button>
          </div>
          <div id="fp-node-sections-body" class="collapse">
          <div class="table-responsive small">
            <table class="table table-sm table-bordered mb-0" id="nodeSectionsTable"><thead><tr>
              <th>Node ID</th><th>Name</th><th>Type</th><th>Primary IP</th><th>Interfaces</th><th>Services</th><th>Vulns</th><th>Seg Rules</th><th>Traffic S</th><th>Traffic R</th>
            </tr></thead><tbody></tbody></table>
          </div>
          </div>
        </div>
  <div class="tab-pane fade" id="fp-traffic">
          <div class="d-flex justify-content-between align-items-center mb-2">
            <h6 class="mb-0">Traffic</h6>
            <button class="btn btn-sm btn-outline-secondary" type="button" data-preview-collapse="fp-traffic-body" data-label-collapse="Collapse" data-label-expand="Expand">Collapse</button>
          </div>
          <div id="fp-traffic-body" class="collapse">
          {% set tsummary = full_preview.traffic_summary or {} %}
          {% set flows = tsummary.flows or [] %}
          {% if flows %}
          <div class="table-responsive" style="max-height:440px;overflow:auto;">
            <table class="table table-sm table-striped small" id="trafficFlowsTable">
              <thead><tr><th>#</th><th>Src ID</th><th>Dst ID</th><th>Pattern</th><th>Rate (kbps)</th><th>Proto</th><th>Script</th></tr></thead>
              <tbody>
              {% for f in flows %}
                <tr>
                  <td>{{ loop.index }}</td>
                  <td>{{ f.src_id or f.src }}</td>
                  <td>{{ f.dst_id or f.dst }}</td>
                  <td>{{ f.pattern or '-' }}</td>
                  <td>{{ f.rate_kbps or f.rate or '-' }}</td>
                  <td>{{ f.protocol or f.kind or 'tcp' }}</td>
                  <td>
                    {% set sender = f.sender_script %}
                    {% set receiver = f.receiver_script %}
                    {% if sender or receiver %}
                      <div class="d-flex gap-1 flex-wrap">
                        {% if sender %}{% set send_name = sender.split('/')[-1] %}<button class="btn btn-sm btn-outline-primary py-0 px-1 view-script-btn" data-kind="traffic" data-file="{{ send_name }}" data-role="sender">Sender</button>{% endif %}
                        {% if receiver %}{% set recv_name = receiver.split('/')[-1] %}<button class="btn btn-sm btn-outline-secondary py-0 px-1 view-script-btn" data-kind="traffic" data-file="{{ recv_name }}" data-role="receiver">Receiver</button>{% endif %}
                      </div>
                    {% else %}-{% endif %}
                  </td>
                </tr>
              {% endfor %}
              </tbody>
            </table>
          </div>
          {% else %}
            <div class="small text-muted fst-italic">(no traffic flows)</div>
          {% endif %}
          </div>
        </div>
  <div class="tab-pane fade" id="fp-json">
          <div class="d-flex justify-content-between align-items-center mb-2">
            <h6 class="mb-0">Raw JSON</h6>
            <button class="btn btn-sm btn-outline-secondary" type="button" data-preview-collapse="fp-json-body" data-label-collapse="Collapse" data-label-expand="Expand">Collapse</button>
          </div>
          <div id="fp-json-body" class="collapse">
            <pre class="small bg-light p-2" style="max-height:440px;overflow:auto;">{{ preview_json }}</pre>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>
<div class="modal fade" id="executeProgressModal" tabindex="-1" aria-hidden="true">
  <div class="modal-dialog modal-dialog-centered modal-lg">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title">Executing scenario…</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <div class="modal-body">
        <div class="d-flex justify-content-between align-items-center mb-2 small text-muted">
          <div id="executeProgressStatus">Starting…</div>
          <div id="executeProgressMeta"></div>
        </div>
        <div class="progress mb-3" role="progressbar" aria-label="Progress" aria-valuemin="0" aria-valuemax="100">
          <div class="progress-bar progress-bar-striped progress-bar-animated" id="executeProgressBar" style="width: 100%;">Working…</div>
        </div>
        <div class="border rounded" style="max-height: 260px; overflow: auto;">
          <pre class="m-0 p-2 small" id="executeProgressLog" style="white-space: pre-wrap;"></pre>
        </div>
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-secondary" id="executeProgressHideBtn" data-bs-dismiss="modal">Hide</button>
      </div>
    </div>
  </div>
</div>
{% block extra_scripts %}
<script src="https://cdn.jsdelivr.net/npm/d3@7/dist/d3.min.js"></script>
<script id="fpDataJson" type="application/json">{{ full_preview | tojson }}</script>
<script id="fpHitlConfigJson" type="application/json">{{ hitl_config | tojson }}</script>
<script id="fpScenarioMetaJson" type="application/json">{{ {'scenario': scenario, 'xml_basename': xml_basename} | tojson }}</script>
<script>
(function(){
  let previewData = {};
  function init(){
    const dataEl = document.getElementById('fpDataJson');
    try { previewData = JSON.parse(dataEl.textContent); } catch(e) { console.warn('Failed parse preview json', e); previewData = {}; }

    let hitlConfig = { enabled: false, interfaces: [] };
    const hitlEl = document.getElementById('fpHitlConfigJson');
    if(hitlEl){
      try {
        const parsed = JSON.parse(hitlEl.textContent || 'null');
        if(parsed && typeof parsed === 'object'){
          hitlConfig = parsed;
        }
      } catch(e){
        console.warn('Failed parse HITL config json', e);
      }
    }
    if(!hitlConfig || typeof hitlConfig !== 'object'){
      hitlConfig = { enabled: false, interfaces: [] };
    }
    if(!Array.isArray(hitlConfig.interfaces)){
      hitlConfig.interfaces = [];
    }
    let scenarioMeta = { scenario: null, xml_basename: '' };
    const scenarioMetaEl = document.getElementById('fpScenarioMetaJson');
    if(scenarioMetaEl){
      try {
        const parsedMeta = JSON.parse(scenarioMetaEl.textContent || 'null');
        if(parsedMeta && typeof parsedMeta === 'object'){
          scenarioMeta = parsedMeta;
        }
      } catch(e){
        console.warn('Failed parse scenario meta json', e);
      }
    }
    const scenarioNameRaw = typeof scenarioMeta.scenario === 'string' ? scenarioMeta.scenario : null;
    const xmlBaseNameRaw = typeof scenarioMeta.xml_basename === 'string' ? scenarioMeta.xml_basename : '';
    const scenarioKey = (hitlConfig && typeof hitlConfig.scenario_key === 'string' && hitlConfig.scenario_key.trim())
      ? hitlConfig.scenario_key.trim()
      : ((scenarioNameRaw && scenarioNameRaw.trim())
          ? scenarioNameRaw.trim()
          : (xmlBaseNameRaw || '__default__'));
    hitlConfig.scenario_key = scenarioKey;

    // Simple graph using d3-force (assumes d3 is loaded in base template). Fallback to textual if not.
    function normalizeVulnerabilitiesByNode(source){
      const out = {};
      if(!source) return out;
      Object.entries(source).forEach(([key, value]) => {
        if(key === '__density_pool__') return;
        if(Array.isArray(value)){
          out[String(key)] = value;
          const numericKey = Number(key);
          if(Number.isFinite(numericKey)){
            out[numericKey] = value;
          }
        }
      });
      return out;
    }

  const ROUTER_NODE_TYPES = new Set(['router', 'prouter', 'mdr', 'core-router', 'gateway']);
  const SWITCH_NODE_TYPES = new Set(['switch', 'lanswitch', 'l3switch', 'bridge', 'core-switch']);
  const HOST_NODE_TYPES = new Set(['host', 'pc', 'server', 'workstation', 'client', 'desktop', 'lxc', 'xterm', 'generic', 'terminal', 'laptop']);
  const NETWORK_NODE_TYPES = new Set(['network', 'lan', 'wan']);
  const WIRELESS_NODE_TYPES = new Set(['wireless', 'wirelesslan', 'wireless-lan', 'wlan', 'wifi']);
  const RJ45_NODE_TYPES = new Set(['rj45']);
  const HUB_NODE_TYPES = new Set(['hub', 'ethernet', 'tap']);

    const NODE_TYPE_STYLE_PRESETS = {
      router: { label: 'Router', color: '#ff7043', radius: 11 },
      switch: { label: 'Switch', color: '#17a2b8', radius: 8 },
      host: { label: 'Host', color: '#ffc107', radius: 5 },
      network: { label: 'Network', color: '#6c757d', radius: 7 },
      hub: { label: 'Hub', color: '#7952b3', radius: 6 },
      rj45: { label: 'RJ45', color: '#20c997', radius: 6, shape: 'square' },
      wireless: { label: 'Wireless', color: '#0dcaf0', radius: 6 },
      wlan: { label: 'WLAN', color: '#0dcaf0', radius: 6 },
      tap: { label: 'TAP', color: '#6f42c1', radius: 6 },
    };

    function canonicalNodeType(raw){
      if(raw === null || raw === undefined) return 'host';
      const key = String(raw).trim().toLowerCase();
      if(!key) return 'host';
      if(ROUTER_NODE_TYPES.has(key)) return 'router';
      if(SWITCH_NODE_TYPES.has(key)) return 'switch';
      if(RJ45_NODE_TYPES.has(key)) return 'rj45';
      if(WIRELESS_NODE_TYPES.has(key)) return 'wireless';
      if(NETWORK_NODE_TYPES.has(key)) return 'network';
      if(HUB_NODE_TYPES.has(key)) return 'hub';
      if(HOST_NODE_TYPES.has(key)) return 'host';
      return key;
    }

    function formatNodeTypeLabel(key){
      if(!key) return 'Node';
      return key.replace(/[-_]/g, ' ').replace(/\b\w/g, c => c.toUpperCase());
    }

    function nodeStyleForType(rawType){
      const key = canonicalNodeType(rawType);
      const preset = NODE_TYPE_STYLE_PRESETS[key];
      if(preset){
        const radius = Number.isFinite(preset.radius) ? preset.radius : 6;
        const shape = preset.shape || 'circle';
        return { ...preset, radius, shape };
      }
      return {
        label: formatNodeTypeLabel(key),
        color: '#adb5bd',
        radius: 6,
        shape: 'circle',
      };
    }

    function makeDeterministicRng(seed){
      const input = typeof seed === 'string' ? seed : String(seed ?? '');
      let h1 = 0xdeadbeef ^ input.length;
      let h2 = 0x41c6ce57 ^ input.length;
      for(let i = 0; i < input.length; i++){
        const ch = input.charCodeAt(i);
        h1 = Math.imul(h1 ^ ch, 2654435761);
        h2 = Math.imul(h2 ^ ch, 1597334677);
      }
      h1 = Math.imul(h1 ^ (h1 >>> 16), 2246822507) ^ Math.imul(h2 ^ (h2 >>> 13), 3266489909);
      h2 = Math.imul(h2 ^ (h2 >>> 16), 2246822507) ^ Math.imul(h1 ^ (h1 >>> 13), 3266489909);
      let idx = 0;
      return () => {
        idx += 0x9e3779b9;
        let h = idx;
        h = Math.imul(h ^ (h >>> 15), 2246822519);
        h ^= h1;
        h = Math.imul(h ^ (h >>> 13), 3266489917);
        h ^= h2;
        h = Math.imul(h ^ (h >>> 16), 668265263);
        return ((h >>> 0) / 4294967296);
      };
    }

    const HITL_ATTACHMENT_ALLOWED = new Set(['existing_router', 'existing_switch', 'new_router', 'new_switch']);
    const DEFAULT_HITL_ATTACHMENT = 'existing_router';

    function normalizeHitlAttachment(value){
      if(value === null || value === undefined) return DEFAULT_HITL_ATTACHMENT;
      let normalized = String(value).trim().toLowerCase();
      if(!normalized) return DEFAULT_HITL_ATTACHMENT;
      normalized = normalized.replace(/[\s-]+/g, '_');
      return HITL_ATTACHMENT_ALLOWED.has(normalized) ? normalized : DEFAULT_HITL_ATTACHMENT;
    }

    function attachmentAttemptOrder(pref){
      const normalized = normalizeHitlAttachment(pref);
      if(normalized === 'existing_router'){
        return ['existing_router', 'existing_switch', 'new_switch', 'new_router'];
      }
      if(normalized === 'existing_switch'){
        return ['existing_switch', 'existing_router', 'new_switch', 'new_router'];
      }
      if(normalized === 'new_router'){
        return ['new_router', 'existing_router', 'existing_switch', 'new_switch'];
      }
      return ['new_switch', 'existing_switch', 'existing_router', 'new_router'];
    }

    function deriveStandaloneHitlArtifacts(preview, hitlCfg, scenarioKeySeed){
      if(!preview || typeof preview !== 'object') return null;
      if(!hitlCfg || typeof hitlCfg !== 'object' || !hitlCfg.enabled) return null;
      const rawInterfaces = Array.isArray(hitlCfg.interfaces) ? hitlCfg.interfaces : [];
      const sanitized = rawInterfaces.map((entry, idx) => {
        if(!entry || typeof entry !== 'object') return null;
        const name = String(entry.name || '').trim();
        if(!name) return null;
        const normalized = { name };
        const alias = entry.alias ?? entry.description ?? entry.display;
        if(typeof alias === 'string' && alias.trim()){
          normalized.alias = alias.trim();
        }
        if(typeof entry.mac === 'string'){
          const macVal = entry.mac.trim();
          if(macVal) normalized.mac = macVal;
        }
        const normalizeList = (value) => {
          if(Array.isArray(value)){
            return value.map(v => String(v || '').trim()).filter(Boolean);
          }
          if(typeof value === 'string'){
            return value.split(',').map(v => v.trim()).filter(Boolean);
          }
          return [];
        };
        const ipv4List = normalizeList(entry.ipv4);
        if(ipv4List.length) normalized.ipv4 = ipv4List;
        const ipv6List = normalizeList(entry.ipv6);
        if(ipv6List.length) normalized.ipv6 = ipv6List;
        normalized.attachment = normalizeHitlAttachment(entry.attachment);
        if(Number.isFinite(Number(entry.ordinal))){
          normalized.ordinal = Number(entry.ordinal);
        }
        if(Number.isFinite(Number(entry.interface_count))){
          normalized.interfaceCount = Number(entry.interface_count);
        }
        const previewRouter = entry.preview_router;
        if(previewRouter && typeof previewRouter === 'object'){
          const routerNodeId = previewRouter.node_id ?? previewRouter.id ?? null;
          if(routerNodeId !== null && routerNodeId !== undefined){
            normalized.previewRouter = {
              nodeId: routerNodeId,
              name: previewRouter.name || null,
            };
            if(previewRouter.metadata && typeof previewRouter.metadata === 'object'){
              const metaRouterId = previewRouter.metadata.target_router_id ?? previewRouter.metadata.peer_router_node_id ?? null;
              if(metaRouterId !== null && metaRouterId !== undefined){
                normalized.targetRouterId = metaRouterId;
              }
            }
          }
        }
        const previewSwitch = entry.preview_switch;
        if(previewSwitch && typeof previewSwitch === 'object'){
          const switchNodeId = previewSwitch.node_id ?? previewSwitch.switch_id ?? null;
          if(switchNodeId !== null && switchNodeId !== undefined){
            normalized.previewSwitch = {
              nodeId: switchNodeId,
              name: previewSwitch.name || null,
              routerId: null,
            };
            if(previewSwitch.metadata && typeof previewSwitch.metadata === 'object'){
              const metaRouterId = previewSwitch.metadata.target_router_id ?? previewSwitch.metadata.peer_router_node_id ?? null;
              if(metaRouterId !== null && metaRouterId !== undefined){
                normalized.targetRouterId = normalized.targetRouterId ?? metaRouterId;
                normalized.previewSwitch.routerId = metaRouterId;
              }
            }
          }
        }
        const explicitTarget = entry.target_router_id ?? entry.peer_router_node_id;
        if(explicitTarget !== null && explicitTarget !== undefined){
          normalized.targetRouterId = normalized.targetRouterId ?? explicitTarget;
        }
        return normalized;
      }).filter(Boolean);
      if(!sanitized.length) return null;

      const normalizeName = (raw, idx) => {
        let base = (raw || `iface-${idx}`).toString().trim().toLowerCase();
        base = base.replace(/[^a-z0-9_-]+/g, '-').replace(/-+/g, '-').replace(/^-|-$/g, '');
        if(!base) base = `iface-${idx}`;
        if(base.length > 48) base = base.slice(0, 48);
        return base;
      };

      const existingIds = new Set();
      const noteExisting = (val) => {
        if(val === undefined || val === null) return;
        existingIds.add(String(val));
      };

      const routers = Array.isArray(preview.routers) ? preview.routers : [];
      const hosts = Array.isArray(preview.hosts) ? preview.hosts : [];
      const switches = Array.isArray(preview.switches_detail) ? preview.switches_detail : [];
      routers.forEach(r => noteExisting(r?.node_id ?? r?.id));
      hosts.forEach(h => noteExisting(h?.node_id ?? h?.id));
      switches.forEach(sw => noteExisting(sw?.switch_id ?? sw?.id));
      const basePreview = preview.base_bridge_preview || {};
      noteExisting(basePreview?.bridge_router_id);
      noteExisting(basePreview?.internal_peer_router_id);

      const routerPeers = routers.filter(r => r && r.node_id !== undefined && r.node_id !== null).slice().sort((a, b) => {
        const aid = Number(a?.node_id ?? a?.id ?? 0);
        const bid = Number(b?.node_id ?? b?.id ?? 0);
        return aid - bid;
      });
      const hostPeers = hosts.filter(h => h && h.node_id !== undefined && h.node_id !== null).slice().sort((a, b) => {
        const aid = Number(a?.node_id ?? a?.id ?? 0);
        const bid = Number(b?.node_id ?? b?.id ?? 0);
        return aid - bid;
      });

      const existingSubnets = switches.filter(sw => sw && sw.switch_id !== undefined && sw.switch_id !== null).slice().sort((a, b) => {
        const aid = Number(a?.switch_id ?? a?.id ?? 0);
        const bid = Number(b?.switch_id ?? b?.id ?? 0);
        return aid - bid;
      });

      const scenarioSeed = typeof scenarioKeySeed === 'string' && scenarioKeySeed ? scenarioKeySeed : '__default__';

      const resultNodes = [];
      const resultLinks = [];

      const makeUniqueId = (base) => {
        let candidate = base;
        let suffix = 2;
        while(existingIds.has(String(candidate))){
          candidate = `${base}-${suffix}`;
          suffix += 1;
        }
        existingIds.add(String(candidate));
        return candidate;
      };

      sanitized.forEach((iface, idx) => {
        const baseName = normalizeName(iface.name, idx);
        const attachmentPref = normalizeHitlAttachment(iface.attachment);
        const nodeId = makeUniqueId(`hitl-${baseName}`);
        const alias = iface.alias;
        const labelParts = [];
        if(iface.name) labelParts.push(iface.name);
        if(alias && alias !== iface.name){
          labelParts.push(alias);
        } else if(iface.mac){
          labelParts.push(iface.mac);
        }
        const nodeLabel = labelParts.filter(Boolean).join(' · ') || iface.name || `HITL ${idx + 1}`;
        const hitlNode = {
          id: nodeId,
          type: 'rj45',
          label: nodeLabel,
          name: nodeLabel,
          isHitl: true,
          hitlInterface: iface,
          attachment: attachmentPref,
        };
        if(Array.isArray(iface.ipv4) && iface.ipv4.length){
          hitlNode.ip4 = iface.ipv4[0];
        }
        resultNodes.push(hitlNode);
        const rng = makeDeterministicRng(`${scenarioSeed}|${iface.name}|${idx}|${sanitized.length}`);
        const attempts = attachmentAttemptOrder(attachmentPref);
        let targetId = null;
        let assignment = null;
        let linkKind = 'hitl-peer';
        let uplinkRouterId = (iface.targetRouterId !== undefined && iface.targetRouterId !== null)
          ? iface.targetRouterId
          : null;
        const pickRouterPeer = () => {
          if(!routerPeers.length) return null;
          const peer = routerPeers[Math.floor(rng() * routerPeers.length)];
          const peerId = peer?.node_id ?? peer?.id;
          return (peerId !== undefined && peerId !== null) ? peerId : null;
        };
        const pickSwitchPeer = () => {
          if(!existingSubnets.length) return null;
          const subnet = existingSubnets[Math.floor(rng() * existingSubnets.length)];
          const candidateId = subnet?.switch_id ?? subnet?.id;
          return (candidateId !== undefined && candidateId !== null) ? candidateId : null;
        };
        const createNewRouter = () => {
          const routerId = makeUniqueId(`hitl-router-${baseName}`);
          const routerLabel = `HITL Router ${idx + 1}`;
          const routerNode = {
            id: routerId,
            node_id: routerId,
            type: 'router',
            label: routerLabel,
            name: routerLabel,
            isHitlRouter: true,
            attachment: attachmentPref,
            hitlInterface: iface,
          };
          const routerCandidates = routerPeers.length ? routerPeers.slice() : [];
          if(routerCandidates.length){
            const chosen = routerCandidates[Math.floor(rng() * routerCandidates.length) % routerCandidates.length];
            const chosenId = chosen?.node_id ?? chosen?.id;
            if(chosenId !== undefined && chosenId !== null){
              uplinkRouterId = chosenId;
              routerNode.uplinkRouterId = chosenId;
              noteExisting(chosenId);
              resultLinks.push({ sourceId: routerId, targetId: chosenId, kind: 'hitl-router-uplink', attachment: attachmentPref, assignment: 'uplink_router' });
            }
          }
          resultNodes.push(routerNode);
          routerPeers.push({ node_id: routerId, id: routerId, name: routerLabel, type: 'router', isHitlRouter: true });
          noteExisting(routerId);
          return routerId;
        };
        const createNewSwitch = () => {
          const previewSwitchMeta = iface.previewSwitch;
          if(previewSwitchMeta && previewSwitchMeta.nodeId !== null && previewSwitchMeta.nodeId !== undefined){
            const existingSwitchId = previewSwitchMeta.nodeId;
            noteExisting(existingSwitchId);
            if(!existingSubnets.some(sw => (sw?.switch_id ?? sw?.id) === existingSwitchId)){
              existingSubnets.push({ switch_id: existingSwitchId, id: existingSwitchId, name: previewSwitchMeta.name || `sw-${existingSwitchId}`, isHitlSwitch: true });
            }
            const hintedRouterId = iface.targetRouterId ?? previewSwitchMeta.routerId ?? null;
            if(hintedRouterId !== null && hintedRouterId !== undefined){
              uplinkRouterId = hintedRouterId;
            }
            return existingSwitchId;
          }
          const switchId = makeUniqueId(`hitl-switch-${baseName}`);
          const switchLabel = `HITL Switch ${idx + 1}`;
          const switchNode = {
            id: switchId,
            switch_id: switchId,
            type: 'switch',
            label: switchLabel,
            name: switchLabel,
            isHitlSwitch: true,
            hitlInterface: iface,
            attachment: attachmentPref,
          };
          const routerCandidates = routerPeers.length ? routerPeers.slice() : [];
          if(routerCandidates.length){
            const chosen = routerCandidates[Math.floor(rng() * routerCandidates.length) % routerCandidates.length];
            const chosenId = chosen?.node_id ?? chosen?.id;
            if(chosenId !== undefined && chosenId !== null){
              uplinkRouterId = chosenId;
              switchNode.uplinkRouterId = chosenId;
              noteExisting(chosenId);
              resultLinks.push({ sourceId: switchId, targetId: chosenId, kind: 'hitl-switch-uplink', attachment: attachmentPref, assignment: 'uplink_switch' });
            }
          }
          resultNodes.push(switchNode);
          existingSubnets.push({ switch_id: switchId, id: switchId, name: switchLabel, isHitlSwitch: true });
          noteExisting(switchId);
          return switchId;
        };
        for(const attempt of attempts){
          if(attempt === 'existing_router'){
            const candidate = pickRouterPeer();
            if(candidate !== null){
              targetId = candidate;
              assignment = 'existing_router';
              linkKind = 'hitl-router';
              noteExisting(candidate);
              uplinkRouterId = candidate;
              break;
            }
          } else if(attempt === 'existing_switch'){
            const candidate = pickSwitchPeer();
            if(candidate !== null){
              targetId = candidate;
              assignment = 'existing_switch';
              linkKind = 'hitl-switch';
              noteExisting(candidate);
              break;
            }
          } else if(attempt === 'new_router'){
            const newRouterId = createNewRouter();
            if(newRouterId !== null){
              targetId = newRouterId;
              assignment = 'new_router';
              linkKind = 'hitl-router';
              break;
            }
          } else if(attempt === 'new_switch'){
            const newSwitchId = createNewSwitch();
            if(newSwitchId !== null){
              targetId = newSwitchId;
              assignment = 'new_switch';
              linkKind = 'hitl-switch';
              break;
            }
          }
        }
        if(targetId === null){
          const fallbackRouter = pickRouterPeer();
          if(fallbackRouter !== null){
            targetId = fallbackRouter;
            assignment = assignment ?? 'existing_router';
            linkKind = 'hitl-router';
            noteExisting(fallbackRouter);
            uplinkRouterId = fallbackRouter;
          }
        }
        if(targetId === null && hostPeers.length){
          const peer = hostPeers[Math.floor(rng() * hostPeers.length)];
          const peerId = peer?.node_id ?? peer?.id;
          if(peerId !== undefined && peerId !== null){
            targetId = peerId;
            assignment = assignment ?? 'existing_host';
            linkKind = 'hitl-host';
            noteExisting(peerId);
          }
        }
        if(targetId === null){
          const networkId = makeUniqueId(`hitl-net-${baseName}`);
          const networkLabel = `HITL Network ${idx + 1}`;
          const networkNode = {
            id: networkId,
            type: 'network',
            label: networkLabel,
            name: networkLabel,
            isHitlNetwork: true,
            hitlInterface: iface,
            attachment: attachmentPref,
          };
          resultNodes.push(networkNode);
          targetId = networkId;
          assignment = assignment ?? 'network';
          linkKind = 'hitl-network';
        }
        if(targetId !== null){
          hitlNode.peerNodeId = targetId;
          hitlNode.assignment = assignment || attachmentPref;
          if(uplinkRouterId !== null){
            hitlNode.uplinkRouterId = uplinkRouterId;
          }
          resultLinks.push({ sourceId: nodeId, targetId, kind: linkKind, attachment: attachmentPref, assignment: assignment || attachmentPref });
        }
      });

      return resultNodes.length ? { nodes: resultNodes, links: resultLinks, interfaces: sanitized, hitlState: hitlCfg } : null;
    }

    const hitlPreviewArtifacts = deriveStandaloneHitlArtifacts(previewData, hitlConfig, scenarioKey);

    function setupPreviewCollapsers(){
      const toggles = document.querySelectorAll('[data-preview-collapse]');
      toggles.forEach(btn => {
        if(btn.dataset.collapserBound) return;
        const targetId = btn.getAttribute('data-preview-collapse');
        const target = document.getElementById(targetId);
        if(!target) return;
        btn.dataset.collapserBound = '1';
        const collapseLabel = btn.dataset.labelCollapse || 'Collapse';
        const expandLabel = btn.dataset.labelExpand || 'Expand';
        const hasBootstrap = !!(window.bootstrap && bootstrap.Collapse);
        if(hasBootstrap){
          const instance = bootstrap.Collapse.getOrCreateInstance(target, { toggle: false });
          const updateLabel = () => {
            btn.textContent = target.classList.contains('show') ? collapseLabel : expandLabel;
          };
          updateLabel();
          btn.addEventListener('click', ev => {
            ev.preventDefault();
            if(target.classList.contains('show')){
              instance.hide();
            } else {
              instance.show();
            }
          });
          target.addEventListener('shown.bs.collapse', updateLabel);
          target.addEventListener('hidden.bs.collapse', updateLabel);
        } else {
          if(!target.classList.contains('d-none')){
            target.classList.add('d-none');
          }
          const updateLabel = () => {
            btn.textContent = target.classList.contains('d-none') ? expandLabel : collapseLabel;
          };
          updateLabel();
          btn.addEventListener('click', ev => {
            ev.preventDefault();
            target.classList.toggle('d-none');
            updateLabel();
          });
        }
      });
    }
    function buildGraph(){
    if(!window.d3){ document.getElementById('previewGraph').textContent='d3 not loaded'; return; }
    const wrap = d3.select('#previewGraph');
    wrap.selectAll('*').remove();
    const width = wrap.node().clientWidth; const height = wrap.node().clientHeight;
    const svg = wrap.append('svg').attr('width', width).attr('height', height).style('cursor','grab');
    const vulnerabilitiesByNode = normalizeVulnerabilitiesByNode(previewData.vulnerabilities_by_node);
    const baseBridgeInfo = previewData.base_bridge_preview || null;
    const baseBridgeKeys = new Set();
    const baseClusterNodeMap = new Map();
    function resolveBaseNodeType(meta){
      if(!meta || typeof meta !== 'object') return 'host';
      const raw = meta.type ?? meta.model ?? meta.kind ?? meta.role ?? '';
      return canonicalNodeType(raw);
    }
    const legend = svg.append('g').attr('class','legend').attr('transform','translate(8,8)');
    let legendOffset = 0;
    const legendTypesSeen = new Set();
    let legendSpacingAdded = false;

    const ensureLegendEntry = (canonicalType) => {
      if(!canonicalType || legendTypesSeen.has(canonicalType)) return;
      legendTypesSeen.add(canonicalType);
      const style = nodeStyleForType(canonicalType);
      const radius = Math.max(4, Math.min((style.radius ?? 6), 12));
      const entry = legend.append('g').attr('transform',`translate(0,${legendOffset})`);
      if(style.shape === 'square'){
        const side = radius * 2;
        entry.append('rect')
          .attr('x', 0)
          .attr('y', 0)
          .attr('width', side)
          .attr('height', side)
          .attr('fill', style.color)
          .attr('stroke','#333')
          .attr('stroke-width',1);
      } else {
        entry.append('circle')
          .attr('r', radius)
          .attr('cx', radius)
          .attr('cy', radius)
          .attr('fill', style.color)
          .attr('stroke','#333')
          .attr('stroke-width',1);
      }
      entry.append('text')
        .text(style.label)
        .attr('x', radius * 2 + 6)
        .attr('y', radius + 4)
        .attr('font-size','11px');
      legendOffset += Math.max(radius * 2 + 6, 20);
    };

    const registerLegendForNodes = (list) => {
      if(!Array.isArray(list)) return;
      list.forEach(node => {
        if(!node) return;
        const canonical = canonicalNodeType(node.type ?? node.kind ?? node.role);
        if(node.type !== canonical) node.type = canonical;
        ensureLegendEntry(canonical);
      });
    };

    const addLegendSpacing = () => {
      if(!legendSpacingAdded && legendTypesSeen.size > 0){
        legendOffset += 6;
        legendSpacingAdded = true;
      }
    };
  const bridgeRouterIdRaw = baseBridgeInfo && baseBridgeInfo.attached ? baseBridgeInfo.bridge_router_id : null;
  const bridgePeerIdRaw = baseBridgeInfo && baseBridgeInfo.attached ? baseBridgeInfo.internal_peer_router_id : null;
  const bridgeRouterId = bridgeRouterIdRaw !== undefined ? bridgeRouterIdRaw : null;
  const bridgePeerId = bridgePeerIdRaw !== undefined ? bridgePeerIdRaw : null;
  const bridgeRouterIdValue = Number.isFinite(Number(bridgeRouterId)) ? Number(bridgeRouterId) : bridgeRouterId;
  const bridgeRouterIdNum = Number(bridgeRouterId);
  const bridgePeerIdNum = Number(bridgePeerId);
    if(Number.isFinite(bridgeRouterIdNum) && Number.isFinite(bridgePeerIdNum)){
      const key = `${Math.min(bridgeRouterIdNum, bridgePeerIdNum)}-${Math.max(bridgeRouterIdNum, bridgePeerIdNum)}`;
      baseBridgeKeys.add(key);
    }
    const baseTargetMeta = baseBridgeInfo && baseBridgeInfo.attached ? (baseBridgeInfo.target || null) : null;
    const baseCluster = baseBridgeInfo && baseBridgeInfo.attached ? (baseBridgeInfo.target_cluster || null) : null;
    const container = svg.append('g').attr('class','zoom-layer');
    // Zoom + Pan
    let currentTransform = d3.zoomIdentity;
    const zoom = d3.zoom().scaleExtent([0.2, 4]).on('zoom', (event)=>{
      currentTransform = event.transform;
      container.attr('transform', currentTransform);
    });
    svg.call(zoom).on('dblclick.zoom', null);
    const nodes = [];
  const linkDescriptors = [];
    const vulnerabilityColor = '#28a745';
    (previewData.routers||[]).forEach(r=>{
      const routerIdNum = Number(r.node_id);
      const isBridge = bridgeRouterId !== null && (routerIdNum === Number(bridgeRouterId));
      nodes.push({id:r.node_id, label:r.name, type:'router', isBaseBridge: isBridge});
    });
    (previewData.hosts||[]).forEach(h=>{
      const hostId = h.node_id;
      const keyStr = String(hostId);
      const assignment = Array.isArray(h.vulnerabilities) ? h.vulnerabilities : vulnerabilitiesByNode[keyStr] || vulnerabilitiesByNode[hostId] || [];
      const vulnList = Array.isArray(assignment) ? assignment : [];
      const hasVuln = vulnList.length > 0;
      nodes.push({id:hostId, label:h.name, type:'host', hasVuln: hasVuln, vulnerabilities: vulnList});
    });
    (previewData.switches_detail||[]).forEach(sw=>{ nodes.push({id:sw.switch_id, label:'sw-'+sw.switch_id, type:'switch'}); });
    (previewData.r2r_edges_preview||[]).forEach(e=>{
      const a = Number(e[0]);
      const b = Number(e[1]);
      const key = `${Math.min(a, b)}-${Math.max(a, b)}`;
      const kind = baseBridgeKeys.has(key) ? 'base-bridge' : 'r2r';
      linkDescriptors.push({sourceId:e[0], targetId:e[1], kind});
    });
    if(baseCluster && Array.isArray(baseCluster.nodes)){
      baseCluster.nodes.forEach((baseNodeMeta, idx)=>{
        if(!baseNodeMeta) return;
        const originalId = baseNodeMeta.id !== undefined && baseNodeMeta.id !== null ? String(baseNodeMeta.id) : `idx-${idx}`;
        if(!originalId) return;
        if(baseClusterNodeMap.has(originalId)) return;
        const clusterNodeId = `base-cluster-${originalId}`;
        baseClusterNodeMap.set(originalId, clusterNodeId);
        const baseType = resolveBaseNodeType(baseNodeMeta);
        const clusterNode = {
          id: clusterNodeId,
          label: baseNodeMeta.name || `Base ${originalId}`,
          type: baseType,
          baseOriginal: baseNodeMeta,
          isBase: true,
          isBaseCluster: true,
        };
        if(baseNodeMeta.position && Number.isFinite(Number(baseNodeMeta.position.x)) && Number.isFinite(Number(baseNodeMeta.position.y))){
          clusterNode._layout = { x: Number(baseNodeMeta.position.x), y: Number(baseNodeMeta.position.y) };
        }
        nodes.push(clusterNode);
      });
    }
    let baseAnchorNodeId = null;
    if(baseClusterNodeMap.size > 0){
      const targetKey = baseTargetMeta && baseTargetMeta.id !== undefined && baseTargetMeta.id !== null ? String(baseTargetMeta.id) : null;
      if(targetKey && baseClusterNodeMap.has(targetKey)){
        baseAnchorNodeId = baseClusterNodeMap.get(targetKey);
      } else {
        baseAnchorNodeId = baseClusterNodeMap.values().next().value;
      }
    } else if(baseTargetMeta && bridgeRouterId !== null){
      const targetId = baseTargetMeta.id || 'base';
      baseAnchorNodeId = `base-target-${targetId}`;
      const baseType = resolveBaseNodeType(baseTargetMeta);
      const fallbackBaseNode = {
        id: baseAnchorNodeId,
        label: baseTargetMeta.name || 'Base Scenario',
        type: baseType,
        baseTarget: baseTargetMeta,
        isBase: true,
        isBaseExternal: true,
      };
      if(baseTargetMeta.position && Number.isFinite(Number(baseTargetMeta.position.x)) && Number.isFinite(Number(baseTargetMeta.position.y))){
        fallbackBaseNode._layout = { x: Number(baseTargetMeta.position.x), y: Number(baseTargetMeta.position.y) };
      }
      nodes.push(fallbackBaseNode);
    }
    if(baseCluster && Array.isArray(baseCluster.edges)){
      baseCluster.edges.forEach(edge => {
        if(!Array.isArray(edge) || edge.length < 2) return;
        const rawA = edge[0];
        const rawB = edge[1];
        const keyA = rawA !== undefined && rawA !== null ? String(rawA) : null;
        const keyB = rawB !== undefined && rawB !== null ? String(rawB) : null;
        if(!keyA || !keyB) return;
        const mappedA = baseClusterNodeMap.get(keyA);
        const mappedB = baseClusterNodeMap.get(keyB);
        if(!mappedA || !mappedB) return;
        linkDescriptors.push({ sourceId: mappedA, targetId: mappedB, kind: 'base-cluster' });
      });
    }
    if(baseAnchorNodeId && bridgeRouterId !== null){
      linkDescriptors.push({ sourceId: bridgeRouterIdValue, targetId: baseAnchorNodeId, kind: 'base-external' });
    }
    const hostRouterMap = previewData.host_router_map || {};
    (previewData.switches_detail||[]).forEach(sw=>{
      (sw.hosts||[]).forEach(hid=>{ linkDescriptors.push({sourceId:sw.switch_id, targetId:hid, kind:'sw-host'}); });
      linkDescriptors.push({sourceId:sw.router_id, targetId:sw.switch_id, kind:'r-sw'});
    });
    Object.entries(hostRouterMap).forEach(([hid,rid])=>{
      const hIdNum = parseInt(hid,10);
      if(!linkDescriptors.find(l=>l.kind==='sw-host' && l.targetId===hIdNum)){
        linkDescriptors.push({sourceId:rid, targetId:hIdNum, kind:'r-host'});
      }
    });

    if(hitlPreviewArtifacts && Array.isArray(hitlPreviewArtifacts.nodes)){
      hitlPreviewArtifacts.nodes.forEach(node => {
        if(!node) return;
        nodes.push({ ...node });
      });
    }

    if(hitlPreviewArtifacts && Array.isArray(hitlPreviewArtifacts.links)){
      hitlPreviewArtifacts.links.forEach(link => {
        if(!link) return;
        const sourceId = link.sourceId ?? link.source ?? null;
        const targetId = link.targetId ?? link.target ?? null;
        if(sourceId === null || targetId === null) return;
        linkDescriptors.push({ sourceId, targetId, kind: link.kind || 'hitl' });
      });
    }

    if(!nodes.length){
      svg.remove();
      wrap.append('div').attr('class','text-muted small p-2').text('No nodes to display');
      return;
    }

    registerLegendForNodes(nodes);
    addLegendSpacing();

    if(baseBridgeInfo && baseBridgeInfo.attached){
      const g = legend.append('g').attr('transform',`translate(0,${legendOffset})`);
      g.append('line')
        .attr('x1',0).attr('y1',8)
        .attr('x2',24).attr('y2',8)
        .attr('stroke','#6f42c1')
        .attr('stroke-width',4)
        .attr('stroke-linecap','round');
      g.append('text').text('Bridge to Base Scenario').attr('x',28).attr('y',12).attr('font-size','11px');
      legendOffset += 20;
    }

    const layoutPositions = previewData.layout_positions;
    const layoutMaps = (layoutPositions && !layoutPositions.error && typeof layoutPositions === 'object')
      ? {
          routers: layoutPositions.routers || {},
          switches: layoutPositions.switches || {},
          hosts: layoutPositions.hosts || {},
        }
      : null;

    function layoutCoordForNode(node){
      if(!layoutMaps) return null;
      let table = null;
      if(node.type === 'router') table = layoutMaps.routers;
      else if(node.type === 'switch') table = layoutMaps.switches;
      else if(node.isBase){
        if(node._layout) return node._layout;
        return null;
      }
      else table = layoutMaps.hosts;
      if(!table) return null;
      const key = String(node.id);
      const raw = table[key] || table[node.id];
      if(!raw) return null;
      const x = Number(raw.x);
      const y = Number(raw.y);
      if(Number.isFinite(x) && Number.isFinite(y)) return {x, y};
      return null;
    }
    const layoutCoords = [];
    if(layoutMaps){
      nodes.forEach(n => {
        let pos = layoutCoordForNode(n);
        if(!pos && n.isBase && n._layout){
          pos = n._layout;
        }
        if(pos){
          n._layout = pos;
          layoutCoords.push(pos);
        } else if(n._layout && n.isBase){
          layoutCoords.push(n._layout);
        }
      });
    }

    const margin = 40;
    const innerWidth = Math.max(width - margin * 2, 200);
    const innerHeight = Math.max(height - margin * 2, 200);
    let usingLayout = layoutCoords.length > 0;
    const staticOriginalPositions = new Map();
    let resetStaticPositions = null;
    function applyRowJitter(list){
      const buckets = new Map();
      list.forEach(node => {
        if(!Number.isFinite(node.y)) return;
  if(node.isBase) return;
        const base = node._layout ? node._layout.y : node.y;
        if(!Number.isFinite(base)) return;
        const key = Math.round(base * 1000);
        const bucket = buckets.get(key);
        if(bucket){
          bucket.push(node);
        } else {
          buckets.set(key, [node]);
        }
      });
      buckets.forEach(group => {
        if(group.length <= 1) return;
        group.sort((a,b)=> String(a.id).localeCompare(String(b.id)));
        const mid = (group.length - 1) / 2;
        const spacing = 8;
        group.forEach((node, idx)=>{
          node.y += (idx - mid) * spacing;
        });
      });
    }
    let scale = 1;
    let offsetX = margin;
    let offsetY = margin;
    if(usingLayout && layoutCoords.length){
      let minX = layoutCoords[0].x;
      let maxX = layoutCoords[0].x;
      let minY = layoutCoords[0].y;
      let maxY = layoutCoords[0].y;
      for(const coord of layoutCoords){
        if(coord.x < minX) minX = coord.x;
        if(coord.x > maxX) maxX = coord.x;
        if(coord.y < minY) minY = coord.y;
        if(coord.y > maxY) maxY = coord.y;
      }
      const spanX = Math.max(1, maxX - minX);
      const spanY = Math.max(1, maxY - minY);
      scale = Math.min(innerWidth / spanX, innerHeight / spanY);
      if(!Number.isFinite(scale) || scale <= 0){
        scale = 1;
        usingLayout = false;
      } else {
        offsetX = margin + (innerWidth - spanX * scale) / 2 - minX * scale;
        offsetY = margin + (innerHeight - spanY * scale) / 2 - minY * scale;
      }
    }

    if(usingLayout){
      nodes.forEach(n => {
        if(n._layout){
          n.x = offsetX + n._layout.x * scale;
          n.y = offsetY + n._layout.y * scale;
        } else {
          n.x = width / 2 + Math.random() * 40 - 20;
          n.y = height / 2 + Math.random() * 40 - 20;
        }
      });
      applyRowJitter(nodes);
      nodes.forEach(n => {
        n.layoutX = n.x;
        n.layoutY = n.y;
        if(Number.isFinite(n.x) && Number.isFinite(n.y)){
          staticOriginalPositions.set(n.id, { x: n.x, y: n.y });
        }
      });
    } else {
      nodes.forEach(n => {
        n.x = width / 2 + Math.random() * 80 - 40;
        n.y = height / 2 + Math.random() * 80 - 40;
        n.layoutX = undefined;
        n.layoutY = undefined;
      });
    }

    const simLinks = linkDescriptors.map(l => ({...l, source: l.sourceId, target: l.targetId}));

    const link = container.selectAll('line').data(simLinks).enter().append('line')
      .attr('stroke', l=> {
        if(l.kind === 'base-bridge' || l.kind === 'base-external' || l.kind === 'base-cluster') return '#6f42c1';
        if(l.kind === 'r2r') return '#007bff';
        if(l.kind === 'hitl' || l.kind === 'hitl-peer' || l.kind === 'hitl-network') return '#20c997';
        return (l.kind === 'r-sw' ? '#28a745' : '#999');
      })
      .attr('stroke-width', l=> {
        if(l.kind === 'base-cluster') return 3;
        if(l.kind === 'base-bridge' || l.kind === 'base-external') return 4;
        if(l.kind === 'hitl' || l.kind === 'hitl-peer' || l.kind === 'hitl-network') return 2.4;
        return l.kind === 'r2r' ? 2 : 1.2;
      })
      .attr('stroke-linecap', l=> (l.kind === 'base-bridge' || l.kind === 'base-external' || l.kind === 'base-cluster') ? 'round' : null)
      .attr('stroke-dasharray', l=> {
        if(l.kind === 'r-host') return '3,3';
        if(l.kind === 'hitl-network') return '4,2';
        return null;
      })
      .attr('opacity', 0.85);
    const node = container.selectAll('g.node').data(nodes).enter().append('g').attr('class','node');
    const hasVulnerableHosts = nodes.some(n => n.type === 'host' && n.hasVuln);
    if(hasVulnerableHosts){
      const vulnLegend = legend.append('g').attr('transform',`translate(0,${legendOffset})`);
      const vulnLegendSymbol = d3.symbol().type(d3.symbolStar).size(80);
      vulnLegend.append('path')
        .attr('d', vulnLegendSymbol)
        .attr('transform','translate(8,8)')
        .attr('fill', vulnerabilityColor)
        .attr('stroke', '#333')
        .attr('stroke-width', 1);
      vulnLegend.append('text')
        .text('Host (vulnerable)')
        .attr('x', 18)
        .attr('y', 12)
        .attr('font-size','11px');
      legendOffset += 20;
    }
    const normalNode = node.filter(d => !(d.type === 'host' && d.hasVuln));
    normalNode.each(function(d){
      const nodeGroup = d3.select(this);
      const style = nodeStyleForType(d.type);
      if(style.shape === 'square'){
        const side = (Number.isFinite(style.radius) ? style.radius : 6) * 2;
        nodeGroup.append('rect')
          .attr('x', -side / 2)
          .attr('y', -side / 2)
          .attr('width', side)
          .attr('height', side)
          .attr('rx', 2)
          .attr('ry', 2)
          .attr('fill', style.color)
          .attr('stroke', (d.isBase || d.isBaseBridge) ? '#6f42c1' : '#333')
          .attr('stroke-width', d.isBaseBridge ? 3 : d.isBase ? 2 : 1.1);
      } else {
        const radius = Number.isFinite(style.radius) ? style.radius : 6;
        nodeGroup.append('circle')
          .attr('r', radius)
          .attr('fill', style.color)
          .attr('stroke', (d.isBase || d.isBaseBridge) ? '#6f42c1' : '#333')
          .attr('stroke-width', d.isBaseBridge ? 3 : d.isBase ? 2 : 1.1);
      }
    });
    const vulnNode = node.filter(d => d.type === 'host' && d.hasVuln);
    const vulnSymbol = d3.symbol().type(d3.symbolStar).size(140);
    vulnNode.append('path')
      .attr('d', vulnSymbol)
      .attr('fill', vulnerabilityColor)
      .attr('stroke', '#333')
      .attr('stroke-width', 1);
    const simulation = d3.forceSimulation(nodes)
      .force('link', d3.forceLink(simLinks).id(d=>d.id).distance(l=> {
        if(l.kind === 'base-cluster') return 60;
        if(l.kind === 'base-bridge' || l.kind === 'base-external') return 95;
        if(l.kind === 'hitl' || l.kind === 'hitl-peer') return 70;
        if(l.kind === 'hitl-network') return 55;
        return l.kind==='r2r'? 80 : (l.kind==='r-sw'? 60 : 40);
      }).strength(l => {
        if(l.kind === 'base-cluster') return 0.9;
        if(l.kind === 'base-bridge' || l.kind === 'base-external') return 0.7;
        if(l.kind === 'hitl' || l.kind === 'hitl-peer' || l.kind === 'hitl-network') return 0.6;
        return 0.6;
      }))
      .force('charge', d3.forceManyBody().strength(d => d.type === 'base' ? -160 : -210))
      .force('center', d3.forceCenter(width/2, height/2))
      .force('layoutX', d3.forceX(d => Number.isFinite(d.layoutX) ? d.layoutX : width/2).strength(usingLayout ? 0.18 : 0.04))
      .force('layoutY', d3.forceY(d => Number.isFinite(d.layoutY) ? d.layoutY : height/2).strength(usingLayout ? 0.18 : 0.04));

    simulation.alpha(1).alphaTarget(0.03).restart();

    link.data(simLinks, d=>`${d.source}-${d.target}`);

    simulation.on('tick', ()=>{
      link
        .attr('x1', d=>d.source.x)
        .attr('y1', d=>d.source.y)
        .attr('x2', d=>d.target.x)
        .attr('y2', d=>d.target.y);
      node.attr('transform', d=>`translate(${d.x},${d.y})`);
    });

    node.call(d3.drag().on('start', dragstarted).on('drag', dragged).on('end', dragended));

    let sim = simulation;

    if(usingLayout){
      resetStaticPositions = () => {
        nodes.forEach(n => {
          const orig = staticOriginalPositions.get(n.id);
          if(orig){
            n.layoutX = orig.x;
            n.layoutY = orig.y;
            n.x = orig.x;
            n.y = orig.y;
            n.vx = 0;
            n.vy = 0;
            n.fx = null;
            n.fy = null;
          }
        });
        simulation.alpha(0.55).restart();
      };
    }
    // Build quick lookup structures for tooltips
  const servicesByNode = previewData.services_preview || {}; // { node_id: [service,...] }
  const vulnsByNode = vulnerabilitiesByNode;
  const segRules = (previewData.segmentation_preview && previewData.segmentation_preview.rules) || []; // rules with node_id
    const segCountByNode = {};
    segRules.forEach(r=>{ const nid = r.node_id; segCountByNode[nid] = (segCountByNode[nid]||0)+1; });
    // Traffic summary (if present) - attempt to infer send/recv counts
  const trafficSummary = previewData.traffic_summary || previewData.traffic_plan || {}; // optional future field
    const trafficSend = {};
    const trafficRecv = {};
    try {
      (trafficSummary.flows || trafficSummary || []).forEach(f=>{
        const s = f.src_id ?? f.src ?? null; const d = f.dst_id ?? f.dst ?? null;
        if(s!==null) trafficSend[s] = (trafficSend[s]||0)+1;
        if(d!==null) trafficRecv[d] = (trafficRecv[d]||0)+1;
      });
    } catch(e){}
    function nodeTooltip(d){
      const id = d.id;
      const svc = servicesByNode[id] || [];
      const vul = vulnsByNode[id] || [];
      const segC = segCountByNode[id] || 0;
      const ts = trafficSend[id] || 0;
      const tr = trafficRecv[id] || 0;
      if(d.type === 'base'){
        const target = d.baseTarget || {};
        const path = baseBridgeInfo?.filepath || baseBridgeInfo?.filepath_raw || '';
        return `${d.label || 'Base Scenario'} (base)\nPath: ${path || '-'}\nNode ID: ${target.id || '-'} (${target.type || 'router'})`;
      }
      return `${d.label} (${d.type})\nServices: ${svc.join(',')||'-'}\nVulns: ${vul.join(',')||'-'}\nSegRules: ${segC}\nTraffic S:${ts} R:${tr}`;
    }
  // Tooltip removed per request
    // Populate Node Sections table
    try {
      const tbody = document.querySelector('#nodeSectionsTable tbody');
      if(tbody){
  const hitlNodesForTable = (hitlPreviewArtifacts && Array.isArray(hitlPreviewArtifacts.nodes))
    ? hitlPreviewArtifacts.nodes.filter(Boolean).map(node => {
        const iface = node.hitlInterface || null;
        const primaryIpv4 = iface && Array.isArray(iface.ipv4) && iface.ipv4.length ? iface.ipv4[0]
          : (typeof iface?.ipv4 === 'string' ? iface.ipv4 : (node.ip4 || ''));
        return {
          node_id: node.id,
          name: node.label || node.name || String(node.id),
          _type: node.isHitl ? 'rj45' : (node.isHitlNetwork ? 'network' : canonicalNodeType(node.type)),
          role: node.isHitl ? 'hitl' : (node.isHitlNetwork ? 'network' : (node.type || 'node')),
          hitlInterface: iface,
          hitlAttachment: node.attachment || (iface && iface.attachment) || DEFAULT_HITL_ATTACHMENT,
          hitlAssignment: node.assignment || null,
          hitlUplinkRouterId: node.uplinkRouterId || null,
          ip4: primaryIpv4,
          isHitlNetwork: !!node.isHitlNetwork,
        };
      })
    : [];
  const allNodes = [...(previewData.routers||[]).map(r=>({...r, _type:'router'})), ...(previewData.hosts||[]).map(h=>({...h, _type:'host'})), ...(previewData.switches_detail||[]).map(s=>({...s, node_id:s.switch_id, name:'sw-'+s.switch_id, _type:'switch'})), ...hitlNodesForTable];
  if(!allNodes.length){ tbody.innerHTML = '<tr><td colspan="10" class="text-muted fst-italic">(no nodes)</td></tr>'; return; }
        const switchesDetail = previewData.switches_detail || [];
        const rowsHtml = allNodes.map(n=>{
          const nid = n.node_id;
          const svc = (servicesByNode[nid]||[]).join(',');
          const vul = (vulnsByNode[nid]||[]).join(',');
          const segC = segCountByNode[nid]||0;
          const ts = trafficSend[nid]||0;
          const tr = trafficRecv[nid]||0;
          let primaryIp = n.ip4 || '';
          if(!primaryIp && n.switch_ip) primaryIp = n.switch_ip;
          if(!primaryIp && n.router_ip) primaryIp = n.router_ip;
          let ifaceParts = [];
          if(n._type === 'router'){
            const r2rInterfaces = n.r2r_interfaces || {};
            Object.keys(r2rInterfaces).sort((a,b)=> Number(a) - Number(b)).forEach(nb=>{
              ifaceParts.push(`r${nb}:${r2rInterfaces[nb]}`);
            });
            switchesDetail.filter(sw => sw.router_id === nid).forEach(sw=>{
              ifaceParts.push(`sw-${sw.switch_id}:${sw.router_ip || '-'}`);
            });
            if(n.hitlUplinkRouterId){
              ifaceParts.push(`uplink-router:${n.hitlUplinkRouterId}`);
            }
          } else if(n._type === 'switch'){
            if(typeof n.router_id !== 'undefined'){
              ifaceParts.push(`router:${n.router_id}→${n.router_ip || '-'}`);
            }
            if(n.switch_ip){ ifaceParts.push(`uplink:${n.switch_ip}`); }
            const hostIf = n.host_if_ips || {};
            Object.keys(hostIf).sort((a,b)=> Number(a) - Number(b)).forEach(hid=>{
              ifaceParts.push(`h${hid}:${hostIf[hid]}`);
            });
            if(n.hitlUplinkRouterId){
              ifaceParts.push(`uplink-router:${n.hitlUplinkRouterId}`);
            }
          } else if(n._type === 'host'){
            const routerForHost = hostRouterMap[nid] ?? hostRouterMap[String(nid)];
            if(routerForHost){ ifaceParts.push(`router:${routerForHost}`); }
          } else if(n._type === 'rj45'){
            const hi = n.hitlInterface || {};
            if(hi && typeof hi === 'object'){
              if(hi.name && hi.name !== n.name){ ifaceParts.push(`iface:${hi.name}`); }
              if(hi.mac){ ifaceParts.push(`mac:${hi.mac}`); }
              if(Array.isArray(hi.ipv4) && hi.ipv4.length){ ifaceParts.push(`ipv4:${hi.ipv4.join(',')}`); }
              if(Array.isArray(hi.ipv6) && hi.ipv6.length){ ifaceParts.push(`ipv6:${hi.ipv6.join(',')}`); }
            }
            if(n.hitlAttachment){ ifaceParts.push(`attach:${n.hitlAttachment}`); }
            if(n.hitlAssignment && n.hitlAssignment !== n.hitlAttachment){ ifaceParts.push(`assigned:${n.hitlAssignment}`); }
            if(n.hitlUplinkRouterId){ ifaceParts.push(`uplink-router:${n.hitlUplinkRouterId}`); }
          } else if(n._type === 'network' && n.isHitlNetwork){
            ifaceParts.push('RJ45 isolated network');
          }
          const ifaceStr = ifaceParts.length ? ifaceParts.join('; ') : '-';
          const primaryIpStr = primaryIp || '-';
          return `<tr><td>${nid}</td><td>${n.name||('node-'+nid)}</td><td>${n._type}</td><td>${primaryIpStr}</td><td>${ifaceStr}</td><td>${svc}</td><td>${vul}</td><td>${segC}</td><td>${ts}</td><td>${tr}</td></tr>`;
        }).join('');
        tbody.innerHTML = rowsHtml || '<tr><td colspan="10" class="text-muted fst-italic">(none)</td></tr>';
      }
    } catch(e) { console.warn('node section table build failed', e); }
  // Node labels removed per request
  function dragstarted(event,d){
    try { event.sourceEvent?.stopPropagation?.(); } catch(e){}
    if(sim && !event.active){ sim.alphaTarget(0.35).restart(); }
    d.fx = d.x;
    d.fy = d.y;
  }
  function dragged(event,d){ d.fx = event.x; d.fy = event.y; }
  function dragended(event,d){
    if(sim && !event.active){ sim.alphaTarget(0.03); }
    d.fx = d.x;
    d.fy = d.y;
    d.layoutX = d.x;
    d.layoutY = d.y;
  }
    // Wire zoom control buttons
    const zoomInBtn = document.getElementById('zoomInBtn');
    const zoomOutBtn = document.getElementById('zoomOutBtn');
    const zoomResetBtn = document.getElementById('zoomResetBtn');
    if(zoomInBtn){ zoomInBtn.onclick = ()=> svg.transition().duration(200).call(zoom.scaleBy, 1.2); }
    if(zoomOutBtn){ zoomOutBtn.onclick = ()=> svg.transition().duration(200).call(zoom.scaleBy, 1/1.2); }
    if(zoomResetBtn){
      zoomResetBtn.onclick = ()=>{
        svg.transition().duration(250).call(zoom.transform, d3.zoomIdentity);
        if(resetStaticPositions) resetStaticPositions();
      };
    }
    // Improve grab cursor feedback
    svg.on('mousedown', ()=> svg.style('cursor','grabbing'));
    window.addEventListener('mouseup', ()=> svg.style('cursor','grab'));
  // Close buildGraph function before invoking it
  } // END buildGraph
  // Invoke graph build after definitions
  buildGraph();
  setupPreviewCollapsers();
  // Unified scripts listing modal logic
  function openScriptsModal(initialKind){
    const modalEl = document.getElementById('scriptsListingModal');
    if(!modalEl) return;
    // Ensure modal is a direct body child to avoid stacking/overflow clipping inside tab panes
    if(!modalEl.__appendedToBody){
      document.body.appendChild(modalEl);
      modalEl.__appendedToBody = true;
    }
    if(window.bootstrap){
      const m = (window.bootstrap.Modal.getOrCreateInstance
        ? window.bootstrap.Modal.getOrCreateInstance(modalEl)
        : new bootstrap.Modal(modalEl));
      m.show();
    } else { modalEl.style.display='block'; }
    const targetKind = initialKind || 'traffic';
    const firstBtn = modalEl.querySelector(`button[data-kind='${targetKind}'][data-scope='preview']`) || modalEl.querySelector('button[data-kind]');
    if(firstBtn){ loadScriptsListing(firstBtn.getAttribute('data-kind'), firstBtn.getAttribute('data-scope')); }
  }
  function loadScriptsListing(kind, scope){
    if(window.__SCRIPTS_LISTING_IN_FLIGHT__) return;
    window.__SCRIPTS_LISTING_IN_FLIGHT__ = true;
    const status = document.getElementById('scriptsListingStatus');
    const tbody = document.querySelector('#scriptsListingTable tbody');
    status.textContent = `Loading ${scope} ${kind} scripts...`;
    tbody.innerHTML = `<tr><td colspan="3" class="text-muted fst-italic">Loading...</td></tr>`;
    fetch(`/api/open_scripts?kind=${kind}&scope=${scope}`).then(r=>r.json()).then(d=>{
      if(!d.ok){ status.textContent = `Failed: ${d.error||'error'}`; tbody.innerHTML = '<tr><td colspan="3" class="text-danger">Error loading scripts</td></tr>'; return; }
      status.textContent = `${d.files.length} file(s)`;
      if(d.files.length===0){ tbody.innerHTML = '<tr><td colspan="3" class="text-muted fst-italic">(none)</td></tr>'; return; }
      const rows = d.files.slice(0,500).map(f=>{
        const safe = f.file.replace(/"/g,'&quot;');
        return `<tr><td class="small"><code>${safe}</code></td><td class="text-end small">${f.size}</td><td class="small"><div class="btn-group btn-group-sm" role="group"><button type="button" class="btn btn-outline-primary" data-action="view" data-file="${safe}" data-kind="${kind}" data-scope="${scope}">View</button></div></td></tr>`;
      }).join('');
      tbody.innerHTML = rows;
    }).catch(e=>{ status.textContent = 'Error'; tbody.innerHTML = `<tr><td colspan="3" class="text-danger">${e}</td></tr>`; })
      .finally(()=>{ setTimeout(()=>{ window.__SCRIPTS_LISTING_IN_FLIGHT__ = false; }, 120); });
  }
  document.getElementById('scriptsListingModal')?.addEventListener('click', (e)=>{
    const btn = e.target.closest('button[data-kind][data-scope]');
    if(btn && !btn.dataset.action){
      loadScriptsListing(btn.getAttribute('data-kind'), btn.getAttribute('data-scope'));
      return;
    }
    const actionBtn = e.target.closest('button[data-action="view"]');
    if(actionBtn){
      const file = actionBtn.getAttribute('data-file');
      const kind = actionBtn.getAttribute('data-kind');
      const scope = actionBtn.getAttribute('data-scope');
      viewScript(kind, scope, file);
    }
  });
  function viewScript(kind, scope, file){
    fetch(`/api/open_script_file?kind=${kind}&scope=${scope}&file=${encodeURIComponent(file)}`).then(r=>r.json()).then(d=>{
      if(!d.ok){ alert('Failed to load script: '+(d.error||'')); return; }
      const pre = document.getElementById('segScriptContent');
      pre.textContent = d.content || '(no content)';
      const modalEl = document.getElementById('segScriptModal');
      if(!modalEl.__appendedToBody){
        document.body.appendChild(modalEl);
        modalEl.__appendedToBody = true;
      }
      if(window.bootstrap){
        // Reuse or create a single instance to avoid stacking backdrops; guard against double show within 200ms
        const now = Date.now();
        if(modalEl.__lastShowTs && (now - modalEl.__lastShowTs) < 200){
          return; // prevent rapid double triggering
        }
        modalEl.__lastShowTs = now;
        const m = (window.bootstrap.Modal.getOrCreateInstance
          ? window.bootstrap.Modal.getOrCreateInstance(modalEl)
          : new bootstrap.Modal(modalEl));
        if(!modalEl.__attachedBackdropCleaner){
          modalEl.addEventListener('hidden.bs.modal', ()=>{
            const backs = document.querySelectorAll('.modal-backdrop');
            if(backs.length > 1){ backs.forEach((b,i)=>{ if(i < backs.length-1) b.remove(); }); }
            document.body.classList.remove('modal-open');
            document.body.style.removeProperty('padding-right');
          });
          modalEl.__attachedBackdropCleaner = true;
        }
        m.show();
      } else {
        // Fallback manual modal (no bootstrap JS loaded)
        modalEl.style.display='block';
        modalEl.style.background='rgba(0,0,0,0.5)';
        // Wire close buttons manually
        modalEl.querySelectorAll('[data-bs-dismiss="modal"]').forEach(btn=>{
          if(!btn.__manualCloseBound){
            btn.addEventListener('click', ()=>{ modalEl.style.display='none'; modalEl.style.background=''; });
            btn.__manualCloseBound = true;
          }
        });
      }
    }).catch(e=> alert('Error fetching script: '+e));
  }
  function attachScriptDelegation(containerId, fallbackKind){
    const el = document.getElementById(containerId);
    if(!el) return;
    el.addEventListener('click', (e)=>{
      const btn = e.target.closest('.view-script-btn');
      if(!btn) return;
      const file = btn.getAttribute('data-file');
      if(!file) return;
      const kind = btn.getAttribute('data-kind') || fallbackKind || 'segmentation';
      const scope = btn.getAttribute('data-scope') || 'preview';
      viewScript(kind, scope, file);
    });
  }
  attachScriptDelegation('fp-seg', 'segmentation');
  attachScriptDelegation('fp-traffic', 'traffic');

  // --------- Color-coded badges & collapsible tables ---------
  function applySegmentationRowStyling(){
    const table = document.getElementById('segRulesTable');
    if(!table) return;
    const rows = table.querySelectorAll('tbody tr');
    rows.forEach((tr)=>{
      const cells = tr.children;
      if(cells.length < 3) return;
      const typeCell = cells[2];
      const ruleType = (typeCell.textContent||'').trim().toLowerCase();
      let badgeClass = 'bg-secondary';
      if(ruleType === 'nat') badgeClass = 'bg-info';
      else if(ruleType === 'subnet_block') badgeClass = 'bg-danger';
      else if(ruleType === 'host_block') badgeClass = 'bg-danger-subtle border border-danger';
      else if(ruleType === 'protect_internal') badgeClass = 'bg-warning';
      else if(ruleType === 'allow') badgeClass = 'bg-success';
      else if(ruleType === 'dnat') badgeClass = 'bg-primary';
      else if(ruleType === 'custom') badgeClass = 'bg-purple';
      typeCell.innerHTML = `<span class="badge ${badgeClass} text-dark" style="min-width:70px;display:inline-block;">${typeCell.textContent.trim()||'-'}</span>`;
    });
  }
  function applyTrafficRowStyling(){
    const table = document.getElementById('trafficFlowsTable');
    if(!table) return;
    const rows = table.querySelectorAll('tbody tr');
    const limit = 40; // slightly higher for flows
    let hiddenCt = 0;
    rows.forEach((tr, idx)=>{
      const protoCell = tr.children[5];
      if(protoCell){
        const proto = (protoCell.textContent||'').trim().toLowerCase();
        let cls = 'bg-secondary';
        if(proto==='tcp') cls='bg-success'; else if(proto==='udp') cls='bg-info'; else if(proto==='icmp') cls='bg-warning';
        protoCell.innerHTML = `<span class="badge ${cls} text-dark">${proto||'-'}</span>`;
      }
      if(idx >= limit){
        tr.classList.add('d-none','traffic-extra-row'); hiddenCt++; }
    });
    if(hiddenCt>0){
      const toggleBtn = document.createElement('button');
      toggleBtn.type='button'; toggleBtn.className='btn btn-sm btn-outline-secondary my-1';
      toggleBtn.id='trafficShowMoreBtn';
      toggleBtn.textContent=`Show ${hiddenCt} more flows`;
      table.parentElement.insertBefore(toggleBtn, table);
      toggleBtn.addEventListener('click', ()=>{
        const hidden = table.querySelectorAll('tbody tr.traffic-extra-row');
        const collapsed = toggleBtn.getAttribute('data-collapsed') !== 'false';
        if(collapsed){
          hidden.forEach(r=> r.classList.remove('d-none'));
          toggleBtn.textContent='Collapse flows';
          toggleBtn.setAttribute('data-collapsed','false');
        } else {
          hidden.forEach(r=> r.classList.add('d-none'));
          toggleBtn.textContent=`Show ${hiddenCt} more flows`;
          toggleBtn.setAttribute('data-collapsed','true');
        }
      });
    }
  }
  // Delay styling until after DOM is built
  setTimeout(()=>{ applySegmentationRowStyling(); applyTrafficRowStyling(); }, 0);
  }
  if(document.readyState === 'loading') document.addEventListener('DOMContentLoaded', init); else init();
  // Export JSON
  document.getElementById('exportJsonBtn')?.addEventListener('click', ()=>{
    try {
  const blob = new Blob([JSON.stringify(previewData, null, 2)], {type:'application/json'});
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
  a.download = 'full_preview_seed_'+(previewData.seed||'na')+'.json';
      document.body.appendChild(a); a.click(); a.remove();
      setTimeout(()=>URL.revokeObjectURL(a.href), 5000);
    } catch(e){ console.error('Export JSON failed', e); }
  });
  // Export Graph PNG
  document.getElementById('exportPngBtn')?.addEventListener('click', ()=>{
    try {
      const svg = document.querySelector('#previewGraph svg');
      if(!svg){ alert('Graph not ready'); return; }
      const serializer = new XMLSerializer();
      const svgStr = serializer.serializeToString(svg);
      const canvas = document.createElement('canvas');
      const rect = svg.getBoundingClientRect();
      canvas.width = rect.width * 2; canvas.height = rect.height * 2; // retina
      const ctx = canvas.getContext('2d');
      const img = new Image();
      img.onload = function(){
        ctx.fillStyle = '#ffffff'; ctx.fillRect(0,0,canvas.width,canvas.height);
        ctx.drawImage(img,0,0,canvas.width,canvas.height);
        canvas.toBlob(b=>{
          const a = document.createElement('a');
          a.href = URL.createObjectURL(b); a.download='full_preview_graph_'+(previewData.seed||'na')+'.png';
          document.body.appendChild(a); a.click(); a.remove();
          setTimeout(()=>URL.revokeObjectURL(a.href), 5000);
        });
      };
      img.src = 'data:image/svg+xml;base64,'+btoa(unescape(encodeURIComponent(svgStr)));
    } catch(e){ console.error('Export PNG failed', e); }
  });

  let executeProgressModalInst = null;
  let executeProgressEvtSrc = null;
  let executeProgressRunId = null;

  function ensureExecuteProgressModal(){
    const modalEl = document.getElementById('executeProgressModal');
    if(!modalEl) return null;
    if(!executeProgressModalInst && window.bootstrap){
      executeProgressModalInst = new bootstrap.Modal(modalEl, { backdrop: 'static', keyboard: false });
    }
    return executeProgressModalInst;
  }

  function setExecuteProgressUI(opts){
    const { status, meta, barText, animate } = opts || {};
    const statusEl = document.getElementById('executeProgressStatus');
    if(statusEl !== null && status !== undefined){ statusEl.textContent = status; }
    const metaEl = document.getElementById('executeProgressMeta');
    if(metaEl !== null && meta !== undefined){ metaEl.textContent = meta; }
    const bar = document.getElementById('executeProgressBar');
    if(bar){
      if(barText !== undefined){ bar.textContent = barText; }
      if(animate === true){ bar.classList.add('progress-bar-animated','progress-bar-striped'); }
      else if(animate === false){ bar.classList.remove('progress-bar-animated','progress-bar-striped'); }
    }
  }

  function openExecuteProgress(title){
    const inst = ensureExecuteProgressModal();
    const modalEl = document.getElementById('executeProgressModal');
    if(modalEl && title){
      const titleEl = modalEl.querySelector('.modal-title');
      if(titleEl) titleEl.textContent = title;
    }
    setExecuteProgressUI({ status: 'Starting…', meta: '', barText: 'Working…', animate: true });
    const logEl = document.getElementById('executeProgressLog');
    if(logEl) logEl.textContent = '';
    try { inst?.show(); } catch(e){}
  }

  function appendExecuteProgressLog(line){
    const logEl = document.getElementById('executeProgressLog');
    if(!logEl) return;
    const text = (line === undefined || line === null) ? '' : String(line);
    logEl.textContent += text + '\n';
    logEl.parentElement?.scrollTo({ top: logEl.parentElement.scrollHeight, behavior: 'auto' });
  }

  function cleanupExecuteProgress(){
    if(executeProgressEvtSrc){
      try { executeProgressEvtSrc.close(); } catch(e){}
    }
    executeProgressEvtSrc = null;
    executeProgressRunId = null;
  }

  document.getElementById('executeProgressModal')?.addEventListener('hidden.bs.modal', ()=>{
    cleanupExecuteProgress();
  });

  // Execute: start CLI run for provided xml_path
  const executeRunBtn = document.getElementById('executeRunBtn');
  if(executeRunBtn && !executeRunBtn.dataset.boundExecute){
    executeRunBtn.dataset.boundExecute = '1';
    let executing = false;
    const originalLabel = executeRunBtn.textContent;
    executeRunBtn.addEventListener('click', async ()=>{
      if(executing) return;
      const confirmMsg = 'Execute scenario now? This will invoke the CLI and start a CORE session.';
      if(!window.confirm(confirmMsg)) return;
      executing = true;
      executeRunBtn.disabled = true;
      if(originalLabel){ executeRunBtn.textContent = 'Executing…'; }
      try {
        openExecuteProgress('Executing scenario…');
        appendExecuteProgressLog('Submitting run for {{ xml_path }}');
        cleanupExecuteProgress();
        const form = new FormData(); form.append('xml_path', '{{ xml_path }}');
        const planPath = executeRunBtn.getAttribute('data-preview-plan');
        if(planPath){ form.append('preview_plan', planPath); }
        const res = await fetch("{{ url_for('run_cli_async') }}", { method: 'POST', body: form });
        if(!res.ok){
          appendExecuteProgressLog('Failed to start execution (HTTP '+res.status+')');
          setExecuteProgressUI({ status: 'Failed to start', meta: 'HTTP '+res.status, barText: 'Error', animate: false });
          return;
        }
        const initData = await res.json();
        const run_id = initData?.run_id;
        if(!run_id){
          appendExecuteProgressLog('Execution start response missing run_id');
          setExecuteProgressUI({ status: 'Failed to start', meta: 'Missing run id', barText: 'Error', animate: false });
          return;
        }
        appendExecuteProgressLog('Run ID: '+run_id);
        setExecuteProgressUI({ status: 'Running…', meta: 'Streaming logs…', barText: 'Working…', animate: true });
        executeProgressRunId = run_id;
        executeProgressEvtSrc = new EventSource('/stream/' + run_id);
        executeProgressEvtSrc.onmessage = (ev)=>{
          if(ev && typeof ev.data === 'string'){
            appendExecuteProgressLog(ev.data);
          }
        };
        executeProgressEvtSrc.addEventListener('end', ()=>{
          appendExecuteProgressLog('Execution stream ended');
          cleanupExecuteProgress();
        });
        (async function poll(){
          try {
            const r = await fetch('/run_status/' + run_id);
            if(!r.ok){ setTimeout(poll, 1200); return; }
            const data = await r.json();
            if(!data.done){ setTimeout(poll, 1000); return; }
            cleanupExecuteProgress();
            if(data.returncode===0){
              appendExecuteProgressLog('Execution complete: success; redirecting to Reports');
              setExecuteProgressUI({ status: 'Scenario started', meta: 'Completed', barText: 'Done', animate: false });
              setTimeout(()=>{ window.location.href = "{{ url_for('reports_page') }}"; }, 700);
            } else {
              appendExecuteProgressLog('Execution finished with errors (code '+data.returncode+')');
              setExecuteProgressUI({ status: 'Finished with errors', meta: 'Code '+data.returncode, barText: 'Error', animate: false });
            }
          } catch(e){ setTimeout(poll, 1500); }
        })();
      } catch(e){
        appendExecuteProgressLog('Exception starting execution: '+e);
        setExecuteProgressUI({ status: 'Exception starting run', meta: '', barText: 'Error', animate: false });
        cleanupExecuteProgress();
      }
      finally {
        executeRunBtn.disabled = false;
        if(originalLabel){ executeRunBtn.textContent = originalLabel; }
        executing = false;
      }
    });
  }
})();
</script>
{% endblock %} {# end extra_scripts #}
{% endblock %} {# end content #}
