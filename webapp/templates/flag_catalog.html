{% extends "layout.html" %}

{% block content %}
<div class="container-fluid">
  <div class="row">
    <div class="col-12">
      <ul class="nav nav-tabs" id="flagTabs" role="tablist">
        <li class="nav-item" role="presentation">
          <button class="nav-link active" id="flagGenSourcesTab" data-bs-toggle="tab" data-bs-target="#flagGenSources" type="button" role="tab">Generator Sources</button>
        </li>
        <li class="nav-item" role="presentation">
          <button class="nav-link" id="flagGeneratorsTab" data-bs-toggle="tab" data-bs-target="#flagGenerators" type="button" role="tab">Flag-Generators</button>
        </li>
        <li class="nav-item" role="presentation">
          <button class="nav-link" id="flagNodeGeneratorsTab" data-bs-toggle="tab" data-bs-target="#flagNodeGenerators" type="button" role="tab">Flag-Node-Generators</button>
        </li>
        <li class="nav-item" role="presentation">
          <a class="nav-link" id="flagGeneratorBuilderTab" href="{{ url_for('generator_builder_page') }}"><i class="bi bi-wrench-adjustable me-1"></i>Generator Builder</a>
        </li>
      </ul>

      <div class="tab-content mt-3">
        <div class="tab-pane fade show active" id="flagGenSources" role="tabpanel">
          <h5 class="mb-2">Flag-Generator Sources</h5>
          <div class="card mb-3">
            <div class="card-body">
              <form class="row g-2" action="{{ url_for('flag_generators_sources_upload') }}" method="post" enctype="multipart/form-data">
                <div class="col-auto">
                  <input class="form-control" type="file" name="json_file" accept="application/json,.json" required>
                </div>
                <div class="col-auto">
                  <button class="btn btn-primary" type="submit">Upload JSON</button>
                </div>
                <div class="col-auto">
                  <a class="btn btn-outline-secondary" href="{{ url_for('flag_generators_sources_export_all') }}">Export All</a>
                </div>
              </form>
              <div class="mt-2 small text-muted">Expected format: v3 generator-catalog JSON (schema_version=3, plugin_type=flag-generator)</div>
            </div>
          </div>

          <div class="card">
            <div class="card-body">
              <div class="table-responsive">
                <table class="table table-sm align-middle">
                  <thead>
                    <tr>
                      <th style="width: 80px;">Enabled</th>
                      <th>Name</th>
                      <th>Rows</th>
                      <th style="width: 360px;">Actions</th>
                    </tr>
                  </thead>
                  <tbody>
                    {% for s in sources %}
                    <tr>
                      <td>
                        <form action="{{ url_for('flag_generators_sources_toggle', sid=s.id) }}" method="post">
                          <button class="btn btn-sm {{ 'btn-success' if s.enabled else 'btn-outline-secondary' }}" type="submit">{{ 'On' if s.enabled else 'Off' }}</button>
                        </form>
                      </td>
                      <td>
                        <div><strong>{{ s.name }}</strong></div>
                        <div class="small text-muted" style="max-width: 760px; word-break: break-all;">{{ s.path }}</div>
                      </td>
                      <td class="small">{{ s.rows }}</td>
                      <td>
                        <div class="d-flex gap-2 flex-wrap">
                          <form action="{{ url_for('flag_generators_sources_refresh', sid=s.id) }}" method="post">
                            <button class="btn btn-sm btn-outline-primary" type="submit">Refresh</button>
                          </form>
                          <a class="btn btn-sm btn-outline-secondary" href="{{ url_for('flag_generators_sources_download', sid=s.id) }}">Download</a>
                          <a class="btn btn-sm btn-outline-secondary" href="{{ url_for('flag_generators_sources_edit', sid=s.id) }}">Edit</a>
                          <form action="{{ url_for('flag_generators_sources_delete', sid=s.id) }}" method="post" onsubmit="return confirm('Delete this source?');">
                            <button class="btn btn-sm btn-outline-danger" type="submit">Delete</button>
                          </form>
                        </div>
                      </td>
                    </tr>
                    {% endfor %}
                    {% if not sources %}
                    <tr><td colspan="4" class="text-muted">No sources uploaded yet.</td></tr>
                    {% endif %}
                  </tbody>
                </table>
              </div>
            </div>
          </div>

          <h5 class="mb-2 mt-4">Flag-Node-Generator Sources</h5>
          <div class="card mb-3">
            <div class="card-body">
              <form class="row g-2" action="{{ url_for('flag_node_generators_sources_upload') }}" method="post" enctype="multipart/form-data">
                <div class="col-auto">
                  <input class="form-control" type="file" name="json_file" accept="application/json,.json" required>
                </div>
                <div class="col-auto">
                  <button class="btn btn-primary" type="submit">Upload JSON</button>
                </div>
                <div class="col-auto">
                  <a class="btn btn-outline-secondary" href="{{ url_for('flag_node_generators_sources_export_all') }}">Export All</a>
                </div>
              </form>
              <div class="mt-2 small text-muted">Expected format: v3 generator-catalog JSON (schema_version=3, plugin_type=flag-node-generator)</div>
            </div>
          </div>

          <div class="card">
            <div class="card-body">
              <div class="table-responsive">
                <table class="table table-sm align-middle">
                  <thead>
                    <tr>
                      <th style="width: 80px;">Enabled</th>
                      <th>Name</th>
                      <th>Rows</th>
                      <th style="width: 360px;">Actions</th>
                    </tr>
                  </thead>
                  <tbody>
                    {% for s in node_sources %}
                    <tr>
                      <td>
                        <form action="{{ url_for('flag_node_generators_sources_toggle', sid=s.id) }}" method="post">
                          <button class="btn btn-sm {{ 'btn-success' if s.enabled else 'btn-outline-secondary' }}" type="submit">{{ 'On' if s.enabled else 'Off' }}</button>
                        </form>
                      </td>
                      <td>
                        <div><strong>{{ s.name }}</strong></div>
                        <div class="small text-muted" style="max-width: 760px; word-break: break-all;">{{ s.path }}</div>
                      </td>
                      <td class="small">{{ s.rows }}</td>
                      <td>
                        <div class="d-flex gap-2 flex-wrap">
                          <form action="{{ url_for('flag_node_generators_sources_refresh', sid=s.id) }}" method="post">
                            <button class="btn btn-sm btn-outline-primary" type="submit">Refresh</button>
                          </form>
                          <a class="btn btn-sm btn-outline-secondary" href="{{ url_for('flag_node_generators_sources_download', sid=s.id) }}">Download</a>
                          <a class="btn btn-sm btn-outline-secondary" href="{{ url_for('flag_node_generators_sources_edit', sid=s.id) }}">Edit</a>
                          <form action="{{ url_for('flag_node_generators_sources_delete', sid=s.id) }}" method="post" onsubmit="return confirm('Delete this source?');">
                            <button class="btn btn-sm btn-outline-danger" type="submit">Delete</button>
                          </form>
                        </div>
                      </td>
                    </tr>
                    {% endfor %}
                    {% if not node_sources %}
                    <tr><td colspan="4" class="text-muted">No sources uploaded yet.</td></tr>
                    {% endif %}
                  </tbody>
                </table>
              </div>
            </div>
          </div>
        </div>

        <div class="tab-pane fade" id="flagGenerators" role="tabpanel">
          <div class="card mb-3">
            <div class="card-body">
              <div class="row g-2 align-items-center">
                <div class="col-md-6">
                  <input id="genFilter" class="form-control" placeholder="Filter generators…" />
                </div>
              </div>
              <div class="small text-muted mt-2" id="genMeta"></div>
            </div>
          </div>

          <div class="card">
            <div class="card-body">
              <div class="table-responsive">
                <table class="table table-sm align-middle" id="genTable">
                  <thead>
                    <tr>
                      <th style="width: 60px;">#</th>
                      <th>Name</th>
                      <th>Type</th>
                      <th>Inputs</th>
                      <th>Outputs</th>
                      <th>Injects</th>
                      <th>From Source</th>
                      <th style="width: 100px;">Test</th>
                    </tr>
                  </thead>
                  <tbody id="genBody"></tbody>
                </table>
              </div>
              <pre class="mt-3 small" id="genLog" style="max-height: 240px; overflow: auto;"></pre>
            </div>
          </div>

        </div>

        <div class="tab-pane fade" id="flagNodeGenerators" role="tabpanel">
          <div class="card mb-3">
            <div class="card-body">
              <div class="row g-2 align-items-center">
                <div class="col-md-6">
                  <input id="nodeGenFilter" class="form-control" placeholder="Filter node-generators…" />
                </div>
              </div>
              <div class="small text-muted mt-2" id="nodeGenMeta"></div>
            </div>
          </div>

          <div class="card">
            <div class="card-body">
              <div class="table-responsive">
                <table class="table table-sm align-middle" id="nodeGenTable">
                  <thead>
                    <tr>
                      <th style="width: 60px;">#</th>
                      <th>Name</th>
                      <th>Type</th>
                      <th>Inputs</th>
                      <th>Outputs</th>
                      <th>Injects</th>
                      <th>From Source</th>
                      <th style="width: 100px;">Test</th>
                    </tr>
                  </thead>
                  <tbody id="nodeGenBody"></tbody>
                </table>
              </div>
              <pre class="mt-3 small" id="nodeGenLog" style="max-height: 240px; overflow: auto;"></pre>
            </div>
          </div>
        </div>
      </div>

    </div>
  </div>
</div>

<!-- Generator Test Modal -->
<div class="modal fade" id="genTestModal" tabindex="-1" aria-hidden="true">
  <div class="modal-dialog modal-lg modal-dialog-scrollable">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title">Test Generator</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <div class="modal-body">
        <div class="mb-2">
          <div><strong id="genTestName"></strong></div>
          <div class="small text-muted" id="genTestId"></div>
        </div>

        <form id="genTestForm">
          <input type="hidden" name="generator_id" id="genTestGeneratorId" />
          <div id="genTestInputs"></div>
        </form>

        <div class="mt-3">
          <div class="small text-muted mb-1">Progress / Log</div>
          <pre class="small bg-light p-2" id="genTestLog" style="max-height: 220px; overflow: auto;"></pre>
        </div>

        <div class="mt-3">
          <div class="row g-3">
            <div class="col-12">
              <div class="small text-muted mb-1">Generated Files</div>
              <div id="genTestOutputsStatus" class="small text-muted mb-2" style="display:none;">
                <span class="spinner-border spinner-border-sm me-1" role="status" aria-hidden="true"></span>
                <span id="genTestOutputsStatusText">Working…</span>
              </div>
              <div id="genTestOutputs" class="small"></div>
            </div>
          </div>
        </div>
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-outline-secondary" data-bs-dismiss="modal">Close</button>
        <button type="button" class="btn btn-primary" id="genTestRunBtn">Run</button>
      </div>
    </div>
  </div>
</div>

<!-- Cleanup Modal (shown while removing test artifacts) -->
<div class="modal fade" id="genTestCleanupModal" tabindex="-1" aria-hidden="true" data-bs-backdrop="static" data-bs-keyboard="false">
  <div class="modal-dialog modal-dialog-centered modal-dialog-scrollable" style="max-width: 600px;">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title">Cleaning up</h5>
      </div>
      <div class="modal-body">
        <div class="d-flex align-items-center gap-2">
          <span id="genTestCleanupSpinner" class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span>
          <span id="genTestCleanupText">Cleaning up, please wait…</span>
        </div>
        <pre class="small bg-light p-2 mt-2 mb-0" id="genTestCleanupLog" style="max-height: 320px; overflow: auto;"></pre>
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-primary" id="genTestCleanupCloseBtn" data-bs-dismiss="modal" disabled>Close</button>
      </div>
    </div>
  </div>
</div>

<script>
  const genState = {
    generators: [],
    errors: [],
    filter: '',
    sortKey: 'name',
    sortDir: 'asc',
  };

  const nodeGenState = {
    generators: [],
    errors: [],
    filter: '',
    sortKey: 'name',
    sortDir: 'asc',
  };

  const genTestState = {
    current: null,
    testBase: '/flag_generators_test',
    eventSource: null,
    runId: null,
    savedUploads: {},
    outputsPollTimer: null,
    outputsLastSig: null,
    outputsStablePolls: 0,
  };

  let pendingCleanupRunId = null;
  let pendingCleanupTestBase = null;

  function normalizeForSort(v) {
    try {
      const s = String(v ?? '');
      return s.toLowerCase();
    } catch (e) {
      return '';
    }
  }

  function compareForSort(a, b) {
    const ax = normalizeForSort(a);
    const bx = normalizeForSort(b);
    if (ax < bx) return -1;
    if (ax > bx) return 1;
    return 0;
  }

  function stableSorted(items, keyFn, dir) {
    const direction = (dir === 'desc') ? -1 : 1;
    const decorated = (Array.isArray(items) ? items : []).map((item, idx) => ({ item, idx }));
    decorated.sort((x, y) => {
      const c = compareForSort(keyFn(x.item), keyFn(y.item));
      if (c !== 0) return c * direction;
      return x.idx - y.idx;
    });
    return decorated.map(d => d.item);
  }

  function updateSortIndicators(tableId, state, columns) {
    const table = document.getElementById(tableId);
    if (!table) return;
    const ths = table.querySelectorAll('thead th');
    ths.forEach((th, idx) => {
      const col = columns[idx];
      if (!col) return;
      const base = col.label || th.getAttribute('data-base-label') || th.textContent || '';
      if (!th.getAttribute('data-base-label')) {
        th.setAttribute('data-base-label', base);
      }
      if (col.key && state.sortKey === col.key) {
        const arrow = (state.sortDir === 'desc') ? '▼' : '▲';
        th.textContent = `${base} ${arrow}`;
      } else {
        th.textContent = base;
      }
    });
  }

  function enableTableSorting(tableId, state, columns, renderFn) {
    const table = document.getElementById(tableId);
    if (!table) return;
    const ths = table.querySelectorAll('thead th');
    ths.forEach((th, idx) => {
      const col = columns[idx];
      if (!col || !col.key) return;
      if (th.getAttribute('data-sort-init') === '1') return;
      th.setAttribute('data-sort-init', '1');
      th.style.cursor = 'pointer';
      th.title = 'Click to sort';
      th.classList.add('user-select-none');
      th.addEventListener('click', () => {
        if (state.sortKey === col.key) {
          state.sortDir = (state.sortDir === 'asc') ? 'desc' : 'asc';
        } else {
          state.sortKey = col.key;
          state.sortDir = 'asc';
        }
        try {
          renderFn();
        } catch (e) {}
        updateSortIndicators(tableId, state, columns);
      });
    });
    updateSortIndicators(tableId, state, columns);
  }

  function setOutputsStatus(visible, text) {
    const box = document.getElementById('genTestOutputsStatus');
    const t = document.getElementById('genTestOutputsStatusText');
    if (!box || !t) return;
    if (!visible) {
      box.style.display = 'none';
      t.textContent = '';
      return;
    }
    box.style.display = 'block';
    t.textContent = text || 'Working…';
  }

  function stopOutputsPolling() {
    if (genTestState.outputsPollTimer) {
      try { clearInterval(genTestState.outputsPollTimer); } catch (e) {}
      genTestState.outputsPollTimer = null;
    }
    genTestState.outputsLastSig = null;
    genTestState.outputsStablePolls = 0;
  }

  function resetGenTestUiState() {
    stopOutputsPolling();
    if (genTestState.eventSource) {
      try { genTestState.eventSource.close(); } catch (e) {}
      genTestState.eventSource = null;
    }
    genTestState.runId = null;
    genTestState.current = null;
    genTestState.testBase = '/flag_generators_test';
    genTestState.savedUploads = {};
    clearTestLog();
    setOutputsHtml('');
    setOutputsStatus(false);
    const btn = document.getElementById('genTestRunBtn');
    if (btn) btn.disabled = false;
  }

  function clearCleanupLog() {
    const el = document.getElementById('genTestCleanupLog');
    if (el) el.textContent = '';
  }

  function setCleanupLogLine(line) {
    const el = document.getElementById('genTestCleanupLog');
    if (!el) return;
    el.textContent = (el.textContent || '') + (line || '') + '\n';
    el.scrollTop = el.scrollHeight;
  }

  function setCleanupSpinner(active) {
    const sp = document.getElementById('genTestCleanupSpinner');
    if (!sp) return;
    sp.style.display = active ? 'inline-block' : 'none';
  }

  function _cleanupModalState(el) {
    try {
      const shown = !!(el && el.classList && el.classList.contains('show'));
      const display = el ? (getComputedStyle(el).display || '') : '';
      const backdrops = document.querySelectorAll('.modal-backdrop').length;
      const openModals = document.querySelectorAll('.modal.show').length;
      const bodyOpen = document.body && document.body.classList ? document.body.classList.contains('modal-open') : false;
      return { shown, display, backdrops, openModals, bodyOpen };
    } catch (e) {
      return { error: String(e) };
    }
  }

  function forceHideCleanupModal(cleanupModalEl) {
    const el = cleanupModalEl;
    if (!el) return;
    const st0 = _cleanupModalState(el);
    setCleanupLogLine(`[ui][cleanup] forceHide start state=${JSON.stringify(st0)}`);
    try {
      // Remove Bootstrap's show state.
      el.classList.remove('show');
      el.setAttribute('aria-hidden', 'true');
      el.style.display = 'none';
    } catch (e) {
      setCleanupLogLine(`[ui][cleanup] forceHide modal element error: ${String(e)}`);
    }
    try {
      // Remove any leftover backdrops.
      const bds = Array.from(document.querySelectorAll('.modal-backdrop'));
      bds.forEach(b => {
        try { b.remove(); } catch (e) {}
      });
    } catch (e) {
      setCleanupLogLine(`[ui][cleanup] forceHide backdrop error: ${String(e)}`);
    }
    try {
      // Restore body scroll.
      document.body.classList.remove('modal-open');
      document.body.style.removeProperty('padding-right');
      document.body.style.removeProperty('overflow');
    } catch (e) {
      setCleanupLogLine(`[ui][cleanup] forceHide body restore error: ${String(e)}`);
    }
    const st1 = _cleanupModalState(el);
    setCleanupLogLine(`[ui][cleanup] forceHide end state=${JSON.stringify(st1)}`);
  }

  async function cleanupRunArtifacts(runId, testBase) {
    if (!runId) return { ok: true };
    const cleanupText = document.getElementById('genTestCleanupText');
    const closeBtn = document.getElementById('genTestCleanupCloseBtn');
    clearCleanupLog();
    setCleanupLogLine(`[ui][cleanup] begin run_id=${runId}`);
    if (cleanupText) cleanupText.textContent = 'Cleaning up, please wait…';
    if (closeBtn) closeBtn.disabled = true;
    setCleanupSpinner(true);
    const cleanupModalEl = document.getElementById('genTestCleanupModal');
    const cleanupModal = cleanupModalEl ? bootstrap.Modal.getOrCreateInstance(cleanupModalEl) : null;
    if (cleanupModal) {
      setCleanupLogLine('[ui][cleanup] showing modal…');
      try { cleanupModal.show(); } catch (e) { setCleanupLogLine(`[ui][cleanup] modal.show error: ${String(e)}`); }
    }
    try {
      const timeoutMs = 30000;
      const controller = (typeof AbortController !== 'undefined') ? new AbortController() : null;
      const base = testBase || (genTestState && genTestState.testBase ? String(genTestState.testBase) : '/flag_generators_test');
      const url = `${base}/cleanup/${encodeURIComponent(runId)}`;
      const doReq = async () => {
        setCleanupLogLine(`[ui][cleanup] POST ${url}`);
        return await fetchJson(url, { method: 'POST', signal: controller ? controller.signal : undefined });
      };
      const resp = await Promise.race([
        doReq(),
        new Promise((resolve) => setTimeout(() => {
          try { if (controller) controller.abort(); } catch (e) {}
          resolve({ ok: false, error: `Cleanup timed out after ${timeoutMs}ms.` });
        }, timeoutMs)),
      ]);

      setCleanupLogLine(`[ui][cleanup] response ok=${resp && resp.ok !== false}`);
      if (resp && resp.ok === false) {
        setCleanupLogLine(`[ui][cleanup] error: ${resp.error || 'unknown error'}`);
        if (cleanupText) cleanupText.textContent = resp.error || 'Cleanup failed.';
        await new Promise(r => setTimeout(r, 800));
      } else {
        if (cleanupText) cleanupText.textContent = 'Cleanup completed.';
      }
      return resp || { ok: true };
    } finally {
      // Do NOT auto-close the modal. Enable Close when cleanup is complete.
      if (closeBtn) closeBtn.disabled = false;
      setCleanupSpinner(false);
      setCleanupLogLine('[ui][cleanup] end');
    }
  }

  function fileListSignature(data) {
    const paths = [];
    try {
      const add = (arr) => {
        (Array.isArray(arr) ? arr : []).forEach(f => {
          if (f && f.path) paths.push(String(f.path));
        });
      };
      add(data && data.inputs);
      add(data && data.outputs);
      add(data && data.files);
      add(data && data.misc);
    } catch (e) {}
    paths.sort();
    return JSON.stringify(paths);
  }

  async function pollOutputsOnce(runId) {
    const base = genTestState && genTestState.testBase ? String(genTestState.testBase) : '/flag_generators_test';
    const data = await fetchJson(`${base}/outputs/${encodeURIComponent(runId)}`);
    if (!data) return;
    if (data._nonJson) {
      setOutputsHtml(`<div class="text-danger">${escapeHtml(data.error || 'Login required')}</div>`);
      setOutputsStatus(false);
      stopOutputsPolling();
      return;
    }
    if (data.ok === false) {
      // If the run isn't found (e.g., server restart), surface it.
      setOutputsHtml(`<div class="text-danger">${escapeHtml(data.error || 'Failed loading outputs')}</div>`);
      setOutputsStatus(false);
      stopOutputsPolling();
      return;
    }

    // Track stability of the file list so the spinner doesn't disappear
    // before the last files (including bundle) are visible.
    const sig = fileListSignature(data);
    if (genTestState.outputsLastSig === sig) {
      genTestState.outputsStablePolls = (genTestState.outputsStablePolls || 0) + 1;
    } else {
      genTestState.outputsLastSig = sig;
      genTestState.outputsStablePolls = 0;
    }

    const inputs = Array.isArray(data.inputs) ? data.inputs : [];
    const outputs = Array.isArray(data.outputs) ? data.outputs : (Array.isArray(data.files) ? data.files : []);
    const misc = Array.isArray(data.misc) ? data.misc : [];
    const hasAny = !!(inputs.length || outputs.length || misc.length);

    if (!data.done) {
      setOutputsStatus(true, 'Generating outputs…');
    } else if (data.done && genTestState.outputsStablePolls < 1) {
      setOutputsStatus(true, 'Finalizing file list…');
    } else {
      setOutputsStatus(false);
    }

    // Update the UI as soon as anything exists, or when run completes.
    if (hasAny || data.done) {
      await loadTestOutputs(runId);
    }
    // Stop polling once the run is done and the file list is stable.
    if (data.done && genTestState.outputsStablePolls >= 1) {
      stopOutputsPolling();
    }
  }

  function startOutputsPolling(runId) {
    stopOutputsPolling();
    // Poll once immediately, then every second until done.
    setOutputsStatus(true, 'Generating outputs…');
    pollOutputsOnce(runId);
    genTestState.outputsPollTimer = setInterval(() => {
      pollOutputsOnce(runId);
    }, 1000);
  }

  async function fetchJson(url, options) {
    let resp;
    try {
      resp = await fetch(url, options);
    } catch (e) {
      return { ok: false, error: `Network error calling ${url}: ${String(e)}` };
    }
    const ct = (resp.headers.get('content-type') || '').toLowerCase();
    const redirectedToLogin = !!(resp.redirected && (resp.url || '').includes('/login'));
    if (redirectedToLogin || (!ct.includes('application/json') && !ct.includes('+json'))) {
      let snippet = '';
      try {
        const txt = await resp.text();
        snippet = (txt || '').slice(0, 200);
      } catch (e) {}
      return {
        ok: false,
        error: 'Login required (your session may have expired). Please reload and sign in at /login.' + (snippet ? ` Response: ${snippet}` : ''),
        _nonJson: true,
        _status: resp.status,
        _url: resp.url,
      };
    }
    try {
      return await resp.json();
    } catch (e) {
      let snippet = '';
      try {
        const txt = await resp.text();
        snippet = (txt || '').slice(0, 200);
      } catch (e2) {}
      return { ok: false, error: 'Failed to parse server response.' + (snippet ? ` Response: ${snippet}` : ''), _parseError: true };
    }
  }

  function setGenLog(lines) {
    document.getElementById('genLog').textContent = (lines || []).join('\n');
  }

  function setNodeGenLog(lines) {
    document.getElementById('nodeGenLog').textContent = (lines || []).join('\n');
  }

  function joinPath(a, b) {
    const aa = String(a || '').trim();
    const bb = String(b || '').trim();
    if (!aa) return bb;
    if (!bb) return aa;
    return aa.replace(/\/+$/, '') + '/' + bb.replace(/^\/+/, '');
  }

  function normalizeIOType(t) {
    const v = String(t || '').trim().toLowerCase();
    if (!v) return '';
    const map = {
      'string': 'text',
      'text': 'text',
      'json': 'json',
      'yaml': 'yaml',
      'yml': 'yaml',
      'md': 'markdown',
      'markdown': 'markdown',
      'html': 'html',
      'file': 'file',
      'path': 'file',
      'artifact': 'file',
      'binary': 'binary file',
      'exe': 'binary file',
      'image': 'photo',
      'photo': 'photo',
      'picture': 'photo',
    };
    return map[v] || v;
  }

  function typeSummary(items) {
    const arr = Array.isArray(items) ? items : [];
    const seen = new Set();
    arr.forEach((it) => {
      if (!it || typeof it !== 'object') return;
      const label = normalizeIOType(it.type);
      if (label) seen.add(label);
    });
    const out = Array.from(seen);
    out.sort();
    return out.length ? out.join(', ') : '—';
  }

  function nameSummary(items) {
    const arr = Array.isArray(items) ? items : [];
    const out = [];
    arr.forEach((it) => {
      if (!it || typeof it !== 'object') return;
      const nm = String(it.name || '').trim();
      if (!nm) return;
      out.push(nm);
    });
    out.sort();
    return out.length ? out.join(', ') : '—';
  }

  function groupedNameHtml(items) {
    const arr = Array.isArray(items) ? items : [];
    const req = [];
    const opt = [];
    arr.forEach((it) => {
      if (!it || typeof it !== 'object') return;
      const nm = String(it.name || '').trim();
      if (!nm) return;
      const isOptional = it.required === false;
      (isOptional ? opt : req).push(nm);
    });
    req.sort();
    opt.sort();
    const hasReq = req.length > 0;
    const hasOpt = opt.length > 0;
    if (!hasReq && !hasOpt) return '—';

    const parts = [];
    if (hasReq) {
      parts.push(`<div><strong>Required:</strong> ${escapeHtml(req.join(', '))}</div>`);
    }
    if (hasOpt) {
      parts.push(`<div><strong>Optional:</strong> ${escapeHtml(opt.join(', '))}</div>`);
    }
    return parts.join('');
  }

  function injectedSummary(items) {
    const arr = Array.isArray(items) ? items : [];
    const out = [];
    arr.forEach((x) => {
      const s = String(x || '').trim();
      if (!s) return;
      out.push(s);
    });
    out.sort();
    return out.length ? out.join(', ') : '—';
  }

  function renderGenerators() {
    const body = document.getElementById('genBody');
    const q = (genState.filter || '').toLowerCase();
    body.innerHTML = '';

    let filtered = (genState.generators || []).filter((g) => {
      if (!q) return true;
      const src = (g.source && g.source.path) ? g.source.path : '';
      const entry = (g.source && g.source.entry) ? g.source.entry : '';
      const composeFile = (g.compose && typeof g.compose === 'object' && typeof g.compose.file === 'string') ? g.compose.file : '';
      const composeService = (g.compose && typeof g.compose === 'object' && typeof g.compose.service === 'string') ? g.compose.service : '';
      const hay = [
        g.id,
        g.name,
        g.language,
        src,
        entry,
        composeFile,
        composeService,
        nameSummary(g.inputs),
        nameSummary(g.outputs),
        typeSummary(g.inputs),
        typeSummary(g.outputs),
        g.description || '',
        g._source_name || '',
      ].join(' ').toLowerCase();
      return hay.includes(q);
    });

    const sortKey = genState.sortKey || 'name';
    const sortDir = genState.sortDir || 'asc';
    filtered = stableSorted(filtered, (g) => {
      if (!g || typeof g !== 'object') return '';
      if (sortKey === 'name') return g.name || '';
      if (sortKey === 'type') return g.language || '';
      if (sortKey === 'inputs') return nameSummary(g.inputs);
      if (sortKey === 'outputs') return nameSummary(g.outputs);
      if (sortKey === 'injects') return injectedSummary(g.inject_files);
      if (sortKey === 'source') return g._source_name || '';
      return g[sortKey] || '';
    }, sortDir);

    filtered.forEach((g, idx) => {
      const tr = document.createElement('tr');
      const src = (g.source && g.source.path) ? g.source.path : '';
      const entry = (g.source && g.source.entry) ? g.source.entry : '';
      const inHtml = groupedNameHtml(g.inputs);
      const outHtml = groupedNameHtml(g.outputs);
      const injected = injectedSummary(g.inject_files);
      const inTypes = typeSummary(g.inputs);
      const outTypes = typeSummary(g.outputs);
      const hasCompose = !!(g.compose && typeof g.compose === 'object');
      const composeService = hasCompose && typeof g.compose.service === 'string' ? g.compose.service : '';
      const composeFile = hasCompose && typeof g.compose.file === 'string' ? g.compose.file : '';
      const composeLabel = composeService ? `compose: ${composeService}` : 'compose';

      const typeLabel = String(g.language || '');
      tr.innerHTML = `
        <td class="text-muted">${idx + 1}</td>
        <td>
          <div>
            <strong>${escapeHtml(g.name || '')}</strong>
            ${hasCompose ? `<span class="badge bg-secondary ms-2">${escapeHtml(composeLabel)}</span>` : ''}
          </div>
          ${g.description ? `<div class="small text-muted">${escapeHtml(g.description)}</div>` : ''}
        </td>
        <td class="small">${escapeHtml(typeLabel)}</td>
        <td class="small" title="${escapeHtml(inTypes)}">${inHtml}</td>
        <td class="small" title="${escapeHtml(outTypes)}">${outHtml}</td>
        <td class="small" style="max-width: 520px; word-break: break-all;">${escapeHtml(injected)}</td>
        <td class="small">${escapeHtml(g._source_name || '')}</td>
        <td>
          <button class="btn btn-sm btn-outline-primary genTestBtn" type="button" data-genid="${escapeHtml(g.id || '')}">Test</button>
        </td>
      `;
      body.appendChild(tr);

      const btn = tr.querySelector('.genTestBtn');
      if (btn) {
        btn.addEventListener('click', () => {
          openGenTestModal(g);
        });
      }
    });
  }

  function renderNodeGenerators() {
    const body = document.getElementById('nodeGenBody');
    const q = (nodeGenState.filter || '').toLowerCase();
    body.innerHTML = '';

    let filtered = (nodeGenState.generators || []).filter((g) => {
      if (!q) return true;
      const src = (g.source && g.source.path) ? g.source.path : '';
      const entry = (g.source && g.source.entry) ? g.source.entry : '';
      const composeFile = (g.compose && typeof g.compose === 'object' && typeof g.compose.file === 'string') ? g.compose.file : '';
      const composeService = (g.compose && typeof g.compose === 'object' && typeof g.compose.service === 'string') ? g.compose.service : '';
      const hay = [
        g.id,
        g.name,
        g.language,
        src,
        entry,
        composeFile,
        composeService,
        nameSummary(g.inputs),
        nameSummary(g.outputs),
        typeSummary(g.inputs),
        typeSummary(g.outputs),
        g.description || '',
        g._source_name || '',
      ].join(' ').toLowerCase();
      return hay.includes(q);
    });

    const sortKey = nodeGenState.sortKey || 'name';
    const sortDir = nodeGenState.sortDir || 'asc';
    filtered = stableSorted(filtered, (g) => {
      if (!g || typeof g !== 'object') return '';
      if (sortKey === 'name') return g.name || '';
      if (sortKey === 'type') return g.language || '';
      if (sortKey === 'inputs') return nameSummary(g.inputs);
      if (sortKey === 'outputs') return nameSummary(g.outputs);
      if (sortKey === 'injects') return injectedSummary(g.inject_files);
      if (sortKey === 'source') return g._source_name || '';
      return g[sortKey] || '';
    }, sortDir);

    filtered.forEach((g, idx) => {
      const tr = document.createElement('tr');
      const src = (g.source && g.source.path) ? g.source.path : '';
      const entry = (g.source && g.source.entry) ? g.source.entry : '';
      const inHtml = groupedNameHtml(g.inputs);
      const outHtml = groupedNameHtml(g.outputs);
      const injected = injectedSummary(g.inject_files);
      const inTypes = typeSummary(g.inputs);
      const outTypes = typeSummary(g.outputs);
      const hasCompose = !!(g.compose && typeof g.compose === 'object');
      const composeService = hasCompose && typeof g.compose.service === 'string' ? g.compose.service : '';
      const composeFile = hasCompose && typeof g.compose.file === 'string' ? g.compose.file : '';
      const composeLabel = composeService ? `compose: ${composeService}` : 'compose';

      const typeLabel = String(g.language || '');
      tr.innerHTML = `
        <td class="text-muted">${idx + 1}</td>
        <td>
          <div>
            <strong>${escapeHtml(g.name || '')}</strong>
            ${hasCompose ? `<span class="badge bg-secondary ms-2">${escapeHtml(composeLabel)}</span>` : ''}
          </div>
          ${g.description ? `<div class="small text-muted">${escapeHtml(g.description)}</div>` : ''}
        </td>
        <td class="small">${escapeHtml(typeLabel)}</td>
        <td class="small" title="${escapeHtml(inTypes)}">${inHtml}</td>
        <td class="small" title="${escapeHtml(outTypes)}">${outHtml}</td>
        <td class="small" style="max-width: 520px; word-break: break-all;">${escapeHtml(injected)}</td>
        <td class="small">${escapeHtml(g._source_name || '')}</td>
        <td>
          <button class="btn btn-sm btn-outline-primary nodeGenTestBtn" type="button" data-genid="${escapeHtml(g.id || '')}">Test</button>
        </td>
      `;
      body.appendChild(tr);

      const btn = tr.querySelector('.nodeGenTestBtn');
      if (btn) {
        btn.addEventListener('click', () => {
          openGenTestModal(g, '/flag_node_generators_test');
        });
      }
    });
  }

  function setTestLogLine(line) {
    const el = document.getElementById('genTestLog');
    el.textContent = (el.textContent || '') + (line || '') + '\n';
    el.scrollTop = el.scrollHeight;
  }

  function clearTestLog() {
    document.getElementById('genTestLog').textContent = '';
  }

  function setOutputsHtml(html) {
    document.getElementById('genTestOutputs').innerHTML = html || '';
  }

  function humanFileSize(bytes) {
    const n = Number(bytes);
    if (!isFinite(n) || n < 0) return '';
    if (n < 1024) return `${n} B`;
    const units = ['KB', 'MB', 'GB', 'TB'];
    let v = n / 1024;
    let u = 0;
    while (v >= 1024 && u < units.length - 1) {
      v /= 1024;
      u++;
    }
    return `${v.toFixed(v < 10 ? 1 : 0)} ${units[u]}`;
  }

  function describeFile(path, category) {
    const p = String(path || '');
    const c = String(category || '').toLowerCase();
    if (p === 'run.log') return 'Run log';
    if (p === 'outputs.json') return 'Outputs manifest';
    if (c === 'inputs') {
      if (p.endsWith('/config.json') || p === 'inputs/config.json') return 'Generator config';
      try {
        const saved = (genTestState && genTestState.savedUploads) ? genTestState.savedUploads : {};
        const rel = p.startsWith('inputs/') ? p : `inputs/${p}`;

        for (const key of Object.keys(saved || {})) {
          const meta = saved[key] || {};
          const storedPath = String(meta.stored_path || '');
          const storedFilename = String(meta.stored_filename || '');
          if (!storedPath && !storedFilename) continue;
          const hit = (storedPath && storedPath === rel) || (storedFilename && rel.endsWith('/' + storedFilename));
          if (!hit) continue;

          const containerPath = String(meta.container_path || '');
          const orig = String(meta.original_filename || '');
          const req = String(meta.requested_filename || '');
          if (req) return `Upload for ${key} → ${containerPath} (requested: ${req}; orig: ${orig || '—'})`;
          return `Upload for ${key} → ${containerPath}${orig ? ` (orig: ${orig})` : ''}`;
        }
      } catch (e) {}
      return 'Input file';
    }
    if (c === 'logs') return 'Log file';
    if (c === 'outputs') {
      // Try to map to declared outputs (even though we no longer display them).
      const g = genTestState.current || {};
      const declared = Array.isArray(g.outputs) ? g.outputs : [];
      const base = p.split('/').pop() || p;
      const hit = declared.find(o => {
        if (!o) return false;
        const name = String(o.name || '').trim();
        if (!name) return false;
        return name === base || p.includes(name);
      });
      if (hit) return String(hit.description || 'Declared output');
      return 'Generated output';
    }
    return 'File';
  }

  function renderFilesTable(rows) {
    const items = Array.isArray(rows) ? rows : [];
    if (!items.length) {
      return '<div class="text-muted">No files available.</div>';
    }
    const body = items.map((r, idx) => {
      const cat = escapeHtml(r.category || '');
      const p = escapeHtml(r.path || '');
      const size = escapeHtml(r.size || '');
      const desc = escapeHtml(r.desc || '');
      const href = r.href || '#';
      return `
        <tr>
          <td class="text-muted">${idx + 1}</td>
          <td class="text-muted">${cat}</td>
          <td style="word-break: break-all;">${p}</td>
          <td class="text-muted">${size}</td>
          <td class="text-muted">${desc}</td>
          <td><a href="${href}">Download</a></td>
        </tr>
      `;
    }).join('');
    return `
      <div class="table-responsive">
        <table class="table table-sm align-middle mb-0">
          <thead>
            <tr>
              <th style="width: 50px;">#</th>
              <th style="width: 90px;">Type</th>
              <th>Path</th>
              <th style="width: 90px;">Size</th>
              <th>Description</th>
              <th style="width: 90px;">Action</th>
            </tr>
          </thead>
          <tbody>
            ${body}
          </tbody>
        </table>
      </div>
    `;
  }

  function isFileInputType(t) {
    const v = (t || '').toLowerCase();
    return v === 'file' || v === 'path' || v === 'artifact' || v === 'binary';
  }

  function buildInputRow(inp) {
    const name = inp && inp.name ? String(inp.name) : '';
    if (!name) return '';
    const required = !!(inp && inp.required);
    const type = inp && inp.type ? String(inp.type) : 'string';
    const desc = inp && inp.description ? String(inp.description) : '';
    const hasDefault = !!(inp && Object.prototype.hasOwnProperty.call(inp, 'default'));
    const defaultVal = hasDefault ? String(inp.default) : '';
    const label = `${name}${required ? ' *' : ''}`;
    const help = desc ? `<div class="form-text">${escapeHtml(desc)}</div>` : '';
    if (isFileInputType(type)) {
      return `
        <div class="mb-3">
          <label class="form-label">${escapeHtml(label)}</label>
          <input class="form-control" type="file" name="${escapeHtml(name)}" ${required ? 'required' : ''} />
          ${help}
        </div>
      `;
    }

    const inputType = (type || '').toLowerCase() === 'number' ? 'number' : 'text';
    const valueAttr = hasDefault && defaultVal !== '' ? ` value="${escapeHtml(defaultVal)}"` : '';
    return `
      <div class="mb-3">
        <label class="form-label">${escapeHtml(label)}</label>
        <input class="form-control" type="${escapeHtml(inputType)}" name="${escapeHtml(name)}"${valueAttr} ${required ? 'required' : ''} />
        ${help}
      </div>
    `;
  }

  function openGenTestModal(generator, testBase) {
    genTestState.current = generator;
    genTestState.testBase = testBase || '/flag_generators_test';
    genTestState.runId = null;
    genTestState.savedUploads = {};
    stopOutputsPolling();
    if (genTestState.eventSource) {
      try { genTestState.eventSource.close(); } catch (e) {}
      genTestState.eventSource = null;
    }

    document.getElementById('genTestName').textContent = generator.name || '';
    document.getElementById('genTestId').textContent = generator.id || '';
    document.getElementById('genTestGeneratorId').value = generator.id || '';

    const inputs = Array.isArray(generator.inputs) ? generator.inputs : [];
    const inputsHtml = inputs.map(buildInputRow).join('') || '<div class="text-muted small">No inputs</div>';
    document.getElementById('genTestInputs').innerHTML = inputsHtml;

    clearTestLog();
    setOutputsHtml('');
    setOutputsStatus(false);

    const btn = document.getElementById('genTestRunBtn');
    btn.disabled = false;
    const modal = new bootstrap.Modal(document.getElementById('genTestModal'));
    modal.show();
  }

  async function loadTestOutputs(runId) {
    const base = genTestState.testBase || '/flag_generators_test';
    const data = await fetchJson(`${base}/outputs/${encodeURIComponent(runId)}`);
    if (!data.ok) {
      setOutputsHtml(`<div class="text-danger">${escapeHtml(data.error || 'Failed loading outputs')}</div>`);
      setOutputsStatus(false);
      return;
    }
    // Back-compat: older backend returned {files:[...]}
    const inputs = Array.isArray(data.inputs) ? data.inputs : [];
    const outputs = Array.isArray(data.outputs) ? data.outputs : (Array.isArray(data.files) ? data.files : []);
    const misc = Array.isArray(data.misc) ? data.misc : [];

    if (!data.done) {
      setOutputsStatus(true, 'Generating outputs…');
    } else {
      setOutputsStatus(false);
    }

    const all = [].concat(inputs, outputs, misc);
    if (!all.length) {
      const rc = (data && (data.returncode === 0 || data.returncode)) ? String(data.returncode) : '';
      setOutputsHtml(`<div class=\"text-muted\">No outputs found${rc ? ` (returncode=${escapeHtml(rc)})` : ''}.</div>`);
      return;
    }

    const rows = [];
    const pushFiles = (categoryLabel, files, categoryKey) => {
      (files || []).forEach(f => {
        const p = f.path || '';
        const href = `${base}/download/${encodeURIComponent(runId)}?p=${encodeURIComponent(p)}`;
        rows.push({
          category: categoryLabel,
          path: p,
          size: humanFileSize(f.size),
          desc: describeFile(p, categoryKey),
          href,
        });
      });
    };

    pushFiles('Input', inputs, 'inputs');
    pushFiles('Output', outputs, 'outputs');
    pushFiles('Log', misc, 'logs');

    setOutputsHtml(renderFilesTable(rows));

  }

  async function loadTestOutputsWithRetry(runId, attempts = 10) {
    for (let i = 0; i < attempts; i++) {
      const base = genTestState.testBase || '/flag_generators_test';
      const data = await fetchJson(`${base}/outputs/${encodeURIComponent(runId)}`);
      if (data && data._nonJson) {
        setOutputsHtml(`<div class="text-danger">${escapeHtml(data.error || 'Login required')}</div>`);
        setOutputsStatus(false);
        return;
      }
      const inputs = data && Array.isArray(data.inputs) ? data.inputs : [];
      const outputs = data && Array.isArray(data.outputs) ? data.outputs : (data && Array.isArray(data.files) ? data.files : []);
      const misc = data && Array.isArray(data.misc) ? data.misc : [];
      if (data && data.ok && (inputs.length || outputs.length || misc.length)) {
        await loadTestOutputs(runId);
        return;
      }
      // If not done yet, wait a bit and retry. If done but no files yet, still retry briefly.
      await new Promise(r => setTimeout(r, 500));
    }
    await loadTestOutputs(runId);
  }

  async function runCurrentGenTest() {
    const btn = document.getElementById('genTestRunBtn');
    btn.disabled = true;
    clearTestLog();
    setOutputsHtml('<div class="text-muted">Waiting for outputs…</div>');
    stopOutputsPolling();
    setOutputsStatus(true, 'Starting generator…');

    setTestLogLine('[ui] preparing request…');

    const form = document.getElementById('genTestForm');
    const fd = new FormData(form);
    const base = genTestState.testBase || '/flag_generators_test';
    setTestLogLine(`[ui] POST ${base}/run …`);
    const data = await fetchJson(`${base}/run`, { method: 'POST', body: fd });
    setTestLogLine(`[ui] response received (status unknown; ok=${data && data.ok !== false})`);

    if (!data || data.ok === false) {
      setTestLogLine(`ERROR: ${data && data.error ? data.error : 'Failed to start run'}`);
      setOutputsStatus(false);
      btn.disabled = false;
      return;
    }

    const runId = data.run_id;
    genTestState.runId = runId;
    genTestState.savedUploads = (data && data.saved_uploads) ? data.saved_uploads : {};
    setTestLogLine(`[ui] run_id=${runId}`);
    setTestLogLine(`Started run ${runId}`);

    try {
      const saved = genTestState.savedUploads || {};
      const keys = Object.keys(saved);
      if (keys.length) {
        keys.forEach((k) => {
          const m = saved[k] || {};
          const orig = String(m.original_filename || '');
          const dst = String(m.container_path || '');
          const req = String(m.requested_filename || '');
          setTestLogLine(`[ui] saved upload ${k}: ${orig || 'upload'} → ${dst || '(unknown)'}${req ? ` (requested: ${req})` : ''}`);
        });
      }
    } catch (e) {}

    // Start polling outputs immediately (works even if SSE disconnects).
    startOutputsPolling(runId);

    const es = new EventSource(`/stream/${encodeURIComponent(runId)}`);
    genTestState.eventSource = es;
    setTestLogLine('[ui] opening log stream…');
    es.onmessage = (ev) => {
      setTestLogLine(ev.data);
    };
    es.addEventListener('phase', (ev) => {
      try {
        const payload = JSON.parse(ev.data || '{}');
        if (payload && payload.phase) {
          setTestLogLine(`[phase] ${payload.phase}`);
        }
      } catch (e) {}
    });
    es.addEventListener('end', async () => {
      try { es.close(); } catch (e) {}
      genTestState.eventSource = null;
      setTestLogLine('Completed.');
      await loadTestOutputsWithRetry(runId);
      // Keep polling until the file list stabilizes.
      btn.disabled = false;
    });
    es.onerror = () => {
      // Keep UI responsive; user can retry.
      setTestLogLine('Log stream disconnected.');
      try { es.close(); } catch (e) {}
      genTestState.eventSource = null;
      // Keep polling outputs so links still appear.
      startOutputsPolling(runId);
      btn.disabled = false;
    };
  }

  function escapeHtml(str) {
    return (str || '').replace(/[&<>"']/g, c => ({
      '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;'
    }[c]));
  }

  async function loadGenerators() {
    const metaEl = document.getElementById('genMeta');
    metaEl.textContent = 'Loading…';
    setGenLog([]);
    const data = await fetchJson('/flag_generators_data');
    if (data && data.ok === false) {
      metaEl.textContent = data.error || 'Failed loading generators.';
      return;
    }
    genState.generators = data.generators || [];
    genState.errors = data.errors || [];
    metaEl.textContent = `Loaded ${genState.generators.length} generators from enabled sources.`;
    const lines = [];
    (genState.errors || []).forEach(e => lines.push(JSON.stringify(e)));
    setGenLog(lines);
    renderGenerators();
  }

  document.getElementById('genFilter').addEventListener('input', (e) => {
    genState.filter = e.target.value || '';
    renderGenerators();
  });

  // Load generator list when the tab is shown
  document.getElementById('flagGeneratorsTab').addEventListener('shown.bs.tab', async () => {
    await loadGenerators();
  });

  document.getElementById('genTestRunBtn').addEventListener('click', async () => {
    await runCurrentGenTest();
  });

  // Cleanup when the Test Generator modal is closed.
  // Important: don't block the close transition (Bootstrap can get stuck).
  // Instead: capture run id on hide, then perform cleanup after it's hidden.
  (function attachGenTestCleanupHandler() {
    const el = document.getElementById('genTestModal');
    if (!el) return;

    el.addEventListener('hide.bs.modal', () => {
      pendingCleanupRunId = genTestState.runId || null;
      pendingCleanupTestBase = genTestState.testBase || '/flag_generators_test';
      try { setTestLogLine(`[ui][cleanup] genTestModal hide: pendingCleanupRunId=${pendingCleanupRunId || ''}`); } catch (e) {}
      // Stop background activity immediately to reduce flakiness.
      stopOutputsPolling();
      if (genTestState.eventSource) {
        try { genTestState.eventSource.close(); } catch (e) {}
        genTestState.eventSource = null;
      }
    });

    el.addEventListener('hidden.bs.modal', async () => {
      const runId = pendingCleanupRunId;
      const testBase = pendingCleanupTestBase;
      pendingCleanupRunId = null;
      pendingCleanupTestBase = null;
      try { setTestLogLine(`[ui][cleanup] genTestModal hidden: runId=${runId || ''}`); } catch (e) {}
      resetGenTestUiState();
      if (!runId) return;
      try {
        try { setCleanupLogLine(`[ui][cleanup] invoked from genTestModal hidden (runId=${runId})`); } catch (e) {}
        await cleanupRunArtifacts(runId, testBase);
      } catch (e) {
        // Ignore cleanup errors; UI already closed.
      }
    });
  })();

  async function loadNodeGenerators() {
    const metaEl = document.getElementById('nodeGenMeta');
    metaEl.textContent = 'Loading…';
    setNodeGenLog([]);
    const data = await fetchJson('/flag_node_generators_data');
    if (data && data.ok === false) {
      metaEl.textContent = data.error || 'Failed loading node-generators.';
      return;
    }
    nodeGenState.generators = data.generators || [];
    nodeGenState.errors = data.errors || [];
    metaEl.textContent = `Loaded ${nodeGenState.generators.length} node-generators from enabled sources.`;
    const lines = [];
    (nodeGenState.errors || []).forEach(e => lines.push(JSON.stringify(e)));
    setNodeGenLog(lines);
    renderNodeGenerators();
  }

  document.getElementById('nodeGenFilter').addEventListener('input', (e) => {
    nodeGenState.filter = e.target.value || '';
    renderNodeGenerators();
  });

  // Load node-generator list when the tab is shown
  document.getElementById('flagNodeGeneratorsTab').addEventListener('shown.bs.tab', async () => {
    await loadNodeGenerators();
  });

  // Enable sorting (click any header) for both generator tables.
  enableTableSorting('genTable', genState, [
    { key: null, label: '#' },
    { key: 'name', label: 'Name' },
    { key: 'type', label: 'Type' },
    { key: 'inputs', label: 'Inputs' },
    { key: 'outputs', label: 'Outputs' },
    { key: 'injects', label: 'Injects' },
    { key: 'source', label: 'From Source' },
    { key: null, label: 'Test' },
  ], renderGenerators);

  enableTableSorting('nodeGenTable', nodeGenState, [
    { key: null, label: '#' },
    { key: 'name', label: 'Name' },
    { key: 'type', label: 'Type' },
    { key: 'inputs', label: 'Inputs' },
    { key: 'outputs', label: 'Outputs' },
    { key: 'injects', label: 'Injects' },
    { key: 'source', label: 'From Source' },
    { key: null, label: 'Test' },
  ], renderNodeGenerators);

  (function attachCleanupModalHandlers() {
    const el = document.getElementById('genTestCleanupModal');
    if (!el) return;
    const closeBtn = document.getElementById('genTestCleanupCloseBtn');
    if (closeBtn) {
      closeBtn.addEventListener('click', () => {
        try { setCleanupLogLine('[ui][cleanup] user clicked Close'); } catch (e) {}
      });
    }
    el.addEventListener('hidden.bs.modal', () => {
      try { clearCleanupLog(); } catch (e) {}
    });
  })();
</script>
{% endblock %}
