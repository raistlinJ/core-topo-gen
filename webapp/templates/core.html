{% extends 'layout.html' %}
{% block title %}CORE Sessions & Topologies{% endblock %}
{% block active_page %}{% set active_page='core' %}{% endblock %}
{% block header_icon %}<i class="bi bi-diagram-3-fill fs-4"></i>{% endblock %}
{% block header_title %}CORE Sessions & Topologies{% endblock %}
{% block header_right_extra %}
{% set current_role = (current_user.role|default('')|lower) if (current_user is defined and current_user.is_authenticated) else '' %}
{% set hide_daemon_badge = is_builder_view or current_role == 'builder' %}
<div class="d-flex align-items-center gap-3 small flex-wrap justify-content-end">
  <div class="d-flex align-items-center gap-2">
    <label for="refreshInterval" class="form-label mb-0 text-white">Every</label>
    <select id="refreshInterval" class="form-select form-select-sm w-auto" title="Auto-refresh interval">
      <option value="2000">2s</option>
      <option value="5000" selected>5s</option>
      <option value="10000">10s</option>
      <option value="30000">30s</option>
      <option value="60000">60s</option>
    </select>
    <span id="refreshStatus" class="text-white-50">auto</span>
    <button class="btn btn-sm btn-outline-light" id="toggleRefreshBtn" type="button">Pause</button>
  </div>
  {% if not hide_daemon_badge %}
  <div class="text-white-50 small">Daemon: {{ host }}:{{ port }}</div>
  {% endif %}
</div>
{% endblock %}
{% block extra_head %}
<style>
  body { padding-bottom: 0; }
  #coreLayoutRow { min-height: calc(100vh - 200px); }
  @media (max-width: 992px) {
    #coreLayoutRow { min-height: 0; }
  }
  th.actions-col, td.actions-col { white-space: nowrap; }
  th.col-check, td.col-check { width: 2rem; text-align: center; }
  /* File column: fixed width + horizontal scroll inside the cell */
  th.filename-col, td.filename-col { overflow: hidden; }
  .filename-scroll { max-width: 100%; display:block; overflow-x:auto; overflow-y:hidden; white-space:nowrap; }
  #sessionsTable { table-layout: fixed; }
  #sessionsTable th, #sessionsTable td { padding: .3rem .35rem; }
  #sessionsTable th.col-id, #sessionsTable td.col-id { width: 5%; white-space: nowrap; text-align: center; overflow: hidden; text-overflow: ellipsis; }
  #sessionsTable th.col-state, #sessionsTable td.col-state { width: 10%; white-space: nowrap; text-align: center; }
  #sessionsTable th.col-nodes, #sessionsTable td.col-nodes { width: 7%; white-space: nowrap; text-align: center; overflow: hidden; text-overflow: ellipsis; }
  #sessionsTable th.col-hitl, #sessionsTable td.col-hitl { width: 28%; }
  #sessionsTable td.col-hitl { font-size: 0.85rem; }
  #sessionsTable td.col-hitl .hitl-scroll { max-height: 3.5rem; overflow: auto; }
  #sessionsTable td.col-hitl .hitl-entry { line-height: 1.2; white-space: nowrap; }
  #sessionsTable td.col-hitl .hitl-entry-link { color: inherit; text-decoration: none; display: inline-flex; align-items: baseline; gap: .15rem; }
  #sessionsTable td.col-hitl .hitl-entry-link:hover { text-decoration: underline; }
  #sessionsTable th.col-scenario, #sessionsTable td.col-scenario { width: 13%; white-space: nowrap; text-align: center; }
  #sessionsTable th.filename-col, #sessionsTable td.filename-col { width: 22rem; max-width: 22rem; }
  #sessionsTable th.actions-col, #sessionsTable td.actions-col { width: 15rem; }

  #xmlsTable { table-layout: fixed; }
  #xmlsTable th.filename-col, #xmlsTable td.filename-col { width: 26rem; max-width: 26rem; }
  #xmlsTable th.actions-col, #xmlsTable td.actions-col { width: 14rem; }
  #xmlsTable thead th:nth-child(3), #xmlsTable tbody td:nth-child(3) { width: 5rem; text-align: center; white-space: nowrap; }
  .actions-col .btn { padding: .15rem .3rem; line-height: 1; vertical-align: middle; display: inline-flex; align-items: center; justify-content: center; }
  .actions-col .btn i, .actions-col .btn .bi { font-size: .95em; line-height: 1; display: block; }
  .actions-col .actions-wrap > a { display: inline-flex; align-items: center; margin-right: 2px; }
  .actions-col .actions-wrap > form { display: contents; }
  .actions-col .actions-wrap > form > .btn { margin-right: 2px; }
  .actions-col .actions-wrap > a:last-child { margin-right: 0; }
  .actions-col .actions-wrap > form:last-child > .btn { margin-right: 0; }
  /* Inline loading bar */
  #dataLoadingBar { height:4px; position:relative; margin-bottom:.5rem; overflow:hidden; border-radius:2px; background:rgba(0,0,0,0.08); }
  #dataLoadingBar.d-none { display:none !important; }
  #dataLoadingBar .bar { position:absolute; top:0; bottom:0; width:30%; background:linear-gradient(90deg,#0d6efd,#66b2ff); animation: coreLoadingBar 1.1s ease-in-out infinite; }
  @keyframes coreLoadingBar { 0% { transform: translateX(-120%); } 50% { transform: translateX(30%); } 100% { transform: translateX(220%); } }
  /* Skeleton row style (optional future) */
  .skeleton-cell { position:relative; overflow:hidden; background:linear-gradient(90deg,#e9ecef 0%,#f8f9fa 40%,#e9ecef 80%); background-size:200% 100%; animation:skeletonPulse 1.2s linear infinite; color:transparent; }
  @keyframes skeletonPulse { 0% { background-position:0 0; } 100% { background-position:-200% 0; } }
</style>
{% endblock %}
{% block nav_right_extra %}{% endblock %}
{% block content %}
{% set scenario_filter = request.args.get('scenario', '').strip() if request else '' %}
{% if scenario_filter %}
  {% set core_modal_href = url_for('index', core_modal=1, scenario=scenario_filter) %}
{% else %}
  {% set core_modal_href = url_for('index', core_modal=1) %}
{% endif %}
<div id="dataLoadingBar" class="d-none"><div class="bar"></div></div>

<!-- Loading modal for slow CORE details navigation -->
<div class="modal fade" id="coreDetailsLoadingModal" tabindex="-1" aria-hidden="true">
  <div class="modal-dialog modal-dialog-centered">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title">Loading…</h5>
      </div>
      <div class="modal-body">
        <div class="small text-muted mb-2">Loading scenario details…</div>
        <div class="progress" role="progressbar" aria-label="Loading" aria-valuemin="0" aria-valuemax="100">
          <div class="progress-bar progress-bar-striped progress-bar-animated" style="width: 100%">Loading</div>
        </div>
      </div>
    </div>
  </div>
</div>
<div id="coreErrorContainer" class="mb-3">
  {% if core_errors and not is_builder_view %}
  <div class="alert alert-danger" role="alert">
    <div class="fw-bold">CORE connection issues</div>
    <ul class="mb-0">
      {% for err in core_errors %}
      <li>{{ err }}</li>
      {% endfor %}
    </ul>
  </div>
  {% endif %}
</div>
{% set has_core_errors = core_errors|default([])|length > 0 %}
{% if core_vm_configured and core_vm_summary and not has_core_errors %}
<div class="alert alert-success" role="status">
  <div class="d-flex flex-wrap justify-content-between align-items-start gap-2">
    <div class="flex-grow-1">
      <div class="d-flex flex-wrap align-items-center gap-2">
        <span class="fw-bold">CORE VM connected</span>
        <span>
          {% if not is_builder_view %}
            {{ core_vm_summary.label }}{% if core_vm_summary.node %}
              <span class="text-muted">• Node {{ core_vm_summary.node }}</span>
            {% endif %}
          {% else %}
            CORE VM managed by admin
          {% endif %}
        </span>
      </div>
      {% if not is_builder_view %}
      <div class="small text-muted">
        gRPC {{ core_vm_summary.host }}:{{ core_vm_summary.port }} •
        SSH {{ core_vm_summary.ssh_username or 'unknown' }}@{{ core_vm_summary.ssh_host }}:{{ core_vm_summary.ssh_port }}
      </div>
      {% endif %}
    </div>
    {% if not is_builder_view %}
    <a class="btn btn-sm btn-dark" href="{{ core_modal_href }}">Change CORE VM</a>
    {% else %}
    <span class="badge text-bg-secondary">Admin managed</span>
    {% endif %}
  </div>
</div>
{% elif core_vm_configured and core_vm_summary %}
<div class="alert alert-warning" role="status">
  <div class="d-flex flex-wrap justify-content-between align-items-start gap-2">
    <div class="flex-grow-1">
      <div class="d-flex flex-wrap align-items-center gap-2">
        <span class="fw-bold">CORE VM assigned, but connection issues detected</span>
        <span>
          {% if not is_builder_view %}
            {{ core_vm_summary.label }}{% if core_vm_summary.node %}
              <span class="text-muted">• Node {{ core_vm_summary.node }}</span>
            {% endif %}
          {% else %}
            Admin-managed CORE VM
          {% endif %}
        </span>
      </div>
      <div class="small text-muted">Resolve the errors above and re-validate the CORE connection.</div>
    </div>
    {% if not is_builder_view %}
    <a class="btn btn-sm btn-outline-dark" href="{{ core_modal_href }}">Review CORE VM</a>
    {% else %}
    <span class="badge text-bg-secondary">Contact admin</span>
    {% endif %}
  </div>
</div>
{% else %}
<div class="alert alert-warning d-flex flex-wrap justify-content-between align-items-center gap-3" role="status">
  <span class="fw-semibold">No CORE VM configured</span>
  {% if not is_builder_view %}
  <a class="btn btn-sm btn-outline-primary" href="{{ core_modal_href }}">Select CORE VM</a>
  {% else %}
  <span class="text-muted small">Contact an admin to assign a CORE VM.</span>
  {% endif %}
</div>
{% endif %}
<div class="row g-3 align-items-stretch" id="coreLayoutRow">
  <div class="col-12 col-lg-3 d-flex">
    <div class="card shadow-sm flex-fill d-flex flex-column">
      <div class="card-header d-flex justify-content-between align-items-center">
        <span class="fw-bold">Scenarios</span>
        <button class="btn btn-sm btn-outline-secondary {% if not active_scenario %}d-none{% endif %}" id="coreScenarioFilterClear" type="button">Clear</button>
      </div>
      <div class="list-group list-group-flush flex-grow-1 overflow-auto" id="coreScenarioList" style="min-height:0; max-height:65vh;">
        {% if scenarios %}
          {% for s in scenarios %}
          <button type="button" class="list-group-item list-group-item-action small py-2 {% if active_scenario and active_scenario==s %}active{% endif %}" data-scen-name="{{ s }}">{{ s }}</button>
          {% endfor %}
        {% else %}
          <div class="p-3 text-muted small">No scenarios yet</div>
        {% endif %}
      </div>
    </div>
  </div>
  <div class="col-12 col-lg-9">
    <div class="row g-3">
      <div class="col-12">
        <div class="card mb-3">
          <div class="card-header py-2 d-flex justify-content-between align-items-center">
            <strong class="mb-0">Active Sessions</strong>
            <div class="d-flex align-items-center gap-2">
              <input id="sessionsFilter" class="form-control form-control-sm" type="text" placeholder="Filter..." style="width: 12rem;">
              <button class="btn btn-sm btn-outline-danger" id="sessionsDeleteBtn" type="button" title="Delete Selected" disabled>
                <i class="bi bi-trash"></i> Selected
              </button>
              <small class="text-muted ms-2">via gRPC</small>
            </div>
          </div>
          <div class="table-responsive" style="max-height:60vh; overflow-y:auto; overflow-x:auto;">
            <table class="table table-sm align-middle mb-0" id="sessionsTable">
              <thead class="table-light">
                <tr>
                  <th class="col-check"><input type="checkbox" id="sessionsCheckAll"></th>
                  <th class="col-id">ID</th>
                  <th class="col-state">State</th>
                  <th class="col-nodes">Nodes</th>
                  <th class="col-hitl">HITL gateway</th>
                  <th class="col-scenario">Scenario</th>
                  <th class="filename-col">File</th>
                  <th class="actions-col">Actions</th>
                </tr>
              </thead>
              <tbody></tbody>
            </table>
          </div>
        </div>
      </div>
      <div class="col-12">
        <div class="card mb-3">
          <div class="card-header py-2 d-flex justify-content-between align-items-center">
            <strong class="mb-0">Saved XML Topologies</strong>
            <div class="d-flex align-items-center gap-2">
              <input id="xmlsFilter" class="form-control form-control-sm" type="text" placeholder="Filter..." style="width: 12rem;">
              <button class="btn btn-sm btn-outline-danger" id="xmlsDeleteBtn" type="button" title="Delete Selected" disabled>
                <i class="bi bi-trash"></i> Selected
              </button>
              <small class="text-muted ms-2">on disk</small>
            </div>
          </div>
          <div class="table-responsive" style="max-height:60vh; overflow-y:auto; overflow-x:auto;">
            <table class="table table-sm align-middle mb-0" id="xmlsTable">
              <thead class="table-light">
                <tr>
                  <th class="col-check"><input type="checkbox" id="xmlsCheckAll"></th>
                  <th class="filename-col">File</th>
                  <th>Valid</th>
                  <th class="actions-col">Actions</th>
                </tr>
              </thead>
              <tbody></tbody>
            </table>
          </div>
        </div>
      </div>
      <div class="col-12">
        <div class="card mb-3">
          <div class="card-header py-2 d-flex justify-content-between align-items-center">
            <strong class="mb-0">Docker Compose (per-node)</strong>
            <div class="d-flex gap-2 align-items-center">
              <button class="btn btn-sm btn-outline-secondary" id="dockerRefreshBtn" type="button">Refresh</button>
              <button class="btn btn-sm btn-outline-danger" id="dockerCleanupBtn" type="button">Clean Stale Containers</button>
            </div>
          </div>
          <div class="table-responsive" style="max-height:40vh; overflow-y:auto; overflow-x:auto;">
            <table class="table table-sm align-middle mb-0" id="dockerTable">
              <thead class="table-light">
                <tr>
                  <th>Name</th>
                  <th>Compose</th>
                  <th>File</th>
                  <th>Images</th>
                  <th>Container</th>
                </tr>
              </thead>
              <tbody></tbody>
            </table>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>
{% include 'partials/dock.html' %}
<!-- Progress Modal -->
<div class="modal fade" id="progressModal" tabindex="-1" aria-labelledby="progressModalLabel" aria-hidden="true">
  <div class="modal-dialog modal-dialog-centered">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title" id="progressModalLabel">Processing…</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <div class="modal-body">
        <div class="mb-2 small text-muted" id="progressStatusText"></div>
        <div class="progress mb-3" role="progressbar" aria-label="Progress" aria-valuemin="0" aria-valuemax="100">
          <div class="progress-bar" id="progressBar" style="width: 0%">0%</div>
        </div>
        <div class="border rounded" style="max-height: 200px; overflow: auto;">
          <pre class="m-0 p-2 small" id="progressLog"></pre>
        </div>
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
      </div>
    </div>
  </div>
</div>
{% endblock %}
{% block extra_scripts %}
<script>
(function(){
  let auto = true;
  let timer = null;
  let intervalMs = parseInt(localStorage.getItem('coreRefreshMs') || '5000', 10);
  const coreDataBaseUrl = "{{ url_for('core_data') }}";
  let scenarioNamesCache = {{ (scenarios or [])|tojson }};
  const initialScenarioFilter = {{ (active_scenario or '')|tojson }};
  let scenarioFilter = initialScenarioFilter || null;
  const initialCoreErrors = {{ (core_errors or [])|tojson }};
  const initialGrpcCommand = {{ (core_grpc_command or '')|tojson }};
  const initialCoreLogs = {{ (core_log_entries or [])|tojson }};
  let lastGrpcCommand = initialGrpcCommand || null;
  const sessionsTable = document.getElementById('sessionsTable');
  const sessionsTBody = sessionsTable?.querySelector('tbody');
  const xmlsTable = document.getElementById('xmlsTable');
  const xmlsTBody = xmlsTable?.querySelector('tbody');
  const dockerTable = document.getElementById('dockerTable');
  const dockerTBody = dockerTable?.querySelector('tbody');
  const sessionsFilterInput = document.getElementById('sessionsFilter');
  const xmlsFilterInput = document.getElementById('xmlsFilter');
  const sessionsCheckAll = document.getElementById('sessionsCheckAll');
  const xmlsCheckAll = document.getElementById('xmlsCheckAll');
  const sessionsDeleteBtn = document.getElementById('sessionsDeleteBtn');
  const xmlsDeleteBtn = document.getElementById('xmlsDeleteBtn');
  const scenarioFilterList = document.getElementById('coreScenarioList');
  const scenarioClearBtn = document.getElementById('coreScenarioFilterClear');
  let sessionsFilterText = '';
  let xmlsFilterText = '';
  // Persistent selection state (restored across full page reloads)
  const LS_KEYS = {
    sessions: 'coreSelectedSessions',
    xmls: 'coreSelectedXmls',
    masterSessions: 'coreMasterSessionsAll',
    masterXmls: 'coreMasterXmlsAll'
  };
  function loadJsonArray(key){
    try { const raw = localStorage.getItem(key); if(!raw) return []; const arr = JSON.parse(raw); return Array.isArray(arr)? arr: []; } catch(e){ return []; }
  }
  function loadBool(key){
    try { const raw = localStorage.getItem(key); return raw === 'true'; } catch(e){ return false; }
  }
  const selectedSessions = new Set(loadJsonArray(LS_KEYS.sessions));
  const selectedXmlPaths = new Set(loadJsonArray(LS_KEYS.xmls));
  let sessionsMasterSelectAll = loadBool(LS_KEYS.masterSessions);
  let xmlsMasterSelectAll = loadBool(LS_KEYS.masterXmls);
  // Auto reapply flags (so user can permanently opt-out of reapplication until they re-enable)
  let sessionsAutoReapply = true;
  let xmlsAutoReapply = true;
  // Timestamp of last manual header toggle (used if we want throttling)
  let lastHeaderToggleTs = 0;
  function persistSelections(){
    try {
      localStorage.setItem(LS_KEYS.sessions, JSON.stringify(Array.from(selectedSessions)));
      localStorage.setItem(LS_KEYS.xmls, JSON.stringify(Array.from(selectedXmlPaths)));
      localStorage.setItem(LS_KEYS.masterSessions, sessionsMasterSelectAll ? 'true':'false');
      localStorage.setItem(LS_KEYS.masterXmls, xmlsMasterSelectAll ? 'true':'false');
    } catch(e) {}
  }

  function dockLog(level, message){
    const lvl = (level || 'INFO').toString().toUpperCase();
    const msg = message != null ? String(message) : '';
    if(typeof window.logLine === 'function'){
      window.logLine(lvl, msg);
    } else {
      try { window.dispatchEvent(new CustomEvent('dock-log', { detail: { level: lvl, message: msg } })); } catch(_e) {}
    }
  }

  function buildCoreDataUrl(){
    if(!scenarioFilter) return coreDataBaseUrl;
    const sep = coreDataBaseUrl.includes('?') ? '&' : '?';
    return `${coreDataBaseUrl}${sep}scenario=${encodeURIComponent(scenarioFilter)}`;
  }

  function updateCoreScenarioQueryParam(){
    const url = new URL(window.location.href);
    if(scenarioFilter){
      url.searchParams.set('scenario', scenarioFilter);
    } else {
      url.searchParams.delete('scenario');
    }
    window.history.replaceState({}, '', url.toString());
  }

  function updateCoreScenarioControls(){
    if(scenarioClearBtn){
      scenarioClearBtn.classList.toggle('d-none', !scenarioFilter);
    }
    if(!scenarioFilterList) return;
    scenarioFilterList.querySelectorAll('[data-scen-name]').forEach(btn => {
      const name = btn.getAttribute('data-scen-name');
      btn.classList.toggle('active', !!scenarioFilter && name === scenarioFilter);
    });
  }

  function renderCoreErrors(errs){
    const container = document.getElementById('coreErrorContainer');
    if(!container) return;
    if(!Array.isArray(errs) || errs.length === 0){
      container.innerHTML = '';
      return;
    }
    const items = errs.map(err => `<li>${esc(err)}</li>`).join('');
    container.innerHTML = `
      <div class="alert alert-danger" role="alert">
        <div class="fw-bold">CORE connection issues</div>
        <ul class="mb-0">${items}</ul>
      </div>`;
  }

  function renderCoreScenarioButtons(){
    if(!scenarioFilterList) return;
    scenarioFilterList.innerHTML = '';
    if(!Array.isArray(scenarioNamesCache) || scenarioNamesCache.length === 0){
      const empty = document.createElement('div');
      empty.className = 'p-3 text-muted small';
      empty.textContent = 'No scenarios yet';
      scenarioFilterList.appendChild(empty);
      updateCoreScenarioControls();
      return;
    }
    scenarioNamesCache.forEach(name => {
      const btn = document.createElement('button');
      btn.type = 'button';
      btn.className = 'list-group-item list-group-item-action small py-2 text-start';
      btn.dataset.scenName = name;
      btn.textContent = name;
      if(scenarioFilter && name === scenarioFilter){
        btn.classList.add('active');
      }
      btn.addEventListener('click', async () => {
        const nextValue = (scenarioFilter === name) ? null : name;
        await setCoreScenarioFilter(nextValue);
      });
      scenarioFilterList.appendChild(btn);
    });
    updateCoreScenarioControls();
  }

  async function setCoreScenarioFilter(value){
    scenarioFilter = value || null;
    updateCoreScenarioQueryParam();
    updateCoreScenarioControls();
    dockLog('INFO', `[core] Scenario filter set to ${scenarioFilter || 'All'}`);
    await refresh();
  }

  let progressModalInstance = null;
  function ensureProgressModal(){
    if(!progressModalInstance){
      const el = document.getElementById('progressModal');
      if(el) progressModalInstance = new bootstrap.Modal(el, { backdrop: 'static', keyboard: false });
    }
    return progressModalInstance;
  }
  function openProgress(title, total){
    ensureProgressModal();
    document.getElementById('progressModalLabel').textContent = title || 'Processing…';
    document.getElementById('progressStatusText').textContent = `0 of ${total}`;
    const bar = document.getElementById('progressBar');
    bar.style.width = '0%';
    bar.textContent = '0%';
    document.getElementById('progressLog').textContent = '';
    progressModalInstance?.show();
  }
  function updateProgress(done, total, msg){
    const pct = total > 0 ? Math.round((done/total)*100) : 0;
    const bar = document.getElementById('progressBar');
    bar.style.width = pct + '%';
    bar.textContent = pct + '%';
    document.getElementById('progressStatusText').textContent = `${done} of ${total}`;
    if(msg){
      const line = `[${new Date().toLocaleTimeString()}] ${msg}\n`;
      document.getElementById('progressLog').textContent += line;
      try { window.dispatchEvent(new CustomEvent('dock-log', { detail: { level: 'INFO', message: msg } })); } catch(e) {}
    }
  }
  function closeProgress(){ progressModalInstance?.hide(); }

  function esc(s){ return (s||'').toString().replace(/[&<>"']/g, c=>({"&":"&amp;","<":"&lt;",">":"&gt;","\"":"&quot;","'":"&#39;"}[c])); }

  function normalizeParticipantHitlHref(value){
    if(value === undefined || value === null) return '';
    let trimmed = String(value).trim();
    if(!trimmed) return '';
    if(!/^https?:\/\//i.test(trimmed)){
      trimmed = `https://${trimmed}`;
    }
    try {
      const parsed = new URL(trimmed);
      if(parsed.protocol !== 'http:' && parsed.protocol !== 'https:'){
        return '';
      }
      return parsed.toString();
    } catch(e){
      return '';
    }
  }

  function buildSessionRow(s){
    const id = esc(s.id);
    const state = esc(s.state||'');
    const nodesVal = (s.nodes === null || s.nodes === undefined) ? '-' : String(s.nodes);
    const nodes = esc(nodesVal);
    const rawFile = s.file || s.filename || s.path || '';
    const baseName = rawFile ? rawFile.split(/[/\\\\]/).pop() : '—';
    const file = esc(baseName);
    const fullFileTitle = esc(rawFile || '');
    const scenarioRaw = (s.scenario_name || '').toString().trim();
    const scenarioDisplay = scenarioRaw ? `<span class="badge text-bg-primary">${esc(scenarioRaw)}</span>` : '<span class="text-muted">—</span>';
    const hitlEntries = Array.isArray(s.hitl) ? s.hitl : [];
    const participantHref = normalizeParticipantHitlHref(s.participant_proxmox_url || '');
    const participantHrefEsc = participantHref ? esc(participantHref) : '';
    const hitlFilterText = hitlEntries.map(entry => {
      const parts = [];
      if(entry && entry.name) parts.push(entry.name);
      if(entry && entry.type) parts.push(entry.type);
      if(entry && Array.isArray(entry.ips)) parts.push(entry.ips.join(' '));
      return parts.join(' ');
    }).join(' ');
    const hitlCell = hitlEntries.length
        ? `<div class="hitl-scroll d-flex flex-column gap-1">${hitlEntries.map(entry => {
          const name = esc((entry && entry.name) || (entry && entry.type) || 'HITL');
          const ips = (entry && Array.isArray(entry.ips)) ? entry.ips.filter(ip => !!ip).map(ip => esc(ip)) : [];
          const ipLabel = ips.length ? ` <span class="text-muted">(${ips.join(', ')})</span>` : ' <span class="text-muted">(no IP)</span>';
          const inner = participantHrefEsc
            ? `<a class="hitl-entry-link" href="${participantHrefEsc}" target="_blank" rel="noopener noreferrer" title="Open Participant UI">${name}${ipLabel}</a>`
            : `${name}${ipLabel}`;
          return `<div class="hitl-entry">${inner}</div>`;
        }).join('')}</div>`
      : '<span class="text-muted">—</span>';
    const lower = (s.state||'').toString().toLowerCase();
    const hasFile = !!s.file;
    const rowStr = `${id} ${state} ${nodes} ${scenarioRaw} ${file} ${hitlFilterText}`.toLowerCase();
    if (sessionsFilterText && !rowStr.includes(sessionsFilterText)) return '';
    // Always pass session_id for Details so the backend can export session XML via gRPC.
    // NOTE: `s.file` is commonly a remote path (not readable locally), so `path=` would cause fallback/mismatch.
    const detailsParams = [];
    detailsParams.push('session_id=' + encodeURIComponent(String(s.id||'')));
    if (scenarioRaw) {
      detailsParams.push('scenario_name=' + encodeURIComponent(scenarioRaw));
    }
    const detailsHrefBase = '{{ url_for('core_details') }}';
    const detailsHref = detailsParams.length ? `${detailsHrefBase}?${detailsParams.join('&')}` : detailsHrefBase;
    const scenarioHidden = scenarioFilter ? `<input type="hidden" name="scenario" value="${esc(scenarioFilter)}">` : '';
    const stopBtn = `
      <form action="{{ url_for('core_stop') }}" method="post">
        ${scenarioHidden}
        <input type="hidden" name="session_id" value="${id}">
        <button class="btn btn-sm btn-outline-warning" title="Stop"><i class="bi bi-stop-circle"></i></button>
      </form>`;
    const startBtn = `
      <form action="{{ url_for('core_start_session') }}" method="post">
        ${scenarioHidden}
        <input type="hidden" name="session_id" value="${id}">
        <button class="btn btn-sm btn-outline-success" title="Start"><i class="bi bi-play-circle"></i></button>
      </form>`;
    const participantBtn = participantHrefEsc
      ? `<a class="btn btn-sm btn-outline-success" href="${participantHrefEsc}" target="_blank" rel="noopener noreferrer" title="Open Participant UI"><i class="bi bi-box-arrow-up-right"></i></a>`
      : '';
    const stateIcon = (
      lower.includes('run')
        ? `<i class="bi bi-play-circle-fill text-success" data-bs-toggle="tooltip" title="${state}"></i>`
        : (lower.includes('shutdown')
          ? `<i class="bi bi-power text-secondary" data-bs-toggle="tooltip" title="${state}"></i>`
          : `<i class="bi bi-question-circle text-muted" data-bs-toggle="tooltip" title="${state}"></i>`)
    );
    const actions = `
      <div class="d-flex align-items-center flex-nowrap actions-wrap">
        ${participantBtn}
        <a class=\"btn btn-sm btn-outline-info\" href=\"${detailsHref}\" title=\"Details\"><i class=\"bi bi-info-circle\"></i></a>
        ${lower.includes('run') ? stopBtn : (lower.includes('shutdown') ? startBtn : '')}
        <form action=\"{{ url_for('core_delete') }}\" method=\"post\" onsubmit=\"return confirm('Delete session ${id}?')\">
          ${scenarioHidden}
          <input type=\"hidden\" name=\"session_id\" value=\"${id}\">
          <button class=\"btn btn-sm btn-outline-danger\" title=\"Delete\"><i class=\"bi bi-trash\"></i></button>
        </form>
        <form action=\"{{ url_for('core_save_xml') }}\" method=\"post\" title=\"Save XML\">
          ${scenarioHidden}
          <input type=\"hidden\" name=\"session_id\" value=\"${id}\">
          <button class=\"btn btn-sm btn-outline-secondary\"><i class=\"bi bi-download\"></i></button>
        </form>
      </div>`;
    return `<tr>
      <td class="col-check"><input type="checkbox" class="row-select" data-type="session" data-id="${id}" ${selectedSessions.has(String(s.id))? 'checked':''}></td>
      <td class="col-id">${id}</td>
      <td class="col-state">${stateIcon}</td>
      <td class="col-nodes">${nodes}</td>
      <td class="col-hitl">${hitlCell}</td>
      <td class="col-scenario">${scenarioDisplay}</td>
      <td class="filename-col"><div class="filename-scroll" title="${fullFileTitle}">${file}</div></td>
      <td class="actions-col">${actions}</td>
    </tr>`;
  }

  function buildXmlRow(x){
    const path = esc(x.path);
    const name = esc(x.name);
    const validBadge = x.valid ? '<span class="badge text-bg-success">yes</span>' : '<span class="badge text-bg-danger">no</span>';
  const detailsHref = '{{ url_for('core_details') }}?path=' + encodeURIComponent(x.path);
    const startDisabled = x.valid ? '' : 'disabled';
    const rowStr = `${name} ${path} ${x.valid? 'yes':'no'}`.toLowerCase();
    if (xmlsFilterText && !rowStr.includes(xmlsFilterText)) return '';
    const scenarioHidden = scenarioFilter ? `<input type="hidden" name="scenario" value="${esc(scenarioFilter)}">` : '';
    return `<tr>
      <td class="col-check"><input type="checkbox" class="row-select" data-type="xml" data-path="${path}" ${selectedXmlPaths.has(x.path)? 'checked':''}></td>
      <td class="filename-col"><div class="filename-scroll" title="${path}">${name}</div></td>
      <td>${validBadge}</td>
      <td class="actions-col">
        <a class="btn btn-sm btn-outline-info" href="${detailsHref}" title="Details"><i class="bi bi-info-circle"></i></a>
        <form action="{{ url_for('core_start') }}" method="post" class="d-inline">
          ${scenarioHidden}
          <input type="hidden" name="path" value="${path}">
          <button class="btn btn-sm btn-outline-success" title="Start" ${startDisabled}><i class="bi bi-play-circle"></i></button>
        </form>
        <a class="btn btn-sm btn-outline-secondary" href="{{ url_for('download_report') }}?path=${encodeURIComponent(x.path)}" title="Download"><i class="bi bi-download"></i></a>
        <form action="{{ url_for('core_delete') }}" method="post" class="d-inline" onsubmit="return confirm('Delete file ${name}?')">
          ${scenarioHidden}
          <input type="hidden" name="path" value="${path}">
          <button class="btn btn-sm btn-outline-danger" title="Delete"><i class="bi bi-trash"></i></button>
        </form>
      </td>
    </tr>`;
  }

  let isFetching = false;
  let firstLoadDone = false;
  const minLoadDisplayMs = 300;
  function setLoading(on){
    const bar = document.getElementById('dataLoadingBar');
    if(!bar) return;
    if(on){ bar.classList.remove('d-none'); }
    else { bar.classList.add('d-none'); }
  }
  async function refresh(){
    if(isFetching) return; // avoid overlaps
    isFetching = true;
    const startTs = performance.now();
    setLoading(true);
    try{
      const dataUrl = buildCoreDataUrl();
      dockLog('DEBUG', `[core] Refreshing sessions from ${dataUrl}${scenarioFilter ? ` (scenario=${scenarioFilter})` : ''}`);
      const res = await fetch(dataUrl, { cache:'no-store' });
      if(!res.ok){
        dockLog('WARN', `[core] refresh failed (${res.status}) for ${dataUrl}`);
        return;
      }
      const data = await res.json();
      if(Array.isArray(data.logs) && data.logs.length){
        data.logs.forEach(entry => {
          if(!entry) return;
          dockLog(entry.level || 'INFO', entry.message || '');
        });
      }
      if(Array.isArray(data.errors)){
        renderCoreErrors(data.errors);
      } else {
        renderCoreErrors([]);
      }
      if(data.grpc_command && data.grpc_command !== lastGrpcCommand){
        dockLog('INFO', `[core] gRPC command: ${data.grpc_command}`);
        lastGrpcCommand = data.grpc_command;
      }
      const serverScenario = (data.active_scenario || '').trim();
      if(serverScenario){
        scenarioFilter = serverScenario;
      } else if(!serverScenario && scenarioFilter){
        scenarioFilter = null;
      }
      if(Array.isArray(data.scenarios)){
        scenarioNamesCache = data.scenarios;
        renderCoreScenarioButtons();
      } else {
        updateCoreScenarioControls();
      }
      updateCoreScenarioQueryParam();
      if(Array.isArray(data.sessions) && sessionsTBody){
        sessionsTBody.innerHTML = data.sessions.map(buildSessionRow).filter(Boolean).join('\n');
        try { document.querySelectorAll('[data-bs-toggle="tooltip"]').forEach(el => new bootstrap.Tooltip(el)); } catch(e) {}
        bindSelectionHandlers('session');
        // Re-apply master select-all if active AND auto-reapply still allowed
        if (sessionsMasterSelectAll && sessionsAutoReapply) applyMasterSelectAll('session');
        dockLog('INFO', `[core] Sessions updated (${data.sessions.length} items)`);
      }
      if(Array.isArray(data.xmls) && xmlsTBody){
        xmlsTBody.innerHTML = data.xmls.map(buildXmlRow).filter(Boolean).join('\n');
        bindSelectionHandlers('xml');
        if (xmlsMasterSelectAll && xmlsAutoReapply) applyMasterSelectAll('xml');
        dockLog('DEBUG', `[core] XML catalog updated (${data.xmls.length} files)`);
      }
      await refreshDocker();
    }catch(e){ dockLog('ERROR', `[core] refresh error: ${e}`); }
    finally {
      const elapsed = performance.now() - startTs;
      const remain = elapsed < minLoadDisplayMs ? (minLoadDisplayMs - elapsed) : 0;
      setTimeout(()=> { setLoading(false); isFetching=false; firstLoadDone=true; }, remain);
    }
  }

  // Show a "Loading" progress modal when navigating to core_details.
  (function bindCoreDetailsLoading(){
    function shouldInterceptClick(ev){
      if(!ev) return false;
      if(ev.defaultPrevented) return false;
      // Respect new-tab / new-window gestures.
      if(ev.button !== 0) return false;
      if(ev.metaKey || ev.ctrlKey || ev.shiftKey || ev.altKey) return false;
      return true;
    }
    function showLoadingModal(){
      try {
        const el = document.getElementById('coreDetailsLoadingModal');
        if(!el) return null;
        if(window.bootstrap && window.bootstrap.Modal){
          const inst = bootstrap.Modal.getOrCreateInstance(el, { backdrop: 'static', keyboard: false });
          inst.show();
          return inst;
        }
      } catch(e) {}
      return null;
    }
    document.addEventListener('click', (ev)=>{
      try {
        const a = ev.target && ev.target.closest ? ev.target.closest('a[href]') : null;
        if(!a) return;
        const href = a.getAttribute('href') || '';
        if(!href) return;
        if(href.indexOf('{{ url_for('core_details') }}') === -1 && href.indexOf('/core/details') === -1) return;
        if(!shouldInterceptClick(ev)) return;
        ev.preventDefault();
        showLoadingModal();
        // Give the browser a moment to paint the modal before navigating.
        requestAnimationFrame(()=>{ setTimeout(()=>{ window.location.assign(href); }, 50); });
      } catch(e) {}
    }, true);
  })();

  function schedule(){
    if(timer) clearTimeout(timer);
    if(!auto) return;
    // Show loading bar immediately upon scheduling next cycle (visual immediacy)
    setLoading(true);
    timer = setTimeout(async ()=>{ await refresh(); schedule(); }, intervalMs);
  }

  document.getElementById('toggleRefreshBtn')?.addEventListener('click', ()=>{
    auto = !auto;
    document.getElementById('toggleRefreshBtn').textContent = auto ? 'Pause' : 'Resume';
    document.getElementById('refreshStatus').textContent = auto ? 'auto' : 'paused';
    schedule();
  });

  const sel = document.getElementById('refreshInterval');
  if (sel) {
    if ([2000,5000,10000,30000,60000].includes(intervalMs)) {
      sel.value = String(intervalMs);
    }
    sel.addEventListener('change', ()=>{
      const v = parseInt(sel.value, 10);
      if (!isNaN(v) && v > 0) {
        intervalMs = v;
        localStorage.setItem('coreRefreshMs', String(intervalMs));
        schedule();
      }
    });
  }

  // Show bar immediately on initial load, then kick first refresh now (not after interval)
  dockLog('INFO', `[core] CORE page initialized (scenario=${initialScenarioFilter || 'All'})`);
  if(Array.isArray(initialCoreLogs) && initialCoreLogs.length){
    initialCoreLogs.forEach(entry => {
      if(!entry) return;
      dockLog(entry.level || 'INFO', entry.message || '');
    });
  }
  setLoading(true);
  refresh().then(()=> schedule());
  try { bindSelectionHandlers('session'); } catch(e) {}
  try { bindSelectionHandlers('xml'); } catch(e) {}

  function badge(ok, yes, no){ return ok ? `<span class="badge text-bg-success">${yes}</span>` : `<span class="badge text-bg-secondary">${no}</span>`; }
  function badgeWarn(ok, yes, no){ return ok ? `<span class="badge text-bg-success">${yes}</span>` : `<span class="badge text-bg-danger">${no}</span>`; }
  async function refreshDocker(){
    if(!dockerTBody) return;
    try{
      dockLog('DEBUG', '[core] Refreshing docker status');
      const res = await fetch("/docker/status");
      if(!res.ok){
        dockLog('WARN', `[core] docker refresh failed (${res.status})`);
        return;
      }
      const js = await res.json();
      const rows = (js.items||[]).map(it=>{
        const file = badge(!!it.exists, 'yes', 'no');
        const pulled = badge(!!it.pulled, 'yes', 'no');
        const cont = it.container_exists ? badgeWarn(!!it.running, 'running', 'stopped') : '<span class="badge text-bg-secondary">none</span>';
        const name = (it.name||'');
        const comp = (it.compose||'');
        return `<tr>
          <td>${name}</td>
          <td><div class="filename-scroll" title="${comp}">${comp}</div></td>
          <td>${file}</td>
          <td>${pulled}</td>
          <td>${cont}</td>
        </tr>`;
      });
      dockerTBody.innerHTML = rows.join('\n');
      dockLog('INFO', `[core] Docker table updated (${(js.items||[]).length} nodes)`);
    }catch(e){ dockLog('ERROR', `[core] docker refresh error: ${e}`); }
  }
  document.getElementById('dockerRefreshBtn')?.addEventListener('click', refreshDocker);
  document.getElementById('dockerCleanupBtn')?.addEventListener('click', async ()=>{
    if(!confirm('Stop and remove containers for all assigned docker nodes?')) return;
    openProgress('Cleaning stale containers…', 1);
    try{
      const res = await fetch('/docker/cleanup', { method:'POST' });
      if(res.ok){
        updateProgress(1,1,'Cleanup done');
        dockLog('INFO', '[core] Docker cleanup completed');
        await refreshDocker();
      }
      else {
        updateProgress(0,1,'Cleanup failed');
        dockLog('WARN', `[core] Docker cleanup failed (${res.status})`);
      }
    }catch(e){ updateProgress(0,1,'Cleanup failed'); dockLog('ERROR', `[core] Docker cleanup error: ${e}`); }
    finally{ closeProgress(); }
  });

  scenarioClearBtn?.addEventListener('click', async ()=>{ await setCoreScenarioFilter(null); });
  renderCoreScenarioButtons();
  renderCoreErrors(initialCoreErrors);
  if(initialGrpcCommand){
    dockLog('INFO', `[core] gRPC command: ${initialGrpcCommand}`);
  }

  sessionsFilterInput?.addEventListener('input', ()=>{
    sessionsFilterText = sessionsFilterInput.value.trim().toLowerCase();
    refresh();
  });
  xmlsFilterInput?.addEventListener('input', ()=>{
    xmlsFilterText = xmlsFilterInput.value.trim().toLowerCase();
    refresh();
  });

  function bindSelectionHandlers(type){
    const table = type==='session' ? sessionsTable : xmlsTable;
    const checkAll = type==='session' ? sessionsCheckAll : xmlsCheckAll;
    const deleteBtn = type==='session' ? sessionsDeleteBtn : xmlsDeleteBtn;
    if (!table) return;
    const checkboxes = table.querySelectorAll('tbody input.row-select');
    const updateSetsFromDom = ()=>{
      if(!checkboxes || checkboxes.length===0){
        if(checkAll){
          checkAll.indeterminate = false;
          checkAll.checked = false;
          // keep enabled even with zero rows
        }
        if(deleteBtn) deleteBtn.disabled = true;
        persistSelections();
        return;
      }
      if(type==='session'){
        checkboxes.forEach(cb=>{
          const id = cb.getAttribute('data-id');
          if(!id) return;
          if(cb.checked) selectedSessions.add(id); else selectedSessions.delete(id);
        });
      } else {
        checkboxes.forEach(cb=>{
          const p = cb.getAttribute('data-path');
          if(!p) return;
          if(cb.checked) selectedXmlPaths.add(p); else selectedXmlPaths.delete(p);
        });
      }
      const anyChecked = (type==='session') ? (selectedSessions.size>0) : (selectedXmlPaths.size>0);
      if(deleteBtn){ deleteBtn.disabled = !anyChecked; }
      const total = checkboxes.length;
      const checkedCount = Array.from(checkboxes).filter(cb=>cb.checked).length;
      if(checkAll){
        if(total === 0){
          checkAll.indeterminate = false;
          checkAll.checked = false;
        } else {
          const master = (type==='session') ? sessionsMasterSelectAll : xmlsMasterSelectAll;
          if (master) {
            checkAll.indeterminate = false;
            checkAll.checked = true;
          } else {
            checkAll.indeterminate = checkedCount>0 && checkedCount<total;
            checkAll.checked = checkedCount===total;
          }
        }
      }
      persistSelections();
    };
    checkboxes.forEach(cb=> cb.addEventListener('change', ()=>{
      updateSetsFromDom();
      // If user manually unchecks any box while master select-all was active, disable master for that table
      const master = (type==='session') ? sessionsMasterSelectAll : xmlsMasterSelectAll;
      if (master) {
        const allChecked = Array.from(checkboxes).every(c=>c.checked);
        if(!allChecked){
          if(type==='session') sessionsMasterSelectAll = false; else xmlsMasterSelectAll = false;
          // disable auto reapply for this table until user re-enables explicitly
          if(type==='session') sessionsAutoReapply = false; else xmlsAutoReapply = false;
          updateSetsFromDom();
        }
      }
    }));
    checkboxes.forEach(cb=>{
      if(type==='session'){
        const id = cb.getAttribute('data-id');
        if(id && selectedSessions.has(id)) cb.checked = true;
      } else {
        const p = cb.getAttribute('data-path');
        if(p && selectedXmlPaths.has(p)) cb.checked = true;
      }
    });
    updateSetsFromDom();
    if(checkAll && !checkAll.dataset.selAllBound){
      checkAll.dataset.selAllBound = '1';
      checkAll.addEventListener('change', ()=>{
        lastHeaderToggleTs = Date.now();
        const target = checkAll.checked;
        if (target){
          if(type==='session') sessionsMasterSelectAll = true; else xmlsMasterSelectAll = true;
          if(type==='session') sessionsAutoReapply = true; else xmlsAutoReapply = true; // re-enable auto reapply when user explicitly selects all
          applyMasterSelectAll(type);
        } else {
          if(type==='session') sessionsMasterSelectAll = false; else xmlsMasterSelectAll = false;
          if(type==='session') sessionsAutoReapply = false; else xmlsAutoReapply = false; // user turned it off
          // Clear ALL selections (including those not currently visible due to filtering)
          if(type==='session') selectedSessions.clear(); else selectedXmlPaths.clear();
          const rows = table.querySelectorAll('tbody input.row-select');
          rows.forEach(cb=>{ cb.checked = false; });
          // Reflect cleared state in UI (no indeterminate, unchecked)
          if(checkAll){ checkAll.indeterminate = false; checkAll.checked = false; }
          updateSetsFromDom(); // will persist cleared sets
        }
        persistSelections();
      });
    }
  }

  function applyMasterSelectAll(type){
    const table = type==='session' ? sessionsTable : xmlsTable;
    if(!table) return;
    const rows = table.querySelectorAll('tbody input.row-select');
    // Mark all as checked (only current visible rows)
    rows.forEach(cb=>{ cb.checked = true; });
    // Update internal selection sets without rebinding handlers (avoid duplicate listeners)
    if(type==='session'){
      selectedSessions.clear();
      rows.forEach(cb=>{ const id = cb.getAttribute('data-id'); if(id) selectedSessions.add(id); });
    } else {
      selectedXmlPaths.clear();
      rows.forEach(cb=>{ const p = cb.getAttribute('data-path'); if(p) selectedXmlPaths.add(p); });
    }
    // Reflect header & action button state
    const checkAll = type==='session' ? sessionsCheckAll : xmlsCheckAll;
    const deleteBtn = type==='session' ? sessionsDeleteBtn : xmlsDeleteBtn;
    if(checkAll){
      checkAll.indeterminate = false;
      checkAll.checked = rows.length > 0;
    }
    if(deleteBtn){ deleteBtn.disabled = rows.length === 0; }
    persistSelections();
  }

  function appendScenarioField(fd){
    if(!fd) return;
    if(scenarioFilter && typeof scenarioFilter === 'string' && scenarioFilter.trim()){
      fd.set('scenario', scenarioFilter.trim());
    }
  }

  async function postForm(url, formData){
    appendScenarioField(formData);
    const res = await fetch(url, { method: 'POST', body: formData });
    return res.ok;
  }

  sessionsDeleteBtn?.addEventListener('click', async ()=>{
    const ids = Array.from(selectedSessions);
    if(ids.length===0) return;
    if(!confirm(`Delete ${ids.length} selected session(s)?`)) return;
    openProgress(`Deleting ${ids.length} session(s)…`, ids.length);
    let done = 0;
    for(const id of ids){
      const fd = new FormData();
      fd.append('session_id', id);
      const ok = await postForm("{{ url_for('core_delete') }}", fd);
      if(ok){
        selectedSessions.delete(id);
        updateProgress(++done, ids.length, `Deleted session ${id}`);
      } else {
        updateProgress(done, ids.length, `Failed to delete session ${id}`);
      }
    }
    closeProgress();
    persistSelections();
    refresh();
  });

  xmlsDeleteBtn?.addEventListener('click', async ()=>{
    const paths = Array.from(selectedXmlPaths);
    if(paths.length===0) return;
    if(!confirm(`Delete ${paths.length} selected file(s)?`)) return;
    openProgress(`Deleting ${paths.length} file(s)…`, paths.length);
    let done = 0;
    for(const path of paths){
      const fd = new FormData();
      fd.append('path', path);
      const ok = await postForm("{{ url_for('core_delete') }}", fd);
      if(ok){
        selectedXmlPaths.delete(path);
        updateProgress(++done, paths.length, `Deleted ${path}`);
      } else {
        updateProgress(done, paths.length, `Failed to delete ${path}`);
      }
    }
    closeProgress();
    persistSelections();
    refresh();
  });

  const PATHS = {
    stop: "{{ url_for('core_stop') }}",
    startSession: "{{ url_for('core_start_session') }}",
    startXml: "{{ url_for('core_start') }}",
    saveXml: "{{ url_for('core_save_xml') }}",
  };
  function actionPathname(url){ try { return new URL(url, window.location.href).pathname; } catch(e){ return url; } }
  function filenameFromContentDisposition(header){
    if(!header) return null;
    const match = /filename\*=UTF-8''([^;]+)|filename="?([^";]+)"?/i.exec(header);
    if(match){
      const val = match[1] || match[2];
      try { return decodeURIComponent(val); } catch { return val; }
    }
    return null;
  }
  function downloadBlob(blob, filename){
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename || 'download.xml';
    document.body.appendChild(a);
    a.click();
    setTimeout(()=>{ URL.revokeObjectURL(url); a.remove(); }, 0);
  }
  document.addEventListener('submit', async (ev)=>{
    const form = ev.target;
    if(!(form instanceof HTMLFormElement)) return;
    const p = actionPathname(form.action);
    const targets = [PATHS.stop, PATHS.startSession, PATHS.startXml, PATHS.saveXml];
    if(!targets.includes(p)) return;
    ev.preventDefault();
    const fd = new FormData(form);
    let title = 'Processing…';
    if(p === PATHS.stop){
      const id = fd.get('session_id');
      title = `Stopping session ${id}…`;
    } else if(p === PATHS.startSession){
      const id = fd.get('session_id');
      title = `Starting session ${id}…`;
    } else if(p === PATHS.saveXml){
      const id = fd.get('session_id');
      title = `Saving XML for session ${id}…`;
    } else if(p === PATHS.startXml){
      const path = fd.get('path');
      title = `Starting topology from ${path}…`;
    }
    openProgress(title, 1);
    try{
      if(p === PATHS.saveXml){
        appendScenarioField(fd);
        const res = await fetch(p, { method: 'POST', body: fd });
        if(res.ok){
          const blob = await res.blob();
          const cd = res.headers.get('Content-Disposition');
          const fname = filenameFromContentDisposition(cd) || `session-${fd.get('session_id')||'export'}.xml`;
          downloadBlob(blob, fname);
          updateProgress(1, 1, title.replace('…','') + ' done');
        } else {
          updateProgress(0, 1, title.replace('…','') + ' failed');
        }
      } else {
        const ok = await postForm(p, fd);
        if(ok){
          updateProgress(1, 1, title.replace('…','') + ' done');
        } else {
          updateProgress(0, 1, title.replace('…','') + ' failed');
        }
      }
    } catch(e){
      updateProgress(0, 1, title.replace('…','') + ' failed');
    } finally {
      closeProgress();
      refresh();
    }
  });
})();
</script>
{% endblock %}
